this["rl_components"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "output";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	__webpack_require__(2);
	__webpack_require__(3);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	__webpack_require__(6);
	__webpack_require__(13);
	var behaviors = __webpack_require__(14);
	exports.behaviors = behaviors;
	var components = __webpack_require__(26);
	exports.components = components;
	var services = __webpack_require__(134);
	exports.services = services;
	var types = __webpack_require__(200);
	exports.types = types;
	exports.moduleName = 'rl.ui';
	angular.module(exports.moduleName, [
	    'ui.bootstrap',
	    'ui.bootstrap-slider',
	    'ngSanitize',
	    typescript_angular_utilities_1.name,
	    behaviors.moduleName,
	    components.moduleName,
	    services.moduleName,
	]);


/***/ },
/* 1 */
/***/ function(module, exports) {

	(function() { module.exports = this["angular"]; }());

/***/ },
/* 2 */
/***/ function(module, exports) {

	(function() { module.exports = this["angular-ui"]; }());

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	module.exports = 'ngSanitize';


/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.5.0
	 * (c) 2010-2016 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 *     Any commits to this file should be reviewed with security in mind.  *
	 *   Changes to this file can potentially create security vulnerabilities. *
	 *          An approval from 2 Core members with history of modifying      *
	 *                         this file is required.                          *
	 *                                                                         *
	 *  Does the change somehow allow for arbitrary javascript to be executed? *
	 *    Or allows for someone to change the prototype of built-in objects?   *
	 *     Or gives undesired access to variables likes document or window?    *
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	
	var $sanitizeMinErr = angular.$$minErr('$sanitize');
	
	/**
	 * @ngdoc module
	 * @name ngSanitize
	 * @description
	 *
	 * # ngSanitize
	 *
	 * The `ngSanitize` module provides functionality to sanitize HTML.
	 *
	 *
	 * <div doc-module-components="ngSanitize"></div>
	 *
	 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
	 */
	
	/**
	 * @ngdoc service
	 * @name $sanitize
	 * @kind function
	 *
	 * @description
	 *   Sanitizes an html string by stripping all potentially dangerous tokens.
	 *
	 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
	 *   then serialized back to properly escaped html string. This means that no unsafe input can make
	 *   it into the returned string.
	 *
	 *   The whitelist for URL sanitization of attribute values is configured using the functions
	 *   `aHrefSanitizationWhitelist` and `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider
	 *   `$compileProvider`}.
	 *
	 *   The input may also contain SVG markup if this is enabled via {@link $sanitizeProvider}.
	 *
	 * @param {string} html HTML input.
	 * @returns {string} Sanitized HTML.
	 *
	 * @example
	   <example module="sanitizeExample" deps="angular-sanitize.js">
	   <file name="index.html">
	     <script>
	         angular.module('sanitizeExample', ['ngSanitize'])
	           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
	             $scope.snippet =
	               '<p style="color:blue">an html\n' +
	               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
	               'snippet</p>';
	             $scope.deliberatelyTrustDangerousSnippet = function() {
	               return $sce.trustAsHtml($scope.snippet);
	             };
	           }]);
	     </script>
	     <div ng-controller="ExampleController">
	        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <td>Directive</td>
	           <td>How</td>
	           <td>Source</td>
	           <td>Rendered</td>
	         </tr>
	         <tr id="bind-html-with-sanitize">
	           <td>ng-bind-html</td>
	           <td>Automatically uses $sanitize</td>
	           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind-html="snippet"></div></td>
	         </tr>
	         <tr id="bind-html-with-trust">
	           <td>ng-bind-html</td>
	           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
	           <td>
	           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
	&lt;/div&gt;</pre>
	           </td>
	           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
	         </tr>
	         <tr id="bind-default">
	           <td>ng-bind</td>
	           <td>Automatically escapes</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	       </div>
	   </file>
	   <file name="protractor.js" type="protractor">
	     it('should sanitize the html snippet by default', function() {
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
	     });
	
	     it('should inline raw snippet if bound to a trusted value', function() {
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
	         toBe("<p style=\"color:blue\">an html\n" +
	              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
	              "snippet</p>");
	     });
	
	     it('should escape snippet without any filter', function() {
	       expect(element(by.css('#bind-default div')).getInnerHtml()).
	         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
	              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
	              "snippet&lt;/p&gt;");
	     });
	
	     it('should update', function() {
	       element(by.model('snippet')).clear();
	       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
	         toBe('new <b>text</b>');
	       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
	         'new <b onclick="alert(1)">text</b>');
	       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
	         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
	     });
	   </file>
	   </example>
	 */
	
	
	/**
	 * @ngdoc provider
	 * @name $sanitizeProvider
	 *
	 * @description
	 * Creates and configures {@link $sanitize} instance.
	 */
	function $SanitizeProvider() {
	  var svgEnabled = false;
	
	  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
	    if (svgEnabled) {
	      angular.extend(validElements, svgElements);
	    }
	    return function(html) {
	      var buf = [];
	      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
	        return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
	      }));
	      return buf.join('');
	    };
	  }];
	
	
	  /**
	   * @ngdoc method
	   * @name $sanitizeProvider#enableSvg
	   * @kind function
	   *
	   * @description
	   * Enables a subset of svg to be supported by the sanitizer.
	   *
	   * <div class="alert alert-warning">
	   *   <p>By enabling this setting without taking other precautions, you might expose your
	   *   application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned
	   *   outside of the containing element and be rendered over other elements on the page (e.g. a login
	   *   link). Such behavior can then result in phishing incidents.</p>
	   *
	   *   <p>To protect against these, explicitly setup `overflow: hidden` css rule for all potential svg
	   *   tags within the sanitized content:</p>
	   *
	   *   <br>
	   *
	   *   <pre><code>
	   *   .rootOfTheIncludedContent svg {
	   *     overflow: hidden !important;
	   *   }
	   *   </code></pre>
	   * </div>
	   *
	   * @param {boolean=} regexp New regexp to whitelist urls with.
	   * @returns {boolean|ng.$sanitizeProvider} Returns the currently configured value if called
	   *    without an argument or self for chaining otherwise.
	   */
	  this.enableSvg = function(enableSvg) {
	    if (angular.isDefined(enableSvg)) {
	      svgEnabled = enableSvg;
	      return this;
	    } else {
	      return svgEnabled;
	    }
	  };
	}
	
	function sanitizeText(chars) {
	  var buf = [];
	  var writer = htmlSanitizeWriter(buf, angular.noop);
	  writer.chars(chars);
	  return buf.join('');
	}
	
	
	// Regular Expressions for parsing tags and attributes
	var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	  // Match everything outside of normal chars and " (quote character)
	  NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	
	
	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var voidElements = toMap("area,br,col,hr,img,wbr");
	
	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
	    optionalEndTagInlineElements = toMap("rp,rt"),
	    optionalEndTagElements = angular.extend({},
	                                            optionalEndTagInlineElements,
	                                            optionalEndTagBlockElements);
	
	// Safe Block Elements - HTML5
	var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," +
	        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
	        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
	
	// Inline Elements - HTML5
	var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," +
	        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
	        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
	
	// SVG Elements
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
	// Note: the elements animate,animateColor,animateMotion,animateTransform,set are intentionally omitted.
	// They can potentially allow for arbitrary javascript to be executed. See #11290
	var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," +
	        "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," +
	        "radialGradient,rect,stop,svg,switch,text,title,tspan");
	
	// Blocked Elements (will be stripped)
	var blockedElements = toMap("script,style");
	
	var validElements = angular.extend({},
	                                   voidElements,
	                                   blockElements,
	                                   inlineElements,
	                                   optionalEndTagElements);
	
	//Attributes that have href and hence need to be sanitized
	var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
	
	var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
	    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
	    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
	    'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' +
	    'valign,value,vspace,width');
	
	// SVG attributes (without "id" and "name" attributes)
	// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
	var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
	    'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' +
	    'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' +
	    'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' +
	    'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' +
	    'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' +
	    'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' +
	    'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' +
	    'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' +
	    'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' +
	    'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' +
	    'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' +
	    'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' +
	    'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' +
	    'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
	
	var validAttrs = angular.extend({},
	                                uriAttrs,
	                                svgAttrs,
	                                htmlAttrs);
	
	function toMap(str, lowercaseKeys) {
	  var obj = {}, items = str.split(','), i;
	  for (i = 0; i < items.length; i++) {
	    obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
	  }
	  return obj;
	}
	
	var inertBodyElement;
	(function(window) {
	  var doc;
	  if (window.document && window.document.implementation) {
	    doc = window.document.implementation.createHTMLDocument("inert");
	  } else {
	    throw $sanitizeMinErr('noinert', "Can't create an inert html document");
	  }
	  var docElement = doc.documentElement || doc.getDocumentElement();
	  var bodyElements = docElement.getElementsByTagName('body');
	
	  // usually there should be only one body element in the document, but IE doesn't have any, so we need to create one
	  if (bodyElements.length === 1) {
	    inertBodyElement = bodyElements[0];
	  } else {
	    var html = doc.createElement('html');
	    inertBodyElement = doc.createElement('body');
	    html.appendChild(inertBodyElement);
	    doc.appendChild(html);
	  }
	})(window);
	
	/**
	 * @example
	 * htmlParser(htmlString, {
	 *     start: function(tag, attrs) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * });
	 *
	 * @param {string} html string
	 * @param {object} handler
	 */
	function htmlParser(html, handler) {
	  if (html === null || html === undefined) {
	    html = '';
	  } else if (typeof html !== 'string') {
	    html = '' + html;
	  }
	  inertBodyElement.innerHTML = html;
	
	  //mXSS protection
	  var mXSSAttempts = 5;
	  do {
	    if (mXSSAttempts === 0) {
	      throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
	    }
	    mXSSAttempts--;
	
	    // strip custom-namespaced attributes on IE<=11
	    if (document.documentMode <= 11) {
	      stripCustomNsAttrs(inertBodyElement);
	    }
	    html = inertBodyElement.innerHTML; //trigger mXSS
	    inertBodyElement.innerHTML = html;
	  } while (html !== inertBodyElement.innerHTML);
	
	  var node = inertBodyElement.firstChild;
	  while (node) {
	    switch (node.nodeType) {
	      case 1: // ELEMENT_NODE
	        handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
	        break;
	      case 3: // TEXT NODE
	        handler.chars(node.textContent);
	        break;
	    }
	
	    var nextNode;
	    if (!(nextNode = node.firstChild)) {
	      if (node.nodeType == 1) {
	        handler.end(node.nodeName.toLowerCase());
	      }
	      nextNode = node.nextSibling;
	      if (!nextNode) {
	        while (nextNode == null) {
	          node = node.parentNode;
	          if (node === inertBodyElement) break;
	          nextNode = node.nextSibling;
	          if (node.nodeType == 1) {
	            handler.end(node.nodeName.toLowerCase());
	          }
	        }
	      }
	    }
	    node = nextNode;
	  }
	
	  while (node = inertBodyElement.firstChild) {
	    inertBodyElement.removeChild(node);
	  }
	}
	
	function attrToMap(attrs) {
	  var map = {};
	  for (var i = 0, ii = attrs.length; i < ii; i++) {
	    var attr = attrs[i];
	    map[attr.name] = attr.value;
	  }
	  return map;
	}
	
	
	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param value
	 * @returns {string} escaped text
	 */
	function encodeEntities(value) {
	  return value.
	    replace(/&/g, '&amp;').
	    replace(SURROGATE_PAIR_REGEXP, function(value) {
	      var hi = value.charCodeAt(0);
	      var low = value.charCodeAt(1);
	      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	    }).
	    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
	      return '&#' + value.charCodeAt(0) + ';';
	    }).
	    replace(/</g, '&lt;').
	    replace(/>/g, '&gt;');
	}
	
	/**
	 * create an HTML/XML writer which writes to buffer
	 * @param {Array} buf use buf.join('') to get out sanitized html string
	 * @returns {object} in the form of {
	 *     start: function(tag, attrs) {},
	 *     end: function(tag) {},
	 *     chars: function(text) {},
	 *     comment: function(text) {}
	 * }
	 */
	function htmlSanitizeWriter(buf, uriValidator) {
	  var ignoreCurrentElement = false;
	  var out = angular.bind(buf, buf.push);
	  return {
	    start: function(tag, attrs) {
	      tag = angular.lowercase(tag);
	      if (!ignoreCurrentElement && blockedElements[tag]) {
	        ignoreCurrentElement = tag;
	      }
	      if (!ignoreCurrentElement && validElements[tag] === true) {
	        out('<');
	        out(tag);
	        angular.forEach(attrs, function(value, key) {
	          var lkey=angular.lowercase(key);
	          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
	          if (validAttrs[lkey] === true &&
	            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
	            out(' ');
	            out(key);
	            out('="');
	            out(encodeEntities(value));
	            out('"');
	          }
	        });
	        out('>');
	      }
	    },
	    end: function(tag) {
	      tag = angular.lowercase(tag);
	      if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
	        out('</');
	        out(tag);
	        out('>');
	      }
	      if (tag == ignoreCurrentElement) {
	        ignoreCurrentElement = false;
	      }
	    },
	    chars: function(chars) {
	      if (!ignoreCurrentElement) {
	        out(encodeEntities(chars));
	      }
	    }
	  };
	}
	
	
	/**
	 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1' attribute to declare
	 * ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo'). This is undesirable since we don't want
	 * to allow any of these custom attributes. This method strips them all.
	 *
	 * @param node Root element to process
	 */
	function stripCustomNsAttrs(node) {
	  if (node.nodeType === Node.ELEMENT_NODE) {
	    var attrs = node.attributes;
	    for (var i = 0, l = attrs.length; i < l; i++) {
	      var attrNode = attrs[i];
	      var attrName = attrNode.name.toLowerCase();
	      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	        node.removeAttributeNode(attrNode);
	        i--;
	        l--;
	      }
	    }
	  }
	
	  var nextNode = node.firstChild;
	  if (nextNode) {
	    stripCustomNsAttrs(nextNode);
	  }
	
	  nextNode = node.nextSibling;
	  if (nextNode) {
	    stripCustomNsAttrs(nextNode);
	  }
	}
	
	
	
	// define ngSanitize module and register $sanitize service
	angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
	
	/* global sanitizeText: false */
	
	/**
	 * @ngdoc filter
	 * @name linky
	 * @kind function
	 *
	 * @description
	 * Finds links in text input and turns them into html links. Supports `http/https/ftp/mailto` and
	 * plain email address links.
	 *
	 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
	 *
	 * @param {string} text Input text.
	 * @param {string} target Window (`_blank|_self|_parent|_top`) or named frame to open links in.
	 * @param {object|function(url)} [attributes] Add custom attributes to the link element.
	 *
	 *    Can be one of:
	 *
	 *    - `object`: A map of attributes
	 *    - `function`: Takes the url as a parameter and returns a map of attributes
	 *
	 *    If the map of attributes contains a value for `target`, it overrides the value of
	 *    the target parameter.
	 *
	 *
	 * @returns {string} Html-linkified and {@link $sanitize sanitized} text.
	 *
	 * @usage
	   <span ng-bind-html="linky_expression | linky"></span>
	 *
	 * @example
	   <example module="linkyExample" deps="angular-sanitize.js">
	     <file name="index.html">
	       <div ng-controller="ExampleController">
	       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
	       <table>
	         <tr>
	           <th>Filter</th>
	           <th>Source</th>
	           <th>Rendered</th>
	         </tr>
	         <tr id="linky-filter">
	           <td>linky filter</td>
	           <td>
	             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
	           </td>
	           <td>
	             <div ng-bind-html="snippet | linky"></div>
	           </td>
	         </tr>
	         <tr id="linky-target">
	          <td>linky target</td>
	          <td>
	            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
	          </td>
	          <td>
	            <div ng-bind-html="snippetWithSingleURL | linky:'_blank'"></div>
	          </td>
	         </tr>
	         <tr id="linky-custom-attributes">
	          <td>linky custom attributes</td>
	          <td>
	            <pre>&lt;div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"&gt;<br>&lt;/div&gt;</pre>
	          </td>
	          <td>
	            <div ng-bind-html="snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}"></div>
	          </td>
	         </tr>
	         <tr id="escaped-html">
	           <td>no filter</td>
	           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
	           <td><div ng-bind="snippet"></div></td>
	         </tr>
	       </table>
	     </file>
	     <file name="script.js">
	       angular.module('linkyExample', ['ngSanitize'])
	         .controller('ExampleController', ['$scope', function($scope) {
	           $scope.snippet =
	             'Pretty text with some links:\n'+
	             'http://angularjs.org/,\n'+
	             'mailto:us@somewhere.org,\n'+
	             'another@somewhere.org,\n'+
	             'and one more: ftp://127.0.0.1/.';
	           $scope.snippetWithSingleURL = 'http://angularjs.org/';
	         }]);
	     </file>
	     <file name="protractor.js" type="protractor">
	       it('should linkify the snippet with urls', function() {
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
	       });
	
	       it('should not linkify snippet without the linky filter', function() {
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
	             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
	                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
	         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
	       });
	
	       it('should update', function() {
	         element(by.model('snippet')).clear();
	         element(by.model('snippet')).sendKeys('new http://link.');
	         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
	             toBe('new http://link.');
	         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
	         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
	             .toBe('new http://link.');
	       });
	
	       it('should work with the target property', function() {
	        expect(element(by.id('linky-target')).
	            element(by.binding("snippetWithSingleURL | linky:'_blank'")).getText()).
	            toBe('http://angularjs.org/');
	        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
	       });
	
	       it('should optionally add custom attributes', function() {
	        expect(element(by.id('linky-custom-attributes')).
	            element(by.binding("snippetWithSingleURL | linky:'_self':{rel: 'nofollow'}")).getText()).
	            toBe('http://angularjs.org/');
	        expect(element(by.css('#linky-custom-attributes a')).getAttribute('rel')).toEqual('nofollow');
	       });
	     </file>
	   </example>
	 */
	angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
	  var LINKY_URL_REGEXP =
	        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
	      MAILTO_REGEXP = /^mailto:/i;
	
	  var linkyMinErr = angular.$$minErr('linky');
	  var isString = angular.isString;
	
	  return function(text, target, attributes) {
	    if (text == null || text === '') return text;
	    if (!isString(text)) throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
	
	    var match;
	    var raw = text;
	    var html = [];
	    var url;
	    var i;
	    while ((match = raw.match(LINKY_URL_REGEXP))) {
	      // We can not end in these as they are sometimes found at the end of the sentence
	      url = match[0];
	      // if we did not match ftp/http/www/mailto then assume mailto
	      if (!match[2] && !match[4]) {
	        url = (match[3] ? 'http://' : 'mailto:') + url;
	      }
	      i = match.index;
	      addText(raw.substr(0, i));
	      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
	      raw = raw.substring(i + match[0].length);
	    }
	    addText(raw);
	    return $sanitize(html.join(''));
	
	    function addText(text) {
	      if (!text) {
	        return;
	      }
	      html.push(sanitizeText(text));
	    }
	
	    function addLink(url, text) {
	      var key;
	      html.push('<a ');
	      if (angular.isFunction(attributes)) {
	        attributes = attributes(url);
	      }
	      if (angular.isObject(attributes)) {
	        for (key in attributes) {
	          html.push(key + '="' + attributes[key] + '" ');
	        }
	      } else {
	        attributes = {};
	      }
	      if (angular.isDefined(target) && !('target' in attributes)) {
	        html.push('target="',
	                  target,
	                  '" ');
	      }
	      html.push('href="',
	                url.replace(/"/g, '&quot;'),
	                '">');
	      addText(text);
	      html.push('</a>');
	    }
	  };
	}]);
	
	
	})(window, window.angular);


/***/ },
/* 5 */
/***/ function(module, exports) {

	(function() { module.exports = this["rl_utilities"]; }());

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(7);
	var Slider = __webpack_require__(11);
	
	angular.module('ui.bootstrap-slider', [])
	    .directive('slider', ['$parse', '$timeout', '$rootScope', function ($parse, $timeout, $rootScope) {
	        return {
	            restrict: 'AE',
	            replace: true,
	            template: '<div><input class="slider-input" type="text" style="width:100%" /></div>',
	            require: 'ngModel',
	            scope: {
	                max: "=",
	                min: "=",
	                step: "=",
	                value: "=",
	                ngModel: '=',
	                ngDisabled: '=',
	                range: '=',
	                sliderid: '=',
	                ticks: '=',
	                ticksLabels: '=',
	                ticksSnapBounds: '=',
	                ticksPositions: '=',
	                scale: '=',
	                formatter: '&',
	                onStartSlide: '&',
	                onStopSlide: '&',
	                onSlide: '&'
	            },
	            link: function ($scope, element, attrs, ngModelCtrl, $compile) {
	                var ngModelDeregisterFn, ngDisabledDeregisterFn;
	
	                initSlider();
	
	                function initSlider() {
	                    var options = {};
	
	                    function setOption(key, value, defaultValue) {
	                        options[key] = value || defaultValue;
	                    }
	
	                    function setFloatOption(key, value, defaultValue) {
	                        options[key] = value || value === 0 ? parseFloat(value) : defaultValue;
	                    }
	
	                    function setBooleanOption(key, value, defaultValue) {
	                        options[key] = value ? value + '' === 'true' : defaultValue;
	                    }
	
	                    function getArrayOrValue(value) {
	                        return (angular.isString(value) && value.indexOf("[") === 0) ? angular.fromJson(value) : value;
	                    }
	
	                    setOption('id', $scope.sliderid);
	                    setOption('orientation', attrs.orientation, 'horizontal');
	                    setOption('selection', attrs.selection, 'before');
	                    setOption('handle', attrs.handle, 'round');
	                    setOption('tooltip', attrs.sliderTooltip || attrs.tooltip, 'show');
	                    setOption('tooltip_position', attrs.sliderTooltipPosition, 'top');
	                    setOption('tooltipseparator', attrs.tooltipseparator, ':');
	                    setOption('ticks', $scope.ticks);
	                    setOption('ticks_labels', $scope.ticksLabels);
	                    setOption('ticks_snap_bounds', $scope.ticksSnapBounds);
	                    setOption('ticks_positions', $scope.ticksPositions);
	                    setOption('scale', $scope.scale, 'linear');
	
	                    setFloatOption('min', $scope.min, 0);
	                    setFloatOption('max', $scope.max, 10);
	                    setFloatOption('step', $scope.step, 1);
	                    var strNbr = options.step + '';
	                    var decimals = strNbr.substring(strNbr.lastIndexOf('.') + 1);
	                    setFloatOption('precision', attrs.precision, decimals);
	
	                    setBooleanOption('tooltip_split', attrs.tooltipsplit, false);
	                    setBooleanOption('enabled', attrs.enabled, true);
	                    setBooleanOption('naturalarrowkeys', attrs.naturalarrowkeys, false);
	                    setBooleanOption('reversed', attrs.reversed, false);
	
	                    setBooleanOption('range', $scope.range, false);
	                    if (options.range) {
	                        if (angular.isArray($scope.value)) {
	                            options.value = $scope.value;
	                        }
	                        else if (angular.isString($scope.value)) {
	                            options.value = getArrayOrValue($scope.value);
	                            if (!angular.isArray(options.value)) {
	                                var value = parseFloat($scope.value);
	                                if (isNaN(value)) value = 5;
	
	                                if (value < $scope.min) {
	                                    value = $scope.min;
	                                    options.value = [value, options.max];
	                                }
	                                else if (value > $scope.max) {
	                                    value = $scope.max;
	                                    options.value = [options.min, value];
	                                }
	                                else {
	                                    options.value = [options.min, options.max];
	                                }
	                            }
	                        }
	                        else {
	                            options.value = [options.min, options.max]; // This is needed, because of value defined at $.fn.slider.defaults - default value 5 prevents creating range slider
	                        }
	                        $scope.ngModel = options.value; // needed, otherwise turns value into [null, ##]
	                    }
	                    else {
	                        setFloatOption('value', $scope.value, 5);
	                    }
	
	                    if ($scope.formatter) options.formatter = $scope.$eval($scope.formatter);
	
	
	                    // check if slider jQuery plugin exists
	                    if ('$' in window && $.fn.slider) {
	                        // adding methods to jQuery slider plugin prototype
	                        $.fn.slider.constructor.prototype.disable = function () {
	                            this.picker.off();
	                        };
	                        $.fn.slider.constructor.prototype.enable = function () {
	                            this.picker.on();
	                        };
	                    }
	
	                    // destroy previous slider to reset all options
	                    if (element[0].__slider)
	                        element[0].__slider.destroy();
	
	                    var slider = new Slider(element[0].getElementsByClassName('slider-input')[0], options);
	                    element[0].__slider = slider;
	
	                    // everything that needs slider element
	                    var updateEvent = getArrayOrValue(attrs.updateevent);
	                    if (angular.isString(updateEvent)) {
	                        // if only single event name in string
	                        updateEvent = [updateEvent];
	                    }
	                    else {
	                        // default to slide event
	                        updateEvent = ['slide'];
	                    }
	                    angular.forEach(updateEvent, function (sliderEvent) {
	                        slider.on(sliderEvent, function (ev) {
	                            ngModelCtrl.$setViewValue(ev);
	                            $timeout(function () {
	                                $scope.$apply();
	                            });
	                        });
	                    });
	                    slider.on('change', function (ev) {
	                        ngModelCtrl.$setViewValue(ev.newValue);
	                        $timeout(function () {
	                            $scope.$apply();
	                        });
	                    });
	
	                    // Event listeners
	                    var sliderEvents = {
	                        slideStart: 'onStartSlide',
	                        slide: 'onSlide',
	                        slideStop: 'onStopSlide'
	                    };
	                    angular.forEach(sliderEvents, function (sliderEventAttr, sliderEvent) {
	                        var fn = $parse(attrs[sliderEventAttr]);
	                        slider.on(sliderEvent, function (ev) {
	                            if ($scope[sliderEventAttr]) {
	
	                                var callback = function () {
	                                    fn($scope.$parent, { $event: ev, value: ev });
	                                }
	
	                                if ($rootScope.$$phase) {
	                                    $scope.$evalAsync(callback);
	                                } else {
	                                    $scope.$apply(callback);
	                                }
	                            }
	                        });
	                    });
	
	                    // deregister ngDisabled watcher to prevent memory leaks
	                    if (angular.isFunction(ngDisabledDeregisterFn)) {
	                        ngDisabledDeregisterFn();
	                        ngDisabledDeregisterFn = null;
	                    }
	
	                    ngDisabledDeregisterFn = $scope.$watch('ngDisabled', function (value) {
	                        if (value) {
	                            slider.disable();
	                        }
	                        else {
	                            slider.enable();
	                        }
	                    });
	
	                    // deregister ngModel watcher to prevent memory leaks
	                    if (angular.isFunction(ngModelDeregisterFn)) ngModelDeregisterFn();
	                    ngModelDeregisterFn = $scope.$watch('ngModel', function (value) {
	                        if($scope.range){
	                            slider.setValue(value);
	                        }else{
	                            slider.setValue(parseFloat(value));
	                        }
	                    }, true);
	                }
	
	
	                var watchers = ['min', 'max', 'step', 'range', 'scale'];
	                angular.forEach(watchers, function (prop) {
	                    $scope.$watch(prop, function () {
	                        initSlider();
	                    });
	                });
	            }
	        };
	    }])
	;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(8);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./bootstrap-slider.min.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./bootstrap-slider.min.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, "/*! =======================================================\r\n                      VERSION  5.1.1\r\n========================================================= */\r\n/*! =========================================================\r\n * bootstrap-slider.js\r\n *\r\n * Maintainers:\r\n *\t\tKyle Kemp\r\n *\t\t\t- Twitter: @seiyria\r\n *\t\t\t- Github:  seiyria\r\n *\t\tRohit Kalkur\r\n *\t\t\t- Twitter: @Rovolutionary\r\n *\t\t\t- Github:  rovolution\r\n *\r\n * =========================================================\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ========================================================= */.slider{display:inline-block;vertical-align:middle;position:relative}.slider.slider-horizontal{width:210px;height:20px}.slider.slider-horizontal .slider-track{height:10px;width:100%;margin-top:-5px;top:50%;left:0}.slider.slider-horizontal .slider-selection,.slider.slider-horizontal .slider-track-low,.slider.slider-horizontal .slider-track-high{height:100%;top:0;bottom:0}.slider.slider-horizontal .slider-tick,.slider.slider-horizontal .slider-handle{margin-left:-10px;margin-top:-5px}.slider.slider-horizontal .slider-tick.triangle,.slider.slider-horizontal .slider-handle.triangle{border-width:0 10px 10px 10px;width:0;height:0;border-bottom-color:#0480be;margin-top:0}.slider.slider-horizontal .slider-tick-label-container{white-space:nowrap;margin-top:20px}.slider.slider-horizontal .slider-tick-label-container .slider-tick-label{padding-top:4px;display:inline-block;text-align:center}.slider.slider-vertical{height:210px;width:20px}.slider.slider-vertical .slider-track{width:10px;height:100%;margin-left:-5px;left:50%;top:0}.slider.slider-vertical .slider-selection{width:100%;left:0;top:0;bottom:0}.slider.slider-vertical .slider-track-low,.slider.slider-vertical .slider-track-high{width:100%;left:0;right:0}.slider.slider-vertical .slider-tick,.slider.slider-vertical .slider-handle{margin-left:-5px;margin-top:-10px}.slider.slider-vertical .slider-tick.triangle,.slider.slider-vertical .slider-handle.triangle{border-width:10px 0 10px 10px;width:1px;height:1px;border-left-color:#0480be;margin-left:0}.slider.slider-disabled .slider-handle{background-image:-webkit-linear-gradient(top,#dfdfdf 0,#bebebe 100%);background-image:-o-linear-gradient(top,#dfdfdf 0,#bebebe 100%);background-image:linear-gradient(to bottom,#dfdfdf 0,#bebebe 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffdfdfdf',endColorstr='#ffbebebe',GradientType=0)}.slider.slider-disabled .slider-track{background-image:-webkit-linear-gradient(top,#e5e5e5 0,#e9e9e9 100%);background-image:-o-linear-gradient(top,#e5e5e5 0,#e9e9e9 100%);background-image:linear-gradient(to bottom,#e5e5e5 0,#e9e9e9 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffe5e5e5',endColorstr='#ffe9e9e9',GradientType=0);cursor:not-allowed}.slider input{display:none}.slider .tooltip.top{margin-top:-36px}.slider .tooltip-inner{white-space:nowrap}.slider .hide{display:none}.slider-track{position:absolute;cursor:pointer;background-image:-webkit-linear-gradient(top,#f5f5f5 0,#f9f9f9 100%);background-image:-o-linear-gradient(top,#f5f5f5 0,#f9f9f9 100%);background-image:linear-gradient(to bottom,#f5f5f5 0,#f9f9f9 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff5f5f5',endColorstr='#fff9f9f9',GradientType=0);-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);border-radius:4px}.slider-selection{position:absolute;background-image:-webkit-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:linear-gradient(to bottom,#f9f9f9 0,#f5f5f5 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;border-radius:4px}.slider-selection.tick-slider-selection{background-image:-webkit-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:-o-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:linear-gradient(to bottom,#89cdef 0,#81bfde 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef',endColorstr='#ff81bfde',GradientType=0)}.slider-track-low,.slider-track-high{position:absolute;background:transparent;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;border-radius:4px}.slider-handle{position:absolute;width:20px;height:20px;background-color:#337ab7;background-image:-webkit-linear-gradient(top,#149bdf 0,#0480be 100%);background-image:-o-linear-gradient(top,#149bdf 0,#0480be 100%);background-image:linear-gradient(to bottom,#149bdf 0,#0480be 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff149bdf',endColorstr='#ff0480be',GradientType=0);filter:none;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05);border:0 solid transparent}.slider-handle.round{border-radius:50%}.slider-handle.triangle{background:transparent none}.slider-handle.custom{background:transparent none}.slider-handle.custom::before{line-height:20px;font-size:20px;content:'\\2605';color:#726204}.slider-tick{position:absolute;width:20px;height:20px;background-image:-webkit-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:-o-linear-gradient(top,#f9f9f9 0,#f5f5f5 100%);background-image:linear-gradient(to bottom,#f9f9f9 0,#f5f5f5 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#fff9f9f9',endColorstr='#fff5f5f5',GradientType=0);-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;filter:none;opacity:.8;border:0 solid transparent}.slider-tick.round{border-radius:50%}.slider-tick.triangle{background:transparent none}.slider-tick.custom{background:transparent none}.slider-tick.custom::before{line-height:20px;font-size:20px;content:'\\2605';color:#726204}.slider-tick.in-selection{background-image:-webkit-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:-o-linear-gradient(top,#89cdef 0,#81bfde 100%);background-image:linear-gradient(to bottom,#89cdef 0,#81bfde 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff89cdef',endColorstr='#ff81bfde',GradientType=0);opacity:1}", ""]);
	
	// exports


/***/ },
/* 9 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! =======================================================
	                      VERSION  5.1.1
	========================================================= */
	/*! =========================================================
	 * bootstrap-slider.js
	 *
	 * Maintainers:
	 *		Kyle Kemp
	 *			- Twitter: @seiyria
	 *			- Github:  seiyria
	 *		Rohit Kalkur
	 *			- Twitter: @Rovolutionary
	 *			- Github:  rovolution
	 *
	 * =========================================================
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================= */
	!function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_FACTORY__ = (b), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if("object"==typeof module&&module.exports){var c;try{c=require("jquery")}catch(d){c=null}module.exports=b(c)}else a.Slider=b(a.jQuery)}(this,function(a){var b;return function(a){"use strict";function b(){}function c(a){function c(b){b.prototype.option||(b.prototype.option=function(b){a.isPlainObject(b)&&(this.options=a.extend(!0,this.options,b))})}function e(b,c){a.fn[b]=function(e){if("string"==typeof e){for(var g=d.call(arguments,1),h=0,i=this.length;i>h;h++){var j=this[h],k=a.data(j,b);if(k)if(a.isFunction(k[e])&&"_"!==e.charAt(0)){var l=k[e].apply(k,g);if(void 0!==l&&l!==k)return l}else f("no such method '"+e+"' for "+b+" instance");else f("cannot call methods on "+b+" prior to initialization; attempted to call '"+e+"'")}return this}var m=this.map(function(){var d=a.data(this,b);return d?(d.option(e),d._init()):(d=new c(this,e),a.data(this,b,d)),a(this)});return!m||m.length>1?m:m[0]}}if(a){var f="undefined"==typeof console?b:function(a){console.error(a)};return a.bridget=function(a,b){c(b),e(a,b)},a.bridget}}var d=Array.prototype.slice;c(a)}(a),function(a){function c(b,c){function d(a,b){var c="data-slider-"+b.replace(/_/g,"-"),d=a.getAttribute(c);try{return JSON.parse(d)}catch(e){return d}}this._state={value:null,enabled:null,offset:null,size:null,percentage:null,inDrag:!1,over:!1},"string"==typeof b?this.element=document.querySelector(b):b instanceof HTMLElement&&(this.element=b),c=c?c:{};for(var f=Object.keys(this.defaultOptions),g=0;g<f.length;g++){var h=f[g],i=c[h];i="undefined"!=typeof i?i:d(this.element,h),i=null!==i?i:this.defaultOptions[h],this.options||(this.options={}),this.options[h]=i}"vertical"!==this.options.orientation||"top"!==this.options.tooltip_position&&"bottom"!==this.options.tooltip_position?"horizontal"!==this.options.orientation||"left"!==this.options.tooltip_position&&"right"!==this.options.tooltip_position||(this.options.tooltip_position="top"):this.options.tooltip_position="right";var j,k,l,m,n,o=this.element.style.width,p=!1,q=this.element.parentNode;if(this.sliderElem)p=!0;else{this.sliderElem=document.createElement("div"),this.sliderElem.className="slider";var r=document.createElement("div");if(r.className="slider-track",k=document.createElement("div"),k.className="slider-track-low",j=document.createElement("div"),j.className="slider-selection",l=document.createElement("div"),l.className="slider-track-high",m=document.createElement("div"),m.className="slider-handle min-slider-handle",n=document.createElement("div"),n.className="slider-handle max-slider-handle",r.appendChild(k),r.appendChild(j),r.appendChild(l),this.ticks=[],Array.isArray(this.options.ticks)&&this.options.ticks.length>0){for(g=0;g<this.options.ticks.length;g++){var s=document.createElement("div");s.className="slider-tick",this.ticks.push(s),r.appendChild(s)}j.className+=" tick-slider-selection"}if(r.appendChild(m),r.appendChild(n),this.tickLabels=[],Array.isArray(this.options.ticks_labels)&&this.options.ticks_labels.length>0)for(this.tickLabelContainer=document.createElement("div"),this.tickLabelContainer.className="slider-tick-label-container",g=0;g<this.options.ticks_labels.length;g++){var t=document.createElement("div");t.className="slider-tick-label",t.innerHTML=this.options.ticks_labels[g],this.tickLabels.push(t),this.tickLabelContainer.appendChild(t)}var u=function(a){var b=document.createElement("div");b.className="tooltip-arrow";var c=document.createElement("div");c.className="tooltip-inner",a.appendChild(b),a.appendChild(c)},v=document.createElement("div");v.className="tooltip tooltip-main",u(v);var w=document.createElement("div");w.className="tooltip tooltip-min",u(w);var x=document.createElement("div");x.className="tooltip tooltip-max",u(x),this.sliderElem.appendChild(r),this.sliderElem.appendChild(v),this.sliderElem.appendChild(w),this.sliderElem.appendChild(x),this.tickLabelContainer&&this.sliderElem.appendChild(this.tickLabelContainer),q.insertBefore(this.sliderElem,this.element),this.element.style.display="none"}if(a&&(this.$element=a(this.element),this.$sliderElem=a(this.sliderElem)),this.eventToCallbackMap={},this.sliderElem.id=this.options.id,this.touchCapable="ontouchstart"in window||window.DocumentTouch&&document instanceof window.DocumentTouch,this.tooltip=this.sliderElem.querySelector(".tooltip-main"),this.tooltipInner=this.tooltip.querySelector(".tooltip-inner"),this.tooltip_min=this.sliderElem.querySelector(".tooltip-min"),this.tooltipInner_min=this.tooltip_min.querySelector(".tooltip-inner"),this.tooltip_max=this.sliderElem.querySelector(".tooltip-max"),this.tooltipInner_max=this.tooltip_max.querySelector(".tooltip-inner"),e[this.options.scale]&&(this.options.scale=e[this.options.scale]),p===!0&&(this._removeClass(this.sliderElem,"slider-horizontal"),this._removeClass(this.sliderElem,"slider-vertical"),this._removeClass(this.tooltip,"hide"),this._removeClass(this.tooltip_min,"hide"),this._removeClass(this.tooltip_max,"hide"),["left","top","width","height"].forEach(function(a){this._removeProperty(this.trackLow,a),this._removeProperty(this.trackSelection,a),this._removeProperty(this.trackHigh,a)},this),[this.handle1,this.handle2].forEach(function(a){this._removeProperty(a,"left"),this._removeProperty(a,"top")},this),[this.tooltip,this.tooltip_min,this.tooltip_max].forEach(function(a){this._removeProperty(a,"left"),this._removeProperty(a,"top"),this._removeProperty(a,"margin-left"),this._removeProperty(a,"margin-top"),this._removeClass(a,"right"),this._removeClass(a,"top")},this)),"vertical"===this.options.orientation?(this._addClass(this.sliderElem,"slider-vertical"),this.stylePos="top",this.mousePos="pageY",this.sizePos="offsetHeight"):(this._addClass(this.sliderElem,"slider-horizontal"),this.sliderElem.style.width=o,this.options.orientation="horizontal",this.stylePos="left",this.mousePos="pageX",this.sizePos="offsetWidth"),this._setTooltipPosition(),Array.isArray(this.options.ticks)&&this.options.ticks.length>0&&(this.options.max=Math.max.apply(Math,this.options.ticks),this.options.min=Math.min.apply(Math,this.options.ticks)),Array.isArray(this.options.value)?(this.options.range=!0,this._state.value=this.options.value):this._state.value=this.options.range?[this.options.value,this.options.max]:this.options.value,this.trackLow=k||this.trackLow,this.trackSelection=j||this.trackSelection,this.trackHigh=l||this.trackHigh,"none"===this.options.selection&&(this._addClass(this.trackLow,"hide"),this._addClass(this.trackSelection,"hide"),this._addClass(this.trackHigh,"hide")),this.handle1=m||this.handle1,this.handle2=n||this.handle2,p===!0)for(this._removeClass(this.handle1,"round triangle"),this._removeClass(this.handle2,"round triangle hide"),g=0;g<this.ticks.length;g++)this._removeClass(this.ticks[g],"round triangle hide");var y=["round","triangle","custom"],z=-1!==y.indexOf(this.options.handle);if(z)for(this._addClass(this.handle1,this.options.handle),this._addClass(this.handle2,this.options.handle),g=0;g<this.ticks.length;g++)this._addClass(this.ticks[g],this.options.handle);this._state.offset=this._offset(this.sliderElem),this._state.size=this.sliderElem[this.sizePos],this.setValue(this._state.value),this.handle1Keydown=this._keydown.bind(this,0),this.handle1.addEventListener("keydown",this.handle1Keydown,!1),this.handle2Keydown=this._keydown.bind(this,1),this.handle2.addEventListener("keydown",this.handle2Keydown,!1),this.mousedown=this._mousedown.bind(this),this.touchCapable&&this.sliderElem.addEventListener("touchstart",this.mousedown,!1),this.sliderElem.addEventListener("mousedown",this.mousedown,!1),"hide"===this.options.tooltip?(this._addClass(this.tooltip,"hide"),this._addClass(this.tooltip_min,"hide"),this._addClass(this.tooltip_max,"hide")):"always"===this.options.tooltip?(this._showTooltip(),this._alwaysShowTooltip=!0):(this.showTooltip=this._showTooltip.bind(this),this.hideTooltip=this._hideTooltip.bind(this),this.sliderElem.addEventListener("mouseenter",this.showTooltip,!1),this.sliderElem.addEventListener("mouseleave",this.hideTooltip,!1),this.handle1.addEventListener("focus",this.showTooltip,!1),this.handle1.addEventListener("blur",this.hideTooltip,!1),this.handle2.addEventListener("focus",this.showTooltip,!1),this.handle2.addEventListener("blur",this.hideTooltip,!1)),this.options.enabled?this.enable():this.disable()}var d={formatInvalidInputErrorMsg:function(a){return"Invalid input value '"+a+"' passed in"},callingContextNotSliderInstance:"Calling context element does not have instance of Slider bound to it. Check your code to make sure the JQuery object returned from the call to the slider() initializer is calling the method"},e={linear:{toValue:function(a){var b=a/100*(this.options.max-this.options.min);if(this.options.ticks_positions.length>0){for(var c,d,e,f=0,g=0;g<this.options.ticks_positions.length;g++)if(a<=this.options.ticks_positions[g]){c=g>0?this.options.ticks[g-1]:0,e=g>0?this.options.ticks_positions[g-1]:0,d=this.options.ticks[g],f=this.options.ticks_positions[g];break}if(g>0){var h=(a-e)/(f-e);b=c+h*(d-c)}}var i=this.options.min+Math.round(b/this.options.step)*this.options.step;return i<this.options.min?this.options.min:i>this.options.max?this.options.max:i},toPercentage:function(a){if(this.options.max===this.options.min)return 0;if(this.options.ticks_positions.length>0){for(var b,c,d,e=0,f=0;f<this.options.ticks.length;f++)if(a<=this.options.ticks[f]){b=f>0?this.options.ticks[f-1]:0,d=f>0?this.options.ticks_positions[f-1]:0,c=this.options.ticks[f],e=this.options.ticks_positions[f];break}if(f>0){var g=(a-b)/(c-b);return d+g*(e-d)}}return 100*(a-this.options.min)/(this.options.max-this.options.min)}},logarithmic:{toValue:function(a){var b=0===this.options.min?0:Math.log(this.options.min),c=Math.log(this.options.max),d=Math.exp(b+(c-b)*a/100);return d=this.options.min+Math.round((d-this.options.min)/this.options.step)*this.options.step,d<this.options.min?this.options.min:d>this.options.max?this.options.max:d},toPercentage:function(a){if(this.options.max===this.options.min)return 0;var b=Math.log(this.options.max),c=0===this.options.min?0:Math.log(this.options.min),d=0===a?0:Math.log(a);return 100*(d-c)/(b-c)}}};if(b=function(a,b){return c.call(this,a,b),this},b.prototype={_init:function(){},constructor:b,defaultOptions:{id:"",min:0,max:10,step:1,precision:0,orientation:"horizontal",value:5,range:!1,selection:"before",tooltip:"show",tooltip_split:!1,handle:"round",reversed:!1,enabled:!0,formatter:function(a){return Array.isArray(a)?a[0]+" : "+a[1]:a},natural_arrow_keys:!1,ticks:[],ticks_positions:[],ticks_labels:[],ticks_snap_bounds:0,scale:"linear",focus:!1,tooltip_position:null},getElement:function(){return this.sliderElem},getValue:function(){return this.options.range?this._state.value:this._state.value[0]},setValue:function(a,b,c){a||(a=0);var d=this.getValue();this._state.value=this._validateInputValue(a);var e=this._applyPrecision.bind(this);this.options.range?(this._state.value[0]=e(this._state.value[0]),this._state.value[1]=e(this._state.value[1]),this._state.value[0]=Math.max(this.options.min,Math.min(this.options.max,this._state.value[0])),this._state.value[1]=Math.max(this.options.min,Math.min(this.options.max,this._state.value[1]))):(this._state.value=e(this._state.value),this._state.value=[Math.max(this.options.min,Math.min(this.options.max,this._state.value))],this._addClass(this.handle2,"hide"),this._state.value[1]="after"===this.options.selection?this.options.max:this.options.min),this._state.percentage=this.options.max>this.options.min?[this._toPercentage(this._state.value[0]),this._toPercentage(this._state.value[1]),100*this.options.step/(this.options.max-this.options.min)]:[0,0,100],this._layout();var f=this.options.range?this._state.value:this._state.value[0];return b===!0&&this._trigger("slide",f),d!==f&&c===!0&&this._trigger("change",{oldValue:d,newValue:f}),this._setDataVal(f),this},destroy:function(){this._removeSliderEventHandlers(),this.sliderElem.parentNode.removeChild(this.sliderElem),this.element.style.display="",this._cleanUpEventCallbacksMap(),this.element.removeAttribute("data"),a&&(this._unbindJQueryEventHandlers(),this.$element.removeData("slider"))},disable:function(){return this._state.enabled=!1,this.handle1.removeAttribute("tabindex"),this.handle2.removeAttribute("tabindex"),this._addClass(this.sliderElem,"slider-disabled"),this._trigger("slideDisabled"),this},enable:function(){return this._state.enabled=!0,this.handle1.setAttribute("tabindex",0),this.handle2.setAttribute("tabindex",0),this._removeClass(this.sliderElem,"slider-disabled"),this._trigger("slideEnabled"),this},toggle:function(){return this._state.enabled?this.disable():this.enable(),this},isEnabled:function(){return this._state.enabled},on:function(a,b){return this._bindNonQueryEventHandler(a,b),this},off:function(b,c){a?(this.$element.off(b,c),this.$sliderElem.off(b,c)):this._unbindNonQueryEventHandler(b,c)},getAttribute:function(a){return a?this.options[a]:this.options},setAttribute:function(a,b){return this.options[a]=b,this},refresh:function(){return this._removeSliderEventHandlers(),c.call(this,this.element,this.options),a&&a.data(this.element,"slider",this),this},relayout:function(){return this._layout(),this},_removeSliderEventHandlers:function(){this.handle1.removeEventListener("keydown",this.handle1Keydown,!1),this.handle1.removeEventListener("focus",this.showTooltip,!1),this.handle1.removeEventListener("blur",this.hideTooltip,!1),this.handle2.removeEventListener("keydown",this.handle2Keydown,!1),this.handle2.removeEventListener("focus",this.handle2Keydown,!1),this.handle2.removeEventListener("blur",this.handle2Keydown,!1),this.sliderElem.removeEventListener("mouseenter",this.showTooltip,!1),this.sliderElem.removeEventListener("mouseleave",this.hideTooltip,!1),this.sliderElem.removeEventListener("touchstart",this.mousedown,!1),this.sliderElem.removeEventListener("mousedown",this.mousedown,!1)},_bindNonQueryEventHandler:function(a,b){void 0===this.eventToCallbackMap[a]&&(this.eventToCallbackMap[a]=[]),this.eventToCallbackMap[a].push(b)},_unbindNonQueryEventHandler:function(a,b){var c=this.eventToCallbackMap[a];if(void 0!==c)for(var d=0;d<c.length;d++)if(c[d]===b){c.splice(d,1);break}},_cleanUpEventCallbacksMap:function(){for(var a=Object.keys(this.eventToCallbackMap),b=0;b<a.length;b++){var c=a[b];this.eventToCallbackMap[c]=null}},_showTooltip:function(){this.options.tooltip_split===!1?(this._addClass(this.tooltip,"in"),this.tooltip_min.style.display="none",this.tooltip_max.style.display="none"):(this._addClass(this.tooltip_min,"in"),this._addClass(this.tooltip_max,"in"),this.tooltip.style.display="none"),this._state.over=!0},_hideTooltip:function(){this._state.inDrag===!1&&this.alwaysShowTooltip!==!0&&(this._removeClass(this.tooltip,"in"),this._removeClass(this.tooltip_min,"in"),this._removeClass(this.tooltip_max,"in")),this._state.over=!1},_layout:function(){var a;if(a=this.options.reversed?[100-this._state.percentage[0],this.options.range?100-this._state.percentage[1]:this._state.percentage[1]]:[this._state.percentage[0],this._state.percentage[1]],this.handle1.style[this.stylePos]=a[0]+"%",this.handle2.style[this.stylePos]=a[1]+"%",Array.isArray(this.options.ticks)&&this.options.ticks.length>0){var b=Math.max.apply(Math,this.options.ticks),c=Math.min.apply(Math,this.options.ticks),d="vertical"===this.options.orientation?"height":"width",e="vertical"===this.options.orientation?"marginTop":"marginLeft",f=this._state.size/(this.options.ticks.length-1);if(this.tickLabelContainer){var g=0;if(0===this.options.ticks_positions.length)this.tickLabelContainer.style[e]=-f/2+"px",g=this.tickLabelContainer.offsetHeight;else for(h=0;h<this.tickLabelContainer.childNodes.length;h++)this.tickLabelContainer.childNodes[h].offsetHeight>g&&(g=this.tickLabelContainer.childNodes[h].offsetHeight);"horizontal"===this.options.orientation&&(this.sliderElem.style.marginBottom=g+"px")}for(var h=0;h<this.options.ticks.length;h++){var i=this.options.ticks_positions[h]||100*(this.options.ticks[h]-c)/(b-c);this.ticks[h].style[this.stylePos]=i+"%",this._removeClass(this.ticks[h],"in-selection"),this.options.range?i>=a[0]&&i<=a[1]&&this._addClass(this.ticks[h],"in-selection"):"after"===this.options.selection&&i>=a[0]?this._addClass(this.ticks[h],"in-selection"):"before"===this.options.selection&&i<=a[0]&&this._addClass(this.ticks[h],"in-selection"),this.tickLabels[h]&&(this.tickLabels[h].style[d]=f+"px",void 0!==this.options.ticks_positions[h]&&(this.tickLabels[h].style.position="absolute",this.tickLabels[h].style[this.stylePos]=this.options.ticks_positions[h]+"%",this.tickLabels[h].style[e]=-f/2+"px"))}}var j;if(this.options.range){j=this.options.formatter(this._state.value),this._setText(this.tooltipInner,j),this.tooltip.style[this.stylePos]=(a[1]+a[0])/2+"%","vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px"),"vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px");var k=this.options.formatter(this._state.value[0]);this._setText(this.tooltipInner_min,k);var l=this.options.formatter(this._state.value[1]);this._setText(this.tooltipInner_max,l),this.tooltip_min.style[this.stylePos]=a[0]+"%","vertical"===this.options.orientation?this._css(this.tooltip_min,"margin-top",-this.tooltip_min.offsetHeight/2+"px"):this._css(this.tooltip_min,"margin-left",-this.tooltip_min.offsetWidth/2+"px"),this.tooltip_max.style[this.stylePos]=a[1]+"%","vertical"===this.options.orientation?this._css(this.tooltip_max,"margin-top",-this.tooltip_max.offsetHeight/2+"px"):this._css(this.tooltip_max,"margin-left",-this.tooltip_max.offsetWidth/2+"px")}else j=this.options.formatter(this._state.value[0]),this._setText(this.tooltipInner,j),this.tooltip.style[this.stylePos]=a[0]+"%","vertical"===this.options.orientation?this._css(this.tooltip,"margin-top",-this.tooltip.offsetHeight/2+"px"):this._css(this.tooltip,"margin-left",-this.tooltip.offsetWidth/2+"px");if("vertical"===this.options.orientation)this.trackLow.style.top="0",this.trackLow.style.height=Math.min(a[0],a[1])+"%",this.trackSelection.style.top=Math.min(a[0],a[1])+"%",this.trackSelection.style.height=Math.abs(a[0]-a[1])+"%",this.trackHigh.style.bottom="0",this.trackHigh.style.height=100-Math.min(a[0],a[1])-Math.abs(a[0]-a[1])+"%";else{this.trackLow.style.left="0",this.trackLow.style.width=Math.min(a[0],a[1])+"%",this.trackSelection.style.left=Math.min(a[0],a[1])+"%",this.trackSelection.style.width=Math.abs(a[0]-a[1])+"%",this.trackHigh.style.right="0",this.trackHigh.style.width=100-Math.min(a[0],a[1])-Math.abs(a[0]-a[1])+"%";var m=this.tooltip_min.getBoundingClientRect(),n=this.tooltip_max.getBoundingClientRect();m.right>n.left?(this._removeClass(this.tooltip_max,"top"),this._addClass(this.tooltip_max,"bottom"),this.tooltip_max.style.top="18px"):(this._removeClass(this.tooltip_max,"bottom"),this._addClass(this.tooltip_max,"top"),this.tooltip_max.style.top=this.tooltip_min.style.top)}},_removeProperty:function(a,b){a.style.removeProperty?a.style.removeProperty(b):a.style.removeAttribute(b)},_mousedown:function(a){if(!this._state.enabled)return!1;this._state.offset=this._offset(this.sliderElem),this._state.size=this.sliderElem[this.sizePos];var b=this._getPercentage(a);if(this.options.range){var c=Math.abs(this._state.percentage[0]-b),d=Math.abs(this._state.percentage[1]-b);this._state.dragged=d>c?0:1}else this._state.dragged=0;this._state.percentage[this._state.dragged]=b,this._layout(),this.touchCapable&&(document.removeEventListener("touchmove",this.mousemove,!1),document.removeEventListener("touchend",this.mouseup,!1)),this.mousemove&&document.removeEventListener("mousemove",this.mousemove,!1),this.mouseup&&document.removeEventListener("mouseup",this.mouseup,!1),this.mousemove=this._mousemove.bind(this),this.mouseup=this._mouseup.bind(this),this.touchCapable&&(document.addEventListener("touchmove",this.mousemove,!1),document.addEventListener("touchend",this.mouseup,!1)),document.addEventListener("mousemove",this.mousemove,!1),document.addEventListener("mouseup",this.mouseup,!1),this._state.inDrag=!0;var e=this._calculateValue();return this._trigger("slideStart",e),this._setDataVal(e),this.setValue(e,!1,!0),this._pauseEvent(a),this.options.focus&&this._triggerFocusOnHandle(this._state.dragged),!0},_triggerFocusOnHandle:function(a){0===a&&this.handle1.focus(),1===a&&this.handle2.focus()},_keydown:function(a,b){if(!this._state.enabled)return!1;var c;switch(b.keyCode){case 37:case 40:c=-1;break;case 39:case 38:c=1}if(c){if(this.options.natural_arrow_keys){var d="vertical"===this.options.orientation&&!this.options.reversed,e="horizontal"===this.options.orientation&&this.options.reversed;(d||e)&&(c=-c)}var f=this._state.value[a]+c*this.options.step;return this.options.range&&(f=[a?this._state.value[0]:f,a?f:this._state.value[1]]),this._trigger("slideStart",f),this._setDataVal(f),this.setValue(f,!0,!0),this._setDataVal(f),this._trigger("slideStop",f),this._layout(),this._pauseEvent(b),!1}},_pauseEvent:function(a){a.stopPropagation&&a.stopPropagation(),a.preventDefault&&a.preventDefault(),a.cancelBubble=!0,a.returnValue=!1},_mousemove:function(a){if(!this._state.enabled)return!1;var b=this._getPercentage(a);this._adjustPercentageForRangeSliders(b),this._state.percentage[this._state.dragged]=b,this._layout();var c=this._calculateValue(!0);return this.setValue(c,!0,!0),!1},_adjustPercentageForRangeSliders:function(a){if(this.options.range){var b=this._getNumDigitsAfterDecimalPlace(a);b=b?b-1:0;var c=this._applyToFixedAndParseFloat(a,b);0===this._state.dragged&&this._applyToFixedAndParseFloat(this._state.percentage[1],b)<c?(this._state.percentage[0]=this._state.percentage[1],this._state.dragged=1):1===this._state.dragged&&this._applyToFixedAndParseFloat(this._state.percentage[0],b)>c&&(this._state.percentage[1]=this._state.percentage[0],this._state.dragged=0)}},_mouseup:function(){if(!this._state.enabled)return!1;this.touchCapable&&(document.removeEventListener("touchmove",this.mousemove,!1),document.removeEventListener("touchend",this.mouseup,!1)),document.removeEventListener("mousemove",this.mousemove,!1),document.removeEventListener("mouseup",this.mouseup,!1),this._state.inDrag=!1,this._state.over===!1&&this._hideTooltip();var a=this._calculateValue(!0);return this._layout(),this._setDataVal(a),this._trigger("slideStop",a),!1},_calculateValue:function(a){var b;if(this.options.range?(b=[this.options.min,this.options.max],0!==this._state.percentage[0]&&(b[0]=this._toValue(this._state.percentage[0]),b[0]=this._applyPrecision(b[0])),100!==this._state.percentage[1]&&(b[1]=this._toValue(this._state.percentage[1]),b[1]=this._applyPrecision(b[1]))):(b=this._toValue(this._state.percentage[0]),b=parseFloat(b),b=this._applyPrecision(b)),a){for(var c=[b,1/0],d=0;d<this.options.ticks.length;d++){var e=Math.abs(this.options.ticks[d]-b);e<=c[1]&&(c=[this.options.ticks[d],e])}if(c[1]<=this.options.ticks_snap_bounds)return c[0]}return b},_applyPrecision:function(a){var b=this.options.precision||this._getNumDigitsAfterDecimalPlace(this.options.step);return this._applyToFixedAndParseFloat(a,b)},_getNumDigitsAfterDecimalPlace:function(a){var b=(""+a).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return b?Math.max(0,(b[1]?b[1].length:0)-(b[2]?+b[2]:0)):0},_applyToFixedAndParseFloat:function(a,b){var c=a.toFixed(b);return parseFloat(c)},_getPercentage:function(a){!this.touchCapable||"touchstart"!==a.type&&"touchmove"!==a.type||(a=a.touches[0]);var b=a[this.mousePos],c=this._state.offset[this.stylePos],d=b-c,e=d/this._state.size*100;return e=Math.round(e/this._state.percentage[2])*this._state.percentage[2],this.options.reversed&&(e=100-e),Math.max(0,Math.min(100,e))},_validateInputValue:function(a){if("number"==typeof a)return a;if(Array.isArray(a))return this._validateArray(a),a;throw new Error(d.formatInvalidInputErrorMsg(a))},_validateArray:function(a){for(var b=0;b<a.length;b++){var c=a[b];if("number"!=typeof c)throw new Error(d.formatInvalidInputErrorMsg(c))}},_setDataVal:function(a){this.element.setAttribute("data-value",a),this.element.setAttribute("value",a),this.element.value=a},_trigger:function(b,c){c=c||0===c?c:void 0;var d=this.eventToCallbackMap[b];if(d&&d.length)for(var e=0;e<d.length;e++){var f=d[e];f(c)}a&&this._triggerJQueryEvent(b,c)},_triggerJQueryEvent:function(a,b){var c={type:a,value:b};this.$element.trigger(c),this.$sliderElem.trigger(c)},_unbindJQueryEventHandlers:function(){this.$element.off(),this.$sliderElem.off()},_setText:function(a,b){"undefined"!=typeof a.innerText?a.innerText=b:"undefined"!=typeof a.textContent&&(a.textContent=b)},_removeClass:function(a,b){for(var c=b.split(" "),d=a.className,e=0;e<c.length;e++){var f=c[e],g=new RegExp("(?:\\s|^)"+f+"(?:\\s|$)");d=d.replace(g," ")}a.className=d.trim()},_addClass:function(a,b){for(var c=b.split(" "),d=a.className,e=0;e<c.length;e++){var f=c[e],g=new RegExp("(?:\\s|^)"+f+"(?:\\s|$)"),h=g.test(d);h||(d+=" "+f)}a.className=d.trim()},_offsetLeft:function(a){return a.getBoundingClientRect().left},_offsetTop:function(a){for(var b=a.offsetTop;(a=a.offsetParent)&&!isNaN(a.offsetTop);)b+=a.offsetTop;return b},_offset:function(a){return{left:this._offsetLeft(a),top:this._offsetTop(a)}},_css:function(b,c,d){if(a)a.style(b,c,d);else{var e=c.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,function(a,b){return b.toUpperCase()});b.style[e]=d}},_toValue:function(a){return this.options.scale.toValue.apply(this,[a])},_toPercentage:function(a){return this.options.scale.toPercentage.apply(this,[a])},_setTooltipPosition:function(){var a=[this.tooltip,this.tooltip_min,this.tooltip_max];if("vertical"===this.options.orientation){var b=this.options.tooltip_position||"right",c="left"===b?"right":"left";a.forEach(function(a){this._addClass(a,b),a.style[c]="100%"}.bind(this))}else a.forEach("bottom"===this.options.tooltip_position?function(a){this._addClass(a,"bottom"),a.style.top="22px"}.bind(this):function(a){this._addClass(a,"top"),a.style.top=-this.tooltip.outerHeight-14+"px"}.bind(this))}},a){var f=a.fn.slider?"bootstrapSlider":"slider";a.bridget(f,b)}}(a),b});

/***/ },
/* 12 */
/***/ function(module, exports) {

	(function() { module.exports = this["$"]; }());

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module unless amdModuleId is set
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return (root['SignaturePad'] = factory());
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // Node. Does not work with strict CommonJS, but
	    // only CommonJS-like environments that support module.exports,
	    // like Node.
	    module.exports = factory();
	  } else {
	    root['SignaturePad'] = factory();
	  }
	}(this, function () {
	
	/*!
	 * Signature Pad v1.5.3
	 * https://github.com/szimek/signature_pad
	 *
	 * Copyright 2016 Szymon Nowak
	 * Released under the MIT license
	 *
	 * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:
	 * http://corner.squareup.com/2012/07/smoother-signatures.html
	 *
	 * Implementation of interpolation using cubic Bézier curves is taken from:
	 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
	 *
	 * Algorithm for approximated length of a Bézier curve is taken from:
	 * http://www.lemoda.net/maths/bezier-length/index.html
	 *
	 */
	var SignaturePad = (function (document) {
	    "use strict";
	
	    var SignaturePad = function (canvas, options) {
	        var self = this,
	            opts = options || {};
	
	        this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
	        this.minWidth = opts.minWidth || 0.5;
	        this.maxWidth = opts.maxWidth || 2.5;
	        this.dotSize = opts.dotSize || function () {
	            return (this.minWidth + this.maxWidth) / 2;
	        };
	        this.penColor = opts.penColor || "black";
	        this.backgroundColor = opts.backgroundColor || "rgba(0,0,0,0)";
	        this.onEnd = opts.onEnd;
	        this.onBegin = opts.onBegin;
	
	        this._canvas = canvas;
	        this._ctx = canvas.getContext("2d");
	        this.clear();
	
	        // we need add these inline so they are available to unbind while still having
	        //  access to 'self' we could use _.bind but it's not worth adding a dependency
	        this._handleMouseDown = function (event) {
	            if (event.which === 1) {
	                self._mouseButtonDown = true;
	                self._strokeBegin(event);
	            }
	        };
	
	        this._handleMouseMove = function (event) {
	            if (self._mouseButtonDown) {
	                self._strokeUpdate(event);
	            }
	        };
	
	        this._handleMouseUp = function (event) {
	            if (event.which === 1 && self._mouseButtonDown) {
	                self._mouseButtonDown = false;
	                self._strokeEnd(event);
	            }
	        };
	
	        this._handleTouchStart = function (event) {
	            if (event.targetTouches.length == 1) {
	                var touch = event.changedTouches[0];
	                self._strokeBegin(touch);
	             }
	        };
	
	        this._handleTouchMove = function (event) {
	            // Prevent scrolling.
	            event.preventDefault();
	
	            var touch = event.targetTouches[0];
	            self._strokeUpdate(touch);
	        };
	
	        this._handleTouchEnd = function (event) {
	            var wasCanvasTouched = event.target === self._canvas;
	            if (wasCanvasTouched) {
	                event.preventDefault();
	                self._strokeEnd(event);
	            }
	        };
	
	        this._handleMouseEvents();
	        this._handleTouchEvents();
	    };
	
	    SignaturePad.prototype.clear = function () {
	        var ctx = this._ctx,
	            canvas = this._canvas;
	
	        ctx.fillStyle = this.backgroundColor;
	        ctx.clearRect(0, 0, canvas.width, canvas.height);
	        ctx.fillRect(0, 0, canvas.width, canvas.height);
	        this._reset();
	    };
	
	    SignaturePad.prototype.toDataURL = function (imageType, quality) {
	        var canvas = this._canvas;
	        return canvas.toDataURL.apply(canvas, arguments);
	    };
	
	    SignaturePad.prototype.fromDataURL = function (dataUrl) {
	        var self = this,
	            image = new Image(),
	            ratio = window.devicePixelRatio || 1,
	            width = this._canvas.width / ratio,
	            height = this._canvas.height / ratio;
	
	        this._reset();
	        image.src = dataUrl;
	        image.onload = function () {
	            self._ctx.drawImage(image, 0, 0, width, height);
	        };
	        this._isEmpty = false;
	    };
	
	    SignaturePad.prototype._strokeUpdate = function (event) {
	        var point = this._createPoint(event);
	        this._addPoint(point);
	    };
	
	    SignaturePad.prototype._strokeBegin = function (event) {
	        this._reset();
	        this._strokeUpdate(event);
	        if (typeof this.onBegin === 'function') {
	            this.onBegin(event);
	        }
	    };
	
	    SignaturePad.prototype._strokeDraw = function (point) {
	        var ctx = this._ctx,
	            dotSize = typeof(this.dotSize) === 'function' ? this.dotSize() : this.dotSize;
	
	        ctx.beginPath();
	        this._drawPoint(point.x, point.y, dotSize);
	        ctx.closePath();
	        ctx.fill();
	    };
	
	    SignaturePad.prototype._strokeEnd = function (event) {
	        var canDrawCurve = this.points.length > 2,
	            point = this.points[0];
	
	        if (!canDrawCurve && point) {
	            this._strokeDraw(point);
	        }
	        if (typeof this.onEnd === 'function') {
	            this.onEnd(event);
	        }
	    };
	
	    SignaturePad.prototype._handleMouseEvents = function () {
	        this._mouseButtonDown = false;
	
	        this._canvas.addEventListener("mousedown", this._handleMouseDown);
	        this._canvas.addEventListener("mousemove", this._handleMouseMove);
	        document.addEventListener("mouseup", this._handleMouseUp);
	    };
	
	    SignaturePad.prototype._handleTouchEvents = function () {
	        // Pass touch events to canvas element on mobile IE11 and Edge.
	        this._canvas.style.msTouchAction = 'none';
	        this._canvas.style.touchAction = 'none';
	
	        this._canvas.addEventListener("touchstart", this._handleTouchStart);
	        this._canvas.addEventListener("touchmove", this._handleTouchMove);
	        this._canvas.addEventListener("touchend", this._handleTouchEnd);
	    };
	
	    SignaturePad.prototype.on = function () {
	        this._handleMouseEvents();
	        this._handleTouchEvents();
	    };
	
	    SignaturePad.prototype.off = function () {
	        this._canvas.removeEventListener("mousedown", this._handleMouseDown);
	        this._canvas.removeEventListener("mousemove", this._handleMouseMove);
	        document.removeEventListener("mouseup", this._handleMouseUp);
	
	        this._canvas.removeEventListener("touchstart", this._handleTouchStart);
	        this._canvas.removeEventListener("touchmove", this._handleTouchMove);
	        this._canvas.removeEventListener("touchend", this._handleTouchEnd);
	    };
	
	    SignaturePad.prototype.isEmpty = function () {
	        return this._isEmpty;
	    };
	
	    SignaturePad.prototype._reset = function () {
	        this.points = [];
	        this._lastVelocity = 0;
	        this._lastWidth = (this.minWidth + this.maxWidth) / 2;
	        this._isEmpty = true;
	        this._ctx.fillStyle = this.penColor;
	    };
	
	    SignaturePad.prototype._createPoint = function (event) {
	        var rect = this._canvas.getBoundingClientRect();
	        return new Point(
	            event.clientX - rect.left,
	            event.clientY - rect.top
	        );
	    };
	
	    SignaturePad.prototype._addPoint = function (point) {
	        var points = this.points,
	            c2, c3,
	            curve, tmp;
	
	        points.push(point);
	
	        if (points.length > 2) {
	            // To reduce the initial lag make it work with 3 points
	            // by copying the first point to the beginning.
	            if (points.length === 3) points.unshift(points[0]);
	
	            tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
	            c2 = tmp.c2;
	            tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
	            c3 = tmp.c1;
	            curve = new Bezier(points[1], c2, c3, points[2]);
	            this._addCurve(curve);
	
	            // Remove the first element from the list,
	            // so that we always have no more than 4 points in points array.
	            points.shift();
	        }
	    };
	
	    SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
	        var dx1 = s1.x - s2.x, dy1 = s1.y - s2.y,
	            dx2 = s2.x - s3.x, dy2 = s2.y - s3.y,
	
	            m1 = {x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0},
	            m2 = {x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0},
	
	            l1 = Math.sqrt(dx1*dx1 + dy1*dy1),
	            l2 = Math.sqrt(dx2*dx2 + dy2*dy2),
	
	            dxm = (m1.x - m2.x),
	            dym = (m1.y - m2.y),
	
	            k = l2 / (l1 + l2),
	            cm = {x: m2.x + dxm*k, y: m2.y + dym*k},
	
	            tx = s2.x - cm.x,
	            ty = s2.y - cm.y;
	
	        return {
	            c1: new Point(m1.x + tx, m1.y + ty),
	            c2: new Point(m2.x + tx, m2.y + ty)
	        };
	    };
	
	    SignaturePad.prototype._addCurve = function (curve) {
	        var startPoint = curve.startPoint,
	            endPoint = curve.endPoint,
	            velocity, newWidth;
	
	        velocity = endPoint.velocityFrom(startPoint);
	        velocity = this.velocityFilterWeight * velocity
	            + (1 - this.velocityFilterWeight) * this._lastVelocity;
	
	        newWidth = this._strokeWidth(velocity);
	        this._drawCurve(curve, this._lastWidth, newWidth);
	
	        this._lastVelocity = velocity;
	        this._lastWidth = newWidth;
	    };
	
	    SignaturePad.prototype._drawPoint = function (x, y, size) {
	        var ctx = this._ctx;
	
	        ctx.moveTo(x, y);
	        ctx.arc(x, y, size, 0, 2 * Math.PI, false);
	        this._isEmpty = false;
	    };
	
	    SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
	        var ctx = this._ctx,
	            widthDelta = endWidth - startWidth,
	            drawSteps, width, i, t, tt, ttt, u, uu, uuu, x, y;
	
	        drawSteps = Math.floor(curve.length());
	        ctx.beginPath();
	        for (i = 0; i < drawSteps; i++) {
	            // Calculate the Bezier (x, y) coordinate for this step.
	            t = i / drawSteps;
	            tt = t * t;
	            ttt = tt * t;
	            u = 1 - t;
	            uu = u * u;
	            uuu = uu * u;
	
	            x = uuu * curve.startPoint.x;
	            x += 3 * uu * t * curve.control1.x;
	            x += 3 * u * tt * curve.control2.x;
	            x += ttt * curve.endPoint.x;
	
	            y = uuu * curve.startPoint.y;
	            y += 3 * uu * t * curve.control1.y;
	            y += 3 * u * tt * curve.control2.y;
	            y += ttt * curve.endPoint.y;
	
	            width = startWidth + ttt * widthDelta;
	            this._drawPoint(x, y, width);
	        }
	        ctx.closePath();
	        ctx.fill();
	    };
	
	    SignaturePad.prototype._strokeWidth = function (velocity) {
	        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
	    };
	
	
	    var Point = function (x, y, time) {
	        this.x = x;
	        this.y = y;
	        this.time = time || new Date().getTime();
	    };
	
	    Point.prototype.velocityFrom = function (start) {
	        return (this.time !== start.time) ? this.distanceTo(start) / (this.time - start.time) : 1;
	    };
	
	    Point.prototype.distanceTo = function (start) {
	        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
	    };
	
	    var Bezier = function (startPoint, control1, control2, endPoint) {
	        this.startPoint = startPoint;
	        this.control1 = control1;
	        this.control2 = control2;
	        this.endPoint = endPoint;
	    };
	
	    // Returns approximated length.
	    Bezier.prototype.length = function () {
	        var steps = 10,
	            length = 0,
	            i, t, cx, cy, px, py, xdiff, ydiff;
	
	        for (i = 0; i <= steps; i++) {
	            t = i / steps;
	            cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
	            cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
	            if (i > 0) {
	                xdiff = cx - px;
	                ydiff = cy - py;
	                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
	            }
	            px = cx;
	            py = cy;
	        }
	        return length;
	    };
	
	    Bezier.prototype._point = function (t, start, c1, c2, end) {
	        return          start * (1.0 - t) * (1.0 - t)  * (1.0 - t)
	               + 3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t
	               + 3.0 *  c2    * (1.0 - t) * t          * t
	               +        end   * t         * t          * t;
	    };
	
	    return SignaturePad;
	})(document);
	
	return SignaturePad;
	
	}));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var angular = __webpack_require__(1);
	var alias = __webpack_require__(15);
	exports.alias = alias;
	var autosave = __webpack_require__(16);
	exports.autosave = autosave;
	var popover = __webpack_require__(24);
	exports.popover = popover;
	var required = __webpack_require__(25);
	exports.required = required;
	exports.moduleName = 'rl.ui.behaviors';
	angular.module(exports.moduleName, [
	    alias.moduleName,
	    autosave.moduleName,
	    popover.moduleName,
	    required.moduleName,
	]);
	//# sourceMappingURL=behaviors.module.js.map

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.behaviors.alias';
	exports.directiveName = 'rlAlias';
	exports.controllerName = 'AliasController';
	var AliasController = (function () {
	    function AliasController($scope, $attrs, $parse, $interpolate) {
	        this.$scope = $scope;
	        this.$attrs = $attrs;
	        this.$parse = $parse;
	        this.$interpolate = $interpolate;
	        var initialValue = this.getValue();
	        this.resolveAlias(initialValue);
	        $scope.$watch(this.getValue.bind(this), this.resolveAlias.bind(this));
	    }
	    AliasController.prototype.getValue = function () {
	        this.expression = this.$attrs.rlAlias.split(' as ');
	        return this.$parse(this.expression[0])(this.$scope);
	    };
	    AliasController.prototype.resolveAlias = function (value) {
	        var alias = this.$interpolate(this.expression[1])(this.$scope);
	        if (alias != null) {
	            this.$scope[alias] = value;
	        }
	    };
	    AliasController.$inject = ['$scope', '$attrs', '$parse', '$interpolate'];
	    return AliasController;
	}());
	exports.AliasController = AliasController;
	function alias() {
	    return {
	        restrict: 'A',
	        controller: exports.controllerName,
	    };
	}
	exports.alias = alias;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, alias)
	    .controller(exports.controllerName, AliasController);
	//# sourceMappingURL=alias.js.map

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __objectUtility = typescript_angular_utilities_1.services.object;
	var autosave_service_1 = __webpack_require__(17);
	exports.moduleName = 'rl.ui.behaviors.autosave';
	exports.directiveName = 'rlAutosave';
	exports.controllerName = 'AutosaveController';
	var AutosaveController = (function () {
	    function AutosaveController($scope, $attrs, $parse, $element, $timeout, autosaveFactory, parentChildBehavior, objectUtility) {
	        this.$scope = $scope;
	        this.$attrs = $attrs;
	        this.$parse = $parse;
	        this.$element = $element;
	        this.$timeout = $timeout;
	        this.autosaveFactory = autosaveFactory;
	        this.parentChildBehavior = parentChildBehavior;
	        this.objectUtility = objectUtility;
	    }
	    AutosaveController.prototype.$onInit = function () {
	        var _this = this;
	        this.keyupListener = function (callback) {
	            _this.$element.on('keyup', function () { _this.$scope.$apply(callback); });
	            return function () {
	                _this.$element.off('keyup');
	            };
	        };
	        var saveExpression = this.$parse(this.$attrs.save);
	        var save = function () {
	            return saveExpression(_this.$scope);
	        };
	        var debounce = this.$parse(this.$attrs.debounceDuration)(this.$scope);
	        this.autosave = this.autosaveFactory.getInstance({
	            save: save,
	            contentForm: this.form,
	            debounceDuration: debounce,
	            triggers: this.$attrs.triggers,
	            setChangeListener: this.keyupListener,
	            saveWhenInvalid: this.$parse(this.$attrs.saveWhenInvalid)(this.$scope),
	        });
	        var behavior = {
	            autosave: this.autosave.autosave,
	        };
	        // register autosave behavior and assign the value back to the parent
	        var childLink = this.$parse(this.$attrs.rlAutosave)(this.$scope);
	        this.parentChildBehavior.registerChildBehavior(childLink, behavior);
	    };
	    AutosaveController.$inject = ['$scope',
	        '$attrs',
	        '$parse',
	        '$element',
	        '$timeout',
	        autosave_service_1.factoryName,
	        __parentChild.serviceName,
	        __objectUtility.serviceName];
	    return AutosaveController;
	}());
	exports.AutosaveController = AutosaveController;
	function autosave() {
	    'use strict';
	    return {
	        restrict: 'A',
	        priority: 1000,
	        require: { form: '?form' },
	        controller: exports.controllerName,
	        bindToController: true,
	    };
	}
	exports.autosave = autosave;
	angular.module(exports.moduleName, [
	    autosave_service_1.moduleName,
	    __objectUtility.moduleName,
	    __parentChild.moduleName,
	])
	    .directive(exports.directiveName, autosave)
	    .controller(exports.controllerName, AutosaveController);
	//# sourceMappingURL=autosave.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __notification = typescript_angular_utilities_1.services.notification;
	var autosaveAction_service_1 = __webpack_require__(19);
	var triggers = __webpack_require__(20);
	exports.triggers = triggers;
	var form_service_1 = __webpack_require__(23);
	exports.moduleName = 'rl.ui.services.autosave';
	exports.factoryName = 'autosaveFactory';
	var AutosaveService = (function () {
	    function AutosaveService(notification, autosaveService, options, triggerServiceFactory, formService) {
	        var _this = this;
	        this.notification = notification;
	        this.autosaveService = autosaveService;
	        this.formService = formService;
	        this.autosave = function () {
	            var data = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                data[_i - 0] = arguments[_i];
	            }
	            var result = _this.validateAndSave.apply(_this, data);
	            if (_.isBoolean(result)) {
	                return result;
	            }
	            else {
	                _this.autosaveService.trigger(result);
	                return true;
	            }
	        };
	        this.contentForm = options.contentForm || this.nullForm();
	        this.save = options.save;
	        this.saveWhenInvalid = options.saveWhenInvalid;
	        this.triggerService = triggerServiceFactory.getInstance();
	        this.configureTriggers(options);
	        this.triggerService.setTriggers(options.triggers, this.autosave);
	    }
	    AutosaveService.prototype.validateAndSave = function () {
	        var _this = this;
	        var data = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            data[_i - 0] = arguments[_i];
	        }
	        if (this.contentForm.$pristine) {
	            return true;
	        }
	        if (this.contentForm.$valid || this.saveWhenInvalid) {
	            var promise = this.save.apply(this, data);
	            if (!_.isUndefined(promise)) {
	                return promise.then(function () {
	                    if (_this.contentForm != null) {
	                        _this.contentForm.$setPristine();
	                    }
	                });
	            }
	            return true;
	        }
	        else {
	            this.notification.warning(this.formService.getAggregateError(this.contentForm));
	            return false;
	        }
	    };
	    AutosaveService.prototype.configureTriggers = function (options) {
	        this.triggerService.triggers.onChange.configure({
	            form: options.contentForm,
	            setChangeListener: options.setChangeListener,
	            debounceDuration: options.debounceDuration,
	            saveWhenInvalid: options.saveWhenInvalid,
	        });
	    };
	    AutosaveService.prototype.nullForm = function () {
	        return {
	            $pristine: false,
	            $dirty: true,
	            $valid: true,
	            $setPristine: function () {
	                return;
	            },
	        };
	    };
	    return AutosaveService;
	}());
	autosaveServiceFactory.$inject = [__notification.serviceName, autosaveAction_service_1.serviceName, triggers.factoryName, form_service_1.serviceName];
	function autosaveServiceFactory(notification, autosaveService, triggerServiceFactory, formService) {
	    'use strict';
	    return {
	        getInstance: function (options) {
	            return new AutosaveService(notification, autosaveService, options, triggerServiceFactory, formService);
	        }
	    };
	}
	angular.module(exports.moduleName, [__notification.moduleName, autosaveAction_service_1.moduleName, triggers.moduleName, form_service_1.moduleName])
	    .factory(exports.factoryName, autosaveServiceFactory);
	//# sourceMappingURL=autosave.service.js.map

/***/ },
/* 18 */
/***/ function(module, exports) {

	(function() { module.exports = this["_"]; }());

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ng = __webpack_require__(1);
	exports.moduleName = 'rl.utilities.services.autosaveAction';
	exports.serviceName = 'autosaveAction';
	var AutosaveActionService = (function () {
	    function AutosaveActionService($timeout) {
	        var _this = this;
	        this.$timeout = $timeout;
	        this.completeMessageDuration = 1000;
	        this.autosaveSuccessful = function (data) {
	            return _this.resolveAutosave(data, true);
	        };
	        this.autosaveFailed = function (data) {
	            return _this.resolveAutosave(data, false);
	        };
	        this.resolveAutosave = function (data, success) {
	            _this._saving = false;
	            _this._complete = true;
	            _this._successful = success;
	            _this.$timeout(function () {
	                _this._complete = false;
	            }, _this.completeMessageDuration);
	            return data;
	        };
	    }
	    Object.defineProperty(AutosaveActionService.prototype, "saving", {
	        get: function () {
	            return this._saving;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AutosaveActionService.prototype, "complete", {
	        get: function () {
	            return this._complete;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AutosaveActionService.prototype, "successful", {
	        get: function () {
	            return this._successful;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AutosaveActionService.prototype.trigger = function (promise) {
	        this._saving = true;
	        return promise.then(this.autosaveSuccessful)
	            .catch(this.autosaveFailed);
	    };
	    AutosaveActionService.$inject = ['$timeout'];
	    return AutosaveActionService;
	}());
	ng.module(exports.moduleName, [])
	    .service(exports.serviceName, AutosaveActionService);
	//# sourceMappingURL=autosaveAction.service.js.map

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var onChangeTrigger_1 = __webpack_require__(21);
	var trigger_1 = __webpack_require__(22);
	__export(__webpack_require__(21));
	__export(__webpack_require__(22));
	exports.defaultTriggers = 'onChange';
	exports.moduleName = 'rl.ui.services.autosave.triggers';
	exports.factoryName = 'autosaveTriggers';
	var TriggerService = (function () {
	    function TriggerService($rootScope, $timeout) {
	        this.triggers = {
	            onChange: new onChangeTrigger_1.OnChangeTrigger($rootScope, $timeout),
	            none: new trigger_1.Trigger('none'),
	        };
	    }
	    TriggerService.prototype.setTriggers = function (triggerString, autosave) {
	        if (triggerString == null) {
	            triggerString = exports.defaultTriggers;
	        }
	        _.each(this.triggers, function (trigger) {
	            if (trigger.hasMatch(triggerString)) {
	                trigger.setTrigger(autosave);
	            }
	        });
	    };
	    return TriggerService;
	}());
	triggerServiceFactory.$inject = ['$rootScope', '$timeout'];
	function triggerServiceFactory($rootScope, $timeout) {
	    return {
	        getInstance: function () {
	            return new TriggerService($rootScope, $timeout);
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .factory(exports.factoryName, triggerServiceFactory);
	//# sourceMappingURL=triggers.service.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(18);
	var trigger_1 = __webpack_require__(22);
	var OnChangeTrigger = (function (_super) {
	    __extends(OnChangeTrigger, _super);
	    function OnChangeTrigger($rootScope, $timeout) {
	        _super.call(this, 'onChange');
	        this.$rootScope = $rootScope;
	        this.$timeout = $timeout;
	        this.debounceDuration = 1000;
	    }
	    OnChangeTrigger.prototype.setTrigger = function (autosave) {
	        var _this = this;
	        if (_.isUndefined(this.settings)) {
	            return;
	        }
	        this.initListeners();
	        this.$rootScope.$watch(function () {
	            return _this.settings.form != null
	                ? _this.settings.form.$dirty
	                : false;
	        }, function () { _this.triggerSaveAction(autosave); });
	        this.$rootScope.$watch(function () {
	            return _this.settings.form != null
	                ? _this.settings.form.$valid
	                : false;
	        }, function () { _this.triggerSaveAction(autosave); });
	    };
	    OnChangeTrigger.prototype.triggerSaveAction = function (autosave) {
	        var _this = this;
	        if (this.settings.form.$dirty && (this.settings.form.$valid || this.settings.saveWhenInvalid)) {
	            this.setTimer(autosave);
	            this.clearListener = this.setListener(function () {
	                _this.setTimer(autosave);
	            });
	        }
	    };
	    OnChangeTrigger.prototype.setTimer = function (autosave) {
	        var _this = this;
	        if (this.timer != null) {
	            this.$timeout.cancel(this.timer);
	        }
	        this.timer = this.$timeout(function () {
	            _this.clearListener();
	            autosave();
	        }, this.debounceDuration);
	    };
	    OnChangeTrigger.prototype.initListeners = function () {
	        this.setListener = this.settings.setChangeListener || this.nullSetListener;
	        this.clearListener = this.nullClearListener;
	    };
	    OnChangeTrigger.prototype.nullSetListener = function () {
	        console.log('No change listener available');
	        return this.nullClearListener;
	    };
	    OnChangeTrigger.prototype.nullClearListener = function () {
	        console.log('No change listener register');
	    };
	    return OnChangeTrigger;
	}(trigger_1.Trigger));
	exports.OnChangeTrigger = OnChangeTrigger;
	//# sourceMappingURL=onChangeTrigger.js.map

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(18);
	var Trigger = (function () {
	    function Trigger(aliases, triggerAction) {
	        this.triggerAction = triggerAction;
	        this.aliases = aliases.split(' ');
	    }
	    Trigger.prototype.setTrigger = function (autosave) {
	        if (_.isFunction(this.triggerAction)) {
	            this.triggerAction(this.settings);
	        }
	    };
	    Trigger.prototype.hasMatch = function (triggers) {
	        var _this = this;
	        var triggerList = triggers.split(' ');
	        return _.some(triggerList, function (trigger) {
	            return _.some(_this.aliases, function (alias) {
	                return trigger === alias;
	            });
	        });
	    };
	    Trigger.prototype.configure = function (settings) {
	        this.settings = settings;
	    };
	    return Trigger;
	}());
	exports.Trigger = Trigger;
	//# sourceMappingURL=trigger.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.services.form';
	exports.serviceName = 'formService';
	var FormService = (function () {
	    function FormService() {
	    }
	    FormService.prototype.getAggregateError = function (form) {
	        var filteredForm = _.filter(form, function (prop) {
	            return prop != null && prop.rlErrorMessage != null;
	        });
	        var errors = _.mapValues(filteredForm, 'rlErrorMessage');
	        return _.first(errors);
	    };
	    return FormService;
	}());
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, FormService);
	//# sourceMappingURL=form.service.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __guid = typescript_angular_utilities_1.services.guid;
	exports.moduleName = 'rl.ui.behaviors.popover';
	exports.directiveName = 'rlPopover';
	exports.controllerName = 'PopoverController';
	var PopoverController = (function () {
	    function PopoverController($attrs, $element, $compile, $scope, $parse, $templateCache, guid) {
	        this.$attrs = $attrs;
	        this.$element = $element;
	        this.$compile = $compile;
	        this.$scope = $scope;
	        this.$parse = $parse;
	        this.$templateCache = $templateCache;
	        this.guid = guid;
	    }
	    PopoverController.prototype.$onInit = function () {
	        if (this.$parse(this.$attrs.textOnly)(this.$scope)) {
	            this.$element.attr('uib-popover', this.$attrs.rlPopover);
	        }
	        else {
	            var templatePath = this.guid.random() + '.html';
	            var templateContent = '<div>' + this.$parse(this.$attrs.rlPopover)(this.$scope) + '</div>';
	            if (templateContent != null) {
	                this.$templateCache.put(templatePath, templateContent);
	                this.$element.attr('uib-popover-template', '\'' + templatePath + '\'');
	            }
	        }
	        this.$element.removeAttr('rl-popover');
	        this.$compile(this.$element)(this.$scope);
	    };
	    PopoverController.$inject = ['$attrs',
	        '$element',
	        '$compile',
	        '$scope',
	        '$parse',
	        '$templateCache',
	        __guid.serviceName];
	    return PopoverController;
	}());
	exports.PopoverController = PopoverController;
	function popover() {
	    'use strict';
	    return {
	        restrict: 'A',
	        priority: 300,
	        controller: exports.controllerName,
	    };
	}
	exports.popover = popover;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, popover)
	    .controller(exports.controllerName, PopoverController);
	//# sourceMappingURL=popover.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.behaviors.required';
	exports.directiveName = 'rlRequired';
	exports.controllerName = 'RequiredController';
	var RequiredController = (function () {
	    function RequiredController($scope, $attrs, $interpolate) {
	        this.$scope = $scope;
	        this.$attrs = $attrs;
	        this.$interpolate = $interpolate;
	    }
	    RequiredController.prototype.$onInit = function () {
	        this.message = this.$interpolate(this.$attrs.rlRequired)(this.$scope);
	    };
	    RequiredController.$inject = ['$scope', '$attrs', '$interpolate'];
	    return RequiredController;
	}());
	exports.RequiredController = RequiredController;
	function required() {
	    return {
	        restrict: 'A',
	        priority: 200,
	        controller: exports.controllerName,
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, required)
	    .controller(exports.controllerName, RequiredController);
	//# sourceMappingURL=required.js.map

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var busy = __webpack_require__(27);
	exports.busy = busy;
	var button = __webpack_require__(31);
	exports.button = button;
	var buttonAsync = __webpack_require__(33);
	exports.buttonAsync = buttonAsync;
	var buttonLink = __webpack_require__(35);
	exports.buttonLink = buttonLink;
	var buttonSubmit = __webpack_require__(37);
	exports.buttonSubmit = buttonSubmit;
	var buttonToggle = __webpack_require__(39);
	exports.buttonToggle = buttonToggle;
	var cardContainer = __webpack_require__(41);
	exports.cardContainer = cardContainer;
	var checkbox = __webpack_require__(102);
	exports.checkbox = checkbox;
	var commaList = __webpack_require__(106);
	exports.commaList = commaList;
	var dateTime = __webpack_require__(107);
	exports.dateTime = dateTime;
	var dateTimeStatic = __webpack_require__(114);
	exports.dateTimeStatic = dateTimeStatic;
	var dialog = __webpack_require__(116);
	exports.dialog = dialog;
	var form = __webpack_require__(124);
	exports.form = form;
	var genericContainer = __webpack_require__(125);
	exports.genericContainer = genericContainer;
	var lazyLoad = __webpack_require__(128);
	exports.lazyLoad = lazyLoad;
	var longClickButton = __webpack_require__(129);
	exports.longClickButton = longClickButton;
	var messageLog = __webpack_require__(131);
	exports.messageLog = messageLog;
	var multiStepIndicator = __webpack_require__(144);
	exports.multiStepIndicator = multiStepIndicator;
	var radio = __webpack_require__(146);
	exports.radio = radio;
	var ratingBar = __webpack_require__(149);
	exports.ratingBar = ratingBar;
	var richTextEditor = __webpack_require__(152);
	exports.richTextEditor = richTextEditor;
	var select = __webpack_require__(163);
	exports.select = select;
	var signaturePad = __webpack_require__(169);
	exports.signaturePad = signaturePad;
	var simpleCardList = __webpack_require__(170);
	exports.simpleCardList = simpleCardList;
	var spinner = __webpack_require__(174);
	exports.spinner = spinner;
	var stringWithWatermark = __webpack_require__(180);
	exports.stringWithWatermark = stringWithWatermark;
	var tabs = __webpack_require__(181);
	exports.tabs = tabs;
	var templateRenderer = __webpack_require__(186);
	exports.templateRenderer = templateRenderer;
	var textarea = __webpack_require__(187);
	exports.textarea = textarea;
	var textbox = __webpack_require__(189);
	exports.textbox = textbox;
	var typeahead = __webpack_require__(191);
	exports.typeahead = typeahead;
	var typeaheadList = __webpack_require__(193);
	exports.typeaheadList = typeaheadList;
	var userRating = __webpack_require__(197);
	exports.userRating = userRating;
	var validationGroup = __webpack_require__(198);
	exports.validationGroup = validationGroup;
	var componentsDefaultTheme_1 = __webpack_require__(30);
	exports.defaultThemeValueName = componentsDefaultTheme_1.defaultThemeValueName;
	exports.moduleName = 'rl.ui.components';
	angular.module(exports.moduleName, [
	    busy.moduleName,
	    button.moduleName,
	    buttonAsync.moduleName,
	    buttonLink.moduleName,
	    buttonSubmit.moduleName,
	    buttonToggle.moduleName,
	    cardContainer.moduleName,
	    checkbox.moduleName,
	    commaList.moduleName,
	    dateTime.moduleName,
	    dateTimeStatic.moduleName,
	    dialog.moduleName,
	    form.moduleName,
	    genericContainer.moduleName,
	    lazyLoad.moduleName,
	    longClickButton.moduleName,
	    messageLog.moduleName,
	    multiStepIndicator.moduleName,
	    radio.moduleName,
	    ratingBar.moduleName,
	    richTextEditor.moduleName,
	    select.moduleName,
	    signaturePad.moduleName,
	    simpleCardList.moduleName,
	    spinner.moduleName,
	    stringWithWatermark.moduleName,
	    tabs.moduleName,
	    templateRenderer.moduleName,
	    textarea.moduleName,
	    textbox.moduleName,
	    typeahead.moduleName,
	    typeaheadList.moduleName,
	    userRating.moduleName,
	    validationGroup.moduleName,
	])
	    .value(componentsDefaultTheme_1.defaultThemeValueName, componentsDefaultTheme_1.defaultThemeValue);
	//# sourceMappingURL=components.module.js.map

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(28);
	var angular = __webpack_require__(1);
	var componentsDefaultTheme_1 = __webpack_require__(30);
	exports.moduleName = 'rl.ui.components.busy';
	exports.directiveName = 'rlBusy';
	busy.$inject = [componentsDefaultTheme_1.defaultThemeValueName];
	function busy(useDefaultTheme) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "<i class=\"busy rl-{{size}}\" ng-class=\"{ 'default-theme': useDefaultTheme }\" ng-show=\"loading\"></i>",
	        scope: {
	            loading: '=',
	            // Valid values are:
	            // `lg`, `2x`, `3x`, `4x`, and `5x`
	            size: '@',
	        },
	        link: function (scope) {
	            scope.useDefaultTheme = useDefaultTheme;
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, busy);
	//# sourceMappingURL=busy.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(29);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./busy.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./busy.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, ".default-theme.busy {\r\n\t-webkit-animation: fa-spin 2s infinite linear;\r\n\tanimation: fa-spin 2s infinite linear;\r\n\tdisplay: inline-block;\r\n\tfont-size: inherit;\r\n\tfont-style: normal;\r\n\tfont-family: FontAwesome;\r\n}\r\n\r\n.default-theme.busy:before {\r\n\tcontent: \"\\F110\"; /* fa-spinner */\r\n}", ""]);
	
	// exports


/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";
	exports.defaultThemeValueName = 'useDefaultTheme';
	exports.defaultThemeValue = true;
	//# sourceMappingURL=componentsDefaultTheme.js.map

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.button';
	exports.directiveName = 'rlButton';
	exports.controllerName = 'ButtonController';
	var ButtonController = (function () {
	    function ButtonController() {
	        this.type = this.type != null ? this.type : 'default';
	        this.configuredSize = this.size != null ? 'btn-' + this.size : null;
	    }
	    return ButtonController;
	}());
	exports.ButtonController = ButtonController;
	function button() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(32),
	        scope: {},
	        bindToController: {
	            action: '&',
	            type: '@',
	            ngDisabled: '=',
	            size: '@',
	        },
	        controller: exports.controllerName,
	        controllerAs: 'button',
	    };
	}
	exports.button = button;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, button)
	    .controller(exports.controllerName, ButtonController);
	//# sourceMappingURL=button.js.map

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{button.type}} {{button.configuredSize}}\" ng-click=\"button.action()\" ng-disabled=\"button.ngDisabled\">\r\n\t<span ng-transclude></span>\r\n</button>"

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __promiseUtility = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.buttonAsync';
	exports.directiveName = 'rlButtonAsync';
	exports.controllerName = 'ButtonAsyncController';
	var ButtonAsyncController = (function () {
	    function ButtonAsyncController(promiseUtility) {
	        this.promiseUtility = promiseUtility;
	        this.type = this.type != null ? this.type : 'default';
	        this.sizeClass = this.size != null ? 'btn-' + this.size : null;
	    }
	    ButtonAsyncController.prototype.trigger = function () {
	        var _this = this;
	        if (!this.busy) {
	            this.busy = true;
	            var result = this.action();
	            if (this.promiseUtility.isPromise(result) && _.isFunction(result.finally)) {
	                result.finally(function () {
	                    _this.busy = false;
	                });
	            }
	            else if (result !== true) {
	                this.busy = false;
	            }
	        }
	    };
	    ButtonAsyncController.$inject = [__promiseUtility.serviceName];
	    return ButtonAsyncController;
	}());
	exports.ButtonAsyncController = ButtonAsyncController;
	function buttonAsync() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(34),
	        scope: {},
	        bindToController: {
	            busy: '=?',
	            action: '&',
	            type: '@',
	            ngDisabled: '=?',
	            rightAligned: '=?',
	            size: '@',
	        },
	        controller: exports.controllerName,
	        controllerAs: 'button',
	    };
	}
	angular.module(exports.moduleName, [__promiseUtility.moduleName])
	    .directive(exports.directiveName, buttonAsync)
	    .controller(exports.controllerName, ButtonAsyncController);
	//# sourceMappingURL=buttonAsync.js.map

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{button.type}} {{button.sizeClass}}\" ng-click=\"button.trigger()\" ng-disabled=\"button.busy || button.ngDisabled\">\r\n\t<rl-busy ng-show=\"button.rightAligned\" loading=\"button.busy\"></rl-busy>\r\n\t<span ng-transclude></span>\r\n\t<rl-busy ng-hide=\"button.rightAligned\" loading=\"button.busy\"></rl-busy>\r\n</button>"

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.buttonLink';
	exports.directiveName = 'rlButtonLink';
	exports.controllerName = 'ButtonLinkController';
	var ButtonLinkController = (function () {
	    function ButtonLinkController() {
	        this.type = this.type != null ? this.type : 'default';
	        this.configuredSize = this.size != null ? 'btn-' + this.size : null;
	        this.target = this.newTab ? '_blank' : '_self';
	    }
	    return ButtonLinkController;
	}());
	exports.ButtonLinkController = ButtonLinkController;
	function buttonLink() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(36),
	        scope: {},
	        bindToController: {
	            link: '@',
	            type: '@',
	            ngDisabled: '=',
	            size: '@',
	            newTab: '=',
	        },
	        controller: exports.controllerName,
	        controllerAs: 'button',
	    };
	}
	exports.buttonLink = buttonLink;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, buttonLink)
	    .controller(exports.controllerName, ButtonLinkController);
	//# sourceMappingURL=buttonLink.js.map

/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = "<a class=\"btn btn-{{button.type}} {{button.configuredSize}}\" ng-href=\"{{button.link}}\" ng-disabled=\"button.ngDisabled\" target=\"{{button.target}}\">\r\n\t<span ng-transclude></span>\r\n</a>"

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.buttonSubmit';
	exports.componentName = 'rlButtonSubmit';
	exports.controllerName = 'ButtonSubmitController';
	var ButtonSubmitController = (function () {
	    function ButtonSubmitController($element) {
	        this.$element = $element;
	        this.type = this.type != null ? this.type : 'default';
	        this.configuredSize = this.size != null ? 'btn-' + this.size : null;
	    }
	    ButtonSubmitController.$inject = ['$element'];
	    return ButtonSubmitController;
	}());
	exports.ButtonSubmitController = ButtonSubmitController;
	var buttonSubmit = {
	    transclude: true,
	    template: __webpack_require__(38),
	    bindings: {
	        type: '@',
	        ngDisabled: '<?',
	        size: '@',
	        rightAligned: '<?',
	        saving: '<?',
	    },
	    controller: exports.controllerName,
	    controllerAs: 'button',
	};
	angular.module(exports.moduleName, [])
	    .component(exports.componentName, buttonSubmit)
	    .controller(exports.controllerName, ButtonSubmitController);
	//# sourceMappingURL=buttonSubmit.js.map

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = "<button type=\"submit\" class=\"btn btn-{{button.type}} {{button.configuredSize}}\" ng-disabled=\"button.saving || button.ngDisabled\">\r\n\t<rl-busy ng-show=\"button.rightAligned\" loading=\"button.saving\"></rl-busy>\r\n\t<span ng-transclude></span>\r\n\t<rl-busy ng-hide=\"button.rightAligned\" loading=\"button.saving\"></rl-busy>\r\n</button>"

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __boolean = typescript_angular_utilities_1.services.boolean;
	exports.moduleName = 'rl.ui.components.buttonToggle';
	exports.directiveName = 'rlButtonToggle';
	exports.controllerName = 'ButtonToggleController';
	var ButtonToggleController = (function () {
	    function ButtonToggleController($scope, bool) {
	        var _this = this;
	        this.$scope = $scope;
	        this.buttonClass = $scope.type != null ? $scope.type : 'default';
	        this.buttonSize = $scope.size != null ? 'btn-' + $scope.size : null;
	        $scope.$watch('ngModel.$modelValue', function (value) {
	            _this.isActive = bool.toBool(value);
	            if (value != null && _.isFunction($scope.onToggle)) {
	                $scope.onToggle({ value: value });
	            }
	        });
	    }
	    ButtonToggleController.prototype.clicked = function () {
	        this.$scope.ngModel.$setViewValue(!this.$scope.ngModel.$viewValue);
	    };
	    ButtonToggleController.$inject = ['$scope', __boolean.serviceName];
	    return ButtonToggleController;
	}());
	function buttonToggle() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: '^ngModel',
	        transclude: true,
	        template: __webpack_require__(40),
	        controller: exports.controllerName,
	        controllerAs: 'buttonToggle',
	        scope: {
	            type: '@',
	            size: '@',
	            onToggle: '&',
	            disabled: '=ngDisabled',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.ngModel = ngModel;
	        }
	    };
	}
	angular.module(exports.moduleName, [__boolean.moduleName])
	    .directive(exports.directiveName, buttonToggle)
	    .controller(exports.controllerName, ButtonToggleController);
	//# sourceMappingURL=buttonToggle.js.map

/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = "<button type=\"button\" class=\"btn btn-{{buttonToggle.buttonClass}} {{buttonToggle.buttonSize}}\" \r\n\t\tng-class=\"{ active : buttonToggle.isActive }\" ng-click=\"buttonToggle.clicked()\" ng-disabled=\"disabled\">\r\n\t<i ng-show=\"buttonToggle.isActive\" class=\"fa fa-check completed\"></i> <span ng-transclude></span>\r\n</button>"

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __array = typescript_angular_utilities_1.services.array;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __genericSearchFilter = typescript_angular_utilities_1.services.genericSearchFilter;
	var card = __webpack_require__(42);
	exports.card = card;
	var cardSearch = __webpack_require__(48);
	exports.cardSearch = cardSearch;
	var columnHeader = __webpack_require__(50);
	exports.columnHeader = columnHeader;
	var dataSources = __webpack_require__(52);
	exports.dataSources = dataSources;
	var filters = __webpack_require__(67);
	exports.filters = filters;
	var itemCount = __webpack_require__(88);
	exports.itemCount = itemCount;
	var pager = __webpack_require__(90);
	exports.pager = pager;
	var pageSize = __webpack_require__(92);
	exports.pageSize = pageSize;
	var selectionControl = __webpack_require__(94);
	exports.selectionControl = selectionControl;
	var sorts = __webpack_require__(53);
	exports.sorts = sorts;
	var cardContainer_1 = __webpack_require__(96);
	var builder = __webpack_require__(98);
	exports.builder = builder;
	var defaultComponents_1 = __webpack_require__(99);
	__export(__webpack_require__(96));
	exports.moduleName = 'rl.ui.components.cardContainer';
	angular.module(exports.moduleName, [
	    // dependencies
	    dataSources.dataPager.moduleName,
	    __object.moduleName,
	    __array.moduleName,
	    __parentChild.moduleName,
	    __genericSearchFilter.moduleName,
	    // components
	    card.moduleName,
	    cardSearch.moduleName,
	    columnHeader.moduleName,
	    itemCount.moduleName,
	    pager.moduleName,
	    pageSize.moduleName,
	    selectionControl.moduleName,
	    // submodules
	    dataSources.moduleName,
	    filters.moduleName,
	    sorts.moduleName,
	])
	    .component(cardContainer_1.componentName, cardContainer_1.cardContainer)
	    .controller(cardContainer_1.controllerName, cardContainer_1.CardContainerController)
	    .factory(builder.factoryName, builder.cardContainerBuilderFactory)
	    .component(defaultComponents_1.headerComponentName, defaultComponents_1.defaultContainerHeader)
	    .component(defaultComponents_1.footerComponentName, defaultComponents_1.defaultContainerFooter);
	//# sourceMappingURL=cardContainer.module.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __object = typescript_angular_utilities_1.services.object;
	var headerColumn_module_1 = __webpack_require__(43);
	exports.moduleName = 'rl.ui.components.cardContainer.card';
	exports.directiveName = 'rlCard';
	exports.controllerName = 'CardController';
	var CardController = (function () {
	    function CardController($scope, $controller, $q, parentChild, object) {
	        var _this = this;
	        this.$scope = $scope;
	        this.$q = $q;
	        this.parentChild = parentChild;
	        this.showContent = false;
	        this.dirty = false;
	        this.autosaveLink = {};
	        this.autosave = function () {
	            if (_this.showContent === false) {
	                return true;
	            }
	            return _this.parentChild.triggerChildBehavior(_this.autosaveLink, function (behavior) {
	                if (behavior.autosave()) {
	                    _this.showContent = false;
	                    return true;
	                }
	                else {
	                    return false;
	                }
	            });
	        };
	        if (this.cardAs) {
	            $scope[this.cardAs] = this.item;
	        }
	        $scope.collapse = this.autosave;
	        $scope.setSelected = this.setSelected.bind(this);
	        $scope.refresh = function () {
	            _this.source.refresh();
	            $scope.$broadcast('card.refresh');
	        };
	        $scope.remove = function () {
	            _this.source.remove(_this.item);
	        };
	        $scope.containerData = this.containerData;
	        if (object.isNullOrWhitespace(this.cardController) === false) {
	            var controller = $controller(this.cardController, { $scope: $scope });
	            if (object.isNullOrWhitespace(this.cardControllerAs) === false) {
	                $scope[this.cardControllerAs] = controller;
	            }
	        }
	        parentChild.registerChildBehavior(this.item, {
	            close: this.autosave,
	        });
	        $scope.__setHasBody = function (hasBody) {
	            _this.hasBody = hasBody;
	        };
	        $scope.__setHasFooter = function (hasFooter) {
	            _this.hasFooter = hasFooter;
	        };
	    }
	    CardController.prototype.toggleContent = function () {
	        if (!this.showContent) {
	            this.open();
	        }
	        else {
	            this.autosave();
	        }
	    };
	    CardController.prototype.validateCard = function () {
	        var behavior = this.parentChild.getChildBehavior(this.item);
	        if (_.isFunction(behavior.validateCard)) {
	            return behavior.validateCard();
	        }
	        else {
	            return true;
	        }
	    };
	    CardController.prototype.saveCard = function () {
	        var behavior = this.parentChild.getChildBehavior(this.item);
	        if (_.isFunction(behavior.saveCard)) {
	            return behavior.saveCard();
	        }
	        else {
	            return this.$q.when();
	        }
	    };
	    CardController.prototype.clickCard = function () {
	        this.parentChild.triggerChildBehavior(this.item, function (behavior) {
	            if (_.isFunction(behavior.clickCard)) {
	                return behavior.clickCard();
	            }
	        });
	    };
	    CardController.prototype.open = function () {
	        this.parentChild.triggerChildBehavior(this.item, function (behavior) {
	            if (_.isFunction(behavior.initCard)) {
	                behavior.initCard();
	            }
	        });
	        if (this.$scope.__rlCardContainer.openCard()) {
	            this.showContent = true;
	        }
	    };
	    CardController.prototype.setSelected = function (value) {
	        if (_.isUndefined(this.item.viewData)) {
	            this.item.viewData = {};
	        }
	        this.item.viewData.selected = value;
	        this.selectionChanged();
	    };
	    CardController.$inject = ['$scope', '$controller', '$q', __parentChild.serviceName, __object.serviceName];
	    return CardController;
	}());
	exports.CardController = CardController;
	function card() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(47),
	        require: '^^rlCardContainer',
	        controller: exports.controllerName,
	        controllerAs: '__card',
	        scope: {},
	        bindToController: {
	            columns: '=',
	            item: '=',
	            clickable: '=',
	            source: '=',
	            containerData: '=',
	            cardController: '=',
	            cardControllerAs: '=',
	            cardAs: '=',
	            permanentFooter: '=',
	            selectable: '=',
	            selectionChanged: '&',
	            saveWhenInvalid: '<?',
	        },
	        link: function (scope, element, attrs, rlCardContainer) {
	            scope.__rlCardContainer = rlCardContainer;
	            rlCardContainer.makeCard(scope, function (content) {
	                var contentArea = element.find('.content-template');
	                contentArea.append(content);
	                var hasBody = content.length > 0;
	                scope.__setHasBody(hasBody);
	            }, null, 'contentSlot');
	            rlCardContainer.makeCard(scope, function (footer) {
	                var hasFooter = (footer.length > 0);
	                if (hasFooter) {
	                    var footerArea = element.find('.footer-template');
	                    footerArea.append(footer);
	                }
	                scope.__setHasFooter(hasFooter);
	            }, null, 'footerSlot');
	        },
	    };
	}
	exports.card = card;
	angular.module(exports.moduleName, [
	    __parentChild.moduleName,
	    __object.moduleName,
	    headerColumn_module_1.moduleName,
	])
	    .directive(exports.directiveName, card)
	    .controller(exports.controllerName, CardController);
	//# sourceMappingURL=card.js.map

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var headerColumn_1 = __webpack_require__(44);
	var sizeForBreakpoints_1 = __webpack_require__(45);
	exports.moduleName = 'rl.ui.components.cardContainer.card.headerColumn';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.string.moduleName,
	])
	    .directive(sizeForBreakpoints_1.sizeForBreakpointsName, sizeForBreakpoints_1.sizeForBreakpoints)
	    .directive(headerColumn_1.directiveName, headerColumn_1.headerColumn)
	    .controller(headerColumn_1.controllerName, headerColumn_1.HeaderColumnController);
	//# sourceMappingURL=headerColumn.module.js.map

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	exports.directiveName = 'rlCardHeaderColumn';
	exports.controllerName = 'CardHeaderColumnController';
	var HeaderColumnController = (function () {
	    function HeaderColumnController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        this.update = function () {
	            _this.value = __transform.getValue(_this.item, _this.column.getValue);
	        };
	        this.update();
	        $scope.$on('card.refresh', this.update); //*event?
	    }
	    HeaderColumnController.$inject = ['$scope'];
	    return HeaderColumnController;
	}());
	exports.HeaderColumnController = HeaderColumnController;
	headerColumn.$inject = ['$compile'];
	function headerColumn($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div rl-size-for-breakpoints=\"header.column.size\" title=\"{{::header.column.description}}\">\n\t\t\t\t<div class=\"template-container\"></div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'header',
	        scope: {},
	        bindToController: {
	            column: '<',
	            item: '<',
	            alias: '<',
	        },
	        compile: function () {
	            return {
	                pre: function (scope, element, attrs, header) {
	                    if (header.alias != null) {
	                        scope[header.alias] = header.item;
	                    }
	                    var column = header.column;
	                    if (column.templateUrl != null) {
	                        header.renderedTemplate = $compile('<div ng-include="\'' + column.templateUrl + '\'"></div>')(scope);
	                    }
	                    else if (column.template != null) {
	                        header.renderedTemplate = $compile(column.template)(scope);
	                    }
	                    else {
	                        header.renderedTemplate = $compile('<span>{{header.value}}</span>')(scope);
	                    }
	                },
	                post: function (scope, element, attrs, header) {
	                    var container = element.find('.template-container');
	                    container.append(header.renderedTemplate);
	                },
	            };
	        },
	    };
	}
	exports.headerColumn = headerColumn;
	//# sourceMappingURL=headerColumn.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __string = typescript_angular_utilities_1.services.string;
	var breakpoint_1 = __webpack_require__(46);
	exports.sizeForBreakpointsName = 'rlSizeForBreakpoints';
	sizeForBreakpoints.$inject = ['$parse', __string.serviceName];
	function sizeForBreakpoints($parse, stringUtility) {
	    'use strict';
	    return {
	        restrict: 'A',
	        link: linkDirective,
	    };
	    function linkDirective(scope, element, attributes) {
	        var sizes = $parse(attributes.rlSizeForBreakpoints)(scope);
	        var classes = [];
	        classes.push(getColumnClass(sizes, breakpoint_1.xs));
	        classes.push(getColumnClass(sizes, breakpoint_1.sm));
	        classes.push(getColumnClass(sizes, breakpoint_1.md));
	        classes.push(getColumnClass(sizes, breakpoint_1.lg));
	        element.addClass(classes.join(' '));
	    }
	    function getColumnClass(columnSizes, breakpoint) {
	        var value = columnSizes[breakpoint];
	        if (value > 0 && value !== 'hidden') {
	            return stringUtility.substitute('col-{0}-{1}', breakpoint, value);
	        }
	        else {
	            return 'hidden-' + breakpoint;
	        }
	    }
	}
	exports.sizeForBreakpoints = sizeForBreakpoints;
	//# sourceMappingURL=sizeForBreakpoints.js.map

/***/ },
/* 46 */
/***/ function(module, exports) {

	'use strict';
	exports.lg = 'lg';
	exports.md = 'md';
	exports.sm = 'sm';
	exports.xs = 'xs';
	exports.all = [exports.xs, exports.sm, exports.md, exports.lg];
	//# sourceMappingURL=breakpoint.js.map

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = "<rl-generic-container selector=\"__card.selectable\">\r\n\t<template when-selector=\"false\" default>\r\n\t\t<div class=\"card\" ng-class=\"{ 'selected': __card.item.viewData.selected }\">\r\n\t\t\t<div class=\"header\" ng-click=\"__card.toggleContent()\" ng-class=\"{ 'active': __card.hasBody || !__card.permanentFooter }\">\r\n\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t<div ng-repeat=\"column in __card.columns\">\r\n\t\t\t\t\t\t<rl-card-header-column column=\"column\" item=\"__card.item\" alias=\"__card.cardAs\"></rl-card-header-column>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\r\n\t\t\t<div ng-show=\"__card.showContent\">\r\n\t\t\t\t<ng-form rl-autosave=\"__card.autosaveLink\" save=\"__card.saveCard()\" save-when-invalid=\"__card.saveWhenInvalid\">\r\n\t\t\t\t\t<div class=\"body\" ng-class=\"{ 'active': __card.clickable }\" ng-click=\"__card.clickCard()\">\r\n\t\t\t\t\t\t<div class=\"content-template\"></div>\r\n\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</ng-form>\r\n\t\t\t</div>\r\n\t\t\t<div ng-show=\"__card.hasFooter && (__card.showContent || __card.permanentFooter)\">\r\n\t\t\t\t<div class=\"footer\">\r\n\t\t\t\t\t<div class=\"footer-template\"></div>\r\n\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</template>\r\n\t<template when-selector=\"true\">\r\n\t\t<div class=\"select-group\">\r\n\t\t\t<div class=\"select-column\">\r\n\t\t\t\t<input type=\"checkbox\" class=\"stand-alone-checkbox\" ng-model=\"__card.item.viewData.selected\" ng-change=\"__card.selectionChanged()\"\r\n\t\t\t\t\t   ng-disabled=\"__card.item.viewData.disabledSelection\" title=\"{{__card.item.viewData.selectionTitle}}\" />\r\n\t\t\t</div>\r\n\t\t\t<div class=\"select-content\">\r\n\r\n\t\t\t\t<div class=\"card selectable\" ng-class=\"{ 'selected': __card.item.viewData.selected }\">\r\n\t\t\t\t\t<div class=\"header active\" ng-click=\"__card.toggleContent()\">\r\n\t\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t\t<div ng-repeat=\"column in __card.columns\">\r\n\t\t\t\t\t\t\t\t<rl-card-header-column column=\"column\" item=\"__card.item\"></rl-card-header-column>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\r\n\t\t\t\t\t<div ng-show=\"__card.showContent\">\r\n\t\t\t\t\t\t<ng-form rl-autosave=\"__card.autosaveLink\" save=\"__card.saveCard()\" save-when-invalid=\"__card.saveWhenInvalid\">\r\n\t\t\t\t\t\t\t<div class=\"body\" ng-class=\"{ 'active': __card.clickable }\" ng-click=\"__card.clickCard()\">\r\n\t\t\t\t\t\t\t\t<div class=\"content-template\"></div>\r\n\t\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</ng-form>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div ng-show=\"__card.hasFooter && (__card.showContent || __card.permanentFooter)\">\r\n\t\t\t\t\t\t<div class=\"footer\">\r\n\t\t\t\t\t\t\t<div class=\"footer-template\"></div>\r\n\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</template>\r\n</rl-generic-container>"

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.cardSearch';
	exports.directiveName = 'rlCardSearch';
	exports.controllerName = 'CardSearchController';
	exports.defaultSearchPlaceholder = 'Search';
	exports.defaultSearchDelay = 1000;
	var CardSearchController = (function () {
	    function CardSearchController($scope, $timeout) {
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.searchLengthError = false;
	        this.hasSearchFilter = true;
	    }
	    CardSearchController.prototype.$onInit = function () {
	        var _this = this;
	        if (this.cardContainer == null) {
	            return;
	        }
	        this.minSearchError = 'You must enter at least {{cardSearch.minSearchLength}} characters to perform a search';
	        if (this.searchFilter == null) {
	            var filter = this.cardContainer.searchFilter;
	            this.searchFilter = filter;
	            if (filter == null) {
	                this.hasSearchFilter = false;
	            }
	        }
	        if (this.hasSearchFilter) {
	            this.searchPlaceholder = exports.defaultSearchPlaceholder;
	            var dataSource = this.cardContainer.dataSource;
	            var delay = this.delay != null
	                ? this.delay
	                : exports.defaultSearchDelay;
	            var timer;
	            this.$scope.$watch(function () { return _this.searchText; }, function (search) {
	                _this.searchFilter.searchText = search;
	                _this.minSearchLength = _this.searchFilter.minSearchLength;
	                _this.validateSearchLength(search, _this.minSearchLength);
	                if (timer != null) {
	                    _this.$timeout.cancel(timer);
	                }
	                timer = _this.$timeout(dataSource.refresh.bind(dataSource), delay);
	            });
	            this.$scope.$watch(function () {
	                return _this.searchFilter.searchText;
	            }, function () {
	                _this.searchText = _this.searchFilter.searchText;
	            });
	        }
	    };
	    CardSearchController.prototype.validateSearchLength = function (search, minLength) {
	        // show error if search string exists but is below minimum size
	        this.searchLengthError = search != null
	            && search.length > 0
	            && search.length < minLength;
	    };
	    CardSearchController.$inject = ['$scope', '$timeout'];
	    return CardSearchController;
	}());
	exports.CardSearchController = CardSearchController;
	function cardSearch() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: { cardContainer: '?^^rlCardContainer' },
	        template: __webpack_require__(49),
	        controller: exports.controllerName,
	        controllerAs: 'cardSearch',
	        scope: {},
	        bindToController: {
	            delay: '=searchDelay',
	            searchFilter: '=?',
	        },
	    };
	}
	exports.cardSearch = cardSearch;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, cardSearch)
	    .controller(exports.controllerName, CardSearchController);
	//# sourceMappingURL=cardSearch.js.map

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = "<div class=\"input-group\" ng-show=\"cardSearch.hasSearchFilter\" ng-class=\"{ 'has-error': cardSearch.searchLengthError }\">\r\n\t<input class=\"form-control\" type=\"text\" placeholder=\"{{cardSearch.searchPlaceholder}}\" ng-model=\"cardSearch.searchText\"\r\n\t\t   rl-popover=\"cardSearch.minSearchError\" popover-trigger=\"mouseenter\" popover-enable=\"cardSearch.searchLengthError\" />\r\n\t<div class=\"input-group-btn\">\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-disabled=\"cardSearch.searchText | isEmpty\" ng-click=\"cardSearch.searchText = null\">\r\n\t\t\t<i class=\"fa fa-times\"></i>\r\n\t\t</button>\r\n\t</div>\r\n</div>"

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var sortDirection_1 = __webpack_require__(51);
	exports.moduleName = 'rl.ui.components.cardContainer.columnHeader';
	exports.directiveName = 'rlColumnHeader';
	cardColumnHeader.$inject = ['$compile'];
	function cardColumnHeader($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div rl-size-for-breakpoints=\"column.size\" ng-click=\"sort()\" title=\"{{::column.description}}\"\n\t\t\t\t\tclass=\"column-header\">\n\t\t\t\t<div class=\"template-container\"></div>\n\t\t\t\t<i ng-show=\"sorting === sortDirection.ascending\" class=\"fa fa-sort-asc\"></i>\n\t\t\t\t<i ng-show=\"sorting === sortDirection.descending\" class=\"fa fa-sort-desc\"></i>\n\t\t\t</div>\n\t\t",
	        scope: {
	            column: '=',
	            sorting: '=',
	            sort: '&',
	        },
	        compile: function () {
	            return {
	                pre: function (scope) {
	                    var column = scope.column;
	                    if (column.headerTemplateUrl != null) {
	                        scope.renderedTemplate = $compile('<div ng-include="\'' + column.headerTemplateUrl + '\'"></div>')(scope);
	                    }
	                    else if (column.headerTemplate != null) {
	                        scope.renderedTemplate = $compile(column.headerTemplate)(scope);
	                    }
	                    else {
	                        scope.renderedTemplate = ('<h5>' + column.label + '</h5');
	                    }
	                },
	                post: function (scope, element) {
	                    if (scope.column.displayColumnHeader != null && scope.column.displayColumnHeader === false) {
	                        element.remove();
	                        return;
	                    }
	                    var container = element.find('.template-container');
	                    container.append(scope.renderedTemplate);
	                    scope.sortDirection = sortDirection_1.SortDirection;
	                },
	            };
	        }
	    };
	}
	exports.cardColumnHeader = cardColumnHeader;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, cardColumnHeader);
	//# sourceMappingURL=columnHeader.js.map

/***/ },
/* 51 */
/***/ function(module, exports) {

	'use strict';
	var SortDirection = (function () {
	    function SortDirection(value) {
	        this.value = value;
	    }
	    SortDirection.toggle = function (direction) {
	        if (direction === SortDirection.ascending) {
	            return SortDirection.descending;
	        }
	        else if (direction === SortDirection.descending) {
	            return SortDirection.none;
	        }
	        else {
	            return SortDirection.ascending;
	        }
	    };
	    SortDirection.getFullName = function (direction) {
	        'use strict';
	        if (direction === SortDirection.ascending) {
	            return 'ascending';
	        }
	        else if (direction === SortDirection.descending) {
	            return 'descending';
	        }
	        else {
	            return 'none';
	        }
	    };
	    SortDirection.none = new SortDirection(0);
	    SortDirection.ascending = new SortDirection(1);
	    SortDirection.descending = new SortDirection(2);
	    return SortDirection;
	}());
	exports.SortDirection = SortDirection;
	//# sourceMappingURL=sortDirection.js.map

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var sorts_module_1 = __webpack_require__(53);
	var clientServerDataSource = __webpack_require__(57);
	exports.clientServerDataSource = clientServerDataSource;
	var dataPager = __webpack_require__(62);
	exports.dataPager = dataPager;
	var dataServiceDataSource = __webpack_require__(63);
	exports.dataServiceDataSource = dataServiceDataSource;
	var serverSideDataSource = __webpack_require__(64);
	exports.serverSideDataSource = serverSideDataSource;
	var simpleDataSource = __webpack_require__(65);
	exports.simpleDataSource = simpleDataSource;
	var smartDataSource = __webpack_require__(66);
	exports.smartDataSource = smartDataSource;
	var events = __webpack_require__(60);
	exports.events = events;
	var dataSourceProcessor = __webpack_require__(61);
	exports.dataSourceProcessor = dataSourceProcessor;
	var dataSourceBase = __webpack_require__(59);
	exports.dataSourceBase = dataSourceBase;
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.object.moduleName,
	    sorts_module_1.moduleName,
	    clientServerDataSource.moduleName,
	    dataPager.moduleName,
	    dataServiceDataSource.moduleName,
	    serverSideDataSource.moduleName,
	    simpleDataSource.moduleName,
	    smartDataSource.moduleName,
	])
	    .service(dataSourceProcessor.processorServiceName, dataSourceProcessor.DataSourceProcessor);
	//# sourceMappingURL=dataSources.module.js.map

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var mergeSort = __webpack_require__(54);
	exports.mergeSort = mergeSort;
	var sorter = __webpack_require__(55);
	exports.sorter = sorter;
	__export(__webpack_require__(56));
	__export(__webpack_require__(51));
	exports.moduleName = 'rl.ui.components.cardContainer.sorts';
	angular.module(exports.moduleName, [
	    mergeSort.moduleName,
	    sorter.moduleName,
	]);
	//# sourceMappingURL=sorts.module.js.map

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	exports.moduleName = 'rl.ui.components.cardContainer.sorts.mergeSort';
	exports.serviceName = 'mergeSort';
	var MergeSort = (function () {
	    function MergeSort() {
	    }
	    MergeSort.prototype.sort = function (data, compare) {
	        if (data.length < 2) {
	            return data;
	        }
	        if (compare == null) {
	            compare = this.defaultCompare;
	        }
	        var mid;
	        var left;
	        var right;
	        mid = data.length / 2;
	        left = this.sort(data.slice(0, mid), compare);
	        right = this.sort(data.slice(mid, data.length), compare);
	        return this.merge(left, right, compare);
	    };
	    MergeSort.prototype.defaultCompare = function (a, b) {
	        return a < b
	            ? typescript_angular_utilities_1.types.CompareResult.less
	            : (a > b ? typescript_angular_utilities_1.types.CompareResult.greater : typescript_angular_utilities_1.types.CompareResult.equal);
	    };
	    MergeSort.prototype.merge = function (left, right, compare) {
	        var result = [];
	        while (left.length && right.length) {
	            if (compare(left[0], right[0]) === typescript_angular_utilities_1.types.CompareResult.greater) {
	                result.push(right.shift());
	            }
	            else {
	                // if equal it should preserve same order (stable)
	                result.push(left.shift());
	            }
	        }
	        if (left.length) {
	            result.push.apply(result, left);
	        }
	        if (right.length) {
	            result.push.apply(result, right);
	        }
	        return result;
	    };
	    return MergeSort;
	}());
	exports.MergeSort = MergeSort;
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, MergeSort);
	//# sourceMappingURL=mergeSort.service.js.map

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	var sortDirection_1 = __webpack_require__(51);
	var mergeSort_service_1 = __webpack_require__(54);
	exports.moduleName = 'rl.ui.components.cardContainer.sorts.sorter';
	exports.serviceName = 'sorter';
	var Sorter = (function () {
	    function Sorter(mergeSort) {
	        this.mergeSort = mergeSort;
	    }
	    Sorter.prototype.sort = function (data, sort) {
	        var _this = this;
	        if (sort === null) {
	            return data;
	        }
	        if (_.isArray(sort)) {
	            var reverseSorts = _.clone(sort);
	            reverseSorts.reverse();
	            return _.reduce(reverseSorts, function (sortedData, nextSort) {
	                return _this.singleSort(sortedData, nextSort);
	            }, data);
	        }
	        return this.singleSort(data, sort);
	    };
	    Sorter.prototype.singleSort = function (data, sort) {
	        var compareFunction = this.buildSortFunction(sort);
	        return this.mergeSort.sort(data, compareFunction);
	    };
	    Sorter.prototype.buildSortFunction = function (sort) {
	        return function (a, b) {
	            if (sort.direction === sortDirection_1.SortDirection.none) {
	                return typescript_angular_utilities_1.types.CompareResult.equal;
	            }
	            var valueOfA = __transform.getValue(a, sort.column.getValue);
	            var valueOfB = __transform.getValue(b, sort.column.getValue);
	            var greaterResult = typescript_angular_utilities_1.types.CompareResult.greater;
	            var lessResult = typescript_angular_utilities_1.types.CompareResult.less;
	            var descendingSort = (sort.direction === sortDirection_1.SortDirection.descending);
	            var flip = sort.column.flipSort;
	            // Exclusive OR... if flipping a descending sort, you get an ascending sort
	            if ((descendingSort || flip) && !(descendingSort && flip)) {
	                greaterResult = typescript_angular_utilities_1.types.CompareResult.less;
	                lessResult = typescript_angular_utilities_1.types.CompareResult.greater;
	            }
	            return valueOfA > valueOfB
	                ? greaterResult
	                : (valueOfA < valueOfB ? lessResult : typescript_angular_utilities_1.types.CompareResult.equal);
	        };
	    };
	    Sorter.$inject = [mergeSort_service_1.serviceName];
	    return Sorter;
	}());
	exports.Sorter = Sorter;
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, Sorter);
	//# sourceMappingURL=sorter.service.js.map

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(51));
	//# sourceMappingURL=sort.js.map

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var __object = typescript_angular_utilities_1.services.object;
	var __synchronizedRequests = typescript_angular_utilities_1.services.synchronizedRequests;
	var asyncDataSource_service_1 = __webpack_require__(58);
	var dataSourceProcessor_service_1 = __webpack_require__(61);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.clientServerDataSource';
	exports.factoryName = 'clientServerDataSource';
	var ClientServerDataSource = (function (_super) {
	    __extends(ClientServerDataSource, _super);
	    function ClientServerDataSource(getDataSet, searchFilter, getFilterModel, validateModel, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	        _super.call(this, getDataSet, observableFactory, dataSourceProcessor, array, synchronizedRequestsFactory);
	        this.searchFilter = searchFilter;
	        this.getFilterModel = getFilterModel;
	        this.validateModel = validateModel;
	        this.object = object;
	        this.minSearchLength = 4;
	        this.getFilterModel = this.getFilterModel || function () { return null; };
	        this.validateModel = this.validateModel || function () { return true; };
	        this.countFilterGroups = true;
	        this.search = searchFilter.searchText;
	        this.filterModel = _.clone(this.getFilterModel());
	        searchFilter.minSearchLength = this.minSearchLength;
	    }
	    ClientServerDataSource.prototype.refresh = function () {
	        if (this.searchFilter.searchText !== this.search
	            || this.filterModelChanged()) {
	            this.reload();
	        }
	        else {
	            _super.prototype.refresh.call(this);
	        }
	    };
	    ClientServerDataSource.prototype.reload = function () {
	        this.search = this.searchFilter.searchText;
	        this.filterModel = _.clone(this.getFilterModel());
	        var hasValidSearch = !this.object.isNullOrEmpty(this.search) && this.search.length >= this.minSearchLength;
	        var hasValidFilterModel = this.filterModel != null && this.validateModel(this.filterModel);
	        if (!hasValidSearch && !hasValidFilterModel) {
	            this.resolveReload(null);
	            return;
	        }
	        _super.prototype.reload.call(this);
	    };
	    ClientServerDataSource.prototype.filterModelChanged = function () {
	        return !this.object.areEqual(this.getFilterModel(), this.filterModel);
	    };
	    ClientServerDataSource.prototype.getParams = function () {
	        var searchModel = this.getFilterModel();
	        if (searchModel != null) {
	            searchModel.search = this.search;
	        }
	        else {
	            searchModel = this.search;
	        }
	        return searchModel;
	    };
	    return ClientServerDataSource;
	}(asyncDataSource_service_1.AsyncDataSource));
	exports.ClientServerDataSource = ClientServerDataSource;
	clientServerDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, __object.serviceName, __synchronizedRequests.factoryName];
	function clientServerDataSourceFactory(observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet, searchFilter, getFilterModel, validateModel) {
	            return new ClientServerDataSource(getDataSet, searchFilter, getFilterModel, validateModel, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory);
	        },
	    };
	}
	exports.clientServerDataSourceFactory = clientServerDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName, __object.moduleName, __synchronizedRequests.moduleName])
	    .factory(exports.factoryName, clientServerDataSourceFactory);
	//# sourceMappingURL=clientServerDataSource.service.js.map

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var dataSourceBase_service_1 = __webpack_require__(59);
	var events = __webpack_require__(60);
	var AsyncDataSource = (function (_super) {
	    __extends(AsyncDataSource, _super);
	    function AsyncDataSource(getDataSet, observableFactory, dataSourceProcessor, array, synchronizedRequestsFactory) {
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.observable.allowableEvents = events.async.all;
	        this.synchronizedRequests = synchronizedRequestsFactory.getInstance(getDataSet, this.resolveReload.bind(this));
	    }
	    Object.defineProperty(AsyncDataSource.prototype, "getDataSet", {
	        set: function (value) {
	            this.synchronizedRequests.dataProvider = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AsyncDataSource.prototype.reload = function () {
	        this.dataSet = null;
	        this.rawDataSet = null;
	        this.loadingDataSet = true;
	        this.synchronizedRequests.getData(this.getParams());
	    };
	    AsyncDataSource.prototype.resolveReload = function (data) {
	        this.loadingDataSet = false;
	        this.rawDataSet = data;
	        this.processData();
	        this.observable.fire(events.async.reloaded);
	        this.observable.fire(events.redrawing);
	        this.observable.fire(events.changed);
	    };
	    // override with params for getDataSet
	    AsyncDataSource.prototype.getParams = function () {
	        return null;
	    };
	    return AsyncDataSource;
	}(dataSourceBase_service_1.DataSourceBase));
	exports.AsyncDataSource = AsyncDataSource;
	//# sourceMappingURL=asyncDataSource.service.js.map

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var events = __webpack_require__(60);
	var DataSourceBase = (function () {
	    function DataSourceBase(observableFactory, dataSourceProcessor, array) {
	        this.dataSourceProcessor = dataSourceProcessor;
	        this.array = array;
	        this.sorts = [];
	        this.filters = [];
	        this.count = 0;
	        this.countFilterGroups = false;
	        this.loadingDataSet = false;
	        this.observable = observableFactory.getInstance();
	        this.observable.allowableEvents = events.all;
	    }
	    DataSourceBase.prototype.watch = function (action, event) {
	        return this.observable.register(action, event);
	    };
	    Object.defineProperty(DataSourceBase.prototype, "needsRefinedSearch", {
	        get: function () {
	            var noItemsDisplayed = __object.objectUtility.isNullOrEmpty(this.dataSet);
	            var moreItemsOnServer = this._isEmpty === false || (this.rawDataSet != null && this.rawDataSet.length < this.count);
	            return noItemsDisplayed && moreItemsOnServer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DataSourceBase.prototype, "isEmpty", {
	        get: function () {
	            return __object.objectUtility.isNullOrEmpty(this.rawDataSet)
	                && (this._isEmpty != null ? this._isEmpty : true);
	        },
	        set: function (value) {
	            this._isEmpty = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DataSourceBase.prototype.processData = function () {
	        var processedData;
	        if (this.countFilterGroups) {
	            processedData = this.dataSourceProcessor.processAndCount(this.sorts, this.filters, this.pager, this.rawDataSet);
	        }
	        else {
	            processedData = this.dataSourceProcessor.process(this.sorts, this.filters, this.pager, this.rawDataSet);
	        }
	        this.setProcessedData(processedData);
	    };
	    //used when we need to process data but without client filters.
	    DataSourceBase.prototype.processDataNoClientFilters = function () {
	        var processedData;
	        if (this.countFilterGroups) {
	            processedData = this.dataSourceProcessor.processAndCount(this.sorts, null, this.pager, this.rawDataSet);
	        }
	        else {
	            processedData = this.dataSourceProcessor.process(this.sorts, null, this.pager, this.rawDataSet);
	        }
	        this.setProcessedData(processedData);
	    };
	    DataSourceBase.prototype.setProcessedData = function (processedData) {
	        this.count = processedData.count;
	        this.dataSet = processedData.dataSet;
	        this.filteredDataSet = processedData.filteredDataSet;
	    };
	    DataSourceBase.prototype.onSortChange = function () {
	        if (!this.loadingDataSet) {
	            this.filteredDataSet = this.dataSourceProcessor.sort(this.filteredDataSet, this.sorts);
	            this.dataSet = this.dataSourceProcessor.page(this.filteredDataSet, this.pager);
	            this.observable.fire(events.redrawing);
	        }
	    };
	    DataSourceBase.prototype.onPagingChange = function () {
	        if (!this.loadingDataSet) {
	            this.dataSet = this.dataSourceProcessor.page(this.filteredDataSet, this.pager);
	            this.observable.fire(events.redrawing);
	        }
	    };
	    DataSourceBase.prototype.refresh = function () {
	        if (!this.loadingDataSet) {
	            this.processData();
	            this.observable.fire(events.redrawing);
	        }
	    };
	    DataSourceBase.prototype.remove = function (data) {
	        var item = this.array.remove(this.rawDataSet, data);
	        if (item != null) {
	            this.observable.fire(events.removed);
	            this.observable.fire(events.changed);
	            if (this.pager) {
	                this.refresh();
	            }
	        }
	    };
	    DataSourceBase.prototype.push = function (data) {
	        this.rawDataSet.push(data);
	        this.observable.fire(events.added);
	        this.observable.fire(events.changed);
	        this.refresh();
	    };
	    DataSourceBase.prototype.replace = function (oldData, newData) {
	        var locationOfOldData = this.rawDataSet.indexOf(oldData);
	        if (locationOfOldData >= 0) {
	            this.array.replace(this.rawDataSet, oldData, newData);
	            this.observable.fire(events.replaced);
	            this.observable.fire(events.changed);
	            this.refresh();
	        }
	    };
	    return DataSourceBase;
	}());
	exports.DataSourceBase = DataSourceBase;
	//# sourceMappingURL=dataSourceBase.service.js.map

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(18);
	exports.redrawing = 'redrawing';
	exports.changed = 'changed';
	exports.added = 'added';
	exports.removed = 'removed';
	exports.replaced = 'replaced';
	exports.all = [exports.redrawing, exports.changed, exports.added, exports.removed, exports.replaced];
	exports.async = {
	    reloaded: 'reloaded',
	    all: [],
	};
	exports.async.all = _.clone(exports.all);
	exports.async.all.push(exports.async.reloaded);
	//# sourceMappingURL=dataSourceEvents.js.map

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var sorter_service_1 = __webpack_require__(55);
	exports.processorServiceName = 'dataSourceProcessor';
	var DataSourceProcessor = (function () {
	    function DataSourceProcessor(object, sorter) {
	        this.object = object;
	        this.sorter = sorter;
	    }
	    DataSourceProcessor.prototype.process = function (sorts, filters, pager, data) {
	        var processedData = data;
	        processedData = this.sort(processedData, sorts);
	        if (this.object.isNullOrEmpty(filters) === false) {
	            processedData = _.reduce(filters, function (filteredData, filter) {
	                // Filter the data set using the filter function on the filter
	                return _.filter(filteredData, filter.filter.bind(filter));
	            }, processedData);
	        }
	        var result = {
	            count: (processedData != null ? processedData.length : 0),
	            filteredDataSet: processedData,
	            dataSet: processedData,
	        };
	        result.dataSet = this.page(processedData, pager);
	        return result;
	    };
	    DataSourceProcessor.prototype.processAndCount = function (sorts, filters, pager, data) {
	        var _this = this;
	        // If there are no filters that need to updated option counts, use the normal processor
	        if (this.object.isNullOrEmpty(filters)
	            || _.some(filters, function (filter) { return _.isFunction(filter.updateOptionCounts); }) === false) {
	            return this.process(sorts, filters, pager, data);
	        }
	        var processedData = data;
	        processedData = this.sort(processedData, sorts);
	        var wrappedData = this.wrapData(processedData);
	        // Run filtration logic and compute visible items
	        _.each(filters, function (filter /* filters.IFilterWithCounts */) {
	            _.each(wrappedData, function (item) {
	                item.filterData[filter.type] = filter.filter(item.data);
	            });
	        });
	        // Give each filter a chance to update option counts
	        _.each(filters, function (filter /* filters.IFilterWithCounts */) {
	            if (_.isFunction(filter.updateOptionCounts)) {
	                var otherFiltersApplied = _.filter(wrappedData, function (item) {
	                    // Omit the true or false of the current filter an
	                    //  only filter out items removed by other filters
	                    var filterData = _.omit(item.filterData, filter.type); //*filterData
	                    return _.every(_.values(filterData));
	                });
	                filter.updateOptionCounts(_this.unwrapData(otherFiltersApplied));
	            }
	        });
	        // Filter down to final data set by removing items that don't match all filters
	        wrappedData = _.filter(wrappedData, function (item) {
	            return _.every(_.values(item.filterData));
	        });
	        processedData = this.unwrapData(wrappedData);
	        var result = {
	            count: processedData.length,
	            filteredDataSet: processedData,
	            dataSet: processedData,
	        };
	        result.dataSet = this.page(processedData, pager);
	        return result;
	    };
	    DataSourceProcessor.prototype.sort = function (data, sorts) {
	        if (this.object.isNullOrEmpty(sorts) === false) {
	            return this.sorter.sort(data, sorts);
	        }
	        return data;
	    };
	    DataSourceProcessor.prototype.page = function (data, pager) {
	        if (pager != null) {
	            return pager.filter(data);
	        }
	        return data;
	    };
	    DataSourceProcessor.prototype.wrapData = function (data) {
	        return _.map(data, function (item) {
	            return {
	                data: item,
	                filterData: {},
	            };
	        });
	    };
	    DataSourceProcessor.prototype.unwrapData = function (data) {
	        return _.map(data, function (item) {
	            return item.data;
	        });
	    };
	    DataSourceProcessor.$inject = [__object.serviceName, sorter_service_1.serviceName];
	    return DataSourceProcessor;
	}());
	exports.DataSourceProcessor = DataSourceProcessor;
	//# sourceMappingURL=dataSourceProcessor.service.js.map

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/lodashTypeExtensions.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.dataPager';
	exports.factoryName = 'dataPager';
	exports.defaultPageSize = 10;
	var DataPager = (function () {
	    function DataPager() {
	        this.pageNumber = 1;
	        this.pageSize = exports.defaultPageSize;
	    }
	    Object.defineProperty(DataPager.prototype, "startItem", {
	        get: function () {
	            return (this.pageNumber - 1) * this.pageSize;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DataPager.prototype.filter = function (dataSet) {
	        return _(dataSet)
	            .drop(this.startItem)
	            .take(this.pageSize)
	            .value();
	    };
	    return DataPager;
	}());
	exports.DataPager = DataPager;
	function dataPagerFactory() {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new DataPager();
	        },
	    };
	}
	exports.dataPagerFactory = dataPagerFactory;
	angular.module(exports.moduleName, [])
	    .factory(exports.factoryName, dataPagerFactory);
	//# sourceMappingURL=dataPager.service.js.map

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var __synchronizedRequests = typescript_angular_utilities_1.services.synchronizedRequests;
	var asyncDataSource_service_1 = __webpack_require__(58);
	var dataSourceProcessor_service_1 = __webpack_require__(61);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.dataServiceDataSource';
	exports.factoryName = 'dataServiceDataSource';
	var DataServiceDataSource = (function (_super) {
	    __extends(DataServiceDataSource, _super);
	    function DataServiceDataSource(getDataSet, observableFactory, dataSourceProcessor, array, synchronizedRequestsFactory) {
	        _super.call(this, getDataSet, observableFactory, dataSourceProcessor, array, synchronizedRequestsFactory);
	        this.countFilterGroups = true;
	        if (_.isFunction(getDataSet)) {
	            this.reload();
	        }
	    }
	    return DataServiceDataSource;
	}(asyncDataSource_service_1.AsyncDataSource));
	exports.DataServiceDataSource = DataServiceDataSource;
	dataServiceDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, __synchronizedRequests.factoryName];
	function dataServiceDataSourceFactory(observableFactory, dataSourceProcessor, array, synchronizedRequests) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet) {
	            return new DataServiceDataSource(getDataSet, observableFactory, dataSourceProcessor, array, synchronizedRequests);
	        },
	    };
	}
	exports.dataServiceDataSourceFactory = dataServiceDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName])
	    .factory(exports.factoryName, dataServiceDataSourceFactory);
	//# sourceMappingURL=dataServiceDataSource.service.js.map

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var __object = typescript_angular_utilities_1.services.object;
	var __synchronizedRequests = typescript_angular_utilities_1.services.synchronizedRequests;
	var asyncDataSource_service_1 = __webpack_require__(58);
	var dataSourceProcessor_service_1 = __webpack_require__(61);
	var sort_1 = __webpack_require__(56);
	var events = __webpack_require__(60);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.serverSideDataSource';
	exports.factoryName = 'serverSideDataSource';
	var ServerSideDataSource = (function (_super) {
	    __extends(ServerSideDataSource, _super);
	    function ServerSideDataSource(getDataSet, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	        _super.call(this, getDataSet, observableFactory, dataSourceProcessor, array, synchronizedRequestsFactory);
	        this.object = object;
	    }
	    ServerSideDataSource.prototype.refresh = function () {
	        this.reload();
	    };
	    ServerSideDataSource.prototype.getParams = function () {
	        var filterDictionary = this.array.toDictionary(this.filters, function (filter) {
	            return filter.type;
	        });
	        return {
	            filters: _.mapValues(filterDictionary, function (filter) {
	                if (_.isFunction(filter.serialize)) {
	                    return filter.serialize();
	                }
	                return null;
	            }),
	            sorts: _.map(this.sorts, function (sort) {
	                return {
	                    column: sort.column.label,
	                    direction: sort_1.SortDirection.getFullName(sort.direction),
	                };
	            }),
	            paging: {
	                pageNumber: this.pager.pageNumber,
	                pageSize: this.pager.pageSize,
	            },
	        };
	    };
	    ServerSideDataSource.prototype.resolveReload = function (result) {
	        var data = result;
	        _super.prototype.resolveReload.call(this, data.dataSet);
	        this.setProcessedData({
	            count: data.count,
	            filteredDataSet: data.dataSet,
	            dataSet: data.dataSet,
	        });
	        this.observable.fire(events.redrawing);
	    };
	    return ServerSideDataSource;
	}(asyncDataSource_service_1.AsyncDataSource));
	exports.ServerSideDataSource = ServerSideDataSource;
	serverSideDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, __object.serviceName, __synchronizedRequests.factoryName];
	function serverSideDataSourceFactory(observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet) {
	            return new ServerSideDataSource(getDataSet, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory);
	        },
	    };
	}
	exports.serverSideDataSourceFactory = serverSideDataSourceFactory;
	angular.module(exports.moduleName, [])
	    .factory(exports.factoryName, serverSideDataSourceFactory);
	//# sourceMappingURL=serverSideDataSource.service.js.map

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var dataSourceBase_service_1 = __webpack_require__(59);
	var dataSourceProcessor_service_1 = __webpack_require__(61);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.simpleDataSource';
	exports.factoryName = 'simpleDataSource';
	var SimpleDataSource = (function (_super) {
	    __extends(SimpleDataSource, _super);
	    function SimpleDataSource(data, observableFactory, dataSourceProcessor, array) {
	        _super.call(this, observableFactory, dataSourceProcessor, array);
	        this.countFilterGroups = false;
	        this.rawDataSet = data;
	        this.processData();
	    }
	    return SimpleDataSource;
	}(dataSourceBase_service_1.DataSourceBase));
	exports.SimpleDataSource = SimpleDataSource;
	simpleDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName];
	function simpleDataSourceFactory(observableFactory, dataSourceProcessor, array) {
	    'use strict';
	    return {
	        getInstance: function (data) {
	            return new SimpleDataSource(data, observableFactory, dataSourceProcessor, array);
	        },
	    };
	}
	exports.simpleDataSourceFactory = simpleDataSourceFactory;
	angular.module(exports.moduleName, [__observable.moduleName, __array.moduleName])
	    .factory(exports.factoryName, simpleDataSourceFactory);
	//# sourceMappingURL=simpleDataSource.service.js.map

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __array = typescript_angular_utilities_1.services.array;
	var __object = typescript_angular_utilities_1.services.object;
	var __synchronizedRequests = typescript_angular_utilities_1.services.synchronizedRequests;
	var asyncDataSource_service_1 = __webpack_require__(58);
	var dataSourceProcessor_service_1 = __webpack_require__(61);
	var sort_1 = __webpack_require__(56);
	exports.moduleName = 'rl.ui.components.cardContainer.dataSources.smartDataSource';
	exports.factoryName = 'smartDataSource';
	var SmartDataSource = (function (_super) {
	    __extends(SmartDataSource, _super);
	    function SmartDataSource(getDataSet, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	        _super.call(this, getDataSet, observableFactory, dataSourceProcessor, array, synchronizedRequestsFactory);
	        this.object = object;
	        this.throttled = true;
	        this.throttleLimit = 200;
	    }
	    Object.defineProperty(SmartDataSource.prototype, "filters", {
	        get: function () {
	            return this._filters;
	        },
	        set: function (value) {
	            this._filters = value;
	            this.setupSubscriptions();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SmartDataSource.prototype.onSortChange = function () {
	        if (this.throttled) {
	            this.reload();
	        }
	        else {
	            _super.prototype.onSortChange.call(this);
	        }
	    };
	    SmartDataSource.prototype.refresh = function () {
	        if (this.throttled) {
	            this.reload();
	        }
	        else {
	            _super.prototype.refresh.call(this);
	        }
	    };
	    SmartDataSource.prototype.getParams = function () {
	        this.updateAppliedFilters();
	        return {
	            filters: this.appliedFilters,
	            sorts: _.map(this.sorts, function (sort) {
	                return {
	                    column: sort.column.label,
	                    direction: sort_1.SortDirection.getFullName(sort.direction),
	                };
	            }),
	            paging: {
	                pageNumber: 1,
	                pageSize: this.throttleLimit,
	            },
	        };
	    };
	    SmartDataSource.prototype.updateAppliedFilters = function () {
	        var filterDictionary = this.array.toDictionary(this.filters, function (filter) {
	            return filter.type;
	        });
	        this.appliedFilters = _.mapValues(filterDictionary, function (filter) {
	            if (_.isFunction(filter.serialize)) {
	                return filter.serialize();
	            }
	            return null;
	        });
	        this.appliedFilters = _.omitBy(this.appliedFilters, function (value) { return value == null; });
	    };
	    SmartDataSource.prototype.setupSubscriptions = function () {
	        var _this = this;
	        _.each(this.subscriptions, function (subscription) {
	            subscription.dispose();
	        });
	        this.subscriptions = [];
	        _.each(this.filters, function (filter) {
	            if (_.isFunction(filter.subscribe)) {
	                _this.subscriptions.push(filter.subscribe(function () { _this.onFilterChange(filter); }));
	            }
	        });
	    };
	    SmartDataSource.prototype.onFilterChange = function (filter) {
	        if (_.has(this.appliedFilters, filter.type)) {
	            this.reload();
	        }
	    };
	    SmartDataSource.prototype.resolveReload = function (result) {
	        var data = result;
	        this.throttled = (data.count > data.dataSet.length);
	        _super.prototype.resolveReload.call(this, data.dataSet);
	        this.count = data.count;
	        this.isEmpty = data.isEmpty;
	    };
	    return SmartDataSource;
	}(asyncDataSource_service_1.AsyncDataSource));
	exports.SmartDataSource = SmartDataSource;
	smartDataSourceFactory.$inject = [__observable.factoryName, dataSourceProcessor_service_1.processorServiceName, __array.serviceName, __object.serviceName, __synchronizedRequests.factoryName];
	function smartDataSourceFactory(observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory) {
	    'use strict';
	    return {
	        getInstance: function (getDataSet) {
	            return new SmartDataSource(getDataSet, observableFactory, dataSourceProcessor, array, object, synchronizedRequestsFactory);
	        },
	    };
	}
	exports.smartDataSourceFactory = smartDataSourceFactory;
	angular.module(exports.moduleName, [])
	    .factory(exports.factoryName, smartDataSourceFactory);
	//# sourceMappingURL=smartDataSource.service.js.map

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var columnSearchFilter = __webpack_require__(68);
	exports.columnSearchFilter = columnSearchFilter;
	var dateFilter = __webpack_require__(69);
	var filterGroup = __webpack_require__(74);
	exports.filterGroup = filterGroup;
	var selectFilter = __webpack_require__(82);
	exports.selectFilter = selectFilter;
	var cardContainerFilters = __webpack_require__(86);
	__export(__webpack_require__(86));
	exports.moduleName = 'rl.ui.components.cardContainer.filters';
	angular.module(exports.moduleName, [
	    columnSearchFilter.moduleName,
	    dateFilter.moduleName,
	    filterGroup.moduleName,
	    selectFilter.moduleName,
	    cardContainerFilters.moduleName
	]);
	//# sourceMappingURL=filters.module.js.map

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __string = typescript_angular_utilities_1.services.string;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	exports.moduleName = 'rl.ui.components.cardContainer.filters.columnSearchFilter';
	exports.factoryName = 'columnSearchFilter';
	exports.filterName = 'column-search';
	var ColumnSearchFilter = (function () {
	    function ColumnSearchFilter(object, string) {
	        this.object = object;
	        this.string = string;
	        this.type = exports.filterName;
	    }
	    ColumnSearchFilter.prototype.filter = function (item) {
	        if (this.column == null) {
	            return true;
	        }
	        var value = this.object.toString(__transform.getValue(item, this.column.getValue));
	        var search = this.searchText;
	        if (!this.caseSensitive) {
	            search = search.toLowerCase();
	            value = value.toLowerCase();
	        }
	        return this.string.contains(value, search);
	    };
	    return ColumnSearchFilter;
	}());
	exports.ColumnSearchFilter = ColumnSearchFilter;
	columnSearchFilterFactory.$inject = [__object.serviceName, __string.serviceName];
	function columnSearchFilterFactory(object, string) {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new ColumnSearchFilter(object, string);
	        },
	    };
	}
	exports.columnSearchFilterFactory = columnSearchFilterFactory;
	angular.module(exports.moduleName, [__object.moduleName, __string.moduleName])
	    .factory(exports.factoryName, columnSearchFilterFactory);
	//# sourceMappingURL=columnSearchFilter.service.js.map

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __date = typescript_angular_utilities_1.services.date;
	var dateFilter_service_1 = __webpack_require__(70);
	var dateFilter_component_1 = __webpack_require__(72);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.dateFilter';
	__export(__webpack_require__(70));
	__export(__webpack_require__(72));
	angular.module(exports.moduleName, [__date.moduleName])
	    .factory(dateFilter_service_1.factoryName, dateFilter_service_1.dateFilterFactory)
	    .directive(dateFilter_component_1.directiveName, dateFilter_component_1.dateFilter)
	    .controller(dateFilter_component_1.controllerName, dateFilter_component_1.DateFilterController);
	//# sourceMappingURL=dateFilter.module.js.map

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var moment = __webpack_require__(71);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __date = typescript_angular_utilities_1.services.date;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	exports.factoryName = 'rlDateFilterFactory';
	var DateFilter = (function () {
	    function DateFilter(settings, dateUtility) {
	        this.dateUtility = dateUtility;
	        this.valueSelector = settings.valueSelector;
	        this.type = settings.type;
	        this.clearButton = settings.clearButton;
	        this.includeDateRange = settings.includeDateRange;
	        this.includeTime = settings.includeTime != null ? settings.includeTime : false;
	        this.label = settings.label;
	        this.template = "<rl-date-filter filter=\"filter\" source=\"dataSource\" label=\"{{filter.label}}\" include-time=\"filter.includeTime\"\n\t\t\t\t\t\t\t\t\t     include-date-range=\"filter.includeDateRange\" clear-button=\"filter.clearButton\"></rl-date-filter>";
	    }
	    DateFilter.prototype.filter = function (item) {
	        if (!this.dateUtility.isDate(this.selectedDate1)) {
	            return true;
	        }
	        if (this.dateRange) {
	            var itemDate = this.getValue(item);
	            var selectedDate1 = void 0;
	            //have to set the selectedDate1 to a valid Date object for comparisons.
	            if (this.includeTime) {
	                selectedDate1 = moment(this.selectedDate1).toDate();
	            }
	            else {
	                //increase it by 1 days. to inlcude the selectec date in the range.
	                selectedDate1 = moment(this.selectedDate1).add(1, 'days').toDate();
	            }
	            return this.dateUtility.dateInRange(itemDate, this.selectedDate2, this.selectedDate1);
	        }
	        else {
	            if (this.includeTime) {
	                return this.dateUtility.sameDateTime(this.getValue(item), this.selectedDate1);
	            }
	            else {
	                return this.dateUtility.sameDate(this.getValue(item), this.selectedDate1);
	            }
	        }
	    };
	    DateFilter.prototype.getValue = function (item) {
	        return __transform.getValue(item, this.valueSelector);
	    };
	    return DateFilter;
	}());
	dateFilterFactory.$inject = [__date.serviceName];
	function dateFilterFactory(dateUtility) {
	    return {
	        getInstance: function (settings) {
	            return new DateFilter(settings, dateUtility);
	        },
	    };
	}
	exports.dateFilterFactory = dateFilterFactory;
	//# sourceMappingURL=dateFilter.service.js.map

/***/ },
/* 71 */
/***/ function(module, exports) {

	(function() { module.exports = this["moment"]; }());

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	'use strict';
	var moment = __webpack_require__(71);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __date = typescript_angular_utilities_1.services.date;
	exports.directiveName = 'rlDateFilter';
	exports.controllerName = 'rlDateFilterController';
	// Optional interface for bound attributes
	var DateOptions;
	(function (DateOptions) {
	    DateOptions[DateOptions["Day"] = 0] = "Day";
	    DateOptions[DateOptions["Week"] = 1] = "Week";
	    DateOptions[DateOptions["Month"] = 2] = "Month";
	})(DateOptions || (DateOptions = {}));
	;
	var DateFilterController = (function () {
	    function DateFilterController($scope, dateUtility, $element) {
	        this.$scope = $scope;
	        this.dateUtility = dateUtility;
	        this.$element = $element;
	        this.count = 0;
	        this.type = "days";
	        this.filter.includeTime = this.includeTime;
	        //this is added to address an agular quirk on the service event list page.
	        //the input field was not clearing correclty when the selectedDate1 value is null.
	        this.inputField = this.$element.find('rl-date-time input');
	        this.filter.dateRange = false;
	        if (this.clearButton == null)
	            this.clearButton = true;
	    }
	    Object.defineProperty(DateFilterController.prototype, "selectedDate1", {
	        get: function () {
	            if (this.filter.selectedDate1 != null) {
	                return moment(this.filter.selectedDate1).format('M/D/YYYY');
	            }
	            else {
	                //clear input field of date value. and rest past day/week count
	                this.inputField.val('');
	                this.clearCount();
	                return null;
	            }
	        },
	        set: function (v) {
	            if (this.dateUtility.isDate(v)) {
	                this.filter.selectedDate1 = moment(v).toDate();
	            }
	            else {
	                //clear input field of date value. and rest past day/week count
	                this.inputField.val('');
	                this.clearCount();
	                this.filter.selectedDate1 = null;
	            }
	            this.refreshDataSource();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DateFilterController.prototype, "selectedDate2", {
	        get: function () {
	            return this.filter.selectedDate2;
	        },
	        set: function (v) {
	            this.filter.selectedDate2 = v;
	            this.refreshDataSource();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DateFilterController.prototype.refreshDataSource = function () {
	        if (this.source != null) {
	            this.source.refresh();
	        }
	        else {
	            this.$scope.$emit('dataSource.requestRefresh'); //*event?
	        }
	    };
	    DateFilterController.prototype.clearCount = function () {
	        this.count = 0;
	        this.countChange();
	    };
	    DateFilterController.prototype.decreaseCount = function () {
	        this.count -= 1;
	        this.setDateTimeNowIfNull();
	        //do not allow count below 0
	        if (this.count < 0 || this.count === 0) {
	            this.count = 0;
	        }
	        this.countChange();
	    };
	    DateFilterController.prototype.countChange = function () {
	        if (this.count == null) {
	            this.count = 0;
	        }
	        if (this.count > 0) {
	            this.filter.dateRange = true;
	            // add days has to be a negative number to go backwords.
	            this.selectedDate2 = moment(this.selectedDate1).add((this.count * -1), this.type).toDate();
	        }
	        else if (this.count == 0) {
	            //only change this values the first time.
	            if (this.filter.dateRange) {
	                this.filter.dateRange = false;
	                this.selectedDate2 = null;
	            }
	        }
	    };
	    DateFilterController.prototype.increaseCount = function () {
	        this.count += 1;
	        this.setDateTimeNowIfNull();
	        this.countChange();
	    };
	    DateFilterController.prototype.setDateTimeNowIfNull = function () {
	        if (this.selectedDate1 == null) {
	            this.selectedDate1 = moment(Date.now()).format('M/D/YYYY');
	        }
	    };
	    DateFilterController.prototype.toggle = function () {
	        if (this.type === 'days') {
	            this.type = 'weeks';
	        }
	        else {
	            this.type = 'days';
	        }
	        this.countChange();
	    };
	    DateFilterController.$inject = ['$scope', __date.serviceName, '$element'];
	    return DateFilterController;
	}());
	exports.DateFilterController = DateFilterController;
	function dateFilter() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(73),
	        controller: exports.controllerName,
	        controllerAs: 'filter',
	        scope: {},
	        bindToController: {
	            filter: '=',
	            source: '=',
	            label: '@',
	            includeTime: '=',
	            includeDateRange: '=',
	            clearButton: '='
	        },
	    };
	}
	exports.dateFilter = dateFilter;
	//# sourceMappingURL=dateFilter.component.js.map

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filter-group\">\r\n\t<div class=\"content-group\">\r\n\t\t<label>{{::filter.label}}</label>\r\n\t\t<div class=\"input-group-btn\">\r\n\t\t\t<rl-date-time ng-model=\"filter.selectedDate1\" use-time=\"filter.includeTime\" clear-button=\"filter.clearButton\" on-clear-event=\"filter.clearCount()\"\r\n\t\t\tclass=\"pull-left\"></rl-date-time>\r\n\t\t</div>\r\n\t</div>\r\n\t<div ng-if=\"filter.includeDateRange\" class=\"content-group\">\r\n\t\t<label>Add previous</label>\r\n\t\t<div class=\"input-group\">\r\n\t\t<span class=\"input-group-btn\">\r\n\t\t\t<button  class=\"btn btn-default\" ng-click=\"filter.decreaseCount();\">\r\n\t\t\t\t<i class=\"fa fa-minus\"></i>\r\n\t\t\t</button>\r\n\t\t</span>\r\n\t\t<input type=\"number\" class=\"form-control\" ng-model=\"filter.count\" ng-change=\"filter.countChange();\" />\r\n\t\t<span class=\"input-group-btn\">\r\n\t\t\t<button class=\"btn btn-default\" ng-click=\"filter.toggle();\">\r\n\t\t\t{{filter.type}}\r\n\t\t\t</button>\r\n\t\t</span>\r\n\t\t<span class=\"input-group-btn\">\r\n\t\t\t<button class=\"btn btn-default\" ng-click=\"filter.increaseCount();\">\r\n\t\t\t\t<i class=\"fa fa-plus\"></i>\r\n\t\t\t</button>\r\n\t\t</span>\r\n\t\t</div>\r\n\t</div>\r\n</div>"

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var filterOption = __webpack_require__(75);
	exports.filterOption = filterOption;
	var modeFilterGroup = __webpack_require__(77);
	exports.modeFilterGroup = modeFilterGroup;
	var rangeFilterGroup = __webpack_require__(79);
	exports.rangeFilterGroup = rangeFilterGroup;
	var filterGroup_service_1 = __webpack_require__(78);
	var filterGroup_directive_1 = __webpack_require__(80);
	__export(__webpack_require__(80));
	__export(__webpack_require__(78));
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.object.moduleName,
	    filterOption.moduleName,
	    modeFilterGroup.moduleName,
	    rangeFilterGroup.moduleName,
	])
	    .factory(filterGroup_service_1.factoryName, filterGroup_service_1.filterGroupFactory)
	    .directive(filterGroup_directive_1.directiveName, filterGroup_directive_1.filterGroup)
	    .controller(filterGroup_directive_1.controllerName, filterGroup_directive_1.FilterGroupController);
	//# sourceMappingURL=filterGroup.module.js.map

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.filterOption';
	exports.directiveName = 'rlFilterOption';
	function filterOption() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(76),
	        scope: {
	            activate: '&',
	            isActive: '=active',
	            option: '=',
	        },
	    };
	}
	exports.filterOption = filterOption;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, filterOption);
	//# sourceMappingURL=filterOption.js.map

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row filter-option\" ng-class=\"{ 'active': isActive }\" ng-click=\"activate()\">\r\n\t<div class=\"col-xs-1\">\r\n\t\t<i class='fa fa-arrow-right' ng-show=\"isActive == true\"></i>\r\n\t</div>\r\n\t<div class=\"col-xs-1\" ng-if=\"hasIcon\" ng-bind-html=\"option.icon\"></div>\r\n\t<div ng-class=\"{ 'col-xs-6': hasIcon, 'col-xs-7': !hasIcon }\">\r\n\t\t{{option.label}}\r\n\t</div>\r\n\t<div class=\"col-xs-3 text-right\" ng-show=\"option.count != null\">\r\n\t\t({{option.count}})\r\n\t</div>\r\n</div>"

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	var filterGroup_service_1 = __webpack_require__(78);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.modeFilterGroup';
	exports.factoryName = 'modeFilterGroup';
	var ModeFilterGroup = (function (_super) {
	    __extends(ModeFilterGroup, _super);
	    function ModeFilterGroup(settings, object) {
	        _super.call(this, settings, object);
	        this.getValue = settings.getValue;
	        settings.options = _.map(settings.options, this.buildModeOption.bind(this));
	        this.initOptions();
	    }
	    ModeFilterGroup.prototype.serialize = function () {
	        var activeOption = this.activeOption;
	        if (activeOption.displayAll) {
	            return null;
	        }
	        return activeOption.value;
	    };
	    ModeFilterGroup.prototype.buildModeOption = function (option) {
	        var _this = this;
	        var modeOption = option;
	        modeOption.filter = function (item) {
	            if (modeOption.displayAll) {
	                return true;
	            }
	            return __transform.getValue(item, _this.getValue) === modeOption.value;
	        };
	        return modeOption;
	    };
	    return ModeFilterGroup;
	}(filterGroup_service_1.FilterGroup));
	exports.ModeFilterGroup = ModeFilterGroup;
	modeFilterGroupFactory.$inject = [__object.serviceName];
	function modeFilterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new ModeFilterGroup(settings, object);
	        },
	    };
	}
	exports.modeFilterGroupFactory = modeFilterGroupFactory;
	angular.module(exports.moduleName, [__object.moduleName])
	    .factory(exports.factoryName, modeFilterGroupFactory);
	//# sourceMappingURL=modeFilterGroup.service.js.map

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	exports.factoryName = 'filterGroup';
	var FilterGroup = (function (_super) {
	    __extends(FilterGroup, _super);
	    function FilterGroup(settings, object) {
	        _super.call(this);
	        this.settings = settings;
	        this.object = object;
	        this.template = '<rl-filter-group filter-group="filter" source="dataSource"></rl-filter-group>';
	        this.label = settings.label;
	        this.type = settings.type != null ? settings.type : settings.label;
	        this.initOptions();
	    }
	    FilterGroup.prototype.initOptions = function () {
	        var _this = this;
	        this.options = this.settings.options;
	        this.activeOption = this.setDefaultOption();
	        _.each(this.options, function (option) {
	            if (_.isUndefined(option.type)) {
	                option.type = option.label;
	            }
	            option.type = _this.object.toString(option.type).toLowerCase();
	        });
	    };
	    Object.defineProperty(FilterGroup.prototype, "activeOption", {
	        get: function () {
	            return this._activeOption;
	        },
	        set: function (value) {
	            this._activeOption = value;
	            this.onChange(false);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    FilterGroup.prototype.setDefaultOption = function () {
	        var defaultOption = this.options[0];
	        _.each(this.options, function (item) {
	            if (item.active != null && item.active === true) {
	                defaultOption = item;
	            }
	        });
	        return defaultOption;
	    };
	    FilterGroup.prototype.filter = function (item) {
	        return this.activeOption.filter(item);
	    };
	    FilterGroup.prototype.serialize = function () {
	        if (_.isFunction(this.settings.serialize)) {
	            return this.settings.serialize();
	        }
	        if (_.isFunction(this.activeOption.serialize)) {
	            return this.activeOption.serialize();
	        }
	        return this.activeOption.value;
	    };
	    FilterGroup.prototype.setActiveOption = function (index) {
	        if (index >= 0 && index < this.options.length) {
	            this.activeOption = this.options[index];
	        }
	    };
	    FilterGroup.prototype.setOptionCounts = function (counts) {
	        _.each(this.options, function (option) {
	            if (_.has(counts, option.type)) {
	                option.count = counts[option.type];
	            }
	        });
	    };
	    FilterGroup.prototype.updateOptionCounts = function (filteredDataSet) {
	        _.each(this.options, function (option) {
	            option.count = _.filter(filteredDataSet, option.filter.bind(option)).length;
	        });
	    };
	    return FilterGroup;
	}(typescript_angular_utilities_1.filters.SerializableFilter));
	exports.FilterGroup = FilterGroup;
	filterGroupFactory.$inject = [__object.serviceName];
	function filterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new FilterGroup(settings, object);
	        },
	    };
	}
	exports.filterGroupFactory = filterGroupFactory;
	//# sourceMappingURL=filterGroup.service.js.map

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	var filterGroup_service_1 = __webpack_require__(78);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.filterGroup.rangeFilterGroup';
	exports.factoryName = 'rangeFilterGroup';
	var RangeFilterGroup = (function (_super) {
	    __extends(RangeFilterGroup, _super);
	    function RangeFilterGroup(settings, object) {
	        _super.call(this, settings, object);
	        this.getValue = settings.getValue;
	        settings.options = _.map(settings.options, this.buildRangeOption.bind(this));
	        this.initOptions();
	    }
	    RangeFilterGroup.prototype.serialize = function () {
	        var activeOption = this.activeOption;
	        if (this.isNullOption(activeOption)) {
	            return null;
	        }
	        return {
	            highInclusive: activeOption.highInclusive,
	            highExclusive: activeOption.highExclusive,
	            lowInclusive: activeOption.lowInclusive,
	            lowExclusive: activeOption.lowExclusive,
	        };
	    };
	    RangeFilterGroup.prototype.buildRangeOption = function (option) {
	        var _this = this;
	        var modeOption = option;
	        modeOption.filter = function (item) {
	            var value = __transform.getValue(item, _this.getValue);
	            var result = true;
	            if (_.isUndefined(option.highExclusive) === false) {
	                result = value < option.highExclusive;
	            }
	            else if (_.isUndefined(option.highInclusive) === false) {
	                result = value <= option.highInclusive;
	            }
	            if (_.isUndefined(option.lowExclusive) === false) {
	                result = result && value > option.lowExclusive;
	            }
	            else if (_.isUndefined(option.lowInclusive) === false) {
	                result = result && value >= option.lowInclusive;
	            }
	            return result;
	        };
	        return modeOption;
	    };
	    RangeFilterGroup.prototype.isNullOption = function (option) {
	        return option.highInclusive == null
	            && option.highExclusive == null
	            && option.lowInclusive == null
	            && option.lowExclusive == null;
	    };
	    return RangeFilterGroup;
	}(filterGroup_service_1.FilterGroup));
	rangeFilterGroupFactory.$inject = [__object.serviceName];
	function rangeFilterGroupFactory(object) {
	    'use strict';
	    return {
	        getInstance: function (settings) {
	            return new RangeFilterGroup(settings, object);
	        },
	    };
	}
	exports.rangeFilterGroupFactory = rangeFilterGroupFactory;
	angular.module(exports.moduleName, [__object.moduleName])
	    .factory(exports.factoryName, rangeFilterGroupFactory);
	//# sourceMappingURL=rangeFilterGroup.service.js.map

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/commonjs.d.ts' />
	'use strict';
	exports.directiveName = 'rlFilterGroup';
	exports.controllerName = 'FilterGroupController';
	var FilterGroupController = (function () {
	    function FilterGroupController($scope) {
	        this.$scope = $scope;
	        this.hasIcon = this.icon != null && this.icon !== '';
	        this.showChildren = true;
	    }
	    FilterGroupController.prototype.toggleChildren = function () {
	        this.showChildren = !this.showChildren;
	    };
	    FilterGroupController.prototype.selectOption = function (option) {
	        this.filterGroup.activeOption = option;
	        this.showChildren = false;
	        if (this.source != null) {
	            this.source.refresh();
	        }
	        else {
	            this.$scope.$emit('dataSource.requestRefresh'); //*event?
	        }
	    };
	    FilterGroupController.$inject = ['$scope'];
	    return FilterGroupController;
	}());
	exports.FilterGroupController = FilterGroupController;
	function filterGroup() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(81),
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            icon: '=',
	            filterGroup: '=',
	            source: '=',
	        },
	    };
	}
	exports.filterGroup = filterGroup;
	//# sourceMappingURL=filterGroup.directive.js.map

/***/ },
/* 81 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filter-group\">\r\n\t<div class=\"row filter-header\" ng-click=\"controller.toggleChildren()\">\r\n\t\t<div class=\"col-sm-12\">\r\n\t\t\t<i class=\"collapse-icon fa fa-caret-down fa-2x\" ng-show=\"controller.showChildren\" title=\"Hide filter list\"></i>\r\n\t\t\t<i class=\"collapse-icon fa fa-caret-right fa-2x\" ng-hide=\"controller.showChildren\" title=\"Show filter list\"></i>\r\n\t\t\t<div class=\"filter-option\">\r\n\t\t\t\t<div style=\"display:inline-block\" ng-show=\"controller.hasIcon\" ng-bind-html=\"controller.icon\"></div>\r\n\t\t\t\t<h4 style=\"display: inline-block\">{{controller.filterGroup.label}}: {{controller.filterGroup.activeOption.label}}</h4>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n\t<div ng-show=\"controller.showChildren\" ng-repeat=\"filterOption in controller.filterGroup.options\">\r\n\t\t<rl-filter-option option=\"filterOption\" active=\"filterGroup.activeOption === filterOption\" activate=\"controller.selectOption(filterOption)\"></rl-filter-option>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var selectFilter_service_1 = __webpack_require__(83);
	var selectFilter_component_1 = __webpack_require__(84);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.selectFilter';
	__export(__webpack_require__(83));
	__export(__webpack_require__(84));
	angular.module(exports.moduleName, [])
	    .factory(selectFilter_service_1.factoryName, selectFilter_service_1.selectFilterFactory)
	    .directive(selectFilter_component_1.directiveName, selectFilter_component_1.selectFilter)
	    .controller(selectFilter_component_1.controllerName, selectFilter_component_1.SelectFilterController);
	//# sourceMappingURL=selectFilter.module.js.map

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	exports.factoryName = 'rlSelectFilterFactory';
	var SelectFilter = (function () {
	    function SelectFilter(settings) {
	        this.type = 'selectFilter';
	        this.valueSelector = settings.valueSelector;
	        this.comparer = settings.comparer;
	        this.options = settings.options;
	        this.getOptions = settings.getOptions;
	        this.label = settings.label;
	        this.displayNameSelector = settings.displayNameSelector;
	        this.nullOption = settings.nullOption;
	        this.template = "<rl-select-filter filter=\"filter\" source=\"dataSource\" options=\"filter.options\" get-options=\"filter.getOptions()\"\n\t\t\t\t\t\t\t\t\t\t   label=\"{{filter.label}}\" selector=\"filter.displayNameSelector\" null-option=\"{{filter.nullOption}}\"></rl-select-filter>";
	    }
	    SelectFilter.prototype.filter = function (item) {
	        if (this.selectedValue == null) {
	            return true;
	        }
	        if (this.comparer != null) {
	            return this.comparer(this.getValue(item), this.selectedValue);
	        }
	        return __object.objectUtility.areEqual(this.getValue(item), this.selectedValue);
	    };
	    SelectFilter.prototype.getValue = function (item) {
	        return __transform.getValue(item, this.valueSelector);
	    };
	    return SelectFilter;
	}());
	function selectFilterFactory() {
	    return {
	        getInstance: function (settings) {
	            return new SelectFilter(settings);
	        },
	    };
	}
	exports.selectFilterFactory = selectFilterFactory;
	//# sourceMappingURL=selectFilter.service.js.map

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../../typings/commonjs.d.ts' />
	'use strict';
	exports.directiveName = 'rlSelectFilter';
	exports.controllerName = 'SelectFilterController';
	var SelectFilterController = (function () {
	    function SelectFilterController($scope) {
	        this.$scope = $scope;
	    }
	    Object.defineProperty(SelectFilterController.prototype, "selectedValue", {
	        get: function () {
	            return this.filter.selectedValue;
	        },
	        set: function (v) {
	            this.filter.selectedValue = v;
	            if (this.source != null) {
	                this.source.refresh();
	            }
	            else {
	                this.$scope.$emit('dataSource.requestRefresh'); //*event?
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SelectFilterController.$inject = ['$scope'];
	    return SelectFilterController;
	}());
	exports.SelectFilterController = SelectFilterController;
	function selectFilter() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(85),
	        controller: exports.controllerName,
	        controllerAs: 'filter',
	        scope: {},
	        bindToController: {
	            filter: '=',
	            options: '=',
	            getOptions: '&',
	            source: '=',
	            label: '@',
	            selector: '=',
	            nullOption: '@'
	        },
	    };
	}
	exports.selectFilter = selectFilter;
	//# sourceMappingURL=selectFilter.component.js.map

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = "<div class=\"filter-group\">\r\n\t<rl-select ng-model=\"filter.selectedValue\" options=\"filter.options\" label=\"{{filter.label}}\"\r\n\t\t\t   selector=\"filter.selector\" get-options=\"filter.getOptions()\" null-option=\"{{filter.nullOption}}\"></rl-select>\r\n</div>"

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	exports.moduleName = 'rl.ui.components.cardContainer.filters.cardContainerFilters';
	exports.componentName = 'rlCardContainerFilters';
	exports.controllerName = 'CardContainerFiltersController';
	var CardContainerFiltersController = (function () {
	    function CardContainerFiltersController($rootScope) {
	        this.$rootScope = $rootScope;
	    }
	    CardContainerFiltersController.prototype.$onInit = function () {
	        var _this = this;
	        this.renderableFilters = _(this.filters).filter(function (filter) {
	            return filter.template != null;
	        }).map(function (filter) {
	            var scope = _this.$rootScope.$new();
	            scope.filter = filter;
	            scope.dataSource = _this.source;
	            filter.template = {
	                template: filter.template,
	                scope: scope,
	            };
	            return filter;
	        }).value();
	    };
	    CardContainerFiltersController.$inject = ['$rootScope'];
	    return CardContainerFiltersController;
	}());
	exports.CardContainerFiltersController = CardContainerFiltersController;
	var cardContainerFilters = {
	    template: __webpack_require__(87),
	    controller: exports.controllerName,
	    controllerAs: 'controller',
	    bindings: {
	        filters: '<',
	        source: '<',
	    },
	};
	angular.module(exports.moduleName, [])
	    .component(exports.componentName, cardContainerFilters)
	    .controller(exports.controllerName, CardContainerFiltersController);
	//# sourceMappingURL=cardContainerFilters.js.map

/***/ },
/* 87 */
/***/ function(module, exports) {

	module.exports = "<div ng-repeat=\"filter in controller.renderableFilters\">\r\n\t<rl-template-renderer template=\"filter.template\"></rl-template-renderer>\r\n</div>"

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.itemCount';
	exports.directiveName = 'rlItemCount';
	function itemCount() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: { cardContainer: '?^^rlCardContainer' },
	        template: __webpack_require__(89),
	        controller: function () { },
	        controllerAs: 'itemCount',
	        scope: {},
	        bindToController: true,
	    };
	}
	exports.itemCount = itemCount;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, itemCount);
	//# sourceMappingURL=itemCount.js.map

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "<p ng-show=\"!itemCount.cardContainer.dataSource.loadingDataSet\">\r\n\tShowing <strong>{{itemCount.cardContainer.dataSource.dataSet.length}} of {{itemCount.cardContainer.dataSource.count}}</strong> total items\r\n</p>"

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	exports.moduleName = 'rl.ui.components.cardContainer.pager';
	exports.directiveName = 'rlPager';
	exports.controllerName = 'PagerController';
	exports.defaultVisiblePageCount = 5;
	var PagerController = (function () {
	    function PagerController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        this.canGoBack = false;
	        this.canGoForward = false;
	        this.hasPageFilter = true;
	        this.updatePageCount = function () {
	            var totalItems = _this.dataSource.count;
	            var newLastPage = Math.ceil(totalItems / _this.pager.pageSize);
	            if (newLastPage !== _this.lastPage) {
	                _this.lastPage = newLastPage;
	                _this.currentPage = 1;
	            }
	            _this.updatePaging();
	        };
	    }
	    PagerController.prototype.$onInit = function () {
	        var _this = this;
	        if (this.cardContainer == null) {
	            return;
	        }
	        this.pager = this.cardContainer.dataSource.pager;
	        if (this.pager == null) {
	            this.hasPageFilter = false;
	        }
	        else {
	            this.visiblePageCount = this.pageCount != null ? this.pageCount : exports.defaultVisiblePageCount;
	            this.lastPage = 1;
	            this.dataSource = this.cardContainer.dataSource;
	            this.$scope.$watch(function () { return _this.dataSource.count; }, this.updatePageCount);
	            this.$scope.$watch(function () { return _this.pager.pageSize; }, this.updatePageCount);
	            this.$scope.$watch(function () { return _this.currentPage; }, function (page) {
	                _this.updatePaging();
	                _this.pager.pageNumber = page;
	                _this.dataSource.onPagingChange();
	            });
	        }
	    };
	    PagerController.prototype.updatePaging = function () {
	        var page = this.currentPage;
	        this.canGoBack = page > 1;
	        this.canGoForward = page < this.lastPage;
	        var nonCurrentVisiblePages = this.visiblePageCount - 1;
	        var before = Math.floor(nonCurrentVisiblePages / 2);
	        var after = Math.ceil(nonCurrentVisiblePages / 2);
	        var startPage = page - before;
	        var endPage = page + after;
	        if (startPage < 1) {
	            startPage = 1;
	            endPage = Math.min(this.visiblePageCount, this.lastPage);
	        }
	        else if (endPage > this.lastPage) {
	            endPage = this.lastPage;
	            startPage = Math.max(this.lastPage - nonCurrentVisiblePages, 1);
	        }
	        this.pages = _.range(startPage, endPage + 1);
	    };
	    PagerController.prototype.first = function () {
	        this.currentPage = 1;
	    };
	    PagerController.prototype.previous = function () {
	        if (this.currentPage > 1) {
	            this.currentPage--;
	        }
	    };
	    PagerController.prototype.goto = function (page) {
	        if (page >= 1 && page <= this.lastPage) {
	            this.currentPage = page;
	        }
	    };
	    PagerController.prototype.next = function () {
	        if (this.currentPage < this.lastPage) {
	            this.currentPage++;
	        }
	    };
	    PagerController.prototype.last = function () {
	        this.currentPage = this.lastPage;
	    };
	    PagerController.$inject = ['$scope'];
	    return PagerController;
	}());
	exports.PagerController = PagerController;
	function pager() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: { cardContainer: '?^^rlCardContainer' },
	        template: __webpack_require__(91),
	        controller: exports.controllerName,
	        controllerAs: 'pager',
	        scope: {},
	        bindToController: {
	            pageCount: '=visiblePages',
	        },
	    };
	}
	exports.pager = pager;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, pager)
	    .controller(exports.controllerName, PagerController);
	//# sourceMappingURL=pager.js.map

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = "<nav ng-if=\"pager.hasPageFilter\">\r\n\t<ul class=\"pagination\">\r\n\t\t<li title=\"Go to first page\" ng-click=\"pager.first()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoBack }\">\r\n\t\t\t<a><i class=\"fa fa-angle-double-left\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to previous page\" ng-click=\"pager.previous()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoBack }\">\r\n\t\t\t<a><i class=\"fa fa-angle-left\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to page {{pager.page}}\" ng-click=\"pager.goto(page)\"\r\n\t\t\tng-repeat=\"page in pager.pages\"\r\n\t\t\tng-class=\"{ 'active': pager.currentPage == page }\">\r\n\t\t\t<a>{{page}}</a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to next page\" ng-click=\"pager.next()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoForward }\">\r\n\t\t\t<a><i class=\"fa fa-angle-right\"></i></a>\r\n\t\t</li>\r\n\t\t<li title=\"Go to last page\" ng-click=\"pager.last()\"\r\n\t\t\tng-class=\"{ 'disabled': !pager.canGoForward }\">\r\n\t\t\t<a><i class=\"fa fa-angle-double-right\"></i></a>\r\n\t\t</li>\r\n\t</ul>\r\n</nav>\r\n"

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.cardContainer.pageSize';
	exports.directiveName = 'rlPageSize';
	exports.controllerName = 'PageSizeController';
	exports.availablePageSizes = [10, 25, 50, 100];
	exports.defaultPageSize = 10;
	var PageSizeController = (function () {
	    function PageSizeController($scope) {
	        this.$scope = $scope;
	    }
	    PageSizeController.prototype.$onInit = function () {
	        var _this = this;
	        if (this.cardContainer == null) {
	            return;
	        }
	        this.selectedPageSize = exports.defaultPageSize;
	        this.pageSizes = exports.availablePageSizes;
	        this.hasPageFilter = true;
	        var pager = this.cardContainer.dataSource.pager;
	        if (pager == null) {
	            this.hasPageFilter = false;
	        }
	        else {
	            this.$scope.$watch(function () { return _this.selectedPageSize; }, function (newPageSize) {
	                if (pager != null) {
	                    pager.pageSize = newPageSize;
	                    _this.cardContainer.dataSource.onPagingChange();
	                }
	            });
	        }
	    };
	    PageSizeController.$inject = ['$scope'];
	    return PageSizeController;
	}());
	exports.PageSizeController = PageSizeController;
	function pageSize() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: { cardContainer: '?^^rlCardContainer' },
	        template: __webpack_require__(93),
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {},
	    };
	}
	exports.pageSize = pageSize;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, pageSize)
	    .controller(exports.controllerName, PageSizeController);
	//# sourceMappingURL=pageSize.js.map

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = "<div ng-show=\"controller.hasPageFilter\">\r\n\t<select class=\"form-control\" title=\"Cards per page\" ng-model=\"controller.selectedPageSize\"\r\n\t\t\tng-options=\"pageSize for pageSize in controller.pageSizes\"></select>\r\n</div>\r\n"

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __boolean = typescript_angular_utilities_1.services.boolean;
	exports.moduleName = 'rl.ui.components.cardContainer.selectionControl';
	exports.directiveName = 'rlSelectionControl';
	exports.controllerName = 'SelectionControlController';
	var SelectionControlController = (function () {
	    function SelectionControlController($scope, bool) {
	        this.$scope = $scope;
	        this.bool = bool;
	    }
	    SelectionControlController.prototype.$onInit = function () {
	        var _this = this;
	        if (this.cardContainer == null) {
	            return;
	        }
	        this.selectedItems = this.cardContainer.numberSelected;
	        this.pagingEnabled = this.bool.toBool(this.cardContainer.dataSource.pager);
	        this.dataSource = this.cardContainer.dataSource;
	        this.$scope.$watch(function () { return _this.cardContainer.numberSelected; }, function (value) {
	            _this.selectedItems = value;
	        });
	    };
	    SelectionControlController.prototype.selectPage = function () {
	        _.each(this.dataSource.dataSet, function (item) {
	            item.viewData.selected = true;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.selectAll = function () {
	        _.each(this.dataSource.filteredDataSet, function (item) {
	            item.viewData.selected = true;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.clearPage = function () {
	        _.each(this.dataSource.dataSet, function (item) {
	            item.viewData.selected = false;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.prototype.clearAll = function () {
	        _.each(this.dataSource.filteredDataSet, function (item) {
	            item.viewData.selected = false;
	        });
	        this.$scope.$emit('selectionChanged'); //*events?
	    };
	    SelectionControlController.$inject = ['$scope', __boolean.serviceName];
	    return SelectionControlController;
	}());
	exports.SelectionControlController = SelectionControlController;
	function selectionControl() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: { cardContainer: '?^^rlCardContainer' },
	        template: __webpack_require__(95),
	        controller: exports.controllerName,
	        controllerAs: 'selection',
	        scope: {},
	        bindToController: {},
	    };
	}
	exports.selectionControl = selectionControl;
	angular.module(exports.moduleName, [__boolean.moduleName])
	    .directive(exports.directiveName, selectionControl)
	    .controller(exports.controllerName, SelectionControlController);
	//# sourceMappingURL=selectionControl.js.map

/***/ },
/* 95 */
/***/ function(module, exports) {

	module.exports = "<div>\r\n\t<div style=\"margin-bottom: 5px\">\r\n\t\t<span><strong>{{selection.selectedItems}}</strong> items selected</span>\r\n\t</div>\r\n\t<div style=\"margin-bottom: 5px\" ng-if=\"selection.pagingEnabled\">\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.selectPage()\">Select page</button>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.clearPage()\">Clear page</button>\r\n\t</div>\r\n\t<div>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.selectAll()\">Select all</button>\r\n\t\t<button type=\"button\" class=\"btn btn-default\" ng-click=\"selection.clearAll()\">Clear all</button>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __array = typescript_angular_utilities_1.services.array;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var dataSources_module_1 = __webpack_require__(52);
	var sorts_module_1 = __webpack_require__(53);
	var breakpoint_1 = __webpack_require__(46);
	exports.componentName = 'rlCardContainer';
	exports.controllerName = 'CardContainerController';
	exports.defaultMaxColumnSorts = 2;
	exports.defaultSelectionTitle = 'Select card';
	var CardContainerController = (function () {
	    function CardContainerController($scope, $attrs, $transclude, object, array, dataPagerFactory, parentChild) {
	        var _this = this;
	        this.$scope = $scope;
	        this.object = object;
	        this.array = array;
	        this.dataPagerFactory = dataPagerFactory;
	        this.parentChild = parentChild;
	        this.numberSelected = 0;
	        this.addViewData = function () {
	            _.each(_this.dataSource.rawDataSet, function (item) {
	                if (_.isUndefined(item.viewData)) {
	                    item.viewData = {
	                        selected: false,
	                    };
	                }
	            });
	            _this.updateDisabledSelections();
	        };
	        this.clearFilteredSelections = function () {
	            var nonVisibleItems = _.difference(_this.dataSource.rawDataSet, _this.dataSource.filteredDataSet);
	            _.each(nonVisibleItems, function (item) {
	                if (_.isUndefined(item.viewData)) {
	                    item.viewData = {
	                        selected: false,
	                    };
	                }
	                item.viewData.selected = false;
	                item.viewData.selectionTitle = exports.defaultSelectionTitle;
	            });
	            _this.updateSelected();
	        };
	        this.updateSelected = function () {
	            _this.numberSelected = _.filter(_this.dataSource.filteredDataSet, function (item) {
	                return item.viewData != null && item.viewData.selected;
	            }).length;
	        };
	        this.updateDisabledSelections = function () {
	            if (_this.disablingSelections) {
	                _.each(_this.dataSource.rawDataSet, function (item) {
	                    var disabledReason = _this.disableSelection({ item: item });
	                    item.viewData.disabledSelection = (disabledReason != null);
	                    item.viewData.selectionTitle = (item.viewData.disabledSelection ? disabledReason : exports.defaultSelectionTitle);
	                });
	            }
	        };
	        if (this.builder != null) {
	            this.builder.setCardContainerProperties(this);
	        }
	        this.makeCard = $transclude;
	        this.dataSource = this.source;
	        this.permanentFooters = _.isUndefined(this.permanentFooters) ? false : this.permanentFooters;
	        this.maxColSorts = this.maxColumnSorts != null ? this.maxColumnSorts : exports.defaultMaxColumnSorts;
	        this.disablingSelections = object.isNullOrWhitespace($attrs.disableSelection) === false;
	        this.sortDirection = sorts_module_1.SortDirection;
	        this.syncFilters();
	        this.setupPaging();
	        this.buildColumnSizes();
	        if (this.selectableCards) {
	            //*use card container event service?
	            $scope.$on('selectionChanged', this.updateSelected);
	            $scope.$on('updateDisabledSelections', this.updateDisabledSelections);
	            this.dataSource.watch(this.addViewData, 'changed');
	            this.dataSource.watch(this.clearFilteredSelections, 'redrawing');
	            this.addViewData();
	            this.selectionColumn = {
	                label: null,
	                size: null,
	                getValue: function (item) {
	                    return item.viewData.selected;
	                },
	                flipSort: true,
	            };
	        }
	        if (this.dataSource.sorts == null) {
	            this.dataSource.sorts = [];
	        }
	        $scope.containerData = this.containerData;
	    }
	    CardContainerController.prototype.sortSelected = function () {
	        this.sort(this.selectionColumn);
	    };
	    CardContainerController.prototype.openCard = function () {
	        var behaviors = this.parentChild.getAllChildBehaviors(this.dataSource.dataSet);
	        return _.every(_.map(behaviors, function (behavior) { return behavior.close(); }));
	    };
	    CardContainerController.prototype.sort = function (column) {
	        var sortList = this.dataSource.sorts;
	        var firstSort = sortList[0];
	        // If column is already the primary sort, change the direction
	        if (firstSort != null
	            && firstSort.column === column) {
	            firstSort.direction = sorts_module_1.SortDirection.toggle(firstSort.direction);
	            // Clear sort
	            if (firstSort.direction === sorts_module_1.SortDirection.none) {
	                this.clearVisualSortIndicator(firstSort);
	                firstSort = null;
	                // If the column has secondary sorts don't fall back to a
	                //  secondary sort, instead just clear all sorts
	                if (column.secondarySorts != null) {
	                    sortList.length = 0;
	                }
	                else {
	                    sortList.shift();
	                }
	            }
	        }
	        else {
	            // Else make column primary ascending sort
	            // Remove any existing non-primary sorts on column
	            this.array.remove(sortList, function (sort) {
	                return column === sort.column;
	            });
	            // Build ascending sort for column
	            var newSort = {
	                column: column,
	                direction: sorts_module_1.SortDirection.ascending,
	            };
	            sortList.unshift(newSort);
	            firstSort = newSort;
	        }
	        this.updateVisualColumnSorting();
	        // If column has secondary sorts, wipe the sort order and just apply the secondary sorts
	        if (firstSort != null && column.secondarySorts != null) {
	            sortList.length = 0;
	            var secondarySorts = this.buildSecondarySorts(firstSort.direction, column.secondarySorts);
	            sortList.push(firstSort);
	            sortList.push.apply(sortList, secondarySorts);
	        }
	        else {
	            // If not using column secondary sorts, limit the maximum number
	            //  of sorts applied to the maximum number of sorts
	            this.dataSource.sorts = _.take(sortList, this.maxColSorts);
	        }
	        this.dataSource.onSortChange();
	    };
	    CardContainerController.prototype.selectionChanged = function () {
	        this.updateSelected();
	        this.$scope.$emit('selectionChanged');
	    };
	    CardContainerController.prototype.syncFilters = function () {
	        if (!this.object.isNullOrEmpty(this.filters)) {
	            this.dataSource.filters = this.filters;
	            this.dataSource.refresh();
	        }
	        else if (this.dataSource.filters != null) {
	            this.filters = this.dataSource.filters;
	        }
	    };
	    CardContainerController.prototype.setupPaging = function () {
	        // If paging flag is specified, card container controls pager instance
	        if (this.paging != null) {
	            if (this.paging === false) {
	                this.dataSource.pager = null;
	            }
	            else {
	                this.builder._pager = this.dataPagerFactory.getInstance();
	                this.dataSource.pager = this.builder._pager;
	            }
	        }
	        else if (this.dataSource.pager) {
	            // If the paging flag is not set and the dataSource has a pager, save a reference here
	            this.builder._pager = this.dataSource.pager;
	        }
	    };
	    CardContainerController.prototype.buildColumnSizes = function () {
	        var _this = this;
	        _.each(this.columns, function (column) {
	            var sizes = column.size;
	            if (_.isObject(sizes)) {
	                sizes[breakpoint_1.xs] = _this.object.valueOrDefault(sizes[breakpoint_1.xs], 0);
	                sizes[breakpoint_1.sm] = _this.object.valueOrDefault(sizes[breakpoint_1.sm], sizes[breakpoint_1.xs]);
	                sizes[breakpoint_1.md] = _this.object.valueOrDefault(sizes[breakpoint_1.md], sizes[breakpoint_1.sm]);
	                sizes[breakpoint_1.lg] = _this.object.valueOrDefault(sizes[breakpoint_1.lg], sizes[breakpoint_1.md]);
	            }
	            else {
	                column.size = {
	                    xs: sizes,
	                    sm: sizes,
	                    md: sizes,
	                    lg: sizes,
	                };
	            }
	        });
	    };
	    CardContainerController.prototype.lookupColumn = function (label) {
	        return _.find(this.columns, function (column) {
	            return column.label === label;
	        });
	    };
	    CardContainerController.prototype.buildSecondarySorts = function (direction, secondarySorts) {
	        var _this = this;
	        var sortList = secondarySorts[sorts_module_1.SortDirection.getFullName(direction)];
	        return _.map(sortList, function (sort) {
	            return {
	                direction: sort.direction,
	                column: _this.lookupColumn(sort.column),
	            };
	        });
	    };
	    CardContainerController.prototype.updateVisualColumnSorting = function () {
	        var _this = this;
	        _.each(this.dataSource.sorts, function (sort, index) {
	            // Only first sort should have visible direction
	            if (index === 0) {
	                _this.updateVisualSortIndicator(sort);
	            }
	            else {
	                _this.clearVisualSortIndicator(sort);
	            }
	        });
	    };
	    CardContainerController.prototype.updateVisualSortIndicator = function (sort) {
	        sort.column.sortDirection = sort.direction;
	    };
	    CardContainerController.prototype.clearVisualSortIndicator = function (sort) {
	        sort.column.sortDirection = null;
	    };
	    CardContainerController.$inject = ['$scope', '$attrs', '$transclude', __object.serviceName, __array.serviceName, dataSources_module_1.dataPager.factoryName, __parentChild.serviceName];
	    return CardContainerController;
	}());
	exports.CardContainerController = CardContainerController;
	exports.cardContainer = {
	    transclude: {
	        'containerHeaderSlot': '?rlContainerHeader',
	        'containerFooterSlot': '?rlContainerFooter',
	        'contentSlot': '?rlCardContent',
	        'footerSlot': '?rlCardFooter',
	    },
	    template: __webpack_require__(97),
	    controller: exports.controllerName,
	    controllerAs: 'cardContainer',
	    bindings: {
	        builder: '=?',
	        cardController: '@',
	        cardControllerAs: '@',
	        cardAs: '@',
	    }
	};
	//# sourceMappingURL=cardContainer.js.map

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\r\n\t<div class=\"col-md-3 col-xs-12\" ng-if=\"cardContainer.renderFilters\">\r\n\t\t<rl-card-container-filters filters=\"cardContainer.filters\" source=\"cardContainer.dataSource\"></rl-card-container-filters>\r\n\t</div>\r\n\t<div class=\"col-xs-12\" ng-class=\"{ 'col-md-9': cardContainer.renderFilters }\">\r\n\t\t<div class=\"card-container\">\r\n\t\t\t<div>\r\n\t\t\t\t<div class=\"card-container-header\">\r\n\t\t\t\t\t<div ng-transclude=\"containerHeaderSlot\">\r\n\t\t\t\t\t\t<rl-default-card-container-header></rl-default-card-container-header>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\r\n\t\t\t\t<rl-generic-container selector=\"cardContainer.selectableCards\">\r\n\t\t\t\t\t<template when-selector=\"false\" default>\r\n\t\t\t\t\t\t<div class=\"card-columns-header\">\r\n\t\t\t\t\t\t\t<div ng-repeat=\"column in cardContainer.columns\">\r\n\t\t\t\t\t\t\t\t<rl-column-header sort=\"cardContainer.sort(column)\" sorting=\"column.sortDirection\" column=\"column\"></rl-column-header>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</template>\r\n\t\t\t\t\t<template when-selector=\"true\">\r\n\t\t\t\t\t\t<div class=\"card-columns-header\">\r\n\t\t\t\t\t\t\t<div class=\"select-group\">\r\n\t\t\t\t\t\t\t\t<div class=\"select-column\">\r\n\t\t\t\t\t\t\t\t\t<i class=\"fa fa-check\" style=\"margin-left: 6px; cursor: pointer\" ng-click=\"cardContainer.sortSelected()\"></i>\r\n\t\t\t\t\t\t\t\t\t<i ng-show=\"cardContainer.sortColumn.sortDirection === cardContainer.sortDirection.ascending\" class=\"fa fa-sort-asc\"></i>\r\n\t\t\t\t\t\t\t\t\t<i ng-show=\"cardContainer.sortColumn.sortDirection === cardContainer.sortDirection.descending\" class=\"fa fa-sort-desc\"></i>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t<div class=\"select-content\">\r\n\t\t\t\t\t\t\t\t\t<div ng-repeat=\"column in cardContainer.columns\">\r\n\t\t\t\t\t\t\t\t\t\t<rl-column-header sort=\"cardContainer.sort(column)\" sorting=\"column.sortDirection\" column=\"column\"></rl-column-header>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</template>\r\n\t\t\t\t</rl-generic-container>\r\n\r\n\t\t\t\t<div ng-if=\"cardContainer.dataSource.dataSet | isEmpty:false\">\r\n\t\t\t\t\t<div ng-repeat=\"card in cardContainer.dataSource.dataSet\">\r\n\t\t\t\t\t\t<rl-card columns=\"cardContainer.columns\" item=\"card\"\r\n\t\t\t\t\t\t\t\tclickable=\"cardContainer.clickableCards\"\r\n\t\t\t\t\t\t\t\tselectable=\"cardContainer.selectableCards\"\r\n\t\t\t\t\t\t\t\tselection-changed=\"cardContainer.selectionChanged()\"\r\n\t\t\t\t\t\t\t\tcontainer-data=\"cardContainer.containerData\"\r\n\t\t\t\t\t\t\t\tsource=\"cardContainer.dataSource\"\r\n\t\t\t\t\t\t\t\tpermanent-footer=\"cardContainer.permanentFooters\"\r\n\t\t\t\t\t\t\t\tcard-controller=\"cardContainer.cardController\"\r\n\t\t\t\t\t\t\t\tcard-controller-as=\"cardContainer.cardControllerAs\"\r\n\t\t\t\t\t\t\t\tcard-as=\"cardContainer.cardAs\"\r\n\t\t\t\t\t\t\t\tsave-when-invalid=\"cardContainer.saveWhenInvalid\"></rl-card>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div ng-if=\"cardContainer.dataSource.needsRefinedSearch\">\r\n\t\t\t\t\tPlease refine your search results\r\n\t\t\t\t</div>\r\n\t\t\t\t<div ng-if=\"cardContainer.dataSource.isEmpty\">\r\n\t\t\t\t\tThere are no items to show\r\n\t\t\t\t</div>\r\n\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<rl-busy loading=\"cardContainer.dataSource.loadingDataSet\" size=\"2x\"></rl-busy>\r\n\t\t\t\t</div>\r\n\r\n\t\t\t\t<div class=\"card-container-footer\">\r\n\t\t\t\t\t<div ng-transclude=\"containerFooterSlot\">\r\n\t\t\t\t\t\t<rl-default-card-container-footer></rl-default-card-container-footer>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n</div>"

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __genericSearchFilter = typescript_angular_utilities_1.services.genericSearchFilter;
	var dataSources = __webpack_require__(52);
	var filterGroup = __webpack_require__(74);
	var selectFilter = __webpack_require__(82);
	var dateFilter = __webpack_require__(69);
	var columnSearchFilter_service_1 = __webpack_require__(68);
	exports.factoryName = 'cardContainerBuilder';
	var CardContainerBuilder = (function () {
	    function CardContainerBuilder($injector) {
	        this.$injector = $injector;
	        this.dataSource = new DataSourceBuilder($injector, this);
	        this.filters = new FilterBuilder($injector, this);
	        this._columns = [];
	    }
	    CardContainerBuilder.prototype.useSearch = function (filter) {
	        if (filter == null) {
	            var factory = this.$injector.get(__genericSearchFilter.factoryName);
	            filter = factory.getInstance();
	        }
	        this._searchFilter = filter;
	        return this._searchFilter;
	    };
	    CardContainerBuilder.prototype.usePaging = function () {
	        this._paging = true;
	    };
	    CardContainerBuilder.prototype.addColumn = function (column) {
	        this._columns.push(column);
	    };
	    CardContainerBuilder.prototype.useClickableCards = function () {
	        this._clickableCards = true;
	    };
	    CardContainerBuilder.prototype.usePermanentFooters = function () {
	        this._permanentFooters = true;
	    };
	    CardContainerBuilder.prototype.useSelection = function () {
	        this._selectableCards = true;
	    };
	    CardContainerBuilder.prototype.renderFilters = function () {
	        this._renderFilters = true;
	    };
	    CardContainerBuilder.prototype.saveWhenInvalid = function () {
	        this._saveWhenInvalid = true;
	    };
	    Object.defineProperty(CardContainerBuilder.prototype, "disableSelection", {
	        set: function (value) {
	            if (!this._selectableCards) {
	                this.useSelection();
	            }
	            this._disableSelection = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CardContainerBuilder.prototype.setCardContainerProperties = function (cardContainer) {
	        if (this._searchFilter != null) {
	            this._filters.push(this._searchFilter);
	        }
	        cardContainer.source = this._dataSource;
	        cardContainer.filters = this._filters;
	        cardContainer.searchFilter = this._searchFilter;
	        cardContainer.paging = this._paging;
	        cardContainer.columns = this._columns;
	        cardContainer.containerData = this.containerData;
	        cardContainer.clickableCards = this._clickableCards;
	        cardContainer.maxColumnSorts = this.maxColumnSorts;
	        cardContainer.permanentFooters = this._permanentFooters;
	        cardContainer.selectableCards = this._selectableCards;
	        cardContainer.disableSelection = this._disableSelection;
	        cardContainer.renderFilters = this._renderFilters;
	        cardContainer.saveWhenInvalid = this._saveWhenInvalid;
	        if (cardContainer.cardController == null) {
	            cardContainer.cardController = this.cardController;
	        }
	        if (cardContainer.cardControllerAs == null) {
	            cardContainer.cardControllerAs = this.cardControllerAs;
	        }
	        if (cardContainer.cardAs == null) {
	            cardContainer.cardAs = this.cardAs;
	        }
	    };
	    return CardContainerBuilder;
	}());
	exports.CardContainerBuilder = CardContainerBuilder;
	var DataSourceBuilder = (function () {
	    function DataSourceBuilder($injector, parent) {
	        this.$injector = $injector;
	        this.parent = parent;
	        var factory = this.$injector.get(dataSources.simpleDataSource.factoryName);
	        parent._dataSource = factory.getInstance([]);
	    }
	    DataSourceBuilder.prototype.buildSimpleDataSource = function (data) {
	        var factory = this.$injector.get(dataSources.simpleDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(data);
	        return this.parent._dataSource;
	    };
	    DataSourceBuilder.prototype.buildDataServiceDataSource = function (getDataSet) {
	        var factory = this.$injector.get(dataSources.dataServiceDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(getDataSet);
	        return this.parent._dataSource;
	    };
	    DataSourceBuilder.prototype.buildClientServerDataSource = function (getDataSet, getFilterModel, validateModel) {
	        if (_.isUndefined(this.parent._searchFilter)) {
	            this.parent.useSearch();
	        }
	        var factory = this.$injector.get(dataSources.clientServerDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(getDataSet, this.parent._searchFilter, getFilterModel, validateModel);
	        return this.parent._dataSource;
	    };
	    DataSourceBuilder.prototype.buildServerSideDataSource = function (getDataSet) {
	        var factory = this.$injector.get(dataSources.serverSideDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(getDataSet);
	        return this.parent._dataSource;
	    };
	    DataSourceBuilder.prototype.buildSmartDataSource = function (getDataSet) {
	        var factory = this.$injector.get(dataSources.smartDataSource.factoryName);
	        this.parent._dataSource = factory.getInstance(getDataSet);
	        return this.parent._dataSource;
	    };
	    DataSourceBuilder.prototype.buildCustomDataSource = function (dataSource) {
	        this.parent._dataSource = dataSource;
	        return this.parent._dataSource;
	    };
	    return DataSourceBuilder;
	}());
	exports.DataSourceBuilder = DataSourceBuilder;
	var FilterBuilder = (function () {
	    function FilterBuilder($injector, parent) {
	        this.$injector = $injector;
	        this.parent = parent;
	        this.parent._filters = [];
	    }
	    FilterBuilder.prototype.buildFilterGroup = function (settings) {
	        var factory = this.$injector.get(filterGroup.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildModeFilterGroup = function (settings) {
	        var factory = this.$injector.get(filterGroup.modeFilterGroup.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildRangeFilterGroup = function (settings) {
	        var factory = this.$injector.get(filterGroup.rangeFilterGroup.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildSelectFilter = function (settings) {
	        var factory = this.$injector.get(selectFilter.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildDateFilter = function (settings) {
	        var factory = this.$injector.get(dateFilter.factoryName);
	        var filter = factory.getInstance(settings);
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.buildColumnSearchFilter = function () {
	        var factory = this.$injector.get(columnSearchFilter_service_1.factoryName);
	        var filter = factory.getInstance();
	        this.parent._filters.push(filter);
	        return filter;
	    };
	    FilterBuilder.prototype.addCustomFilter = function (filter) {
	        this.parent._filters.push(filter);
	    };
	    return FilterBuilder;
	}());
	exports.FilterBuilder = FilterBuilder;
	cardContainerBuilderFactory.$inject = ['$injector'];
	function cardContainerBuilderFactory($injector) {
	    return {
	        useMock: false,
	        getInstance: function () {
	            return this.useMock ? this.mockBuilder : new CardContainerBuilder($injector);
	        },
	        mockBuilder: new CardContainerBuilder($injector),
	    };
	}
	exports.cardContainerBuilderFactory = cardContainerBuilderFactory;
	//# sourceMappingURL=cardContainerBuilder.service.js.map

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	'use strict';
	exports.headerComponentName = 'rlDefaultCardContainerHeader';
	exports.footerComponentName = 'rlDefaultCardContainerFooter';
	exports.defaultContainerHeader = {
	    template: __webpack_require__(100),
	};
	exports.defaultContainerFooter = {
	    template: __webpack_require__(101),
	};
	//# sourceMappingURL=defaultComponents.js.map

/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\r\n\t<div class=\"col-xs-12 col-sm-9\">\r\n\t\t<rl-card-search></rl-card-search>\r\n\t</div>\r\n\t<div class=\"hidden-xs col-sm-3\">\r\n\t\t<rl-page-size></rl-page-size>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = "<div class=\"row\">\r\n\t<div ng-if=\"!cardContainer.selectableCards\" class=\"col-sm-6\">\r\n\t\t<rl-item-count></rl-item-count>\r\n\t</div>\r\n\t<span ng-if=\"cardContainer.selectableCards\">\r\n\t\t<div class=\"col-sm-3\">\r\n\t\t\t<rl-selection-control></rl-selection-control>\r\n\t\t</div>\r\n\t\t<div class=\"col-sm-3\">\r\n\t\t\t<rl-item-count></rl-item-count>\r\n\t\t</div>\r\n\t</span>\r\n\t<div class=\"col-sm-6\">\r\n\t\t<rl-pager class=\"pull-right\"></rl-pager>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	__webpack_require__(103);
	var angular = __webpack_require__(1);
	var componentsDefaultTheme_1 = __webpack_require__(30);
	exports.moduleName = 'rl.ui.components.checkbox';
	exports.componentName = 'rlCheckbox';
	exports.controllerName = 'CheckboxController';
	var CheckboxController = (function () {
	    function CheckboxController(useDefaultTheme) {
	        this.useDefaultTheme = useDefaultTheme;
	    }
	    Object.defineProperty(CheckboxController.prototype, "checked", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            this.ngModel.$setViewValue(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CheckboxController.prototype.toggle = function () {
	        if (this.active && !this.ngDisabled) {
	            this.checked = !this.checked;
	            this.onToggle({ value: this.checked });
	        }
	    };
	    CheckboxController.prototype.$onInit = function () {
	        this.active = this.active != null ? this.active : true;
	    };
	    CheckboxController.$inject = [componentsDefaultTheme_1.defaultThemeValueName];
	    return CheckboxController;
	}());
	exports.CheckboxController = CheckboxController;
	exports.checkbox = {
	    require: { ngModel: 'ngModel' },
	    transclude: true,
	    template: __webpack_require__(105),
	    controller: exports.controllerName,
	    controllerAs: 'checkbox',
	    bindings: {
	        ngDisabled: '<?',
	        active: '<?',
	        onToggle: '&',
	    },
	};
	angular.module(exports.moduleName, [])
	    .component(exports.componentName, exports.checkbox)
	    .controller(exports.controllerName, CheckboxController);
	//# sourceMappingURL=checkbox.js.map

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(104);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./checkbox.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./checkbox.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, ".rl-checkbox.default-theme:before {\r\n\tfont-family: FontAwesome;\r\n\tcontent: \"\\F096\"; /*fa-square-o*/\r\n\tfont-size: 1.5em;\r\n\tposition: relative;\r\n\ttop: .05em;\r\n}\r\n\r\n.rl-checkbox-checked.default-theme:before {\r\n\tfont-family: FontAwesome;\r\n\tcontent: \"\\F046\"; /*fa-check-square-o*/\r\n\tfont-size: 1.4em;\r\n}\r\n\r\n.disabled.default-theme:before {\r\n\tcursor: not-allowed;\r\n}", ""]);
	
	// exports


/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "<span ng-click=\"checkbox.toggle()\" ng-transclude\r\n\t  ng-class=\"{ 'rl-checkbox': !checkbox.checked\r\n\t  , 'rl-checkbox-checked': checkbox.checked\r\n\t  , 'disabled': checkbox.ngDisabled\r\n\t  , 'default-theme': checkbox.useDefaultTheme }\"></span>"

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	exports.moduleName = 'rl.ui.components.commaList';
	exports.directiveName = 'rlCommaList';
	exports.controllerName = 'CommaListController';
	var CommaListController = (function () {
	    function CommaListController(object) {
	        this.remainingItems = 0;
	        this.list = this.getFirstItems(this.inList);
	    }
	    CommaListController.prototype.getFirstItems = function (list) {
	        var _this = this;
	        if (this.transform != null) {
	            list = _.map(list, function (item) {
	                return __transform.getValue(item, _this.transform);
	            });
	        }
	        ;
	        var newList;
	        if (this.max != null) {
	            newList = _.take(list, this.max);
	            this.remainingItems = list.length - this.max;
	        }
	        else {
	            newList = _.clone(list);
	        }
	        return newList;
	    };
	    CommaListController.$inject = [__object.serviceName];
	    return CommaListController;
	}());
	exports.CommaListController = CommaListController;
	function commaList() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<span>\n\t\t\t\t<span ng-repeat=\"item in commaList.list track by $index\">\n\t\t\t\t\t<span>{{item}}</span><span ng-hide=\"$last\">, </span>\n\t\t\t\t</span>\n\t\t\t\t<span ng-show=\"commaList.remainingItems > 0\">... {{commaList.remainingItems}} more items</span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'commaList',
	        scope: {},
	        bindToController: {
	            inList: '<list',
	            max: '<?',
	            transform: '<?',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, commaList)
	    .controller(exports.controllerName, CommaListController);
	//# sourceMappingURL=commaList.js.map

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// /// <reference path='../../../typings/bootstrapDateTimePicker.d.ts' />
	__webpack_require__(108);
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(12);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __dateTimeFormatStrings = typescript_angular_utilities_1.services.date;
	var __object = typescript_angular_utilities_1.services.object;
	var __guid = typescript_angular_utilities_1.services.guid;
	var required_1 = __webpack_require__(25);
	var componentValidator_service_1 = __webpack_require__(112);
	exports.moduleName = 'rl.ui.components.dateTime';
	exports.directiveName = 'rlDateTime';
	exports.controllerName = 'DateTimeController';
	var DateTimeController = (function () {
	    function DateTimeController($scope, $attrs, componentValidatorFactory) {
	        var _this = this;
	        if (__object.objectUtility.isNullOrEmpty($attrs.name)) {
	            $attrs.$set('name', 'date-time-' + __guid.guid.random());
	        }
	        var unregister = $scope.$watch(function () { return _this.ngModel; }, function (value) {
	            var validators = [];
	            if (!_.isUndefined(_this.validator)) {
	                validators.push(_this.validator);
	            }
	            if (_this.required != null) {
	                validators.push({
	                    name: 'rlRequired',
	                    validate: function () { return !__object.objectUtility.isNullOrEmpty(_this.ngModel.$viewValue); },
	                    errorMessage: _this.required.message,
	                });
	            }
	            if (_.some(validators)) {
	                _this.dateTimeValidator = componentValidatorFactory.getInstance({
	                    ngModel: _this.ngModel,
	                    $scope: $scope,
	                    validators: validators,
	                });
	            }
	            unregister();
	        });
	    }
	    DateTimeController.prototype.onClearClick = function () {
	        this.ngModel.$setViewValue('');
	        this.onClearEvent();
	    };
	    DateTimeController.$inject = ['$scope', '$attrs', componentValidator_service_1.factoryName];
	    return DateTimeController;
	}());
	exports.DateTimeController = DateTimeController;
	dateTime.$inject = [typescript_angular_utilities_1.services.moment.serviceName, __dateTimeFormatStrings.dateTimeFormatServiceName, __object.serviceName];
	function dateTime(moment, dateTimeFormatStrings, object) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(113),
	        require: ['ngModel', '?' + required_1.directiveName],
	        controller: exports.controllerName,
	        controllerAs: 'dateTime',
	        scope: {},
	        bindToController: {
	            minuteStepping: '=',
	            useDate: '=',
	            useTime: '=',
	            min: '=',
	            max: '=',
	            validator: '=',
	            clearButton: '=',
	            onClearEvent: '&'
	        },
	        link: function (scope, element, attrs, controllers) {
	            var dateTime = scope.dateTime;
	            var ngModel = controllers[0];
	            dateTime.required = controllers[1];
	            dateTime.ngModel = ngModel;
	            // defaults to true
	            var hasDate = _.isUndefined(dateTime.useDate) ? true : dateTime.useDate;
	            var hasTime = _.isUndefined(dateTime.useTime) ? true : dateTime.useTime;
	            var defaults = element.datetimepicker.defaults;
	            var min = dateTime.min != null ? dateTime.min : defaults.minDate;
	            var max = dateTime.max != null ? dateTime.max : defaults.maxDate;
	            scope.$watch(function () { return ngModel.$viewValue; }, function (newValue) {
	                dateTime.validFormat = object.isNullOrEmpty(newValue)
	                    ? true
	                    : moment(newValue).isValid();
	            });
	            element.find('.show-date-picker').datetimepicker({
	                stepping: dateTime.minuteStepping || 1,
	                format: dateTime.format || defaultFormat(hasDate, hasTime),
	                direction: 'bottom',
	                elementHeight: 2,
	                pickDate: hasDate,
	                pickTime: hasTime,
	                minDate: min,
	                maxDate: max,
	            }).on('change.dp', function () {
	                var newValue = $(this).find('input').val();
	                ngModel.$setViewValue(newValue);
	                scope.$apply();
	            });
	            function defaultFormat(hasDate, hasTime) {
	                if (hasDate && hasTime) {
	                    return dateTimeFormatStrings.dateTimeFormat;
	                }
	                else if (hasDate) {
	                    return dateTimeFormatStrings.dateFormat;
	                }
	                else if (hasTime) {
	                    return dateTimeFormatStrings.timeFormat;
	                }
	                else {
	                    // revert to default format
	                    return false;
	                }
	            }
	        },
	    };
	}
	angular.module(exports.moduleName, [typescript_angular_utilities_1.services.moment.moduleName, typescript_angular_utilities_1.services.date.moduleName, componentValidator_service_1.moduleName, __object.moduleName])
	    .directive(exports.directiveName, dateTime)
	    .controller(exports.controllerName, DateTimeController);
	//# sourceMappingURL=dateTime.js.map

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(109);
	__webpack_require__(111);

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(110);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./bootstrap-datetimepicker.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./bootstrap-datetimepicker.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, "/*!\r\n * Datetimepicker for Bootstrap v3\r\n//! version : 3.1.3\r\n * https://github.com/Eonasdan/bootstrap-datetimepicker/\r\n */\r\n.bootstrap-datetimepicker-widget {\r\n  top: 0;\r\n  left: 0;\r\n  width: 250px;\r\n  padding: 4px;\r\n  margin-top: 1px;\r\n  z-index: 99999 !important;\r\n  border-radius: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget.timepicker-sbs {\r\n  width: 600px;\r\n}\r\n.bootstrap-datetimepicker-widget.bottom:before {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 7px solid transparent;\r\n  border-right: 7px solid transparent;\r\n  border-bottom: 7px solid #ccc;\r\n  border-bottom-color: rgba(0, 0, 0, 0.2);\r\n  position: absolute;\r\n  top: -7px;\r\n  left: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget.bottom:after {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 6px solid transparent;\r\n  border-right: 6px solid transparent;\r\n  border-bottom: 6px solid white;\r\n  position: absolute;\r\n  top: -6px;\r\n  left: 8px;\r\n}\r\n.bootstrap-datetimepicker-widget.top:before {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 7px solid transparent;\r\n  border-right: 7px solid transparent;\r\n  border-top: 7px solid #ccc;\r\n  border-top-color: rgba(0, 0, 0, 0.2);\r\n  position: absolute;\r\n  bottom: -7px;\r\n  left: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget.top:after {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 6px solid transparent;\r\n  border-right: 6px solid transparent;\r\n  border-top: 6px solid white;\r\n  position: absolute;\r\n  bottom: -6px;\r\n  left: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget .dow {\r\n  width: 14.2857%;\r\n}\r\n.bootstrap-datetimepicker-widget.pull-right:before {\r\n  left: auto;\r\n  right: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget.pull-right:after {\r\n  left: auto;\r\n  right: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget > ul {\r\n  list-style-type: none;\r\n  margin: 0;\r\n}\r\n.bootstrap-datetimepicker-widget a[data-action] {\r\n  padding: 0;\r\n}\r\n.bootstrap-datetimepicker-widget a[data-action]:active {\r\n  box-shadow: none;\r\n}\r\n.bootstrap-datetimepicker-widget .timepicker {\r\n  margin: 0 4px 4px 4px;\r\n}\r\n.bootstrap-datetimepicker-widget .timepicker-hour,\r\n.bootstrap-datetimepicker-widget .timepicker-minute,\r\n.bootstrap-datetimepicker-widget .timepicker-second {\r\n  width: 54px;\r\n  font-weight: bold;\r\n  font-size: 1.2em;\r\n  margin-top: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget button[data-action] {\r\n  padding: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget table[data-hour-format=\"12\"] .separator {\r\n  width: 4px;\r\n  padding: 0;\r\n  margin: 0;\r\n}\r\n.bootstrap-datetimepicker-widget .datepicker > div {\r\n  display: none;\r\n}\r\n.bootstrap-datetimepicker-widget .picker-switch {\r\n  text-align: center;\r\n}\r\n.bootstrap-datetimepicker-widget table {\r\n  width: 100%;\r\n  margin: 0;\r\n}\r\n.bootstrap-datetimepicker-widget td,\r\n.bootstrap-datetimepicker-widget th {\r\n  text-align: center;\r\n  border-radius: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget td {\r\n  height: 25px;\r\n  line-height: 25px;\r\n  width: 54px;\r\n}\r\n.bootstrap-datetimepicker-widget td.cw {\r\n  font-size: 10px;\r\n  height: 20px;\r\n  line-height: 20px;\r\n  color: #777777;\r\n}\r\n.bootstrap-datetimepicker-widget td.day {\r\n  height: 20px;\r\n  line-height: 20px;\r\n  width: 20px;\r\n}\r\n.bootstrap-datetimepicker-widget td.day:hover,\r\n.bootstrap-datetimepicker-widget td.hour:hover,\r\n.bootstrap-datetimepicker-widget td.minute:hover,\r\n.bootstrap-datetimepicker-widget td.second:hover {\r\n  background: #eeeeee;\r\n  cursor: pointer;\r\n}\r\n.bootstrap-datetimepicker-widget td.old,\r\n.bootstrap-datetimepicker-widget td.new {\r\n  color: #777777;\r\n}\r\n.bootstrap-datetimepicker-widget td.today {\r\n  position: relative;\r\n}\r\n.bootstrap-datetimepicker-widget td.today:before {\r\n  content: '';\r\n  display: inline-block;\r\n  border-left: 7px solid transparent;\r\n  border-bottom: 7px solid #428bca;\r\n  border-top-color: rgba(0, 0, 0, 0.2);\r\n  position: absolute;\r\n  bottom: 4px;\r\n  right: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget td.active,\r\n.bootstrap-datetimepicker-widget td.active:hover {\r\n  background-color: #428bca;\r\n  color: #ffffff;\r\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\r\n}\r\n.bootstrap-datetimepicker-widget td.active.today:before {\r\n  border-bottom-color: #fff;\r\n}\r\n.bootstrap-datetimepicker-widget td.disabled,\r\n.bootstrap-datetimepicker-widget td.disabled:hover {\r\n  background: none;\r\n  color: #777777;\r\n  cursor: not-allowed;\r\n}\r\n.bootstrap-datetimepicker-widget td span {\r\n  display: inline-block;\r\n  width: 54px;\r\n  height: 25px;\r\n  line-height: 25px;\r\n  margin: 0px 1.5px;\r\n  cursor: pointer;\r\n  border-radius: 4px;\r\n}\r\n.bootstrap-datetimepicker-widget td span:hover {\r\n  background: #eeeeee;\r\n}\r\n.bootstrap-datetimepicker-widget td span.active {\r\n  background-color: #428bca;\r\n  color: #ffffff;\r\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\r\n}\r\n.bootstrap-datetimepicker-widget td span.old {\r\n  color: #777777;\r\n}\r\n.bootstrap-datetimepicker-widget td span.disabled,\r\n.bootstrap-datetimepicker-widget td span.disabled:hover {\r\n  background: none;\r\n  color: #777777;\r\n  cursor: not-allowed;\r\n}\r\n.bootstrap-datetimepicker-widget th {\r\n  height: 20px;\r\n  line-height: 20px;\r\n  width: 20px;\r\n}\r\n.bootstrap-datetimepicker-widget th.picker-switch {\r\n  width: 145px;\r\n}\r\n.bootstrap-datetimepicker-widget th.next,\r\n.bootstrap-datetimepicker-widget th.prev {\r\n  font-size: 21px;\r\n}\r\n.bootstrap-datetimepicker-widget th.disabled,\r\n.bootstrap-datetimepicker-widget th.disabled:hover {\r\n  background: none;\r\n  color: #777777;\r\n  cursor: not-allowed;\r\n}\r\n.bootstrap-datetimepicker-widget thead tr:first-child th {\r\n  cursor: pointer;\r\n}\r\n.bootstrap-datetimepicker-widget thead tr:first-child th:hover {\r\n  background: #eeeeee;\r\n}\r\n.input-group.date .input-group-addon span {\r\n  display: block;\r\n  cursor: pointer;\r\n  width: 16px;\r\n  height: 16px;\r\n}\r\n.bootstrap-datetimepicker-widget.left-oriented:before {\r\n  left: auto;\r\n  right: 6px;\r\n}\r\n.bootstrap-datetimepicker-widget.left-oriented:after {\r\n  left: auto;\r\n  right: 7px;\r\n}\r\n.bootstrap-datetimepicker-widget ul.list-unstyled li div.timepicker div.timepicker-picker table.table-condensed tbody > tr > td {\r\n  padding: 0px !important;\r\n}\r\n@media screen and (max-width: 767px) {\r\n  .bootstrap-datetimepicker-widget.timepicker-sbs {\r\n    width: 283px;\r\n  }\r\n}\r\n", ""]);
	
	// exports


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	//! version : 3.1.3
	=========================================================
	bootstrap-datetimepicker.js
	https://github.com/Eonasdan/bootstrap-datetimepicker
	=========================================================
	The MIT License (MIT)
	
	Copyright (c) 2014 Jonathan Peterson
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/
	; (function (root, factory) {
		'use strict';
		if (true) {
			// AMD is used - Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12), __webpack_require__(71)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			factory(require('jquery'), require('moment'));
		}
		else {
			// Neither AMD or CommonJS used. Use global variables.
			if (!jQuery) {
				throw new Error('bootstrap-datetimepicker requires jQuery to be loaded first');
			}
			if (!moment) {
				throw new Error('bootstrap-datetimepicker requires moment.js to be loaded first');
			}
			factory(root.jQuery, moment);
		}
	}(this, function ($, moment) {
		'use strict';
		if (typeof moment === 'undefined') {
			throw new Error('momentjs is required');
		}
	
		var dpgId = 0,
	
	    DateTimePicker = function (element, options) {
	    	var defaults = $.fn.datetimepicker.defaults,
	
	            icons = {
	            	time: 'fa fa-clock-o',
	            	date: 'fa fa-calendar',
	            	up: 'fa fa-chevron-up',
	            	down: 'fa fa-chevron-down'
	            },
	
	            picker = this,
	            errored = false,
	            dDate,
	
	        init = function () {
	        	var icon = false, localeData, rInterval;
	        	picker.options = $.extend({}, defaults, options);
	        	picker.options.icons = $.extend({}, icons, picker.options.icons);
	
	        	picker.element = $(element);
	
	        	dataToOptions();
	
	        	if (!(picker.options.pickTime || picker.options.pickDate)) {
	        		throw new Error('Must choose at least one picker');
	        	}
	
	        	picker.id = dpgId++;
	        	moment.locale(picker.options.language);
	        	picker.date = moment();
	        	picker.unset = false;
	        	picker.isInput = picker.element.is('input');
	        	picker.component = false;
	
	        	if (picker.element.hasClass('input-group')) {
	        		if (picker.element.find('.datepickerbutton').size() === 0) {//in case there is more then one 'input-group-addon' Issue #48
	        			picker.component = picker.element.find('[class^="input-group-"]');
	        		}
	        		else {
	        			picker.component = picker.element.find('.datepickerbutton');
	        		}
	        	}
	        	picker.format = picker.options.format;
	
	        	localeData = moment().localeData();
	
	        	if (!picker.format) {
	        		picker.format = (picker.options.pickDate ? localeData.longDateFormat('L') : '');
	        		if (picker.options.pickDate && picker.options.pickTime) {
	        			picker.format += ' ';
	        		}
	        		picker.format += (picker.options.pickTime ? localeData.longDateFormat('LT') : '');
	        		if (picker.options.useSeconds) {
	        			if (localeData.longDateFormat('LT').indexOf(' A') !== -1) {
	        				picker.format = picker.format.split(' A')[0] + ':ss A';
	        			}
	        			else {
	        				picker.format += ':ss';
	        			}
	        		}
	        	}
	        	picker.use24hours = (picker.format.toLowerCase().indexOf('a') < 0 && picker.format.indexOf('h') < 0);
	
	        	if (picker.component) {
	        		icon = picker.component.find('span');
	        	}
	
	        	if (picker.options.pickTime) {
	        		if (icon) {
	        			icon.addClass(picker.options.icons.time);
	        		}
	        	}
	        	if (picker.options.pickDate) {
	        		if (icon) {
	        			icon.removeClass(picker.options.icons.time);
	        			icon.addClass(picker.options.icons.date);
	        		}
	        	}
	
	        	picker.options.widgetParent =
	                typeof picker.options.widgetParent === 'string' && picker.options.widgetParent ||
	                picker.element.parents().filter(function () {
	                	return 'scroll' === $(this).css('overflow-y');
	                }).get(0) ||
	                'body';
	
	        	picker.widget = $(getTemplate()).appendTo(picker.options.widgetParent);
	
	        	picker.minViewMode = picker.options.minViewMode || 0;
	        	if (typeof picker.minViewMode === 'string') {
	        		switch (picker.minViewMode) {
	        			case 'months':
	        				picker.minViewMode = 1;
	        				break;
	        			case 'years':
	        				picker.minViewMode = 2;
	        				break;
	        			default:
	        				picker.minViewMode = 0;
	        				break;
	        		}
	        	}
	        	picker.viewMode = picker.options.viewMode || 0;
	        	if (typeof picker.viewMode === 'string') {
	        		switch (picker.viewMode) {
	        			case 'months':
	        				picker.viewMode = 1;
	        				break;
	        			case 'years':
	        				picker.viewMode = 2;
	        				break;
	        			default:
	        				picker.viewMode = 0;
	        				break;
	        		}
	        	}
	
	        	picker.viewMode = Math.max(picker.viewMode, picker.minViewMode);
	
	        	picker.options.disabledDates = indexGivenDates(picker.options.disabledDates);
	        	picker.options.enabledDates = indexGivenDates(picker.options.enabledDates);
	
	        	picker.startViewMode = picker.viewMode;
	        	picker.setMinDate(picker.options.minDate);
	        	picker.setMaxDate(picker.options.maxDate);
	        	fillDow();
	        	fillMonths();
	        	fillHours();
	        	fillMinutes();
	        	fillSeconds();
	        	update();
	        	showMode();
	        	if (!getPickerInput().prop('disabled')) {
	        		attachDatePickerEvents();
	        	}
	        	if (picker.options.defaultDate !== '' && getPickerInput().val() === '') {
	        		picker.setValue(picker.options.defaultDate);
	        	}
	        	if (picker.options.minuteStepping !== 1) {
	        		rInterval = picker.options.minuteStepping;
	        		picker.date.minutes((Math.round(picker.date.minutes() / rInterval) * rInterval) % 60).seconds(0);
	        	}
	        },
	
	        getPickerInput = function () {
	        	var input;
	
	        	if (picker.isInput) {
	        		return picker.element;
	        	}
	        	input = picker.element.find('.datepickerinput');
	        	if (input.size() === 0) {
	        		input = picker.element.find('input');
	        	}
	        	else if (!input.is('input')) {
	        		throw new Error('CSS class "datepickerinput" cannot be applied to non input element');
	        	}
	        	return input;
	        },
	
	        dataToOptions = function () {
	        	var eData;
	        	if (picker.element.is('input')) {
	        		eData = picker.element.data();
	        	}
	        	else {
	        		eData = picker.element.find('input').data();
	        	}
	        	if (eData.dateFormat !== undefined) {
	        		picker.options.format = eData.dateFormat;
	        	}
	        	if (eData.datePickdate !== undefined) {
	        		picker.options.pickDate = eData.datePickdate;
	        	}
	        	if (eData.datePicktime !== undefined) {
	        		picker.options.pickTime = eData.datePicktime;
	        	}
	        	if (eData.dateUseminutes !== undefined) {
	        		picker.options.useMinutes = eData.dateUseminutes;
	        	}
	        	if (eData.dateUseseconds !== undefined) {
	        		picker.options.useSeconds = eData.dateUseseconds;
	        	}
	        	if (eData.dateUsecurrent !== undefined) {
	        		picker.options.useCurrent = eData.dateUsecurrent;
	        	}
	        	if (eData.calendarWeeks !== undefined) {
	        		picker.options.calendarWeeks = eData.calendarWeeks;
	        	}
	        	if (eData.dateMinutestepping !== undefined) {
	        		picker.options.minuteStepping = eData.dateMinutestepping;
	        	}
	        	if (eData.dateMindate !== undefined) {
	        		picker.options.minDate = eData.dateMindate;
	        	}
	        	if (eData.dateMaxdate !== undefined) {
	        		picker.options.maxDate = eData.dateMaxdate;
	        	}
	        	if (eData.dateShowtoday !== undefined) {
	        		picker.options.showToday = eData.dateShowtoday;
	        	}
	        	if (eData.dateCollapse !== undefined) {
	        		picker.options.collapse = eData.dateCollapse;
	        	}
	        	if (eData.dateLanguage !== undefined) {
	        		picker.options.language = eData.dateLanguage;
	        	}
	        	if (eData.dateDefaultdate !== undefined) {
	        		picker.options.defaultDate = eData.dateDefaultdate;
	        	}
	        	if (eData.dateDisableddates !== undefined) {
	        		picker.options.disabledDates = eData.dateDisableddates;
	        	}
	        	if (eData.dateEnableddates !== undefined) {
	        		picker.options.enabledDates = eData.dateEnableddates;
	        	}
	        	if (eData.dateIcons !== undefined) {
	        		picker.options.icons = eData.dateIcons;
	        	}
	        	if (eData.dateUsestrict !== undefined) {
	        		picker.options.useStrict = eData.dateUsestrict;
	        	}
	        	if (eData.dateDirection !== undefined) {
	        		picker.options.direction = eData.dateDirection;
	        	}
	        	if (eData.dateSidebyside !== undefined) {
	        		picker.options.sideBySide = eData.dateSidebyside;
	        	}
	        	if (eData.dateDaysofweekdisabled !== undefined) {
	        		picker.options.daysOfWeekDisabled = eData.dateDaysofweekdisabled;
	        	}
	        },
	
	        place = function () {
	        	var position = 'absolute',
	                offset = picker.component ? picker.component.offset() : picker.element.offset(),
	                $window = $(window),
	                placePosition;
	
	        	picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
	        	offset.top = offset.top + picker.element.outerHeight();
	
	        	if (picker.options.direction === 'up') {
	        		placePosition = 'top';
	        	} else if (picker.options.direction === 'bottom') {
	        		placePosition = 'bottom';
	        	} else if (picker.options.direction === 'auto') {
	        		if (offset.top + picker.widget.height() > $window.height() + $window.scrollTop() && picker.widget.height() + picker.element.outerHeight() < offset.top) {
	        			placePosition = 'top';
	        		} else {
	        			placePosition = 'bottom';
	        		}
	        	}
	        	if (placePosition === 'top') {
	        		offset.bottom = $window.height() - offset.top + picker.element.outerHeight() + 3;
	        		picker.widget.addClass('top').removeClass('bottom');
	        	} else {
	        		offset.top += 1;
	        		offset.top += picker.options.elementHeight;
	        		picker.widget.addClass('bottom').removeClass('top');
	        	}
	
	        	if (picker.options.width !== undefined) {
	        		picker.widget.width(picker.options.width);
	        	}
	
	        	if (picker.options.orientation === 'left') {
	        		picker.widget.addClass('left-oriented');
	        		offset.left = offset.left - picker.widget.width() + 20;
	        	}
	
	        	if (isInFixed()) {
	        		position = 'fixed';
	        		offset.top -= $window.scrollTop();
	        		offset.left -= $window.scrollLeft();
	        	}
	
	        	if ($window.width() < offset.left + picker.widget.outerWidth()) {
	        		offset.right = $window.width() - offset.left - picker.width;
	        		offset.left = 'auto';
	        		picker.widget.addClass('pull-right');
	        	} else {
	        		offset.right = 'auto';
	        		picker.widget.removeClass('pull-right');
	        	}
	
	        	if (placePosition === 'top') {
	        		picker.widget.css({
	        			position: position,
	        			bottom: offset.bottom,
	        			top: 'auto',
	        			left: offset.left,
	        			right: offset.right
	        		});
	        	} else {
	        		picker.widget.css({
	        			position: position,
	        			top: offset.top,
	        			bottom: 'auto',
	        			left: offset.left,
	        			right: offset.right
	        		});
	        	}
	        },
	
	        notifyChange = function (oldDate, eventType) {
	        	if (moment(picker.date).isSame(moment(oldDate)) && !errored) {
	        		return;
	        	}
	        	errored = false;
	        	picker.element.trigger({
	        		type: 'dp.change',
	        		date: moment(picker.date),
	        		oldDate: moment(oldDate)
	        	});
	
	        	if (eventType !== 'change') {
	        		picker.element.change();
	        	}
	        },
	
	        notifyError = function (date) {
	        	errored = true;
	        	picker.element.trigger({
	        		type: 'dp.error',
	        		date: moment(date, picker.format, picker.options.useStrict)
	        	});
	        },
	
	        update = function (newDate) {
	        	moment.locale(picker.options.language);
	        	var dateStr = newDate;
	        	if (!dateStr) {
	        		dateStr = getPickerInput().val();
	        		if (dateStr) {
	        			picker.date = moment(dateStr, picker.format, picker.options.useStrict);
	        		}
	        		if (!picker.date) {
	        			picker.date = moment();
	        		}
	        	}
	        	picker.viewDate = moment(picker.date).startOf('month');
	        	fillDate();
	        	fillTime();
	        },
	
	        fillDow = function () {
	        	moment.locale(picker.options.language);
	        	var html = $('<tr>'), weekdaysMin = moment.weekdaysMin(), i;
	        	if (picker.options.calendarWeeks === true) {
	        		html.append('<th class="cw">#</th>');
	        	}
	        	if (moment().localeData()._week.dow === 0) { // starts on Sunday
	        		for (i = 0; i < 7; i++) {
	        			html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
	        		}
	        	} else {
	        		for (i = 1; i < 8; i++) {
	        			if (i === 7) {
	        				html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
	        			} else {
	        				html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
	        			}
	        		}
	        	}
	        	picker.widget.find('.datepicker-days thead').append(html);
	        },
	
	        fillMonths = function () {
	        	moment.locale(picker.options.language);
	        	var html = '', i, monthsShort = moment.monthsShort();
	        	for (i = 0; i < 12; i++) {
	        		html += '<span class="month">' + monthsShort[i] + '</span>';
	        	}
	        	picker.widget.find('.datepicker-months td').append(html);
	        },
	
	        fillDate = function () {
	        	if (!picker.options.pickDate) {
	        		return;
	        	}
	        	moment.locale(picker.options.language);
	        	var year = picker.viewDate.year(),
	                month = picker.viewDate.month(),
	                startYear = picker.options.minDate.year(),
	                startMonth = picker.options.minDate.month(),
	                endYear = picker.options.maxDate.year(),
	                endMonth = picker.options.maxDate.month(),
	                currentDate,
	                prevMonth, nextMonth, html = [], row, clsName, i, days, yearCont, currentYear, months = moment.months();
	
	        	picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
	        	picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
	        	picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');
	
	        	picker.widget.find('.datepicker-days th:eq(1)').text(
	                months[month] + ' ' + year);
	
	        	prevMonth = moment(picker.viewDate, picker.format, picker.options.useStrict).subtract(1, 'months');
	        	days = prevMonth.daysInMonth();
	        	prevMonth.date(days).startOf('week');
	        	if ((year === startYear && month <= startMonth) || year < startYear) {
	        		picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
	        	}
	        	if ((year === endYear && month >= endMonth) || year > endYear) {
	        		picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
	        	}
	
	        	nextMonth = moment(prevMonth).add(42, 'd');
	        	while (prevMonth.isBefore(nextMonth)) {
	        		if (prevMonth.weekday() === moment().startOf('week').weekday()) {
	        			row = $('<tr>');
	        			html.push(row);
	        			if (picker.options.calendarWeeks === true) {
	        				row.append('<td class="cw">' + prevMonth.week() + '</td>');
	        			}
	        		}
	        		clsName = '';
	        		if (prevMonth.year() < year || (prevMonth.year() === year && prevMonth.month() < month)) {
	        			clsName += ' old';
	        		} else if (prevMonth.year() > year || (prevMonth.year() === year && prevMonth.month() > month)) {
	        			clsName += ' new';
	        		}
	        		if (prevMonth.isSame(moment({ y: picker.date.year(), M: picker.date.month(), d: picker.date.date() }))) {
	        			clsName += ' active';
	        		}
	        		if (isInDisableDates(prevMonth, 'day') || !isInEnableDates(prevMonth)) {
	        			clsName += ' disabled';
	        		}
	        		if (picker.options.showToday === true) {
	        			if (prevMonth.isSame(moment(), 'day')) {
	        				clsName += ' today';
	        			}
	        		}
	        		if (picker.options.daysOfWeekDisabled) {
	        			for (i = 0; i < picker.options.daysOfWeekDisabled.length; i++) {
	        				if (prevMonth.day() === picker.options.daysOfWeekDisabled[i]) {
	        					clsName += ' disabled';
	        					break;
	        				}
	        			}
	        		}
	        		row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');
	
	        		currentDate = prevMonth.date();
	        		prevMonth.add(1, 'd');
	
	        		if (currentDate === prevMonth.date()) {
	        			prevMonth.add(1, 'd');
	        		}
	        	}
	        	picker.widget.find('.datepicker-days tbody').empty().append(html);
	        	currentYear = picker.date.year();
	        	months = picker.widget.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');
	        	if (currentYear === year) {
	        		months.eq(picker.date.month()).addClass('active');
	        	}
	        	if (year - 1 < startYear) {
	        		picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
	        	}
	        	if (year + 1 > endYear) {
	        		picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
	        	}
	        	for (i = 0; i < 12; i++) {
	        		if ((year === startYear && startMonth > i) || (year < startYear)) {
	        			$(months[i]).addClass('disabled');
	        		} else if ((year === endYear && endMonth < i) || (year > endYear)) {
	        			$(months[i]).addClass('disabled');
	        		}
	        	}
	
	        	html = '';
	        	year = parseInt(year / 10, 10) * 10;
	        	yearCont = picker.widget.find('.datepicker-years').find(
	                'th:eq(1)').text(year + '-' + (year + 9)).parents('table').find('td');
	        	picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
	        	if (startYear > year) {
	        		picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
	        	}
	        	if (endYear < year + 9) {
	        		picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
	        	}
	        	year -= 1;
	        	for (i = -1; i < 11; i++) {
	        		html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
	        		year += 1;
	        	}
	        	yearCont.html(html);
	        },
	
	        fillHours = function () {
	        	moment.locale(picker.options.language);
	        	var table = picker.widget.find('.timepicker .timepicker-hours table'), html = '', current, i, j;
	        	table.parent().hide();
	        	if (picker.use24hours) {
	        		current = 0;
	        		for (i = 0; i < 6; i += 1) {
	        			html += '<tr>';
	        			for (j = 0; j < 4; j += 1) {
	        				html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
	        				current++;
	        			}
	        			html += '</tr>';
	        		}
	        	}
	        	else {
	        		current = 1;
	        		for (i = 0; i < 3; i += 1) {
	        			html += '<tr>';
	        			for (j = 0; j < 4; j += 1) {
	        				html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
	        				current++;
	        			}
	        			html += '</tr>';
	        		}
	        	}
	        	table.html(html);
	        },
	
	        fillMinutes = function () {
	        	var table = picker.widget.find('.timepicker .timepicker-minutes table'), html = '', current = 0, i, j, step = picker.options.minuteStepping;
	        	table.parent().hide();
	        	if (step === 1) {
	        		step = 5;
	        	}
	        	for (i = 0; i < Math.ceil(60 / step / 4) ; i++) {
	        		html += '<tr>';
	        		for (j = 0; j < 4; j += 1) {
	        			if (current < 60) {
	        				html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
	        				current += step;
	        			} else {
	        				html += '<td></td>';
	        			}
	        		}
	        		html += '</tr>';
	        	}
	        	table.html(html);
	        },
	
	        fillSeconds = function () {
	        	var table = picker.widget.find('.timepicker .timepicker-seconds table'), html = '', current = 0, i, j;
	        	table.parent().hide();
	        	for (i = 0; i < 3; i++) {
	        		html += '<tr>';
	        		for (j = 0; j < 4; j += 1) {
	        			html += '<td class="second">' + padLeft(current.toString()) + '</td>';
	        			current += 5;
	        		}
	        		html += '</tr>';
	        	}
	        	table.html(html);
	        },
	
	        fillTime = function () {
	        	if (!picker.date) {
	        		return;
	        	}
	        	var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
	                hour = picker.date.hours(),
	                period = picker.date.format('A');
	        	if (!picker.use24hours) {
	        		if (hour === 0) {
	        			hour = 12;
	        		} else if (hour !== 12) {
	        			hour = hour % 12;
	        		}
	        		picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
	        	}
	        	timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
	        	timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
	        	timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
	        },
	
	        click = function (e) {
	        	e.stopPropagation();
	        	e.preventDefault();
	        	picker.unset = false;
	        	var target = $(e.target).closest('span, td, th'), month, year, step, day, oldDate = moment(picker.date);
	        	if (target.length === 1) {
	        		if (!target.is('.disabled')) {
	        			switch (target[0].nodeName.toLowerCase()) {
	        				case 'th':
	        					switch (target[0].className) {
	        						case 'picker-switch':
	        							showMode(1);
	        							break;
	        						case 'prev':
	        						case 'next':
	        							step = dpGlobal.modes[picker.viewMode].navStep;
	        							if (target[0].className === 'prev') {
	        								step = step * -1;
	        							}
	        							picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
	        							fillDate();
	        							break;
	        					}
	        					break;
	        				case 'span':
	        					if (target.is('.month')) {
	        						month = target.parent().find('span').index(target);
	        						picker.viewDate.month(month);
	        					} else {
	        						year = parseInt(target.text(), 10) || 0;
	        						picker.viewDate.year(year);
	        					}
	        					if (picker.viewMode === picker.minViewMode) {
	        						picker.date = moment({
	        							y: picker.viewDate.year(),
	        							M: picker.viewDate.month(),
	        							d: picker.viewDate.date(),
	        							h: picker.date.hours(),
	        							m: picker.date.minutes(),
	        							s: picker.date.seconds()
	        						});
	        						set();
	        						notifyChange(oldDate, e.type);
	        					}
	        					showMode(-1);
	        					fillDate();
	        					break;
	        				case 'td':
	        					if (target.is('.day')) {
	        						day = parseInt(target.text(), 10) || 1;
	        						month = picker.viewDate.month();
	        						year = picker.viewDate.year();
	        						if (target.is('.old')) {
	        							if (month === 0) {
	        								month = 11;
	        								year -= 1;
	        							} else {
	        								month -= 1;
	        							}
	        						} else if (target.is('.new')) {
	        							if (month === 11) {
	        								month = 0;
	        								year += 1;
	        							} else {
	        								month += 1;
	        							}
	        						}
	        						picker.date = moment({
	        							y: year,
	        							M: month,
	        							d: day,
	        							h: picker.date.hours(),
	        							m: picker.date.minutes(),
	        							s: picker.date.seconds()
	        						}
	                                );
	        						picker.viewDate = moment({
	        							y: year, M: month, d: Math.min(28, day)
	        						});
	        						fillDate();
	        						set();
	        						notifyChange(oldDate, e.type);
	        					}
	        					break;
	        			}
	        		}
	        	}
	        },
	
	        actions = {
	        	incrementHours: function () {
	        		checkDate('add', 'hours', 1);
	        	},
	
	        	incrementMinutes: function () {
	        		checkDate('add', 'minutes', picker.options.minuteStepping);
	        	},
	
	        	incrementSeconds: function () {
	        		checkDate('add', 'seconds', 1);
	        	},
	
	        	decrementHours: function () {
	        		checkDate('subtract', 'hours', 1);
	        	},
	
	        	decrementMinutes: function () {
	        		checkDate('subtract', 'minutes', picker.options.minuteStepping);
	        	},
	
	        	decrementSeconds: function () {
	        		checkDate('subtract', 'seconds', 1);
	        	},
	
	        	togglePeriod: function () {
	        		var hour = picker.date.hours();
	        		if (hour >= 12) {
	        			hour -= 12;
	        		} else {
	        			hour += 12;
	        		}
	        		picker.date.hours(hour);
	        	},
	
	        	showPicker: function () {
	        		picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
	        		picker.widget.find('.timepicker .timepicker-picker').show();
	        	},
	
	        	showHours: function () {
	        		picker.widget.find('.timepicker .timepicker-picker').hide();
	        		picker.widget.find('.timepicker .timepicker-hours').show();
	        	},
	
	        	showMinutes: function () {
	        		picker.widget.find('.timepicker .timepicker-picker').hide();
	        		picker.widget.find('.timepicker .timepicker-minutes').show();
	        	},
	
	        	showSeconds: function () {
	        		picker.widget.find('.timepicker .timepicker-picker').hide();
	        		picker.widget.find('.timepicker .timepicker-seconds').show();
	        	},
	
	        	selectHour: function (e) {
	        		var hour = parseInt($(e.target).text(), 10);
	        		if (!picker.use24hours) {
	        			if (picker.date.hours() >= 12) {
	        				if (hour !== 12) {
	        					hour += 12;
	        				}
	        			} else {
	        				if (hour === 12) {
	        					hour = 0;
	        				}
	        			}
	        		}
	        		picker.date.hours(hour);
	        		actions.showPicker.call(picker);
	        	},
	
	        	selectMinute: function (e) {
	        		picker.date.minutes(parseInt($(e.target).text(), 10));
	        		actions.showPicker.call(picker);
	        	},
	
	        	selectSecond: function (e) {
	        		picker.date.seconds(parseInt($(e.target).text(), 10));
	        		actions.showPicker.call(picker);
	        	}
	        },
	
	        doAction = function (e) {
	        	var oldDate = moment(picker.date),
	                action = $(e.currentTarget).data('action'),
	                rv = actions[action].apply(picker, arguments);
	        	stopEvent(e);
	        	if (!picker.date) {
	        		picker.date = moment({ y: 1970 });
	        	}
	        	set();
	        	fillTime();
	        	notifyChange(oldDate, e.type);
	        	return rv;
	        },
	
	        stopEvent = function (e) {
	        	e.stopPropagation();
	        	e.preventDefault();
	        },
	
	        keydown = function (e) {
	        	if (e.keyCode === 27) { // allow escape to hide picker
	        		picker.hide();
	        	}
	        },
	
	        change = function (e) {
	        	moment.locale(picker.options.language);
	        	var input = $(e.target), oldDate = moment(picker.date), newDate = moment(input.val(), picker.format, picker.options.useStrict);
	        	if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
	        		update();
	        		picker.setValue(newDate);
	        		notifyChange(oldDate, e.type);
	        		set();
	        	}
	        	else {
	        		picker.viewDate = oldDate;
	        		picker.unset = true;
	        		notifyChange(oldDate, e.type);
	        		notifyError(newDate);
	        	}
	        },
	
	        showMode = function (dir) {
	        	if (dir) {
	        		picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
	        	}
	        	picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
	        },
	
	        attachDatePickerEvents = function () {
	        	var $this, $parent, expanded, closed, collapseData;
	        	picker.widget.on('click', '.datepicker *', $.proxy(click, this)); // this handles date picker clicks
	        	picker.widget.on('click', '[data-action]', $.proxy(doAction, this)); // this handles time picker clicks
	        	picker.widget.on('mousedown', $.proxy(stopEvent, this));
	        	picker.element.on('keydown', $.proxy(keydown, this));
	        	if (picker.options.pickDate && picker.options.pickTime) {
	        		picker.widget.on('click.togglePicker', '.accordion-toggle', function (e) {
	        			e.stopPropagation();
	        			$this = $(this);
	        			$parent = $this.closest('ul');
	        			expanded = $parent.find('.in');
	        			closed = $parent.find('.collapse:not(.in)');
	
	        			if (expanded && expanded.length) {
	        				collapseData = expanded.data('collapse');
	        				if (collapseData && collapseData.transitioning) {
	        					return;
	        				}
	        				expanded.collapse('hide');
	        				closed.collapse('show');
	        				$this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
	        				if (picker.component) {
	        					picker.component.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
	        				}
	        			}
	        		});
	        	}
	        	if (picker.isInput) {
	        		picker.element.on({
	        			'click': $.proxy(picker.show, this),
	        			'focus': $.proxy(picker.show, this),
	        			'change': $.proxy(change, this),
	        			'blur': $.proxy(picker.hide, this)
	        		});
	        	} else {
	        		picker.element.on({
	        			'change': $.proxy(change, this)
	        		}, 'input');
	        		if (picker.component) {
	        			picker.component.on('click', $.proxy(picker.show, this));
	        			picker.component.on('mousedown', $.proxy(stopEvent, this));
	        		} else {
	        			picker.element.on('click', $.proxy(picker.show, this));
	        		}
	        	}
	        	picker.widget.on('click.togglePicker', '#today-button', function (e) {
	        		if (picker.options.minuteStepping !== 1) {
	        			var mDate = moment(),
							rInterval = picker.options.minuteStepping;
	        			mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60).seconds(0);
	        			picker.setValue(mDate.format(picker.format));
	        		} else {
	        			picker.setValue(moment().format(picker.format));
	        		}
	        		notifyChange('', e.type);
	        		set();
	        	});
	        	picker.widget.on('click.togglePicker', '#clear-button', function (e) {
	        		picker.setValue(null);
	        		notifyChange('', e.type);
	        	});
	        	picker.widget.on('click.togglePicker', '#close-button', function (e) {
	        		picker.hide();
	        	});
	        },
	
	        attachDatePickerGlobalEvents = function () {
	        	$(window).on(
	                'resize.datetimepicker' + picker.id, $.proxy(place, this));
	        	if (!picker.isInput) {
	        		$(document).on(
	                    'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
	        	}
	        },
	
	        detachDatePickerEvents = function () {
	        	picker.widget.off('click', '.datepicker *', picker.click);
	        	picker.widget.off('click', '[data-action]');
	        	picker.widget.off('mousedown', picker.stopEvent);
	        	if (picker.options.pickDate && picker.options.pickTime) {
	        		picker.widget.off('click.togglePicker');
	        	}
	        	if (picker.isInput) {
	        		picker.element.off({
	        			'focus': picker.show,
	        			'change': change,
	        			'click': picker.show,
	        			'blur': picker.hide
	        		});
	        	} else {
	        		picker.element.off({
	        			'change': change
	        		}, 'input');
	        		if (picker.component) {
	        			picker.component.off('click', picker.show);
	        			picker.component.off('mousedown', picker.stopEvent);
	        		} else {
	        			picker.element.off('click', picker.show);
	        		}
	        	}
	        },
	
	        detachDatePickerGlobalEvents = function () {
	        	$(window).off('resize.datetimepicker' + picker.id);
	        	if (!picker.isInput) {
	        		$(document).off('mousedown.datetimepicker' + picker.id);
	        	}
	        },
	
	        isInFixed = function () {
	        	if (picker.element) {
	        		var parents = picker.element.parents(), inFixed = false, i;
	        		for (i = 0; i < parents.length; i++) {
	        			if ($(parents[i]).css('position') === 'fixed') {
	        				inFixed = true;
	        				break;
	        			}
	        		}
	        		return inFixed;
	        	} else {
	        		return false;
	        	}
	        },
	
	        set = function () {
	        	moment.locale(picker.options.language);
	        	var formatted = '';
	        	if (!picker.unset) {
	        		formatted = moment(picker.date).format(picker.format);
	        	}
	        	getPickerInput().val(formatted);
	        	picker.element.data('date', formatted);
	        	if (!picker.options.pickTime) {
	        		picker.hide();
	        	}
	        },
	
	        checkDate = function (direction, unit, amount) {
	        	moment.locale(picker.options.language);
	        	var newDate;
	        	if (direction === 'add') {
	        		newDate = moment(picker.date);
	        		if (newDate.hours() === 23) {
	        			newDate.add(amount, unit);
	        		}
	        		newDate.add(amount, unit);
	        	}
	        	else {
	        		newDate = moment(picker.date).subtract(amount, unit);
	        	}
	        	if (isInDisableDates(moment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
	        		notifyError(newDate.format(picker.format));
	        		return;
	        	}
	
	        	if (direction === 'add') {
	        		picker.date.add(amount, unit);
	        	}
	        	else {
	        		picker.date.subtract(amount, unit);
	        	}
	        	picker.unset = false;
	        },
	
	        isInDisableDates = function (date, timeUnit) {
	        	moment.locale(picker.options.language);
	        	var maxDate = moment(picker.options.maxDate, picker.format, picker.options.useStrict),
	                minDate = moment(picker.options.minDate, picker.format, picker.options.useStrict);
	
	        	if (timeUnit) {
	        		maxDate = maxDate.endOf(timeUnit);
	        		minDate = minDate.startOf(timeUnit);
	        	}
	
	        	if (date.isAfter(maxDate) || date.isBefore(minDate)) {
	        		return true;
	        	}
	        	if (picker.options.disabledDates === false) {
	        		return false;
	        	}
	        	return picker.options.disabledDates[date.format('YYYY-MM-DD')] === true;
	        },
	        isInEnableDates = function (date) {
	        	moment.locale(picker.options.language);
	        	if (picker.options.enabledDates === false) {
	        		return true;
	        	}
	        	return picker.options.enabledDates[date.format('YYYY-MM-DD')] === true;
	        },
	
	        indexGivenDates = function (givenDatesArray) {
	        	// Store given enabledDates and disabledDates as keys.
	        	// This way we can check their existence in O(1) time instead of looping through whole array.
	        	// (for example: picker.options.enabledDates['2014-02-27'] === true)
	        	var givenDatesIndexed = {}, givenDatesCount = 0, i;
	        	for (i = 0; i < givenDatesArray.length; i++) {
	        		if (moment.isMoment(givenDatesArray[i]) || givenDatesArray[i] instanceof Date) {
	        			dDate = moment(givenDatesArray[i]);
	        		} else {
	        			dDate = moment(givenDatesArray[i], picker.format, picker.options.useStrict);
	        		}
	        		if (dDate.isValid()) {
	        			givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
	        			givenDatesCount++;
	        		}
	        	}
	        	if (givenDatesCount > 0) {
	        		return givenDatesIndexed;
	        	}
	        	return false;
	        },
	
	        padLeft = function (string) {
	        	string = string.toString();
	        	if (string.length >= 2) {
	        		return string;
	        	}
	        	return '0' + string;
	        },
	
	        getTemplate = function () {
	        	var
	                headTemplate =
	                        '<thead>' +
	                            '<tr>' +
	                                '<th class="prev">&lsaquo;</th><th colspan="' + (picker.options.calendarWeeks ? '6' : '5') + '" class="picker-switch"></th><th class="next">&rsaquo;</th>' +
	                            '</tr>' +
	                        '</thead>',
	                contTemplate =
	                        '<tbody><tr><td colspan="' + (picker.options.calendarWeeks ? '8' : '7') + '"></td></tr></tbody>',
	                template = '<div class="datepicker-days">' +
	                    '<table class="table-condensed">' + headTemplate + '<tbody></tbody></table>' +
	                '</div>' +
	                '<div class="datepicker-months">' +
	                    '<table class="table-condensed">' + headTemplate + contTemplate + '</table>' +
	                '</div>' +
	                '<div class="datepicker-years">' +
	                    '<table class="table-condensed">' + headTemplate + contTemplate + '</table>' +
	                '</div>',
	                ret = '';
	        	if (picker.options.pickDate && picker.options.pickTime) {
	        		ret = '<div class="bootstrap-datetimepicker-widget' + (picker.options.sideBySide ? ' timepicker-sbs' : '') + (picker.use24hours ? ' usetwentyfour' : '') + ' dropdown-menu" style="z-index:9999 !important;">';
	        		if (picker.options.sideBySide) {
	        			ret += '<div class="row">' +
	                       '<div class="col-sm-6 datepicker">' + template + '</div>' +
	                       '<div class="col-sm-6 timepicker">' + tpGlobal.getTemplate() + '</div>' +
	                     '</div>';
	        		} else {
	        			ret += '<ul class="list-unstyled">' +
	                        '<li' + (picker.options.collapse ? ' class="collapse in"' : '') + '>' +
	                            '<div class="datepicker">' + template + '</div>' +
	                        '</li>' +
							'<li>' +
							'<span class="btn-group" style="float:left; margin-left:4px">' +
							'<button class="btn btn-info"" id="today-button"> Now </button>' +
							'<button class="btn btn-danger" id="clear-button"> Clear </button>' +
							'</span>' +
							'<button class="btn btn-success" id="close-button" style="float:right; margin-right:4px;">Done</button>' +
							'<div style="clear:both; padding-bottom:5px;"></div>' +
							'</li>' +
	                        '<li' + (picker.options.collapse ? ' class="collapse"' : '') + '>' +
	                            '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
	                        '</li>' +
	                   '</ul>';
	        		}
	        		ret += '</div>';
	        		return ret;
	        	}
	        	if (picker.options.pickTime) {
	        		return (
	                    '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
	                        '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
	                    '</div>'
	                );
	        	}
	        	return (
	                '<div class="bootstrap-datetimepicker-widget dropdown-menu">' +
	                    '<div class="datepicker">' + template + '</div>' +
	                '</div>'
	            );
	        },
	
	        dpGlobal = {
	        	modes: [
	                {
	                	clsName: 'days',
	                	navFnc: 'month',
	                	navStep: 1
	                },
	                {
	                	clsName: 'months',
	                	navFnc: 'year',
	                	navStep: 1
	                },
	                {
	                	clsName: 'years',
	                	navFnc: 'year',
	                	navStep: 10
	                }
	        	]
	        },
	
	        tpGlobal = {
	        	hourTemplate: '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
	        	minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
	        	secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
	        };
	
	    	tpGlobal.getTemplate = function () {
	    		return (
	                '<div class="timepicker-picker">' +
	                    '<table class="table-condensed">' +
	                        '<tr>' +
	                            '<td><a href="#" class="btn" data-action="incrementHours"><span class="' + picker.options.icons.up + '"></span></a></td>' +
	                            '<td class="separator"></td>' +
	                            '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><span class="' + picker.options.icons.up + '"></span></a>' : '') + '</td>' +
	                            (picker.options.useSeconds ?
	                                '<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><span class="' + picker.options.icons.up + '"></span></a></td>' : '') +
	                            (picker.use24hours ? '' : '<td class="separator"></td>') + '<td></td>' +
	                        '</tr>' +
	                        '<tr>' +
	                            '<td>' + tpGlobal.hourTemplate + '</td> ' +
	                            '<td class="separator">:</td>' +
	                            '<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
	                            (picker.options.useSeconds ?
	                                '<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
	                            (picker.use24hours ? '' : '<td class="separator"></td>' +
	                            '<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
	                        '</tr>' +
	                        '<tr>' +
	                            '<td><a href="#" class="btn" data-action="decrementHours"><span class="' + picker.options.icons.down + '"></span></a></td>' +
	                            '<td class="separator"></td>' +
	                            '<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><span class="' + picker.options.icons.down + '"></span></a>' : '') + '</td>' +
	                            (picker.options.useSeconds ?
	                                '<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><span class="' + picker.options.icons.down + '"></span></a></td>' : '') +
	                            (picker.use24hours ? '' : '<td class="separator"></td>') + '<td></td>' +
	                        '</tr>' +
	                    '</table>' +
	                '</div>' +
	                '<div class="timepicker-hours" data-action="selectHour">' +
	                    '<table class="table-condensed"></table>' +
	                '</div>' +
	                '<div class="timepicker-minutes" data-action="selectMinute">' +
	                    '<table class="table-condensed"></table>' +
	                '</div>' +
	                (picker.options.useSeconds ?
	                    '<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
	            );
	    	};
	
	    	picker.destroy = function () {
	    		detachDatePickerEvents();
	    		detachDatePickerGlobalEvents();
	    		picker.widget.remove();
	    		picker.element.removeData('DateTimePicker');
	    		if (picker.component) {
	    			picker.component.removeData('DateTimePicker');
	    		}
	    	};
	
	    	picker.show = function (e) {
	    		if (getPickerInput().prop('disabled')) {
	    			return;
	    		}
	    		if (picker.options.useCurrent) {
	    			if (getPickerInput().val() === '') {
	    				if (picker.options.fillEmpty) {
	    					if (picker.options.minuteStepping !== 1) {
	    						var mDate = moment(),
					                rInterval = picker.options.minuteStepping;
	    						mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60).seconds(0);
	    						picker.setValue(mDate.format(picker.format));
	    					} else {
	    						picker.setValue(moment().format(picker.format));
	    					}
	    					notifyChange('', e.type);
	    				}
	    			} else
	    				picker.setValue(getPickerInput().val());
	    		}
	    		// if this is a click event on the input field and picker is already open don't hide it
	    		if (e && e.type === 'click' && picker.isInput && picker.widget.hasClass('picker-open')) {
	    			return;
	    		}
	    		if (picker.widget.hasClass('picker-open')) {
	    			picker.widget.hide();
	    			picker.widget.removeClass('picker-open');
	    		}
	    		else {
	    			picker.widget.show();
	    			picker.widget.addClass('picker-open');
	    		}
	    		picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
	    		place();
	    		picker.element.trigger({
	    			type: 'dp.show',
	    			date: moment(picker.date)
	    		});
	    		attachDatePickerGlobalEvents();
	    		if (e) {
	    			stopEvent(e);
	    		}
	    	};
	
	    	picker.disable = function () {
	    		var input = getPickerInput();
	    		if (input.prop('disabled')) {
	    			return;
	    		}
	    		input.prop('disabled', true);
	    		detachDatePickerEvents();
	    	};
	
	    	picker.enable = function () {
	    		var input = getPickerInput();
	    		if (!input.prop('disabled')) {
	    			return;
	    		}
	    		input.prop('disabled', false);
	    		attachDatePickerEvents();
	    	};
	
	    	picker.hide = function () {
	    		// Ignore event if in the middle of a picker transition
	    		var collapse = picker.widget.find('.collapse'), i, collapseData;
	    		for (i = 0; i < collapse.length; i++) {
	    			collapseData = collapse.eq(i).data('collapse');
	    			if (collapseData && collapseData.transitioning) {
	    				return;
	    			}
	    		}
	    		picker.widget.hide();
	    		picker.widget.removeClass('picker-open');
	    		picker.viewMode = picker.startViewMode;
	    		showMode();
	    		picker.element.trigger({
	    			type: 'dp.hide',
	    			date: moment(picker.date)
	    		});
	    		detachDatePickerGlobalEvents();
	    	};
	
	    	picker.setValue = function (newDate) {
	    		moment.locale(picker.options.language);
	    		if (!newDate) {
	    			picker.unset = true;
	    			set();
	    		} else {
	    			picker.unset = false;
	    		}
	    		if (!moment.isMoment(newDate)) {
	    			newDate = (newDate instanceof Date) ? moment(newDate) : moment(newDate, picker.format, picker.options.useStrict);
	    		} else {
	    			newDate = newDate.locale(picker.options.language);
	    		}
	    		if (newDate.isValid()) {
	    			picker.date = newDate;
	    			set();
	    			picker.viewDate = moment({ y: picker.date.year(), M: picker.date.month() });
	    			fillDate();
	    			fillTime();
	    		}
	    		else {
	    			notifyError(newDate);
	    		}
	    	};
	
	    	picker.getDate = function () {
	    		if (picker.unset) {
	    			return null;
	    		}
	    		return moment(picker.date);
	    	};
	
	    	picker.setDate = function (date) {
	    		var oldDate = moment(picker.date);
	    		if (!date) {
	    			picker.setValue(null);
	    		} else {
	    			picker.setValue(date);
	    		}
	    		notifyChange(oldDate, 'function');
	    	};
	
	    	picker.setDisabledDates = function (dates) {
	    		picker.options.disabledDates = indexGivenDates(dates);
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	picker.setEnabledDates = function (dates) {
	    		picker.options.enabledDates = indexGivenDates(dates);
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	picker.setMaxDate = function (date) {
	    		if (date === undefined) {
	    			return;
	    		}
	    		if (moment.isMoment(date) || date instanceof Date) {
	    			picker.options.maxDate = moment(date);
	    		} else {
	    			picker.options.maxDate = moment(date, picker.format, picker.options.useStrict);
	    		}
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	picker.setMinDate = function (date) {
	    		if (date === undefined) {
	    			return;
	    		}
	    		if (moment.isMoment(date) || date instanceof Date) {
	    			picker.options.minDate = moment(date);
	    		} else {
	    			picker.options.minDate = moment(date, picker.format, picker.options.useStrict);
	    		}
	    		if (picker.viewDate) {
	    			update();
	    		}
	    	};
	
	    	init();
	    };
	
		$.fn.datetimepicker = function (options) {
			return this.each(function () {
				var $this = $(this),
	                data = $this.data('DateTimePicker');
				if (!data) {
					$this.data('DateTimePicker', new DateTimePicker(this, options));
				}
			});
		};
	
		$.fn.datetimepicker.defaults = {
			format: false,
			pickDate: true,
			pickTime: true,
			useMinutes: true,
			useSeconds: false,
			useCurrent: true,
			calendarWeeks: false,
			minuteStepping: 1,
			minDate: moment({ y: 1900 }),
			maxDate: moment().add(100, 'y'),
			showToday: true,
			collapse: false,
			language: moment.locale(),
			defaultDate: '',
			disabledDates: false,
			enabledDates: false,
			icons: {},
			useStrict: false,
			direction: 'auto',
			sideBySide: false,
			daysOfWeekDisabled: [],
			widgetParent: false,
			fillEmpty: false
		};
	}));


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __validation = typescript_angular_utilities_1.services.validation;
	exports.moduleName = 'rl.ui.services.componentValidator';
	exports.factoryName = 'componentValidator';
	var ComponentValidator = (function () {
	    function ComponentValidator(validationService, options) {
	        var _this = this;
	        this.$scope = options.$scope;
	        this.ngModel = options.ngModel;
	        this.form = options.form;
	        this.validator = validationService.buildCustomValidator(function (error, name) {
	            _this.error = error;
	            _this.errorType = name || 'customValidation';
	        });
	        _.each(options.validators, function (customValidator) {
	            _this.validator.registerValidationHandler(customValidator);
	        });
	        this.setValidator();
	    }
	    ComponentValidator.prototype.setValidator = function () {
	        var _this = this;
	        return this.$scope.$watch(this.validator.validate.bind(this.validator), function (value) {
	            if (value) {
	                _this.error = null;
	            }
	            if (!_.isUndefined(_this.ngModel)) {
	                _this.ngModel.$setValidity(_this.errorType, value);
	                _this.ngModel.rlErrorMessage = _this.error;
	            }
	            else if (!_.isUndefined(_this.form)) {
	                _this.form.$setValidity(_this.errorType, value, 'group');
	                _this.form.rlErrorMessage = _this.error;
	            }
	            else if (_.isFunction(_this.setValidity)) {
	                _this.setValidity(value);
	            }
	        });
	    };
	    return ComponentValidator;
	}());
	exports.ComponentValidator = ComponentValidator;
	componentValidatorFactory.$inject = [__validation.serviceName];
	function componentValidatorFactory(validationService) {
	    return {
	        getInstance: function (options) {
	            return new ComponentValidator(validationService, options);
	        },
	    };
	}
	exports.componentValidatorFactory = componentValidatorFactory;
	angular.module(exports.moduleName, [__validation.moduleName])
	    .factory(exports.factoryName, componentValidatorFactory);
	//# sourceMappingURL=componentValidator.service.js.map

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "<div class=\"input-group\" ng-class=\"{ 'has-warning': !dateTime.validFormat, 'error': dateTime.ngModel.$invalid }\">\r\n\t<span class=\"show-date-picker\">\r\n\t\t<input type=\"text\" class=\"form-control\" ng-model=\"dateTime.ngModel.$viewValue\" />\r\n\t\t<span class=\"input-group-btn\">\r\n\t\t\t<button class=\"btn btn-default\" ng-click=\"toggle()\"><i class=\"fa fa-calendar\"></i></button>\r\n\t\t</span>\r\n\t</span>\r\n\t<span class=\"input-group-btn\" ng-if=\"dateTime.clearButton\">\r\n\t\t<button type=\"button\" class=\"btn btn-default pull-left\"  ng-disabled=\"dateTime.ngModel.$viewValue | isEmpty\" ng-click=\"dateTime.onClearClick()\" >\r\n\t\t\t<i class=\"fa fa-times\"></i>\r\n\t\t</button>\r\n\t</span>\r\n\t<span class=\"error-string\" ng-hide=\"dateTime.dateTimeValidator.error | isEmpty\">{{dateTime.dateTimeValidator.error}}</span>\r\n</div>"

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// /// <reference path='../../../typings/bootstrapDateTimePicker.d.ts' />
	var angular = __webpack_require__(1);
	var moment = __webpack_require__(71);
	exports.moduleName = 'rl.ui.components.dateTimeStatic';
	exports.componentName = 'rlDateTimeStatic';
	exports.controllerName = 'DateTimeStaticController';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __date = typescript_angular_utilities_1.services.date;
	var DateTimeStaticController = (function () {
	    function DateTimeStaticController(dateUtility) {
	        this.dateUtility = dateUtility;
	        this.displayValue = '';
	        if (this.dateValue != null && this.dateUtility.isDate(this.dateValue)) {
	            this.displayValue = moment(this.dateValue).format('MM/DD/YYYY');
	            if (this.includeTime) {
	                this.displayTimeZone = true;
	                this.displayValue = this.displayValue + moment(this.dateValue).format(' h:mm a');
	            }
	        }
	    }
	    DateTimeStaticController.$inject = [__date.serviceName];
	    return DateTimeStaticController;
	}());
	exports.DateTimeStaticController = DateTimeStaticController;
	var dateTimeStaticComponent = {
	    template: __webpack_require__(115),
	    controller: exports.controllerName,
	    controllerAs: 'view',
	    bindings: {
	        dateValue: '<',
	        includeTime: '<?',
	        displayTimeZone: '<?',
	    },
	};
	angular.module(exports.moduleName, [])
	    .component(exports.componentName, dateTimeStaticComponent)
	    .controller(exports.controllerName, DateTimeStaticController);
	//# sourceMappingURL=dateTimeStatic.js.map

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "<span class=\"rl-date-time-static\">{{view.displayValue}}&nbsp;<span ng-if=\"view.displayTimeZone\" class=\"time-zone\">EST</span></span>"

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var dialog_service_1 = __webpack_require__(117);
	exports.moduleName = 'rl.ui.components.dialog';
	exports.directiveName = 'rlDialog';
	exports.controllerName = 'DialogController';
	var DialogController = (function () {
	    function DialogController($scope, dialogService) {
	        this.$scope = $scope;
	        this.dialogService = dialogService;
	    }
	    DialogController.prototype.$onInit = function () {
	        var _this = this;
	        var unbind = this.$scope.$watch(function () { return _this.form; }, function (form) {
	            if (form != null) {
	                _this.dialogService.setForm(form);
	                unbind();
	            }
	        });
	    };
	    DialogController.$inject = ['$scope', dialog_service_1.serviceName];
	    return DialogController;
	}());
	exports.DialogController = DialogController;
	dialog.$inject = ['$compile'];
	function dialog($compile) {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: {
	            headerSlot: '?rlDialogHeader',
	            contentSlot: '?rlDialogContent',
	            footerSlot: '?rlDialogFooter',
	        },
	        template: __webpack_require__(122),
	        controller: exports.controllerName,
	        controllerAs: 'dialog',
	        scope: {},
	        bindToController: {
	            autosave: '=',
	        },
	        link: function (scope, element, attrs, controller, transclude) {
	            controller.close = scope.$parent.$close;
	            controller.dismiss = scope.$parent.$dismiss;
	            controller.saveAndClose = scope.$parent.$saveAndClose;
	            var footerArea = element.find('.footer-template');
	            if (transclude.isSlotFilled('footerSlot')) {
	                transclude(function (footer) {
	                    controller.hasFooter = (footer.length > 0);
	                    if (controller.hasFooter) {
	                        footerArea.append(footer);
	                    }
	                }, null, 'footerSlot');
	            }
	            else if (controller.autosave) {
	                var footer = $compile(__webpack_require__(123))(scope);
	                controller.hasFooter = true;
	                footerArea.append(footer);
	            }
	        },
	    };
	}
	angular.module(exports.moduleName, [dialog_service_1.moduleName])
	    .directive(exports.directiveName, dialog)
	    .controller(exports.controllerName, DialogController);
	//# sourceMappingURL=dialog.js.map

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __promise = typescript_angular_utilities_1.services.promise;
	var __notification = typescript_angular_utilities_1.services.notification;
	var bootstrapModalDialog = __webpack_require__(118);
	exports.bootstrapModalDialog = bootstrapModalDialog;
	var autosave_service_1 = __webpack_require__(17);
	var form_service_1 = __webpack_require__(23);
	var dialog_1 = __webpack_require__(116);
	exports.directiveName = dialog_1.directiveName;
	exports.controllerName = dialog_1.controllerName;
	exports.DialogController = dialog_1.DialogController;
	exports.moduleName = 'rl.ui.services.dialog';
	exports.serviceName = 'dialog';
	var DialogService = (function () {
	    function DialogService(dialog, $rootScope, autosaveFactory, promise, notification, formService) {
	        var _this = this;
	        this.dialog = dialog;
	        this.$rootScope = $rootScope;
	        this.autosaveFactory = autosaveFactory;
	        this.promise = promise;
	        this.notification = notification;
	        this.formService = formService;
	        this.autosaveCloseHandler = function (explicit) {
	            if (explicit) {
	                return true;
	            }
	            return _this.autosave.autosave(_this.data);
	        };
	    }
	    DialogService.prototype.open = function (options, closeHandler) {
	        var _this = this;
	        var dialogInstance = this.dialog.open(options, closeHandler);
	        dialogInstance.validateAndNotify = function () {
	            var valid = _this.form.$valid;
	            if (!valid) {
	                _this.notification.warning(_this.formService.getAggregateError(_this.form));
	            }
	            return valid;
	        };
	        return dialogInstance;
	    };
	    DialogService.prototype.prompt = function (options) {
	        options.okButton = options.okButton || 'Ok';
	        options.cancelButton = options.cancelButton || 'Cancel';
	        return this.dialog.prompt(options, __webpack_require__(121));
	    };
	    DialogService.prototype.openForm = function (options) {
	        var _this = this;
	        var dialogInstance = {
	            close: function () { },
	            dismiss: function () { },
	            save: function () { },
	            saveAndClose: function () { },
	            validateAndNotify: function () { },
	        };
	        this.promise.resolvePromises(options.resolve).then(function (resolveData) {
	            var scope = options.scope;
	            if (scope == null) {
	                scope = _this.$rootScope.$new();
	                options.scope = scope;
	            }
	            if (options.data == null) {
	                options.data = {};
	            }
	            if (options.triggers == null) {
	                options.triggers = 'none';
	            }
	            _this.autosave = _this.autosaveFactory.getInstance({
	                save: options.save,
	                triggers: options.triggers,
	            });
	            _this.data = _.extend(options.data, resolveData);
	            scope.dialog = _this.data;
	            var instance = _this.open(options, _this.autosaveCloseHandler);
	            dialogInstance.close = instance.close;
	            dialogInstance.dismiss = instance.dismiss;
	            scope.$save = function () { return _this.autosave.validateAndSave(_this.data); };
	            ;
	            scope.$saveAndClose = function () {
	                var promise = scope.$save();
	                if (_.isBoolean(promise) && promise) {
	                    instance.close();
	                }
	                else if (_this.promise.isPromise(promise)) {
	                    promise.then(function () {
	                        instance.close();
	                    });
	                }
	                return promise;
	            };
	            dialogInstance.save = scope.$save;
	            dialogInstance.saveAndClose = scope.$saveAndClose;
	            dialogInstance.validateAndNotify = instance.validateAndNotify;
	        });
	        return dialogInstance;
	    };
	    DialogService.prototype.setForm = function (form) {
	        if (this.autosave != null) {
	            this.autosave.contentForm = form;
	        }
	        this.form = form;
	    };
	    return DialogService;
	}());
	exports.DialogService = DialogService;
	function dialogServiceProvider() {
	    'use strict';
	    var _this = this;
	    var provider = {
	        setImplementation: function (dialogImplementation) {
	            _this.dialogImplementation = dialogImplementation;
	        },
	        $get: function (bootstrapModalDialog, $rootScope, autosaveFactory, promise, notification, formService) {
	            var dialogImplementation = _this.dialogImplementation != null
	                ? _this.dialogImplementation
	                : bootstrapModalDialog;
	            return new DialogService(dialogImplementation, $rootScope, autosaveFactory, promise, notification, formService);
	        },
	    };
	    provider.$get.$inject = [bootstrapModalDialog.serviceName, '$rootScope', autosave_service_1.factoryName, __promise.serviceName, __notification.serviceName, form_service_1.serviceName];
	    return provider;
	}
	exports.dialogServiceProvider = dialogServiceProvider;
	angular.module(exports.moduleName, [bootstrapModalDialog.moduleName, autosave_service_1.moduleName, __notification.moduleName, form_service_1.moduleName])
	    .provider(exports.serviceName, dialogServiceProvider);
	//# sourceMappingURL=dialog.service.js.map

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __promise = typescript_angular_utilities_1.services.promise;
	var bootstrapModalDialog_controller_1 = __webpack_require__(119);
	var bootstrapModalDialog_service_1 = __webpack_require__(120);
	__export(__webpack_require__(119));
	__export(__webpack_require__(120));
	exports.moduleName = 'rl.ui.services.dialog.bootstrapModalDialog';
	angular.module(exports.moduleName, [__promise.moduleName])
	    .controller(bootstrapModalDialog_controller_1.controllerName, bootstrapModalDialog_controller_1.BootstrapModalDialogController)
	    .service(bootstrapModalDialog_service_1.serviceName, bootstrapModalDialog_service_1.BootstrapModalDialogService);
	//# sourceMappingURL=bootstrapModalDialog.module.js.map

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var bootstrapModalDialog_service_1 = __webpack_require__(120);
	exports.controllerName = 'BootstrapModalDialogController';
	var BootstrapModalDialogController = (function () {
	    function BootstrapModalDialogController($scope, $controller, baseDialog) {
	        var controller;
	        if ($scope.modalController != null) {
	            var locals = $scope.resolveData || {};
	            $scope.resolveData = null;
	            locals.$scope = $scope;
	            controller = $controller($scope.modalController, locals);
	        }
	        $scope.$on('modal.closing', baseDialog.modalClosing);
	        return controller;
	    }
	    BootstrapModalDialogController.$inject = ['$scope', '$controller', bootstrapModalDialog_service_1.serviceName];
	    return BootstrapModalDialogController;
	}());
	exports.BootstrapModalDialogController = BootstrapModalDialogController;
	//# sourceMappingURL=bootstrapModalDialog.controller.js.map

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __promise = typescript_angular_utilities_1.services.promise;
	var bootstrapModalDialog_controller_1 = __webpack_require__(119);
	exports.serviceName = 'uiBootstrapModelDialog';
	var BootstrapModalDialogService = (function () {
	    function BootstrapModalDialogService($modal, $rootScope, promise) {
	        var _this = this;
	        this.$modal = $modal;
	        this.$rootScope = $rootScope;
	        this.promise = promise;
	        this.modalClosing = function (event, reason, explicitlyClosed) {
	            var canClose = true;
	            if (_.isFunction(_this.closeHandler)) {
	                canClose = _this.closeHandler(explicitlyClosed);
	            }
	            if (!canClose) {
	                event.preventDefault();
	            }
	        };
	    }
	    BootstrapModalDialogService.prototype.open = function (options, closeHandler) {
	        var _this = this;
	        if (options == null) {
	            options = {};
	        }
	        var dialogInstance = {
	            close: function () { },
	            dismiss: function () { },
	        };
	        this.promise.resolvePromises(options.resolve).then(function (results) {
	            _this.closeHandler = closeHandler;
	            options = _this.configureModalSettings(options, results);
	            var modalInstance = _this.$modal.open(options);
	            dialogInstance.close = modalInstance.close;
	            dialogInstance.dismiss = modalInstance.dismiss;
	        });
	        return dialogInstance;
	    };
	    BootstrapModalDialogService.prototype.prompt = function (options, template) {
	        var acceptHandler = options.acceptHandler;
	        var cancelHandler = options.cancelHandler;
	        options.acceptHandler = null;
	        options.cancelHandler = null;
	        var modalScope = this.$rootScope.$new();
	        modalScope.prompt = options;
	        var settings = {
	            scope: modalScope,
	            template: template,
	            controller: bootstrapModalDialog_controller_1.controllerName,
	        };
	        var modalInstance = this.$modal.open(settings);
	        var accept = function () {
	            acceptHandler();
	            modalInstance.close();
	        };
	        var cancel = function () {
	            cancelHandler();
	            modalInstance.close();
	        };
	        modalScope.$accept = accept;
	        modalScope.$cancel = cancel;
	        return {
	            accept: accept,
	            cancel: cancel,
	            close: modalInstance.close,
	            dismiss: modalInstance.dismiss,
	        };
	    };
	    BootstrapModalDialogService.prototype.configureModalSettings = function (options, resolveData) {
	        var modalScope = options.scope;
	        if (modalScope == null) {
	            modalScope = this.$rootScope.$new();
	        }
	        if (options.resolveToDialog) {
	            if (options.dialogAs != null) {
	                modalScope[options.dialogAs] = resolveData;
	            }
	            else {
	                modalScope = _.extend(modalScope, resolveData);
	            }
	        }
	        else {
	            modalScope.resolveData = resolveData;
	        }
	        modalScope.modalController = options.controller;
	        options.resolve = null;
	        options.controller = bootstrapModalDialog_controller_1.controllerName;
	        options.scope = modalScope;
	        return options;
	    };
	    BootstrapModalDialogService.$inject = ['$uibModal', '$rootScope', __promise.serviceName];
	    return BootstrapModalDialogService;
	}());
	exports.BootstrapModalDialogService = BootstrapModalDialogService;
	//# sourceMappingURL=bootstrapModalDialog.service.js.map

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = "<div class=\"modal-body\">\r\n\t<div class=\"row\">\r\n\t\t<div class=\"col-xs-12\">\r\n\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\" ng-click=\"$dismiss()\">\r\n\t\t\t\t<span class=\"fa-stack\">\r\n\t\t\t\t\t<i class=\"close-bg fa fa-circle fa-stack-2x\"></i>\r\n\t\t\t\t\t<i class=\"close-icon fa fa-close fa-stack-1x\"></i>\r\n\t\t\t\t</span>\r\n\t\t\t</button>\r\n\t\t</div>\r\n\t</div>\r\n\r\n\t{{prompt.message}}\r\n\t<div class=\"clearfix\"></div>\r\n</div>\r\n<div class=\"modal-footer\">\r\n\t<button class=\"btn btn-danger\" type=\"button\" ng-click=\"$cancel()\"><i class=\"fa fa-times\"></i> {{prompt.cancelButton}}</button>\r\n\t<button class=\"btn btn-success\" type=\"button\" ng-click=\"$accept()\"><i class=\"fa fa-check\"></i> {{prompt.okButton}}</button>\r\n\t<div class=\"clearfix\"></div>\r\n</div>"

/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports = "<rl-form save=\"dialog.saveAndClose()\" saving=\"dialog.saving\" form=\"dialog.form\">\r\n\t<div class=\"modal-header\">\r\n\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\" ng-click=\"dialog.close()\">\r\n\t\t\t<span class=\"fa-stack\">\r\n\t\t\t\t<i class=\"close-bg fa fa-circle fa-stack-2x\"></i>\r\n\t\t\t\t<i class=\"close-icon fa fa-close fa-stack-1x\"></i>\r\n\t\t\t</span>\r\n\t\t</button>\r\n\t\t<div ng-transclude=\"headerSlot\"></div>\r\n\t\t<div class=\"clearfix \"></div>\r\n\t</div>\r\n\t<div class=\"modal-body\">\r\n\t\t<div ng-transclude=\"contentSlot\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n\t<div class=\"modal-footer\" ng-show=\"dialog.hasFooter\">\r\n\t\t<div class=\"footer-template\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n</rl-form>"

/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports = "<rl-button type=\"danger\" action=\"dialog.close()\"><i class=\"fa fa-times\"></i> Cancel</rl-button>\r\n<rl-button-async type=\"success\" action=\"dialog.saveAndClose()\"><i class=\"fa fa-check\"></i> Save</rl-button-submit>"

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var autosave_service_1 = __webpack_require__(17);
	exports.moduleName = 'rl.ui.components.form';
	exports.componentName = 'rlForm';
	exports.controllerName = 'rlFormController';
	var FormController = (function () {
	    function FormController($element, $scope, $timeout, $q, autosaveFactory, parentChild) {
	        this.$element = $element;
	        this.$scope = $scope;
	        this.$timeout = $timeout;
	        this.$q = $q;
	        this.autosaveFactory = autosaveFactory;
	        this.parentChild = parentChild;
	    }
	    FormController.prototype.$onInit = function () {
	        var _this = this;
	        this.$timeout(function () {
	            _this.form = _this.$scope.rlForm;
	            _this.autosave = _this.autosaveFactory.getInstance({
	                save: _this.saveForm.bind(_this),
	                contentForm: _this.$scope.rlForm,
	                triggers: 'none',
	            });
	            _this.parentChild.registerChildBehavior(_this.childLink, {
	                save: _this.autosave.validateAndSave.bind(_this.autosave),
	            });
	        });
	    };
	    FormController.prototype.saveForm = function () {
	        var _this = this;
	        this.saving = true;
	        return this.$q.when(this.save()).then(function () {
	            _this.saving = false;
	        }).catch(function () { _this.saving = false; });
	    };
	    FormController.$inject = ['$element', '$scope', '$timeout', '$q', autosave_service_1.factoryName, __parentChild.serviceName];
	    return FormController;
	}());
	exports.FormController = FormController;
	var form = {
	    transclude: true,
	    template: "<form ng-transclude name=\"rlForm\" ng-submit=\"controller.autosave.validateAndSave()\"></form>",
	    controller: exports.controllerName,
	    controllerAs: 'controller',
	    bindings: {
	        saving: '=?',
	        save: '&',
	        form: '=?',
	        childLink: '=?',
	    },
	};
	angular.module(exports.moduleName, [autosave_service_1.moduleName])
	    .component(exports.componentName, form)
	    .controller(exports.controllerName, FormController);
	//# sourceMappingURL=form.js.map

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var jquery_service_1 = __webpack_require__(126);
	var templateLoader_service_1 = __webpack_require__(127);
	exports.moduleName = 'rl.ui.components.genericContainer';
	exports.directiveName = 'rlGenericContainer';
	exports.controllerName = 'GenericContainerController';
	var __object = typescript_angular_utilities_1.services.object;
	var GenericContainerController = (function () {
	    function GenericContainerController($scope, object) {
	        var _this = this;
	        this.object = object;
	        $scope.$watch(function () { return _this.selector; }, function (newType, oldType) {
	            if (_this.object.areEqual(newType, oldType)) {
	                return;
	            }
	            var template = _this.resolveTemplate(newType);
	            _this.swapTemplates(template);
	        });
	    }
	    GenericContainerController.prototype.refresh = function () {
	        var template = this.resolveTemplate(this.selector);
	        this.swapTemplates(template);
	    };
	    GenericContainerController.prototype.resolveTemplate = function (type) {
	        if (_.has(this.templates, type)) {
	            return this.templates[type];
	        }
	        else {
	            return this.default;
	        }
	    };
	    GenericContainerController.$inject = ['$scope', __object.serviceName];
	    return GenericContainerController;
	}());
	exports.GenericContainerController = GenericContainerController;
	genericContainer.$inject = [
	    '$compile',
	    '$interpolate',
	    jquery_service_1.serviceName,
	    templateLoader_service_1.serviceName,
	    __object.serviceName,
	];
	function genericContainer($compile, $interpolate, jquery, templateLoader, object) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: '<div id="container"></div>',
	        transclude: true,
	        controller: exports.controllerName,
	        controllerAs: 'genericContainer',
	        scope: {},
	        bindToController: {
	            selector: '=',
	            configuredTemplates: '=templates',
	            defaultTemplate: '=',
	        },
	        link: function (scope, element, attributes, controller, transclude) {
	            initDefaults(controller);
	            var container = element.find('#container');
	            var templateResult = templateLoader.loadTemplates(transclude);
	            controller.templates = _.extend(controller.templates, templateResult.templates);
	            controller.default = templateResult.default;
	            var templateScope = templateResult.transclusionScope;
	            if (!controller.default) {
	                controller.default = '<div></div>';
	            }
	            controller.refresh();
	            function initDefaults(controller) {
	                controller.default = controller.defaultTemplate;
	                controller.templates = controller.configuredTemplates ? controller.configuredTemplates : {};
	                controller.swapTemplates = swapTemplates;
	            }
	            function swapTemplates(template) {
	                var content = angular.element(template);
	                jquery.replaceContent(container, content);
	                $compile(content)(templateScope);
	            }
	        }
	    };
	}
	angular.module(exports.moduleName, [jquery_service_1.moduleName, __object.moduleName, templateLoader_service_1.moduleName])
	    .directive(exports.directiveName, genericContainer)
	    .controller(exports.controllerName, GenericContainerController);
	//# sourceMappingURL=genericContainer.js.map

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path="../../../typings/jquery/jquery.d.ts" />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.utilities.services.jquery';
	exports.serviceName = 'jqueryUtility';
	var JQueryUtility = (function () {
	    function JQueryUtility() {
	    }
	    JQueryUtility.prototype.replaceContent = function (contentArea, newContent) {
	        contentArea.empty();
	        return contentArea.append(newContent);
	    };
	    return JQueryUtility;
	}());
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, JQueryUtility);
	//# sourceMappingURL=jquery.service.js.map

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	exports.moduleName = 'rl.utilities.services.templateLoader';
	exports.serviceName = 'templateLoader';
	var TemplateLoader = (function () {
	    function TemplateLoader($interpolate, templateSelectorValue, objectUtility) {
	        this.$interpolate = $interpolate;
	        this.templateSelectorValue = templateSelectorValue;
	        this.objectUtility = objectUtility;
	    }
	    TemplateLoader.prototype.loadTemplates = function (transclude) {
	        var _this = this;
	        var result = {
	            templates: {},
	            default: null,
	            transclusionScope: null,
	        };
	        // Load templates from the DOM
	        transclude(function (clone, transclusionScope) {
	            var templates = clone.filter(_this.templateSelectorValue);
	            templates.each(function (index, template) {
	                var templateElement = angular.element(template);
	                var templateHtml = templateElement.html();
	                var triggerAttribute = templateElement.attr('when-selector');
	                if (!_this.objectUtility.isNullOrWhitespace(triggerAttribute)) {
	                    var trigger = _this.$interpolate(triggerAttribute)(transclusionScope);
	                    result.templates[trigger] = templateHtml;
	                }
	                var isDefault = templateElement.attr('default');
	                if (!_.isUndefined(isDefault) && isDefault.toLowerCase() !== 'false') {
	                    result.default = templateHtml;
	                }
	            });
	            result.transclusionScope = transclusionScope;
	        });
	        return result;
	    };
	    TemplateLoader.$inject = ['$interpolate', 'templateSelectorValue', __object.serviceName];
	    return TemplateLoader;
	}());
	angular.module(exports.moduleName, [__object.moduleName])
	    .value('templateSelectorValue', 'template')
	    .service(exports.serviceName, TemplateLoader);
	//# sourceMappingURL=templateLoader.service.js.map

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.lazyLoad';
	exports.directiveName = 'rlLazyLoad';
	exports.controllerName = 'LazyLoadController';
	var LazyLoadController = (function () {
	    function LazyLoadController($scope) {
	        var _this = this;
	        this.init = false;
	        var unbind = $scope.$watch(function () { return _this.show; }, function (value) {
	            if (value) {
	                _this.init = true;
	                unbind();
	            }
	        });
	    }
	    LazyLoadController.$inject = ['$scope'];
	    return LazyLoadController;
	}());
	exports.LazyLoadController = LazyLoadController;
	function lazyLoad() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: "\n\t\t\t<div ng-if=\"lazyLoad.init\">\n\t\t\t\t<div ng-show=\"lazyLoad.show\">\n\t\t\t\t\t<div ng-transclude></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'lazyLoad',
	        scope: {},
	        bindToController: {
	            show: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, lazyLoad)
	    .controller(exports.controllerName, LazyLoadController);
	//# sourceMappingURL=lazyLoad.js.map

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(12);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __promise = typescript_angular_utilities_1.services.promise;
	exports.moduleName = 'rl.ui.components.longClickButton';
	exports.directiveName = 'rlLongClickButton';
	exports.controllerName = 'LongClickButtonController';
	var __object = typescript_angular_utilities_1.services.object;
	var LongClickButtonController = (function () {
	    function LongClickButtonController($scope, $interval, $timeout, objectUtility, promise) {
	        var _this = this;
	        this.$interval = $interval;
	        this.$timeout = $timeout;
	        this.objectUtility = objectUtility;
	        this.promise = promise;
	        this.interval = 25;
	        this.duration = 1500;
	        this.buttonText = this.text;
	        this.type = this.type != null ? this.type : 'default';
	        this.size = this.size != null ? 'btn-' + this.size : null;
	        $scope.$watch(function () { return _this.buttonText; }, function () {
	            $timeout(function () {
	                _this.width = $('#actionButton').outerWidth();
	            });
	        });
	    }
	    LongClickButtonController.prototype.startAction = function () {
	        var _this = this;
	        if (this.active || this.busy) {
	            return;
	        }
	        this.actionProgress = 0;
	        this.active = true;
	        this.actionInterval = this.$interval(function () {
	            _this.actionProgress += _this.interval;
	            if (_this.actionProgress >= _this.duration) {
	                _this.cleanup();
	                _this.buttonText = _this.text;
	                _this.trigger();
	            }
	        }, this.interval);
	    };
	    LongClickButtonController.prototype.stopAction = function () {
	        if (this.active) {
	            if (this.actionProgress < this.duration) {
	                this.warn();
	            }
	            this.cleanup();
	        }
	    };
	    LongClickButtonController.prototype.cleanup = function () {
	        this.$interval.cancel(this.actionInterval);
	        this.actionProgress = 0;
	        this.active = false;
	    };
	    LongClickButtonController.prototype.warn = function () {
	        if (this.objectUtility.isNullOrEmpty(this.onShortClickText) === false) {
	            this.buttonText = this.onShortClickText;
	        }
	    };
	    LongClickButtonController.prototype.trigger = function () {
	        var _this = this;
	        if (!this.busy) {
	            this.busy = true;
	            var result = this.action();
	            if (this.promise.isPromise(result) && _.isFunction(result.finally)) {
	                result.finally(function () {
	                    _this.busy = false;
	                });
	            }
	        }
	    };
	    LongClickButtonController.$inject = ['$scope', '$interval', '$timeout', __object.serviceName, __promise.serviceName];
	    return LongClickButtonController;
	}());
	exports.LongClickButtonController = LongClickButtonController;
	function longClickButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(130),
	        controller: exports.controllerName,
	        controllerAs: 'button',
	        scope: {},
	        bindToController: {
	            action: '&',
	            text: '@',
	            onShortClickText: '@',
	            icon: '@',
	            busy: '=?',
	            rightAligned: '=?',
	            type: '@',
	            ngDisabled: '=?',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, longClickButton)
	    .controller(exports.controllerName, LongClickButtonController);
	//# sourceMappingURL=longClickButton.js.map

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = "<div class=\"long-click-button\">\r\n\t<button id=\"actionButton\" class=\"btn btn-{{button.type}} {{button.size}}\" ng-mousedown=\"button.startAction()\" ng-mouseleave=\"button.stopAction()\" ng-mouseup=\"button.stopAction()\" ng-disabled=\"button.busy || button.ngDisabled\">\r\n\t\t<rl-busy loading=\"button.busy\" ng-if=\"button.rightAligned\"></rl-busy>\r\n\t\t<i ng-show=\"button.icon != null\" class=\"fa fa-{{button.icon}}\"></i> {{button.buttonText}}\r\n\t\t<rl-busy loading=\"button.busy\" ng-if=\"!button.rightAligned\"></rl-busy>\r\n\t</button>\r\n\t<rl-rating-bar ng-if=\"button.active\" width=\"button.width\" height=\"5\" min=\"0\" max=\"button.duration\"\r\n\t\t\t\tvalue=\"button.actionProgress\" background=\"transparent\"></rl-rating-bar>\r\n</div>"

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var jquery_service_1 = __webpack_require__(126);
	var messageLog_service_1 = __webpack_require__(132);
	var messageLog_directive_1 = __webpack_require__(133);
	var editableMessageLog_1 = __webpack_require__(143);
	var componentServices = __webpack_require__(134);
	var __dialog = componentServices.dialog;
	var templateLoader_service_1 = __webpack_require__(127);
	__export(__webpack_require__(132));
	__export(__webpack_require__(133));
	exports.moduleName = 'rl.ui.components.messageLog';
	angular.module(exports.moduleName, [__object.moduleName, jquery_service_1.moduleName, templateLoader_service_1.moduleName, __dialog.moduleName])
	    .factory(messageLog_service_1.factoryName, messageLog_service_1.messageLogFactory)
	    .directive(messageLog_directive_1.directiveName, messageLog_directive_1.messageLog)
	    .controller(messageLog_directive_1.controllerName, messageLog_directive_1.MessageLogController)
	    .directive(editableMessageLog_1.directiveName, editableMessageLog_1.editableMessageLog)
	    .controller(editableMessageLog_1.controllerName, editableMessageLog_1.EditableMessageLogController);
	//# sourceMappingURL=messageLog.module.js.map

/***/ },
/* 132 */
/***/ function(module, exports) {

	'use strict';
	exports.factoryName = 'messageLog';
	exports.defaultPageSize = 10;
	var MessageLog = (function () {
	    function MessageLog() {
	        this.currentStartingMessage = 0;
	        this._hasForwardMessages = false;
	        this._hasBackwardMessages = false;
	        this._pageSize = exports.defaultPageSize;
	    }
	    Object.defineProperty(MessageLog.prototype, "pageSize", {
	        get: function () {
	            return this._pageSize;
	        },
	        /* tslint:disable */
	        set: function (value) {
	            this._pageSize = value;
	            this.updateCurrentPage();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "hasForwardMessages", {
	        /* tslint:enable */
	        get: function () {
	            return this._hasForwardMessages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "hasBackwardMessages", {
	        get: function () {
	            return this._hasBackwardMessages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MessageLog.prototype, "dataService", {
	        get: function () {
	            return this._dataService;
	        },
	        /* tslint:disable */
	        set: function (value) {
	            this._dataService = value;
	            if (value != null) {
	                this.visibleMessages = null;
	                this.updateCurrentPage();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /* tslint:enable */
	    MessageLog.prototype.addMessage = function (message) {
	        var _this = this;
	        return this.dataService.saveMessage(message).then(function () {
	            _this.getTopPage();
	        });
	    };
	    MessageLog.prototype.updateMessage = function (message) {
	        var _this = this;
	        return this.dataService.updateMessage(message).then(function () {
	            _this.getTopPage();
	        });
	    };
	    MessageLog.prototype.deleteMessage = function (message) {
	        var _this = this;
	        return this.dataService.deleteMessage(message).then(function () {
	            _this.refresh();
	        });
	    };
	    MessageLog.prototype.getNextPage = function () {
	        if (!this.hasForwardMessages) {
	            return;
	        }
	        this.currentStartingMessage += this.pageSize;
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.getPreviousPage = function () {
	        if (!this.hasBackwardMessages) {
	            return;
	        }
	        this.currentStartingMessage -= this.pageSize;
	        if (this.currentStartingMessage < 0) {
	            this.currentStartingMessage = 0;
	        }
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.getTopPage = function () {
	        this.currentStartingMessage = 0;
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.refresh = function () {
	        return this.updateCurrentPage();
	    };
	    MessageLog.prototype.updateCurrentPage = function () {
	        var _this = this;
	        if (this.dataService == null) {
	            return null;
	        }
	        this.busy = true;
	        return this.dataService.getMessages(this.currentStartingMessage, this.pageSize).then(function (result) {
	            _this.visibleMessages = result.messages;
	            _this._hasForwardMessages = result.hasMoreMessages;
	            _this._hasBackwardMessages = (_this.currentStartingMessage > 0);
	            _this.busy = false;
	        });
	    };
	    return MessageLog;
	}());
	exports.MessageLog = MessageLog;
	function messageLogFactory() {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new MessageLog();
	        },
	    };
	}
	exports.messageLogFactory = messageLogFactory;
	//# sourceMappingURL=messageLog.service.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var jquery_service_1 = __webpack_require__(126);
	var messageLog_service_1 = __webpack_require__(132);
	var componentServices = __webpack_require__(134);
	var __dialog = componentServices.dialog;
	var templateLoader_service_1 = __webpack_require__(127);
	exports.directiveName = 'rlMessageLog';
	exports.controllerName = 'MessageLogController';
	(function (DeletePermissions) {
	    DeletePermissions[DeletePermissions["deleteMine"] = 0] = "deleteMine";
	    DeletePermissions[DeletePermissions["deleteAll"] = 1] = "deleteAll";
	    DeletePermissions[DeletePermissions["deleteNone"] = 2] = "deleteNone";
	})(exports.DeletePermissions || (exports.DeletePermissions = {}));
	var DeletePermissions = exports.DeletePermissions;
	(function (EditPermissions) {
	    EditPermissions[EditPermissions["editMine"] = 0] = "editMine";
	    EditPermissions[EditPermissions["editAll"] = 1] = "editAll";
	    EditPermissions[EditPermissions["editNone"] = 2] = "editNone";
	})(exports.EditPermissions || (exports.EditPermissions = {}));
	var EditPermissions = exports.EditPermissions;
	var MessageLogController = (function () {
	    function MessageLogController(dialog, $scope, messageLogFactory) {
	        var _this = this;
	        this.dialog = dialog;
	        this.messageLog = this.messageLogBinding || messageLogFactory.getInstance();
	        $scope.$watch(function () { return _this.messageLog.visibleMessages; }, function (value) {
	            _this.messages = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.hasForwardMessages; }, function (value) {
	            _this.hasNextPage = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.hasBackwardMessages; }, function (value) {
	            _this.hasPreviousPage = value;
	        });
	        $scope.$watch(function () { return _this.messageLog.busy; }, function (value) {
	            if (!value) {
	                _this.loading = false;
	                _this.loadingInitial = false;
	            }
	            else {
	                _this.loading = true;
	            }
	        });
	        $scope.$watch(function () { return _this.service; }, function (service) {
	            _this.messageLog.dataService = service;
	            _this.loadingInitial = true;
	        });
	        this.messageLog.pageSize = this.pageSize != null ? this.pageSize : 8;
	    }
	    MessageLogController.prototype.getEntrySelector = function (entry) {
	        if (_.isString(this.selector)) {
	            return entry[this.selector];
	        }
	        else if (_.isFunction(this.selector)) {
	            return this.selector(entry);
	        }
	    };
	    MessageLogController.prototype.getOlder = function () {
	        return this.messageLog.getNextPage();
	    };
	    MessageLogController.prototype.getTop = function () {
	        return this.messageLog.getTopPage();
	    };
	    MessageLogController.prototype.canDeleteEntry = function (entry) {
	        if (entry.isSystemNote) {
	            return false;
	        }
	        switch (this.canDelete) {
	            case DeletePermissions.deleteAll:
	                return true;
	            case DeletePermissions.deleteMine:
	                return (this.currentUser == null || this.currentUser.id === entry.createdBy.id);
	            default:
	                return false;
	        }
	    };
	    MessageLogController.prototype.canEditEntry = function (entry) {
	        if (entry.isSystemNote) {
	            return false;
	        }
	        switch (this.canEdit) {
	            case EditPermissions.editAll:
	                return true;
	            case EditPermissions.editMine:
	                return (this.currentUser == null || this.currentUser.id === entry.createdBy.id);
	            default:
	                return false;
	        }
	    };
	    MessageLogController.prototype.editMessage = function (entry) {
	        var editedEntry = _.clone(entry);
	        this.dialog.openForm({
	            save: this.updateNote.bind(this),
	            data: {
	                entry: editedEntry,
	                originalEntry: entry,
	            },
	            template: __webpack_require__(141),
	        });
	    };
	    MessageLogController.prototype.updateNote = function (data) {
	        return this.messageLog.updateMessage(data.entry);
	    };
	    MessageLogController.prototype.saveNote = function (data) {
	        return this.messageLog.addMessage(data.entry);
	    };
	    MessageLogController.$inject = [__dialog.serviceName, '$scope', messageLog_service_1.factoryName];
	    return MessageLogController;
	}());
	exports.MessageLogController = MessageLogController;
	messageLog.$inject = [
	    '$interpolate',
	    jquery_service_1.serviceName,
	    templateLoader_service_1.serviceName,
	    __object.serviceName,
	];
	function messageLog($interpolate, jquery, templateLoader, object) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(142),
	        transclude: true,
	        controller: exports.controllerName,
	        controllerAs: 'log',
	        scope: {
	            messageData: "=",
	        },
	        bindToController: {
	            service: '=',
	            selector: '=',
	            pageSize: '=',
	            messageLogBinding: '=messageLog',
	            messageAs: "@",
	            currentUser: '=?',
	            canDelete: '=?',
	            canEdit: '=?',
	        },
	        link: function (scope, element, attributes, controller, transclude) {
	            controller.templates = templateLoader.loadTemplates(transclude).templates;
	        }
	    };
	}
	exports.messageLog = messageLog;
	//# sourceMappingURL=messageLog.directive.js.map

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var autosave = __webpack_require__(17);
	exports.autosave = autosave;
	var autosaveAction = __webpack_require__(19);
	exports.autosaveAction = autosaveAction;
	var breakpoints = __webpack_require__(135);
	exports.breakpoints = breakpoints;
	var componentValidator = __webpack_require__(112);
	exports.componentValidator = componentValidator;
	var contentProvider = __webpack_require__(139);
	exports.contentProvider = contentProvider;
	var dialog = __webpack_require__(117);
	exports.dialog = dialog;
	var documentWrapper = __webpack_require__(140);
	exports.documentWrapper = documentWrapper;
	var form = __webpack_require__(23);
	exports.form = form;
	var jquery = __webpack_require__(126);
	exports.jquery = jquery;
	var templateLoader = __webpack_require__(127);
	exports.templateLoader = templateLoader;
	var windowWrapper = __webpack_require__(136);
	exports.windowWrapper = windowWrapper;
	exports.moduleName = 'rl.ui.services';
	angular.module(exports.moduleName, [
	    autosave.moduleName,
	    autosaveAction.moduleName,
	    breakpoints.moduleName,
	    componentValidator.moduleName,
	    contentProvider.moduleName,
	    dialog.moduleName,
	    documentWrapper.moduleName,
	    form.moduleName,
	    jquery.moduleName,
	    templateLoader.moduleName,
	    windowWrapper.moduleName,
	]);
	//# sourceMappingURL=services.module.js.map

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var windowWrapper_service_1 = __webpack_require__(136);
	var visibleBreakpoint_service_1 = __webpack_require__(137);
	var breakpoints_service_1 = __webpack_require__(138);
	__export(__webpack_require__(46));
	__export(__webpack_require__(137));
	__export(__webpack_require__(138));
	exports.moduleName = 'rl.ui.services.breakpoints';
	angular.module(exports.moduleName, [
	    typescript_angular_utilities_1.services.observable.moduleName,
	    windowWrapper_service_1.moduleName,
	])
	    .constant('resizeDebounceMilliseconds', 500)
	    .service(visibleBreakpoint_service_1.visibleBreakpointServiceName, visibleBreakpoint_service_1.VisibleBreakpointService)
	    .service(breakpoints_service_1.breakpointServiceName, breakpoints_service_1.BreakpointService);
	//# sourceMappingURL=breakpoints.module.js.map

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(12);
	exports.moduleName = 'rl.ui.services.windowWrapper';
	exports.serviceName = 'windowWrapper';
	var WindowService = (function () {
	    function WindowService() {
	        this.windowControl = $(window);
	    }
	    WindowService.prototype.resize = function (callback) {
	        this.windowControl.resize(callback);
	    };
	    WindowService.prototype.scrollTop = function () {
	        return this.windowControl.scrollTop();
	    };
	    WindowService.prototype.scroll = function (handler) {
	        this.windowControl.scroll(handler);
	    };
	    WindowService.prototype.height = function () {
	        return this.windowControl.height();
	    };
	    return WindowService;
	}());
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, WindowService);
	//# sourceMappingURL=windowWrapper.service.js.map

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $ = __webpack_require__(12);
	/*
	 * Implementation also requires the following elements to be inserted on the page:
	 *   <div class="device-xs visible-xs"></div>
	 *   <div class="device-sm visible-sm"></div>
	 *   <div class="device-md visible-md"></div>
	 *   <div class="device-lg visible-lg"></div>
	 * They have been inserted into index.html for your convenience.
	 */
	exports.visibleBreakpointServiceName = 'visibleBreakpoint';
	var VisibleBreakpointService = (function () {
	    function VisibleBreakpointService() {
	    }
	    VisibleBreakpointService.prototype.isVisible = function (breakpoint) {
	        // jquery gets the breakpoint trigger directives listed above on line 3
	        return $('.device-' + breakpoint).is(':visible');
	    };
	    return VisibleBreakpointService;
	}());
	exports.VisibleBreakpointService = VisibleBreakpointService;
	//# sourceMappingURL=visibleBreakpoint.service.js.map

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var windowWrapper_service_1 = __webpack_require__(136);
	var visibleBreakpoint_service_1 = __webpack_require__(137);
	var breakpoint_1 = __webpack_require__(46);
	exports.breakpointServiceName = 'breakpoints';
	var __observable = typescript_angular_utilities_1.services.observable;
	var BreakpointService = (function () {
	    function BreakpointService($rootScope, visibleBreakpoints, resizeDebounceMilliseconds, windowService, observableFactory) {
	        var _this = this;
	        this.$rootScope = $rootScope;
	        this.visibleBreakpoints = visibleBreakpoints;
	        this.updateBreakpoint = function () {
	            var newBreakPoint = _this.getBreakpoint();
	            if (newBreakPoint !== _this.currentBreakpoint) {
	                _this.$rootScope.$apply(function () {
	                    _this.currentBreakpoint = newBreakPoint;
	                    _this.observable.fire('window.breakpointChanged', _this.currentBreakpoint);
	                });
	            }
	        };
	        this.currentBreakpoint = this.getBreakpoint();
	        this.observable = observableFactory.getInstance();
	        var efficientResize = _.debounce(this.updateBreakpoint, resizeDebounceMilliseconds, {
	            leading: true,
	            trailing: true,
	            maxWait: resizeDebounceMilliseconds,
	        });
	        windowService.resize(efficientResize);
	    }
	    BreakpointService.prototype.getBreakpoint = function () {
	        if (this.visibleBreakpoints.isVisible(breakpoint_1.lg)) {
	            return breakpoint_1.lg;
	        }
	        else if (this.visibleBreakpoints.isVisible(breakpoint_1.md)) {
	            return breakpoint_1.md;
	        }
	        else if (this.visibleBreakpoints.isVisible(breakpoint_1.sm)) {
	            return breakpoint_1.sm;
	        }
	        else {
	            return breakpoint_1.xs;
	        }
	    };
	    BreakpointService.prototype.isBreakpoint = function (breakpoint) {
	        return this.currentBreakpoint === breakpoint;
	    };
	    BreakpointService.prototype.register = function (action) {
	        return this.observable.register(action, 'window.breakpointChanged');
	    };
	    BreakpointService.$inject = ['$rootScope', visibleBreakpoint_service_1.visibleBreakpointServiceName, 'resizeDebounceMilliseconds', windowWrapper_service_1.serviceName, __observable.factoryName];
	    return BreakpointService;
	}());
	exports.BreakpointService = BreakpointService;
	//# sourceMappingURL=breakpoints.service.js.map

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path="../../../typings/jquery/jquery.d.ts" />
	'use strict';
	var ng = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	exports.moduleName = 'rl.utilities.services.contentProvider';
	exports.serviceName = 'contentProviderFactory';
	var ContentProviderService = (function () {
	    function ContentProviderService(observableFactory) {
	        var _this = this;
	        this.setTranscludeContent = function (transcludeFunction) {
	            var scope = null;
	            if (_.isFunction(transcludeFunction)) {
	                transcludeFunction(function (clone, transcludeScope) {
	                    _this.setContent(clone, transcludeScope);
	                });
	            }
	            else {
	                _this.setContent(null);
	            }
	        };
	        this.observable = observableFactory.getInstance();
	    }
	    ContentProviderService.prototype.setContent = function (content, scope) {
	        this.content = content;
	        this.scope = scope;
	        this.observable.fire('contentChanged');
	    };
	    ContentProviderService.prototype.register = function (action, selector) {
	        var _this = this;
	        if (this.content != null) {
	            action(this.getContent(selector), this.scope);
	        }
	        return this.observable.register(function () {
	            action(_this.getContent(selector), _this.scope);
	        }, 'contentChanged');
	    };
	    ContentProviderService.prototype.getContent = function (selector) {
	        if (selector != null) {
	            return this.content.filter(selector);
	        }
	        return this.content;
	    };
	    return ContentProviderService;
	}());
	contentProviderServiceFactory.$inject = [__observable.factoryName];
	function contentProviderServiceFactory(observableFactory) {
	    'use strict';
	    return {
	        getInstance: function () {
	            return new ContentProviderService(observableFactory);
	        }
	    };
	}
	ng.module(exports.moduleName, [__observable.moduleName])
	    .factory(exports.serviceName, contentProviderServiceFactory);
	//# sourceMappingURL=contentProvider.service.js.map

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var $ = __webpack_require__(12);
	exports.moduleName = 'rl.ui.services.documentWrapper';
	exports.serviceName = 'documentWrapper';
	var DocumentService = (function () {
	    function DocumentService() {
	        this.documentControl = $(document);
	    }
	    DocumentService.prototype.height = function () {
	        return this.documentControl.height();
	    };
	    return DocumentService;
	}());
	angular.module(exports.moduleName, [])
	    .service(exports.serviceName, DocumentService);
	//# sourceMappingURL=documentWrapper.service.js.map

/***/ },
/* 141 */
/***/ function(module, exports) {

	module.exports = "<rl-dialog autosave=\"true\">\r\n\t<rl-dialog-content>\r\n\t\t<ng-form name=\"noteForm\">\r\n\t\t\t<div class=\"form-group\">\r\n\t\t\t\t<rl-textbox ng-model=\"dialog.entry.message\" label=\"Message:\" maxlength=\"250\"></rl-textbox>\r\n\t\t\t</div>\r\n\t\t</ng-form>\r\n\t</rl-dialog-content>\r\n</rl-dialog>"

/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = "<div>\r\n\t<rl-busy loading=\"log.loadingInitial\" size=\"2x\"></rl-busy>\r\n\t<div class=\"content-group\" ng-repeat=\"entry in log.messages\" rl-alias=\"entry as {{log.messageAs}}\" ng-class=\"{ 'system-note': entry.isSystemNote }\">\r\n\t\t<rl-generic-container selector=\"log.getEntrySelector(entry)\" templates=\"log.templates\">\r\n\t\t\t<template default>\r\n\t\t\t\t<div class=\"message-body\">\r\n\t\t\t\t\t<div class=\"message-content\">\r\n\t\t\t\t\t\t<div ng-bind-html=\"entry.message\"></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<span class=\"message-button\" ng-if=\"log.canDeleteEntry(entry)\">\r\n\t\t\t\t\t\t<rl-button-async type=\"message-delete flat\" action=\"log.messageLog.deleteMessage(entry)\" size=\"xs\"><i class=\"fa fa-remove\"></i></rl-button-async>\r\n\t\t\t\t\t</span>\r\n\t\t\t\t\t<span class=\"message-button\" ng-if=\"log.canEditEntry(entry)\">\r\n\t\t\t\t\t\t<rl-button-async type=\"message-delete-button flat\" action=\"log.editMessage(entry)\" size=\"xs\"><i class=\"fa fa-edit\"></i></rl-button-async>\r\n\t\t\t\t\t</span>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"message-byline\">\r\n\t\t\t\t\t<div class=\"byline\">{{entry.createdBy.name}}</div>\r\n\t\t\t\t\t<div class=\"byline\">{{entry.createdDate | date:'short'}} UTC <span  ng-if=\"entry.edited\" class=\"edited-note\" uib-tooltip=\"Last edited by: {{entry.lastUpdatedBy.name}} {{entry.lastUpdatedDate | date:'short' }} UTC\">(edited)</span></div>\r\n\t\t\t\t</div>\r\n\t\t\t</template>\r\n\t\t</rl-generic-container>\r\n\t</div>\r\n\t<div class=\"content-group\" ng-if=\"(log.messages | isEmpty) && !log.loadingInitial\">No existing messages</div>\r\n\t<div class=\"row\">\r\n\t\t<div class=\"col-xs-12\">\r\n\t\t\t<div class=\"text-center\">\r\n\t\t\t\t<rl-button-async action=\"log.getTop()\" ng-disabled=\"log.loading\" button-right-aligned=\"true\">\r\n\t\t\t\t\t<span ng-show=\"log.hasPreviousPage\">Top <i class=\"fa fa-caret-up\"></i></span>\r\n\t\t\t\t\t<span ng-hide=\"log.hasPreviousPage\"><i class=\"fa fa-refresh\"></i> Refresh</span>\r\n\t\t\t\t</rl-button-async>\r\n\t\t\t\t<rl-button-async ng-disabled=\"log.hasNextPage == false || log.loading\" action=\"log.getOlder()\">\r\n\t\t\t\t\tOlder <i class=\"fa fa-caret-right\"></i>\r\n\t\t\t\t</rl-button-async>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</div>\r\n</div>\r\n"

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var messageLog_service_1 = __webpack_require__(132);
	exports.directiveName = 'rlEditableMessageLog';
	exports.controllerName = 'EditableMessageLogController';
	var __object = typescript_angular_utilities_1.services.object;
	;
	var EditableMessageLogController = (function () {
	    function EditableMessageLogController($scope, messageLogFactory, object) {
	        var _this = this;
	        this.object = object;
	        this.messageLogService = messageLogFactory.getInstance();
	        $scope.$watch(function () { return _this.messageLogService.busy; }, function (value) {
	            if (value === false) {
	                _this.busy = false;
	                _this.savingMessage = false;
	            }
	            else {
	                _this.busy = true;
	            }
	        });
	    }
	    EditableMessageLogController.prototype.add = function () {
	        if (this.object.isNullOrWhitespace(this.newMessage)) {
	            return null;
	        }
	        this.savingMessage = true;
	        var message = this.newMessage;
	        this.newMessage = '';
	        return this.messageLogService.addMessage({ message: message });
	    };
	    EditableMessageLogController.$inject = ['$scope', messageLog_service_1.factoryName, __object.serviceName];
	    return EditableMessageLogController;
	}());
	exports.EditableMessageLogController = EditableMessageLogController;
	function editableMessageLog() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<form ng-submit=\"log.add()\">\n\t\t\t\t<div class=\"input-group\">\n\t\t\t\t\t<input type=\"text\" class=\"form-control\" ng-model=\"log.newMessage\" placeholder=\"Enter log message\" />\n\t\t\t\t\t<span class=\"input-group-btn\">\n\t\t\t\t\t\t<button class=\"btn btn-default\" type=\"submit\" ng-disabled=\"log.busy\">\n\t\t\t\t\t\t\t<rl-busy loading=\"log.savingMessage\"></rl-busy> Add\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"message-log\">\n\t\t\t\t\t<rl-message-log service=\"log.service\" page-size=\"log.pageSize\" message-log=\"log.messageLogService\"\n\t\t\t\t\t\t\t\t\tcurrent-user=\"log.currentUser\" can-delete=\"log.canDelete\"></rl-message-log>\n\t\t\t\t</div>\n\t\t\t</form>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'log',
	        scope: {},
	        bindToController: {
	            service: '=',
	            pageSize: '=',
	            currentUser: '=?',
	            canDelete: '=?',
	        },
	    };
	}
	exports.editableMessageLog = editableMessageLog;
	//# sourceMappingURL=editableMessageLog.js.map

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	exports.moduleName = 'rl.ui.components.multiStepIndicator';
	exports.directiveName = 'rlMultiStepIndicator';
	exports.controllerName = 'MultiStepIndicatorController';
	var __object = typescript_angular_utilities_1.services.object;
	var MultiStepIndicatorController = (function () {
	    function MultiStepIndicatorController($state, $q, object) {
	        this.$state = $state;
	        this.$q = $q;
	        this.object = object;
	        this.configureSteps();
	    }
	    MultiStepIndicatorController.prototype.onClick = function (step) {
	        if (!this.anyLoading()) {
	            step.loading = true;
	            this.$q.when(step.onClick()).then(function () {
	                step.loading = false;
	            });
	        }
	    };
	    MultiStepIndicatorController.prototype.anyLoading = function () {
	        return _.some(this.steps, function (step) {
	            return step.loading;
	        });
	    };
	    MultiStepIndicatorController.prototype.configureSteps = function () {
	        var _this = this;
	        _.each(this.steps, function (step) {
	            step.hasCount = _.isFunction(step.count);
	            step.getCompleted = function () { return _this.getIsCompleted(step); };
	            step.getValid = function () { return _this.getIsValid(step); };
	            if (!_.isFunction(step.onClick)) {
	                if (_this.object.isNullOrWhitespace(step.stateName)) {
	                    step.inactive = true;
	                }
	                else {
	                    step.onClick = function () { return _this.redirectToState(step); };
	                    if (_this.$state.includes(step.stateName)) {
	                        step.isCurrent = true;
	                    }
	                }
	            }
	        });
	    };
	    MultiStepIndicatorController.prototype.redirectToState = function (step) {
	        var _this = this;
	        return this.$state.go(step.stateName).then(function () {
	            _this.clearCurrentState();
	            step.isCurrent = true;
	        });
	    };
	    MultiStepIndicatorController.prototype.clearCurrentState = function () {
	        _.each(this.steps, function (step) {
	            step.isCurrent = false;
	        });
	    };
	    MultiStepIndicatorController.prototype.getIsCompleted = function (step) {
	        return _.isFunction(step.isCompleted)
	            ? step.isCompleted()
	            : step.isCompleted;
	    };
	    MultiStepIndicatorController.prototype.setIsCompleted = function (step, isCompleted) {
	        if (!_.isFunction(step.isCompleted)) {
	            step.isCompleted = isCompleted;
	        }
	    };
	    MultiStepIndicatorController.prototype.getIsValid = function (step) {
	        if (_.isFunction(step.isValid)) {
	            return step.isValid();
	        }
	        else if (!_.isUndefined(step.isValid != null)) {
	            return step.isValid;
	        }
	        else {
	            return true;
	        }
	    };
	    MultiStepIndicatorController.$inject = ['$state', '$q', __object.serviceName];
	    return MultiStepIndicatorController;
	}());
	exports.MultiStepIndicatorController = MultiStepIndicatorController;
	function multiStepIndicator() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(145),
	        controller: exports.controllerName,
	        controllerAs: 'breadcrumb',
	        scope: {},
	        bindToController: {
	            steps: '=',
	            numbered: '=',
	        },
	    };
	}
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, multiStepIndicator)
	    .controller(exports.controllerName, MultiStepIndicatorController);
	//# sourceMappingURL=multiStepIndicator.js.map

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = "<div class=\"multi-step checked\" ng-class=\"{ 'numbered': breadcrumb.numbered }\">\r\n\t<ol>\r\n\t\t<li ng-repeat=\"step in breadcrumb.steps\" ng-click=\"breadcrumb.onClick(step)\"\r\n\t\t\tng-class=\"{ 'completed': step.getCompleted(), 'current': step.isCurrent, 'active': !step.inactive && !breadcrumb.anyLoading() }\">\r\n\t\t\t<div class=\"wrap\">\r\n\t\t\t\t<p class=\"badge\" ng-show=\"step.hasCount\">{{step.count()}}</p>\r\n\t\t\t\t<p class=\"error\" ng-if=\"!step.getValid()\"></p>\r\n\t\t\t\t<p class=\"title\">{{step.title}} <rl-busy loading=\"step.loading\"></rl-busy></p>\r\n\t\t\t\t<p class=\"subtitle\">{{step.subtitle}}</p>\r\n\t\t\t</div>\r\n\t\t</li>\r\n\t</ol>\r\n</div>"

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var radioGroup_1 = __webpack_require__(147);
	exports.radioGroupDirectiveName = radioGroup_1.directiveName;
	exports.radioGroup = radioGroup_1.radioGroup;
	exports.radioGroupControllerName = radioGroup_1.controllerName;
	exports.RadioGroupController = radioGroup_1.RadioGroupController;
	var radio_1 = __webpack_require__(148);
	exports.radioDirectiveName = radio_1.directiveName;
	exports.radio = radio_1.radio;
	exports.radioControllerName = radio_1.controllerName;
	exports.RadioController = radio_1.RadioController;
	exports.moduleName = 'rl21.components.radio';
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(radioGroup_1.directiveName, radioGroup_1.radioGroup)
	    .controller(radioGroup_1.controllerName, radioGroup_1.RadioGroupController)
	    .directive(radio_1.directiveName, radio_1.radio)
	    .controller(radio_1.controllerName, radio_1.RadioController);
	//# sourceMappingURL=radio.module.js.map

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	exports.directiveName = 'rlRadioGroup';
	exports.controllerName = 'RadioGroupController';
	var RadioGroup = (function () {
	    function RadioGroup($scope, ngModel, name) {
	        var _this = this;
	        this.name = name;
	        $scope.$watch(function () { return ngModel.$viewValue; }, function (value) {
	            _this.selection = value;
	        });
	        $scope.$watch(function () { return _this.selection; }, function (value) {
	            ngModel.$setViewValue(value);
	        });
	    }
	    return RadioGroup;
	}());
	exports.RadioGroup = RadioGroup;
	var RadioGroupController = (function () {
	    function RadioGroupController($scope, $attrs, $element, object) {
	        var name;
	        if (!object.isNullOrWhitespace($attrs.rlRadioGroup)) {
	            name = $attrs.rlRadioGroup;
	        }
	        else if (!object.isNullOrWhitespace($attrs.name)) {
	            name = $attrs.name;
	        }
	        else {
	            name = 'RadioGroup' + this.getNextId();
	        }
	        var ngModel = $element.controller('ngModel');
	        this.group = new RadioGroup($scope, ngModel, name);
	    }
	    RadioGroupController.prototype.registerButton = function () {
	        return this.group;
	    };
	    RadioGroupController.prototype.getNextId = function () {
	        var nextId = RadioGroupController.nextId.toString();
	        RadioGroupController.nextId++;
	        return nextId;
	    };
	    RadioGroupController.nextId = 1;
	    RadioGroupController.$inject = ['$scope', '$attrs', '$element', __object.serviceName];
	    return RadioGroupController;
	}());
	exports.RadioGroupController = RadioGroupController;
	function radioGroup() {
	    'use strict';
	    return {
	        restrict: 'AE',
	        require: 'ngModel',
	        controller: exports.controllerName,
	    };
	}
	exports.radioGroup = radioGroup;
	//# sourceMappingURL=radioGroup.js.map

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var radioGroup_1 = __webpack_require__(147);
	exports.directiveName = 'rlRadio';
	exports.controllerName = 'RadioController';
	var RadioController = (function () {
	    function RadioController($scope, $element) {
	        var radioGroupController = $element.controller('rlRadioGroup');
	        if (radioGroupController != null) {
	            this.radioGroup = radioGroupController.registerButton();
	        }
	        else {
	            var ngModel = $element.controller('ngModel');
	            this.radioGroup = new radioGroup_1.RadioGroup($scope, ngModel);
	        }
	    }
	    RadioController.$inject = ['$scope', '$element'];
	    return RadioController;
	}());
	exports.RadioController = RadioController;
	function radio() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: ['?^^rlRadioGroup', '?ngModel'],
	        transclude: true,
	        template: "\n\t\t\t<label>\n\t\t\t\t<input id=\"radio\" type=\"radio\" name=\"{{radio.radioGroup.name}}\" ng-model=\"radio.radioGroup.selection\" ng-value=\"radio.value\" />\n\t\t\t\t<span ng-transclude></div>\n\t\t\t</label>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'radio',
	        scope: true,
	        bindToController: {
	            value: '=',
	        },
	    };
	}
	exports.radio = radio;
	//# sourceMappingURL=radio.js.map

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var ratingBarBackgrounds_service_1 = __webpack_require__(150);
	var ratingBarClass_service_1 = __webpack_require__(151);
	exports.moduleName = 'rl.ui.components.ratingBar';
	exports.directiveName = 'rlRatingBar';
	exports.controllerName = 'RatingBarController';
	var RatingBarController = (function () {
	    function RatingBarController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        var ratingBarBackgrounds = new ratingBarBackgrounds_service_1.RatingBarBackgroundService;
	        this.ratingBarClass = new ratingBarClass_service_1.RatingBarClassService;
	        this.backgroundClass = ratingBarBackgrounds.getBackground(this.background);
	        if (this.value == null) {
	            this.value = 0;
	        }
	        $scope.$watch(function () { return _this.value; }, function (newValue) {
	            _this.updateValue(newValue);
	        });
	        $scope.$watch(function () { return _this.totalWidth; }, function (newWidth) {
	            _this.dimensions = {
	                width: newWidth + 2,
	                height: _this.height + 2,
	            };
	            _this.updateValue(_this.value);
	        });
	    }
	    RatingBarController.prototype.updateValue = function (newValue) {
	        var confidenceScore = (newValue - this.min) / (this.max - this.min);
	        this.barClass = this.ratingBarClass.getClass(confidenceScore);
	        this.width = Math.round(confidenceScore * this.totalWidth);
	    };
	    RatingBarController.$inject = ['$scope'];
	    return RatingBarController;
	}());
	exports.RatingBarController = RatingBarController;
	function ratingBar() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<div class=\"rating-bar\">\n\t\t\t\t<div class=\"{{ratingBar.backgroundClass}}\" ng-class=\"{ empty: ratingBar.value == min }\" ng-style=\"ratingBar.dimensions\">\n\t\t\t\t\t<div ng-class=\"ratingBar.barClass\" ng-style=\"{ width: ratingBar.width, height: ratingBar.height }\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'ratingBar',
	        scope: {},
	        bindToController: {
	            totalWidth: '=width',
	            height: '=',
	            value: '=',
	            min: '=',
	            max: '=',
	            background: '=',
	        },
	    };
	}
	exports.ratingBar = ratingBar;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, ratingBar)
	    .controller(exports.controllerName, RatingBarController);
	//# sourceMappingURL=ratingBar.js.map

/***/ },
/* 150 */
/***/ function(module, exports) {

	'use strict';
	var RatingBarBackgroundService = (function () {
	    function RatingBarBackgroundService() {
	        this.standard = {
	            type: 'standard',
	            class: 'background',
	        };
	        this.dark = {
	            type: 'dark',
	            class: 'background-dark',
	        };
	        this.transparent = {
	            type: 'transparent',
	            class: 'background-transparent',
	        };
	    }
	    RatingBarBackgroundService.prototype.getBackground = function (type) {
	        if (type === this.dark.type) {
	            return this.dark.class;
	        }
	        else if (type === this.transparent.type) {
	            return this.transparent.class;
	        }
	        else {
	            return this.standard.class;
	        }
	    };
	    return RatingBarBackgroundService;
	}());
	exports.RatingBarBackgroundService = RatingBarBackgroundService;
	//# sourceMappingURL=ratingBarBackgrounds.service.js.map

/***/ },
/* 151 */
/***/ function(module, exports) {

	'use strict';
	var RatingBarClassService = (function () {
	    function RatingBarClassService() {
	    }
	    RatingBarClassService.prototype.getClass = function (confidence) {
	        if (confidence >= 0.8) {
	            return 'very-high';
	        }
	        else if (confidence >= 0.6) {
	            return 'high';
	        }
	        else if (confidence >= 0.4) {
	            return 'medium';
	        }
	        else if (confidence >= 0.2) {
	            return 'low';
	        }
	        else {
	            return 'very-low';
	        }
	    };
	    return RatingBarClassService;
	}());
	exports.RatingBarClassService = RatingBarClassService;
	//# sourceMappingURL=ratingBarClass.service.js.map

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	__webpack_require__(153);
	__webpack_require__(155);
	__webpack_require__(156);
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var input_1 = __webpack_require__(158);
	var componentValidator_service_1 = __webpack_require__(112);
	var richTextEditor_config_1 = __webpack_require__(159);
	var headerButton_1 = __webpack_require__(160);
	var paragraphButton_1 = __webpack_require__(161);
	var externalProviderName = richTextEditor_config_1.providerName + 'Provider';
	exports.providerName = externalProviderName;
	exports.moduleName = 'rl.ui.components.richTextEditor';
	exports.componentName = 'rlRichTextEditor';
	exports.controllerName = 'RichTextEditorController';
	var RichTextEditorController = (function (_super) {
	    __extends(RichTextEditorController, _super);
	    function RichTextEditorController($scope, $attrs, componentValidatorFactory, object, provider) {
	        _super.call(this, $scope, $attrs, componentValidatorFactory);
	        this.inputType = 'rich-text-editor';
	        this.toolbar = 'h1, paragraph, bold, italic, underline, list1, list2, indent, outdent';
	        if (!object.isNullOrEmpty(this.customButtons)) {
	            this.toolbar += ', ' + this.customButtons;
	        }
	    }
	    RichTextEditorController.$inject = ['$scope', '$attrs', componentValidator_service_1.factoryName, __object.serviceName, richTextEditor_config_1.providerName];
	    return RichTextEditorController;
	}(input_1.InputController));
	exports.RichTextEditorController = RichTextEditorController;
	var richTextEditor = _.clone(input_1.input);
	richTextEditor.template = __webpack_require__(162);
	richTextEditor.controller = exports.controllerName;
	richTextEditor.controllerAs = 'editor';
	var richTextEditorBindings = richTextEditor.bindings;
	richTextEditorBindings.customButtons = '<?';
	richTextEditorBindings.ngDisabled = '<?';
	angular.module(exports.moduleName, ['ngWig', __object.moduleName, input_1.moduleName])
	    .component(exports.componentName, richTextEditor)
	    .controller(exports.controllerName, RichTextEditorController)
	    .directive(headerButton_1.headerButtonDirectiveName, headerButton_1.headerButton)
	    .directive(paragraphButton_1.paragraphButtonDirectiveName, paragraphButton_1.paragraphButton)
	    .provider(richTextEditor_config_1.providerName, richTextEditor_config_1.richTextEditorProvider);
	//# sourceMappingURL=richTextEditor.js.map

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(154);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./ng-wig.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./ng-wig.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	exports.push([module.id, "@import url(https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css);", ""]);
	
	// module
	exports.push([module.id, "/* -------- NG-WIG -------- */\n/**\n *\n *  RESET BOX MODEL\n *\n */\n.ng-wig,\n[class^=\"nw-\"] {\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  -o-box-sizing: border-box;\n  -ms-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n\n/**\n *   main wrapper for the editor\n *\n *  .ng-wig\n *\n */\n.ng-wig {\n  display: block;\n  padding: 0;\n  margin: 0;\n}\n\n\n/**\n *  styling for toolbar and its items\n *\n *  .nw-toolbar\n *    &__item\n *\n */\n.nw-toolbar {\n  display: block;\n  margin: 0 !important;\n  padding: 0 !important;\n  list-style: none !important;\n  font-size: 12px;\n  color: #6B7277;\n\n  background: -webkit-linear-gradient(90deg, #ffffff 0%, #f9f9f9 100%);\n  background:    -moz-linear-gradient(90deg, #ffffff 0%, #f9f9f9 100%);\n  background:         linear-gradient(180deg, #ffffff 0%, #f9f9f9 100%);\n  border: 1px solid #CCCCCC;\n  border-radius: 3px 3px 0 0;\n}\n\n.nw-toolbar__item {\n  display: inline-block;\n  vertical-align: top;\n  margin: 0;\n\n  border-right: 1px solid #DEDEDE;\n}\n\n.nw-toolbar label {\n  line-height: 30px;\n  display: inline-block;\n  padding: 0 6px 0 3px;\n}\n\n.nw-toolbar input[type=checkbox] {\n  vertical-align: -3px;\n  margin-right: -1px;\n}\n\n/**\n *  styling for the editor part: source code (original textarea) and resulting div\n *\n *  .nw-editor\n *    &__src\n *    &__res\n *\n */\n.nw-editor {\n  display: table;\n  /* Default when height is not set */\n  height: 300px;\n  background: #fff;\n  cursor: text;\n  width:100%;\n}\n\n.nw-editor-container {\n  border: 1px solid #CCCCCC;\n  border-top: none;\n  border-radius: 0 0 3px 3px;\n  position: relative;\n}\n\n.nw-editor__res {\n  min-height: 100%;\n  padding: 0 8px;\n  display: table-cell;\n}\n\n.nw-editor__src,\n.nw-editor__res {\n  width: 100%;\n  outline: none;\n  box-sizing: border-box;\n  border: none;\n  margin: 0;\n}\n\n.nw-editor__src-container {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.nw-editor__src {\n  height: 100%;\n  resize: none;\n  padding: 0 8px;\n}\n\n.nw-editor--fixed .nw-editor {\n  display:block;\n  overflow-y: auto;\n}\n\n.nw-editor--fixed .nw-editor__res {\n  padding: 1px 8px;\n  display:block;\n}\n\n.nw-invisible {\n  visibility: hidden;\n}\n\n.nw-editor--fixed .nw-invisible {\n  display: none;\n}\n\n.nw-editor.nw-disabled {\n\tcursor: default;\n}\n\n/**\n *  styling for toolbar button, has two modifiers: active and type of icon for background\n *\n *  .nw-button\n *    &--active\n *    &--{button type}\n *\n */\n.nw-button {\n  -webkit-appearance: none;\n  -moz-appearance:    none;\n  appearance:         none;\n\n  display: block;\n  width: 30px;\n  height: 30px;\n  margin: 0;\n  padding: 0;\n  opacity: 0.5;\n\n  background-color: transparent;\n  background-position: center center;\n  background-repeat: no-repeat;\n  border: none;\n  border-radius: 2px;\n\n  font-size: 0;\n\n  cursor: pointer;\n}\n\n.nw-button:before {\n  font-size: 12px;\n  font-family: FontAwesome;\n}\n\n.nw-button.bold:before {\n  content: '\\F032';\n}\n\n.nw-button.italic:before {\n  content: '\\F033';\n}\n\n.nw-button.list-ul:before {\n  content: '\\F0CA';\n}\n\n.nw-button.list-ol:before {\n  content: '\\F0CB';\n}\n\n.nw-button.link:before {\n  content: '\\F0C1';\n}\n\n.nw-button.font-color:before {\n  content: '\\F031';\n}\n\n.nw-button.nw-button--source:before {\n  content: '\\F040';\n}\n\n.nw-button:focus {\n  outline: none;\n}\n\n.nw-button:hover,\n.nw-button.nw-button--active {\n  opacity: 1\n}\n\n.nw-button--active {\n  background-color: #EEEEEE;\n}\n\n.nw-button:disabled {\n  cursor: default;\n}\n.nw-button:disabled:hover {\n  opacity: 0.5;\n}\n\n/**\n *  styling & formatting of content inside contenteditable div\n *\n *  .nw-content\n *\n */\n.nw-content {\n  padding: 12px;\n  margin: 0;\n\n  font-family: sans-serif;\n  font-size: 14px;\n  line-height: 24px;\n}\n\n.nw-select {\n  height: 30px;\n  padding: 6px;\n  color: #555;\n  background-color: inherit;\n  border: 0;\n}\n\n.nw-select:disabled {\n\topacity: 0.5;\n}\n\n.nw-select:focus { outline: none; }\n\n", ""]);
	
	// exports


/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * version: 2.3.4
	 */
	angular.module('ngWig', ['ngwig-app-templates']);
	
	angular.module('ngWig')
	  .directive('ngWig', ["$window", "$document", "ngWigToolbar", function ($window, $document, ngWigToolbar) {
	
	    return {
	      scope: {
	        content: '=ngWig',
	        onPaste: '='
	      },
	      restrict: 'A',
	      replace: true,
	      templateUrl: 'ng-wig/views/ng-wig.html',
	      link: function (scope, element, attrs) {
	        scope.formElementName = attrs.name;
	        element.removeAttr('name');
	
	        scope.isRequired = !!attrs.required;
	        scope.isSourceModeAllowed = Object.keys(attrs).indexOf('sourceModeAllowed') !== -1 ? true : false;
	        scope.editMode = false;
	        scope.toolbarButtons = ngWigToolbar.getToolbarButtons(attrs.buttons && string2array(attrs.buttons));
	
	        function string2array(keysString){
	          return keysString.split(',').map(Function.prototype.call, String.prototype.trim);
	        }
	
	        scope.toggleEditMode = function () {
	          scope.editMode = !scope.editMode;
	
	          if ($window.getSelection().removeAllRanges) {
	            $window.getSelection().removeAllRanges();
	          }
	        };
	
	        scope.execCommand = function (command, options) {
	          if(scope.editMode ) return false;
	
	          if (command === 'createlink') {
	            options = prompt('Please enter the URL', 'http://');
	            if(!options) {
	              return;
	            }
	          }
	          scope.$broadcast('execCommand', {command: command, options: options});
	        };
			
			if (attrs.ngDisabled != null || attrs.disabled != null) {
				scope.$watch(function() { return !!attrs.disabled; }, function(isDisabled) {
					scope.isDisabled = isDisabled;
					scope.$broadcast('nw-disabled', isDisabled);
				});	
			}
	      }
	    }
	  }]
	);
	
	
	angular.module('ngWig')
	  .directive('ngWigEditable', ["$document", function ($document) {
	    function init(scope, $element, attrs, ngModelController) {
	
	      $element.attr('contenteditable', true);
	
	      //model --> view
	      ngModelController.$render = function () {
	        $element.html(ngModelController.$viewValue || '');
	      };
	
	      //view --> model
	      function viewToModel() {
	        ngModelController.$setViewValue($element.html());
	      }
	
	      var eventsToBind = [
	        'blur',
	        'keyup',
	        'change',
	        'focus',
	        'click'
	      ];
	
	      if (angular.isFunction(scope.onPaste)) {
	        $element.on('paste', function(e) {
	          scope.onPaste(e, $element.html()).then(function(val) {
	            $element.html(val);
	          })
	        });
	      }else{
	        eventsToBind.push('paste');
	      }
	
	      $element.bind(eventsToBind.join(' '), function() {
	        viewToModel();
	        scope.$applyAsync();
	      });
	
	      scope.isEditorActive = function () {
	        return $element[0] === $document[0].activeElement;
	      };
	
	      scope.$on('execCommand', function (event, params) {
	        $element[0].focus();
	
	        var ieStyleTextSelection = $document[0].selection,
	          command = params.command,
	          options = params.options;
	
	        if (ieStyleTextSelection) {
	          var textRange = ieStyleTextSelection.createRange();
	        }
	
	        if ($document[0].queryCommandSupported && !$document[0].queryCommandSupported(command)) {
	          throw 'The command "' + command + '" is not supported';
	        }
	
	        $document[0].execCommand(command, false, options);
	
	        if (ieStyleTextSelection) {
	          textRange.collapse(false);
	          textRange.select();
	        }
	
	        viewToModel();
	      });
		  
		  scope.$on('nw-disabled', function(event, isDisabled) {
			  $element.attr('contenteditable', !isDisabled);
		  });
	    }
	
	    return {
	      restrict: 'A',
	      require: 'ngModel',
	      replace: true,
	      link: init
	    }
	  }]
	);
	
	angular.module('ngWig')
	    .directive('ngWigPlugin', ["$compile", function ($compile) {
	        return {
	            restrict: 'E',
	            link: function(scope, element) {
	                var template = '<' + scope.button.pluginName + ' />',
	                    compiled = $compile(template)(scope);
	
	                element.replaceWith(compiled);
	            }
	        }
	    }]);
	
	angular.module('ngWig').provider('ngWigToolbar', function () {
	
	  var buttonLibrary = {
	    list1: {title: 'Unordered List', command: 'insertunorderedlist', styleClass: 'list-ul'},
	    list2: {title: 'Ordered List', command: 'insertorderedlist', styleClass: 'list-ol'},
	    bold: {title: 'Bold', command: 'bold', styleClass: 'bold'},
	    italic: {title: 'Italic', command: 'italic', styleClass: 'italic'},
	    link: {title: 'Link', command: 'createlink', styleClass: 'link'}
	  };
	
	  var defaultButtonsList = ['list1', 'list2', 'bold', 'italic', 'link'];
	
	  var isButtonActive = function () {
	    return this.command && document.queryCommandState(this.command);
	  };
	
	  this.setButtons = function(buttons) {
	    if(!angular.isArray(buttons)) {
	      throw 'Argument "buttons" should be an array';
	    }
	
	    defaultButtonsList = buttons;
	  };
	
	  this.addStandardButton = function (name, title, command, styleClass) {
	    if(!name || !title || !command) {
	      throw 'Arguments "name", "title" and "command" are required';
	    }
	
	    styleClass = styleClass || '';
	    buttonLibrary[name] = {title: title, command: command, styleClass: styleClass}
	    defaultButtonsList.push(name);
	  };
	
	  this.addCustomButton = function (name, pluginName) {
	    if(!name || !pluginName) {
	      throw 'Arguments "name" and "pluginName" are required';
	    }
	
	    buttonLibrary[name] = {pluginName: pluginName, isComplex: true};
	    defaultButtonsList.push(name);
	  };
	
	  this.$get = function () {
	    return {
	      getToolbarButtons: function(list) {
	        var toolbarButtons = [];
	        (list || defaultButtonsList).forEach(function(buttonKey) {
	          if(!buttonLibrary[buttonKey]) {
	            throw 'There is no "' + buttonKey + '" in your library. Possible variants: ' + Object.keys(buttonLibrary);
	          }
	
	          var button = angular.copy(buttonLibrary[buttonKey]);
	
	          if(!angular.isFunction(button.isActive)) {
	            button.isActive = isButtonActive;
	          }
	
	          toolbarButtons.push(button);
	        });
	        return toolbarButtons;
	      }
	    };
	  };
	
	
	});
	angular.module('ngWig')
	    .config(['ngWigToolbarProvider', function (ngWigToolbarProvider) {
	       ngWigToolbarProvider.addCustomButton('formats', 'nw-formats-button');
	    }])
	    .directive('nwFormatsButton', function() {
	        return {
	            restrict: 'E',
	            replace: true,
	            template: '<select class="nw-select" ng-model="format" ng-change="execCommand(\'formatblock\', format.value)" ng-options="format.name for format in formats" ng-disabled="editMode || isDisabled"></select>',
	            link: function (scope) {
	                scope.formats = [
	                    {name: 'Normal text', value: 'p'},
	                    {name: 'Header 1', value: 'h1'},
	                    {name: 'Header 2', value: 'h2'},
	                    {name: 'Header 3', value: 'h3'}
	                ];
	
	                scope.format = scope.formats[0];
	            }
	        };
	    });
	
	
	angular.module('ngwig-app-templates', ['ng-wig/views/ng-wig.html']);
	
	angular.module("ng-wig/views/ng-wig.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("ng-wig/views/ng-wig.html",
	    "<div class=\"ng-wig\">\n" +
	    "  <ul class=\"nw-toolbar\">\n" +
	    "    <li class=\"nw-toolbar__item\" ng-repeat=\"button in toolbarButtons\" >\n" +
	    "        <div ng-if=\"!button.isComplex\">\n" +
	    "          <button type=\"button\" class=\"nw-button {{button.styleClass}}\" title=\"{{button.title}}\" ng-click=\"execCommand(button.command)\" ng-class=\"{ 'nw-button--active': isEditorActive() && button.isActive() }\" ng-disabled=\"editMode || isDisabled\">\n" +
	    "            {{ button.title }}\n" +
	    "          </button>\n" +
	    "        </div>\n" +
	    "        <div ng-if=\"button.isComplex\">\n" +
	    "          <ng-wig-plugin plugin=\"{{button}}\"></ng-wig-plugin>\n" +
	    "        </div>\n" +
	    "    </li><!--\n" +
	    "    --><li class=\"nw-toolbar__item\">\n" +
	    "      <button type=\"button\" class=\"nw-button nw-button--source\" title=\"Edit HTML\" ng-class=\"{ 'nw-button--active': editMode }\" ng-show=\"isSourceModeAllowed\" ng-click=\"toggleEditMode()\" ng-disabled=\"isDisabled\">\n" +
	    "        Edit HTML\n" +
	    "      </button>\n" +
	    "    </li>\n" +
	    "  </ul>\n" +
	    "\n" +
	    "  <div class=\"nw-editor-container\">\n" +
	    "    <div class=\"nw-editor__src-container\" ng-show=\"editMode\">\n" +
	    "      <textarea ng-required=\"isRequired\" ng-disabled=\"isDisabled\" class=\"nw-editor__src\" ng-model=\"content\"></textarea>\n" +
	    "    </div>\n" +
	    "    <div class=\"nw-editor\" ng-class=\"{ 'nw-disabled': isDisabled }\">\n" +
	    "      <div name=\"{{formElementName}}\" ng-required=\"isRequired\" tabindex=\"-1\" ng-class=\"{'nw-invisible': editMode}\" class=\"nw-editor__res\" ng-model=\"content\" ng-wig-editable on-paste=\"onPaste\"></div>\n" +
	    "    </div>\n" +
	    "  </div>\n" +
	    "</div>\n" +
	    "");
	}]);


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(157);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./editorButtons.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./editorButtons.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, ".nw-button.header:before {\r\n  content: '\\F1DC'; /* fa-header */\r\n}\r\n\r\n.nw-button.paragraph:before {\r\n  content: '\\F1DD'; /* fa-paragraph */\r\n}", ""]);
	
	// exports


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __guid = typescript_angular_utilities_1.services.guid;
	var required_1 = __webpack_require__(25);
	var componentValidator_service_1 = __webpack_require__(112);
	exports.moduleName = 'rl.ui.components.input';
	exports.controllerName = 'InputController';
	var InputController = (function () {
	    function InputController($scope, $attrs, componentValidatorFactory) {
	        this.$scope = $scope;
	        this.$attrs = $attrs;
	        this.componentValidatorFactory = componentValidatorFactory;
	        this.inputType = 'input';
	    }
	    Object.defineProperty(InputController.prototype, "inputValue", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            this.ngModel.$setViewValue(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    InputController.prototype.$onInit = function () {
	        var _this = this;
	        var validators = [];
	        if (!_.isUndefined(this.validator)) {
	            validators.push(this.validator);
	        }
	        if (__object.objectUtility.isNullOrEmpty(this.$attrs.name)) {
	            this.$attrs.$set('name', this.inputType + '-' + __guid.guid.random());
	        }
	        if (this.required != null) {
	            validators.push({
	                name: 'rlRequired',
	                validate: function () { return !__object.objectUtility.isNullOrEmpty(_this.ngModel.$viewValue); },
	                errorMessage: this.required.message,
	            });
	        }
	        if (_.some(validators)) {
	            this.inputValidator = this.componentValidatorFactory.getInstance({
	                ngModel: this.ngModel,
	                $scope: this.$scope,
	                validators: validators,
	            });
	        }
	    };
	    InputController.$inject = ['$scope', '$attrs', componentValidator_service_1.factoryName];
	    return InputController;
	}());
	exports.InputController = InputController;
	exports.input = {
	    require: {
	        ngModel: 'ngModel',
	        required: '?' + required_1.directiveName,
	    },
	    template: '',
	    controller: exports.controllerName,
	    controllerAs: 'input',
	    bindings: {
	        validator: '<?',
	        label: '@',
	        name: '@',
	    },
	};
	angular.module(exports.moduleName, [componentValidator_service_1.moduleName])
	    .controller(exports.controllerName, InputController);
	//# sourceMappingURL=input.js.map

/***/ },
/* 159 */
/***/ function(module, exports) {

	'use strict';
	exports.providerName = 'richTextEditor';
	richTextEditorProvider.$inject = ['ngWigToolbarProvider'];
	function richTextEditorProvider(ngWigToolbarProvider) {
	    'use strict';
	    return {
	        addCustomButton: function (name, component) {
	            ngWigToolbarProvider.addCustomButton(name, component);
	        },
	        addStandardButton: function (name, tooltip, command, icon) {
	            ngWigToolbarProvider.addStandardButton(name, toolbar, command, 'fa-' + icon);
	        },
	        $get: function () {
	            ngWigToolbarProvider.addCustomButton('paragraph', 'rl-paragraph-button');
	            ngWigToolbarProvider.addCustomButton('h1', 'rl-header-button');
	            ngWigToolbarProvider.addStandardButton('underline', 'Underline', 'underline', 'fa-underline');
	            ngWigToolbarProvider.addStandardButton('indent', 'Indent', 'indent', 'fa-indent');
	            ngWigToolbarProvider.addStandardButton('outdent', 'Outdent', 'outdent', 'fa-outdent');
	        },
	    };
	}
	exports.richTextEditorProvider = richTextEditorProvider;
	//# sourceMappingURL=richTextEditor.config.js.map

/***/ },
/* 160 */
/***/ function(module, exports) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.headerButtonDirectiveName = 'rlHeaderButton';
	function headerButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<button type=\"button\" class=\"nw-button header\" ng-click=\"trigger()\" ng-disabled=\"editMode || isDisabled\" title=\"Header 1\"></button>\n\t\t",
	        link: function (scope) {
	            scope.trigger = function () {
	                scope.execCommand('formatblock', 'h1');
	            };
	        },
	    };
	}
	exports.headerButton = headerButton;
	//# sourceMappingURL=headerButton.js.map

/***/ },
/* 161 */
/***/ function(module, exports) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.paragraphButtonDirectiveName = 'rlParagraphButton';
	function paragraphButton() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<button type=\"button\" class=\"nw-button paragraph\" ng-click=\"trigger()\" ng-disabled=\"editMode || isDisabled\" title=\"paragraph\"></button>\n\t\t",
	        link: function (scope) {
	            scope.trigger = function () {
	                scope.execCommand('formatblock', 'p');
	            };
	        },
	    };
	}
	exports.paragraphButton = paragraphButton;
	//# sourceMappingURL=paragraphButton.js.map

/***/ },
/* 162 */
/***/ function(module, exports) {

	module.exports = "<textarea class=\"rich-text-editor\" ng-wig=\"editor.ngModel\" buttons=\"{{editor.toolbar}}\" ng-disabled=\"editor.ngDisabled\"></textarea>"

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	__webpack_require__(164);
	__webpack_require__(166);
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	var input_1 = __webpack_require__(158);
	var componentValidator_service_1 = __webpack_require__(112);
	exports.moduleName = 'rl.ui.components.select';
	exports.componentName = 'rlSelect';
	exports.controllerName = 'SelectController';
	var SelectController = (function (_super) {
	    __extends(SelectController, _super);
	    function SelectController($scope, $attrs, $q, object, componentValidatorFactory) {
	        _super.call(this, $scope, $attrs, componentValidatorFactory);
	        this.$q = $q;
	        this.object = object;
	        this._nullOption = {
	            __isNullOption: true,
	        };
	        this.inputType = 'select';
	    }
	    Object.defineProperty(SelectController.prototype, "selection", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            if (value.__isNullOption) {
	                this.ngModel.$setViewValue(null);
	            }
	            else {
	                this.ngModel.$setViewValue(value);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SelectController.prototype.$onInit = function () {
	        var _this = this;
	        _super.prototype.$onInit.call(this);
	        if (_.isUndefined(this.options)) {
	            this.loading = true;
	            this.loadItems().then(function (options) {
	                _this.options = options;
	                _this.loading = false;
	            });
	        }
	        else {
	            this.options = this.configureOptions(this.options);
	        }
	    };
	    SelectController.prototype.getDisplayName = function (item) {
	        if (item != null && item.__isNullOption) {
	            return this.nullOption;
	        }
	        return __transform.getValue(item, this.selector);
	    };
	    SelectController.prototype.loadItems = function () {
	        var _this = this;
	        var promise;
	        promise = this.getOptions();
	        if (promise == null) {
	            promise = this.$q.when(this.options);
	        }
	        return promise.then(function (options) { return _this.configureOptions(options); });
	    };
	    SelectController.prototype.configureOptions = function (options) {
	        if (!this.object.isNullOrWhitespace(this.nullOption)) {
	            options.unshift(this._nullOption);
	        }
	        return options;
	    };
	    SelectController.$inject = ['$scope', '$attrs', '$q', __object.serviceName, componentValidator_service_1.factoryName];
	    return SelectController;
	}(input_1.InputController));
	exports.SelectController = SelectController;
	var select = _.clone(input_1.input);
	select.template = __webpack_require__(168);
	select.controller = exports.controllerName;
	select.controllerAs = 'select';
	var selectBindings = select.bindings;
	selectBindings.options = '<?';
	selectBindings.getOptions = '&';
	selectBindings.selector = '<?';
	selectBindings.ngDisabled = '<?';
	selectBindings.nullOption = '@';
	angular.module(exports.moduleName, ['ui.select', __object.moduleName, input_1.moduleName])
	    .component(exports.componentName, select)
	    .controller(exports.controllerName, SelectController);
	//# sourceMappingURL=select.js.map

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(165);
	module.exports = 'ui.select';


/***/ },
/* 165 */
/***/ function(module, exports) {

	/*!
	 * ui-select
	 * http://github.com/angular-ui/ui-select
	 * Version: 0.14.6 - 2016-02-18T21:01:36.893Z
	 * License: MIT
	 */
	
	
	(function () { 
	"use strict";
	var KEY = {
	    TAB: 9,
	    ENTER: 13,
	    ESC: 27,
	    SPACE: 32,
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    DOWN: 40,
	    SHIFT: 16,
	    CTRL: 17,
	    ALT: 18,
	    PAGE_UP: 33,
	    PAGE_DOWN: 34,
	    HOME: 36,
	    END: 35,
	    BACKSPACE: 8,
	    DELETE: 46,
	    COMMAND: 91,
	
	    MAP: { 91 : "COMMAND", 8 : "BACKSPACE" , 9 : "TAB" , 13 : "ENTER" , 16 : "SHIFT" , 17 : "CTRL" , 18 : "ALT" , 19 : "PAUSEBREAK" , 20 : "CAPSLOCK" , 27 : "ESC" , 32 : "SPACE" , 33 : "PAGE_UP", 34 : "PAGE_DOWN" , 35 : "END" , 36 : "HOME" , 37 : "LEFT" , 38 : "UP" , 39 : "RIGHT" , 40 : "DOWN" , 43 : "+" , 44 : "PRINTSCREEN" , 45 : "INSERT" , 46 : "DELETE", 48 : "0" , 49 : "1" , 50 : "2" , 51 : "3" , 52 : "4" , 53 : "5" , 54 : "6" , 55 : "7" , 56 : "8" , 57 : "9" , 59 : ";", 61 : "=" , 65 : "A" , 66 : "B" , 67 : "C" , 68 : "D" , 69 : "E" , 70 : "F" , 71 : "G" , 72 : "H" , 73 : "I" , 74 : "J" , 75 : "K" , 76 : "L", 77 : "M" , 78 : "N" , 79 : "O" , 80 : "P" , 81 : "Q" , 82 : "R" , 83 : "S" , 84 : "T" , 85 : "U" , 86 : "V" , 87 : "W" , 88 : "X" , 89 : "Y" , 90 : "Z", 96 : "0" , 97 : "1" , 98 : "2" , 99 : "3" , 100 : "4" , 101 : "5" , 102 : "6" , 103 : "7" , 104 : "8" , 105 : "9", 106 : "*" , 107 : "+" , 109 : "-" , 110 : "." , 111 : "/", 112 : "F1" , 113 : "F2" , 114 : "F3" , 115 : "F4" , 116 : "F5" , 117 : "F6" , 118 : "F7" , 119 : "F8" , 120 : "F9" , 121 : "F10" , 122 : "F11" , 123 : "F12", 144 : "NUMLOCK" , 145 : "SCROLLLOCK" , 186 : ";" , 187 : "=" , 188 : "," , 189 : "-" , 190 : "." , 191 : "/" , 192 : "`" , 219 : "[" , 220 : "\\" , 221 : "]" , 222 : "'"
	    },
	
	    isControl: function (e) {
	        var k = e.which;
	        switch (k) {
	        case KEY.COMMAND:
	        case KEY.SHIFT:
	        case KEY.CTRL:
	        case KEY.ALT:
	            return true;
	        }
	
	        if (e.metaKey) return true;
	
	        return false;
	    },
	    isFunctionKey: function (k) {
	        k = k.which ? k.which : k;
	        return k >= 112 && k <= 123;
	    },
	    isVerticalMovement: function (k){
	      return ~[KEY.UP, KEY.DOWN].indexOf(k);
	    },
	    isHorizontalMovement: function (k){
	      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);
	    },
	    toSeparator: function (k) {
	      var sep = {ENTER:"\n",TAB:"\t",SPACE:" "}[k];
	      if (sep) return sep;
	      // return undefined for special keys other than enter, tab or space.
	      // no way to use them to cut strings.
	      return KEY[k] ? undefined : k;
	    }
	  };
	
	/**
	 * Add querySelectorAll() to jqLite.
	 *
	 * jqLite find() is limited to lookups by tag name.
	 * TODO This will change with future versions of AngularJS, to be removed when this happens
	 *
	 * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586
	 * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598
	 */
	if (angular.element.prototype.querySelectorAll === undefined) {
	  angular.element.prototype.querySelectorAll = function(selector) {
	    return angular.element(this[0].querySelectorAll(selector));
	  };
	}
	
	/**
	 * Add closest() to jqLite.
	 */
	if (angular.element.prototype.closest === undefined) {
	  angular.element.prototype.closest = function( selector) {
	    var elem = this[0];
	    var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;
	
	    while (elem) {
	      if (matchesSelector.bind(elem)(selector)) {
	        return elem;
	      } else {
	        elem = elem.parentElement;
	      }
	    }
	    return false;
	  };
	}
	
	var latestId = 0;
	
	var uis = angular.module('ui.select', [])
	
	.constant('uiSelectConfig', {
	  theme: 'bootstrap',
	  searchEnabled: true,
	  sortable: false,
	  placeholder: '', // Empty by default, like HTML tag <select>
	  refreshDelay: 1000, // In milliseconds
	  closeOnSelect: true,
	  dropdownPosition: 'auto',
	  generateId: function() {
	    return latestId++;
	  },
	  appendToBody: false
	})
	
	// See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913
	.service('uiSelectMinErr', function() {
	  var minErr = angular.$$minErr('ui.select');
	  return function() {
	    var error = minErr.apply(this, arguments);
	    var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
	    return new Error(message);
	  };
	})
	
	// Recreates old behavior of ng-transclude. Used internally.
	.directive('uisTranscludeAppend', function () {
	  return {
	    link: function (scope, element, attrs, ctrl, transclude) {
	        transclude(scope, function (clone) {
	          element.append(clone);
	        });
	      }
	    };
	})
	
	/**
	 * Highlights text that matches $select.search.
	 *
	 * Taken from AngularUI Bootstrap Typeahead
	 * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340
	 */
	.filter('highlight', function() {
	  function escapeRegexp(queryToEscape) {
	    return ('' + queryToEscape).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
	  }
	
	  return function(matchItem, query) {
	    return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
	  };
	})
	
	/**
	 * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/
	 *
	 * Taken from AngularUI Bootstrap Position:
	 * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70
	 */
	.factory('uisOffset',
	  ['$document', '$window',
	  function ($document, $window) {
	
	  return function(element) {
	    var boundingClientRect = element[0].getBoundingClientRect();
	    return {
	      width: boundingClientRect.width || element.prop('offsetWidth'),
	      height: boundingClientRect.height || element.prop('offsetHeight'),
	      top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
	      left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
	    };
	  };
	}]);
	
	uis.directive('uiSelectChoices',
	  ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile',
	  function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile) {
	
	  return {
	    restrict: 'EA',
	    require: '^uiSelect',
	    replace: true,
	    transclude: true,
	    templateUrl: function(tElement) {
	      // Needed so the uiSelect can detect the transcluded content
	      tElement.addClass('ui-select-choices');
	
	      // Gets theme attribute from parent (ui-select)
	      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
	      return theme + '/choices.tpl.html';
	    },
	
	    compile: function(tElement, tAttrs) {
	
	      if (!tAttrs.repeat) throw uiSelectMinErr('repeat', "Expected 'repeat' expression.");
	
	      return function link(scope, element, attrs, $select, transcludeFn) {
	
	        // var repeat = RepeatParser.parse(attrs.repeat);
	        var groupByExp = attrs.groupBy;
	        var groupFilterExp = attrs.groupFilter;
	
	        $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult
	
	        $select.disableChoiceExpression = attrs.uiDisableChoice;
	        $select.onHighlightCallback = attrs.onHighlight;
	
	        $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;
	
	        if(groupByExp) {
	          var groups = element.querySelectorAll('.ui-select-choices-group');
	          if (groups.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
	          groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
	        }
	
	        var choices = element.querySelectorAll('.ui-select-choices-row');
	        if (choices.length !== 1) {
	          throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
	        }
	
	        choices.attr('ng-repeat', $select.parserResult.repeatExpression(groupByExp))
	            .attr('ng-if', '$select.open') //Prevent unnecessary watches when dropdown is closed
	            .attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',false,$event)');
	
	        var rowsInner = element.querySelectorAll('.ui-select-choices-row-inner');
	        if (rowsInner.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
	        rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat
	
	        $compile(element, transcludeFn)(scope); //Passing current transcludeFn to be able to append elements correctly from uisTranscludeAppend
	
	        scope.$watch('$select.search', function(newValue) {
	          if(newValue && !$select.open && $select.multiple) $select.activate(false, true);
	          $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
	          if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {
	            $select.refresh(attrs.refresh);
	          } else {
	            $select.items = [];
	          }
	        });
	
	        attrs.$observe('refreshDelay', function() {
	          // $eval() is needed otherwise we get a string instead of a number
	          var refreshDelay = scope.$eval(attrs.refreshDelay);
	          $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
	        });
	      };
	    }
	  };
	}]);
	
	/**
	 * Contains ui-select "intelligence".
	 *
	 * The goal is to limit dependency on the DOM whenever possible and
	 * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.
	 */
	uis.controller('uiSelectCtrl',
	  ['$scope', '$element', '$timeout', '$filter', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector',
	  function($scope, $element, $timeout, $filter, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector) {
	
	  var ctrl = this;
	
	  var EMPTY_SEARCH = '';
	
	  ctrl.placeholder = uiSelectConfig.placeholder;
	  ctrl.searchEnabled = uiSelectConfig.searchEnabled;
	  ctrl.sortable = uiSelectConfig.sortable;
	  ctrl.refreshDelay = uiSelectConfig.refreshDelay;
	  ctrl.paste = uiSelectConfig.paste;
	
	  ctrl.removeSelected = false; //If selected item(s) should be removed from dropdown list
	  ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function
	  ctrl.search = EMPTY_SEARCH;
	
	  ctrl.activeIndex = 0; //Dropdown of choices
	  ctrl.items = []; //All available choices
	
	  ctrl.open = false;
	  ctrl.focus = false;
	  ctrl.disabled = false;
	  ctrl.selected = undefined;
	
	  ctrl.dropdownPosition = 'auto';
	
	  ctrl.focusser = undefined; //Reference to input element used to handle focus events
	  ctrl.resetSearchInput = true;
	  ctrl.multiple = undefined; // Initialized inside uiSelect directive link function
	  ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function
	  ctrl.tagging = {isActivated: false, fct: undefined};
	  ctrl.taggingTokens = {isActivated: false, tokens: undefined};
	  ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function
	  ctrl.clickTriggeredSelect = false;
	  ctrl.$filter = $filter;
	
	  // Use $injector to check for $animate and store a reference to it
	  ctrl.$animate = (function () {
	    try {
	      return $injector.get('$animate');
	    } catch (err) {
	      // $animate does not exist
	      return null;
	    }
	  })();
	
	  ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
	  if (ctrl.searchInput.length !== 1) {
	    throw uiSelectMinErr('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
	  }
	
	  ctrl.isEmpty = function() {
	    return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '' || (ctrl.multiple && ctrl.selected.length === 0);
	  };
	
	  function _findIndex(collection, predicate, thisArg){
	    if (collection.findIndex){
	      return collection.findIndex(predicate, thisArg);
	    } else {
	      var list = Object(collection);
	      var length = list.length >>> 0;
	      var value;
	
	      for (var i = 0; i < length; i++) {
	        value = list[i];
	        if (predicate.call(thisArg, value, i, list)) {
	          return i;
	        }
	      }
	      return -1;
	    }
	  }
	
	  // Most of the time the user does not want to empty the search input when in typeahead mode
	  function _resetSearchInput() {
	    if (ctrl.resetSearchInput || (ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput)) {
	      ctrl.search = EMPTY_SEARCH;
	      //reset activeIndex
	      if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
	        ctrl.activeIndex = _findIndex(ctrl.items, function(item){
	          return angular.equals(this, item);
	        }, ctrl.selected);
	      }
	    }
	  }
	
	    function _groupsFilter(groups, groupNames) {
	      var i, j, result = [];
	      for(i = 0; i < groupNames.length ;i++){
	        for(j = 0; j < groups.length ;j++){
	          if(groups[j].name == [groupNames[i]]){
	            result.push(groups[j]);
	          }
	        }
	      }
	      return result;
	    }
	
	  // When the user clicks on ui-select, displays the dropdown list
	  ctrl.activate = function(initSearchValue, avoidReset) {
	    if (!ctrl.disabled  && !ctrl.open) {
	      if(!avoidReset) _resetSearchInput();
	
	      $scope.$broadcast('uis:activate');
	
	      ctrl.open = true;
	
	      ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;
	
	      // ensure that the index is set to zero for tagging variants
	      // that where first option is auto-selected
	      if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {
	        ctrl.activeIndex = 0;
	      }
	
	      var container = $element.querySelectorAll('.ui-select-choices-content');
	      if (ctrl.$animate && ctrl.$animate.enabled(container[0])) {
	        ctrl.$animate.on('enter', container[0], function (elem, phase) {
	          if (phase === 'close') {
	            // Only focus input after the animation has finished
	            $timeout(function () {
	              ctrl.focusSearchInput(initSearchValue);
	            });
	          }
	        });
	      } else {
	        $timeout(function () {
	          ctrl.focusSearchInput(initSearchValue);
	        });
	      }
	    }
	  };
	
	  ctrl.focusSearchInput = function (initSearchValue) {
	    ctrl.search = initSearchValue || ctrl.search;
	    ctrl.searchInput[0].focus();
	    if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {
	     _ensureHighlightVisible();
	    }
	  };
	
	  ctrl.findGroupByName = function(name) {
	    return ctrl.groups && ctrl.groups.filter(function(group) {
	      return group.name === name;
	    })[0];
	  };
	
	  ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {
	    function updateGroups(items) {
	      var groupFn = $scope.$eval(groupByExp);
	      ctrl.groups = [];
	      angular.forEach(items, function(item) {
	        var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
	        var group = ctrl.findGroupByName(groupName);
	        if(group) {
	          group.items.push(item);
	        }
	        else {
	          ctrl.groups.push({name: groupName, items: [item]});
	        }
	      });
	      if(groupFilterExp){
	        var groupFilterFn = $scope.$eval(groupFilterExp);
	        if( angular.isFunction(groupFilterFn)){
	          ctrl.groups = groupFilterFn(ctrl.groups);
	        } else if(angular.isArray(groupFilterFn)){
	          ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
	        }
	      }
	      ctrl.items = [];
	      ctrl.groups.forEach(function(group) {
	        ctrl.items = ctrl.items.concat(group.items);
	      });
	    }
	
	    function setPlainItems(items) {
	      ctrl.items = items;
	    }
	
	    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;
	
	    ctrl.parserResult = RepeatParser.parse(repeatAttr);
	
	    ctrl.isGrouped = !!groupByExp;
	    ctrl.itemProperty = ctrl.parserResult.itemName;
	
	    //If collection is an Object, convert it to Array
	
	    var originalSource = ctrl.parserResult.source;
	
	    //When an object is used as source, we better create an array and use it as 'source'
	    var createArrayFromObject = function(){
	      var origSrc = originalSource($scope);
	      $scope.$uisSource = Object.keys(origSrc).map(function(v){
	        var result = {};
	        result[ctrl.parserResult.keyName] = v;
	        result.value = origSrc[v];
	        return result;
	      });
	    };
	
	    if (ctrl.parserResult.keyName){ // Check for (key,value) syntax
	      createArrayFromObject();
	      ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);
	      $scope.$watch(originalSource, function(newVal, oldVal){
	        if (newVal !== oldVal) createArrayFromObject();
	      }, true);
	    }
	
	    ctrl.refreshItems = function (data){
	      data = data || ctrl.parserResult.source($scope);
	      var selectedItems = ctrl.selected;
	      //TODO should implement for single mode removeSelected
	      if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.removeSelected) {
	        ctrl.setItemsFn(data);
	      }else{
	        if ( data !== undefined ) {
	          var filteredItems = data.filter(function(i) {return selectedItems && selectedItems.indexOf(i) < 0;});
	          ctrl.setItemsFn(filteredItems);
	        }
	      }
	      if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){
	        $scope.calculateDropdownPos();
	      }
	    };
	
	    // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259
	    $scope.$watchCollection(ctrl.parserResult.source, function(items) {
	      if (items === undefined || items === null) {
	        // If the user specifies undefined or null => reset the collection
	        // Special case: items can be undefined if the user did not initialized the collection on the scope
	        // i.e $scope.addresses = [] is missing
	        ctrl.items = [];
	      } else {
	        if (!angular.isArray(items)) {
	          throw uiSelectMinErr('items', "Expected an array but got '{0}'.", items);
	        } else {
	          //Remove already selected items (ex: while searching)
	          //TODO Should add a test
	          ctrl.refreshItems(items);
	          ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
	        }
	      }
	    });
	
	  };
	
	  var _refreshDelayPromise;
	
	  /**
	   * Typeahead mode: lets the user refresh the collection using his own function.
	   *
	   * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31
	   */
	  ctrl.refresh = function(refreshAttr) {
	    if (refreshAttr !== undefined) {
	
	      // Debounce
	      // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155
	      // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177
	      if (_refreshDelayPromise) {
	        $timeout.cancel(_refreshDelayPromise);
	      }
	      _refreshDelayPromise = $timeout(function() {
	        $scope.$eval(refreshAttr);
	      }, ctrl.refreshDelay);
	    }
	  };
	
	  ctrl.isActive = function(itemScope) {
	    if ( !ctrl.open ) {
	      return false;
	    }
	    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
	    var isActive =  itemIndex == ctrl.activeIndex;
	
	    if ( !isActive || ( itemIndex < 0 && ctrl.taggingLabel !== false ) ||( itemIndex < 0 && ctrl.taggingLabel === false) ) {
	      return false;
	    }
	
	    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
	      itemScope.$eval(ctrl.onHighlightCallback);
	    }
	
	    return isActive;
	  };
	
	  ctrl.isDisabled = function(itemScope) {
	
	    if (!ctrl.open) return;
	
	    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
	    var isDisabled = false;
	    var item;
	
	    if (itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression)) {
	      item = ctrl.items[itemIndex];
	      isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression)); // force the boolean value
	      item._uiSelectChoiceDisabled = isDisabled; // store this for later reference
	    }
	
	    return isDisabled;
	  };
	
	
	  // When the user selects an item with ENTER or clicks the dropdown
	  ctrl.select = function(item, skipFocusser, $event) {
	    if (item === undefined || !item._uiSelectChoiceDisabled) {
	
	      if ( ! ctrl.items && ! ctrl.search && ! ctrl.tagging.isActivated) return;
	
	      if (!item || !item._uiSelectChoiceDisabled) {
	        if(ctrl.tagging.isActivated) {
	          // if taggingLabel is disabled, we pull from ctrl.search val
	          if ( ctrl.taggingLabel === false ) {
	            if ( ctrl.activeIndex < 0 ) {
	              item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
	              if (!item || angular.equals( ctrl.items[0], item ) ) {
	                return;
	              }
	            } else {
	              // keyboard nav happened first, user selected from dropdown
	              item = ctrl.items[ctrl.activeIndex];
	            }
	          } else {
	            // tagging always operates at index zero, taggingLabel === false pushes
	            // the ctrl.search value without having it injected
	            if ( ctrl.activeIndex === 0 ) {
	              // ctrl.tagging pushes items to ctrl.items, so we only have empty val
	              // for `item` if it is a detected duplicate
	              if ( item === undefined ) return;
	
	              // create new item on the fly if we don't already have one;
	              // use tagging function if we have one
	              if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {
	                item = ctrl.tagging.fct(item);
	                if (!item) return;
	              // if item type is 'string', apply the tagging label
	              } else if ( typeof item === 'string' ) {
	                // trim the trailing space
	                item = item.replace(ctrl.taggingLabel,'').trim();
	              }
	            }
	          }
	          // search ctrl.selected for dupes potentially caused by tagging and return early if found
	          if ( ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter( function (selection) { return angular.equals(selection, item); }).length > 0 ) {
	            ctrl.close(skipFocusser);
	            return;
	          }
	        }
	
	        $scope.$broadcast('uis:select', item);
	
	        var locals = {};
	        locals[ctrl.parserResult.itemName] = item;
	
	        $timeout(function(){
	          ctrl.onSelectCallback($scope, {
	            $item: item,
	            $model: ctrl.parserResult.modelMapper($scope, locals)
	          });
	        });
	
	        if (ctrl.closeOnSelect) {
	          ctrl.close(skipFocusser);
	        }
	        if ($event && $event.type === 'click') {
	          ctrl.clickTriggeredSelect = true;
	        }
	      }
	    }
	  };
	
	  // Closes the dropdown
	  ctrl.close = function(skipFocusser) {
	    if (!ctrl.open) return;
	    if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();
	    _resetSearchInput();
	    ctrl.open = false;
	
	    $scope.$broadcast('uis:close', skipFocusser);
	
	  };
	
	  ctrl.setFocus = function(){
	    if (!ctrl.focus) ctrl.focusInput[0].focus();
	  };
	
	  ctrl.clear = function($event) {
	    ctrl.select(undefined);
	    $event.stopPropagation();
	    $timeout(function() {
	      ctrl.focusser[0].focus();
	    }, 0, false);
	  };
	
	  // Toggle dropdown
	  ctrl.toggle = function(e) {
	    if (ctrl.open) {
	      ctrl.close();
	      e.preventDefault();
	      e.stopPropagation();
	    } else {
	      ctrl.activate();
	    }
	  };
	
	  ctrl.isLocked = function(itemScope, itemIndex) {
	      var isLocked, item = ctrl.selected[itemIndex];
	
	      if (item && !angular.isUndefined(ctrl.lockChoiceExpression)) {
	          isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression)); // force the boolean value
	          item._uiSelectChoiceLocked = isLocked; // store this for later reference
	      }
	
	      return isLocked;
	  };
	
	  var sizeWatch = null;
	  ctrl.sizeSearchInput = function() {
	
	    var input = ctrl.searchInput[0],
	        container = ctrl.searchInput.parent().parent()[0],
	        calculateContainerWidth = function() {
	          // Return the container width only if the search input is visible
	          return container.clientWidth * !!input.offsetParent;
	        },
	        updateIfVisible = function(containerWidth) {
	          if (containerWidth === 0) {
	            return false;
	          }
	          var inputWidth = containerWidth - input.offsetLeft - 10;
	          if (inputWidth < 50) inputWidth = containerWidth;
	          ctrl.searchInput.css('width', inputWidth+'px');
	          return true;
	        };
	
	    ctrl.searchInput.css('width', '10px');
	    $timeout(function() { //Give tags time to render correctly
	      if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
	        sizeWatch = $scope.$watch(calculateContainerWidth, function(containerWidth) {
	          if (updateIfVisible(containerWidth)) {
	            sizeWatch();
	            sizeWatch = null;
	          }
	        });
	      }
	    });
	  };
	
	  function _handleDropDownSelection(key) {
	    var processed = true;
	    switch (key) {
	      case KEY.DOWN:
	        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        else if (ctrl.activeIndex < ctrl.items.length - 1) { ctrl.activeIndex++; }
	        break;
	      case KEY.UP:
	        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        else if (ctrl.activeIndex > 0 || (ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1)) { ctrl.activeIndex--; }
	        break;
	      case KEY.TAB:
	        if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);
	        break;
	      case KEY.ENTER:
	        if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){
	          ctrl.select(ctrl.items[ctrl.activeIndex]); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode
	        } else {
	          ctrl.activate(false, true); //In case its the search input in 'multiple' mode
	        }
	        break;
	      case KEY.ESC:
	        ctrl.close();
	        break;
	      default:
	        processed = false;
	    }
	    return processed;
	  }
	
	  // Bind to keyboard shortcuts
	  ctrl.searchInput.on('keydown', function(e) {
	
	    var key = e.which;
	
	    // if(~[KEY.ESC,KEY.TAB].indexOf(key)){
	    //   //TODO: SEGURO?
	    //   ctrl.close();
	    // }
	
	    $scope.$apply(function() {
	
	      var tagged = false;
	
	      if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
	        _handleDropDownSelection(key);
	        if ( ctrl.taggingTokens.isActivated ) {
	          for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
	            if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {
	              // make sure there is a new value to push via tagging
	              if ( ctrl.search.length > 0 ) {
	                tagged = true;
	              }
	            }
	          }
	          if ( tagged ) {
	            $timeout(function() {
	              ctrl.searchInput.triggerHandler('tagged');
	              var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();
	              if ( ctrl.tagging.fct ) {
	                newItem = ctrl.tagging.fct( newItem );
	              }
	              if (newItem) ctrl.select(newItem, true);
	            });
	          }
	        }
	      }
	
	    });
	
	    if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){
	      _ensureHighlightVisible();
	    }
	
	    if (key === KEY.ENTER || key === KEY.ESC) {
	      e.preventDefault();
	      e.stopPropagation();
	    }
	
	  });
	
	  ctrl.searchInput.on('paste', function (e) {
	    var data;
	
	    if (window.clipboardData && window.clipboardData.getData) { // IE
	      data = window.clipboardData.getData('Text');
	    } else {
	      data = (e.originalEvent || e).clipboardData.getData('text/plain');
	    }
	
	    // Prepend the current input field text to the paste buffer.
	    data = ctrl.search + data;
	
	    if (data && data.length > 0) {
	      // If tagging try to split by tokens and add items
	      if (ctrl.taggingTokens.isActivated) {
	        var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[0]);
	        var items = data.split(separator || ctrl.taggingTokens.tokens[0]); // split by first token only
	        if (items && items.length > 0) {
	        var oldsearch = ctrl.search;
	          angular.forEach(items, function (item) {
	            var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;
	            if (newItem) {
	              ctrl.select(newItem, true);
	            }
	          });
	          ctrl.search = oldsearch || EMPTY_SEARCH;
	          e.preventDefault();
	          e.stopPropagation();
	        }
	      } else if (ctrl.paste) {
	        ctrl.paste(data);
	        ctrl.search = EMPTY_SEARCH;
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    }
	  });
	
	  ctrl.searchInput.on('tagged', function() {
	    $timeout(function() {
	      _resetSearchInput();
	    });
	  });
	
	  // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431
	  function _ensureHighlightVisible() {
	    var container = $element.querySelectorAll('.ui-select-choices-content');
	    var choices = container.querySelectorAll('.ui-select-choices-row');
	    if (choices.length < 1) {
	      throw uiSelectMinErr('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
	    }
	
	    if (ctrl.activeIndex < 0) {
	      return;
	    }
	
	    var highlighted = choices[ctrl.activeIndex];
	    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
	    var height = container[0].offsetHeight;
	
	    if (posY > height) {
	      container[0].scrollTop += posY - height;
	    } else if (posY < highlighted.clientHeight) {
	      if (ctrl.isGrouped && ctrl.activeIndex === 0)
	        container[0].scrollTop = 0; //To make group header visible when going all the way up
	      else
	        container[0].scrollTop -= highlighted.clientHeight - posY;
	    }
	  }
	
	  $scope.$on('$destroy', function() {
	    ctrl.searchInput.off('keyup keydown tagged blur paste');
	  });
	
	}]);
	
	uis.directive('uiSelect',
	  ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',
	  function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {
	
	  return {
	    restrict: 'EA',
	    templateUrl: function(tElement, tAttrs) {
	      var theme = tAttrs.theme || uiSelectConfig.theme;
	      return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
	    },
	    replace: true,
	    transclude: true,
	    require: ['uiSelect', '^ngModel'],
	    scope: true,
	
	    controller: 'uiSelectCtrl',
	    controllerAs: '$select',
	    compile: function(tElement, tAttrs) {
	
	      // Allow setting ngClass on uiSelect
	      var match = /{(.*)}\s*{(.*)}/.exec(tAttrs.ngClass);
	      if(match) {
	        var combined = '{'+ match[1] +', '+ match[2] +'}';
	        tAttrs.ngClass = combined;
	        tElement.attr('ng-class', combined);
	      }
	
	      //Multiple or Single depending if multiple attribute presence
	      if (angular.isDefined(tAttrs.multiple))
	        tElement.append('<ui-select-multiple/>').removeAttr('multiple');
	      else
	        tElement.append('<ui-select-single/>');
	
	      if (tAttrs.inputId)
	        tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;
	
	      return function(scope, element, attrs, ctrls, transcludeFn) {
	
	        var $select = ctrls[0];
	        var ngModel = ctrls[1];
	
	        $select.generatedId = uiSelectConfig.generateId();
	        $select.baseTitle = attrs.title || 'Select box';
	        $select.focusserTitle = $select.baseTitle + ' focus';
	        $select.focusserId = 'focusser-' + $select.generatedId;
	
	        $select.closeOnSelect = function() {
	          if (angular.isDefined(attrs.closeOnSelect)) {
	            return $parse(attrs.closeOnSelect)();
	          } else {
	            return uiSelectConfig.closeOnSelect;
	          }
	        }();
	
	        $select.onSelectCallback = $parse(attrs.onSelect);
	        $select.onRemoveCallback = $parse(attrs.onRemove);
	
	        //Limit the number of selections allowed
	        $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;
	
	        //Set reference to ngModel from uiSelectCtrl
	        $select.ngModel = ngModel;
	
	        $select.choiceGrouped = function(group){
	          return $select.isGrouped && group && group.name;
	        };
	
	        if(attrs.tabindex){
	          attrs.$observe('tabindex', function(value) {
	            $select.focusInput.attr('tabindex', value);
	            element.removeAttr('tabindex');
	          });
	        }
	
	        scope.$watch('searchEnabled', function() {
	            var searchEnabled = scope.$eval(attrs.searchEnabled);
	            $select.searchEnabled = searchEnabled !== undefined ? searchEnabled : uiSelectConfig.searchEnabled;
	        });
	
	        scope.$watch('sortable', function() {
	            var sortable = scope.$eval(attrs.sortable);
	            $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
	        });
	
	        attrs.$observe('disabled', function() {
	          // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string
	          $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
	        });
	
	        attrs.$observe('resetSearchInput', function() {
	          // $eval() is needed otherwise we get a string instead of a boolean
	          var resetSearchInput = scope.$eval(attrs.resetSearchInput);
	          $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
	        });
	
	        attrs.$observe('paste', function() {
	          $select.paste = scope.$eval(attrs.paste);
	        });
	
	        attrs.$observe('tagging', function() {
	          if(attrs.tagging !== undefined)
	          {
	            // $eval() is needed otherwise we get a string instead of a boolean
	            var taggingEval = scope.$eval(attrs.tagging);
	            $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};
	          }
	          else
	          {
	            $select.tagging = {isActivated: false, fct: undefined};
	          }
	        });
	
	        attrs.$observe('taggingLabel', function() {
	          if(attrs.tagging !== undefined )
	          {
	            // check eval for FALSE, in this case, we disable the labels
	            // associated with tagging
	            if ( attrs.taggingLabel === 'false' ) {
	              $select.taggingLabel = false;
	            }
	            else
	            {
	              $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
	            }
	          }
	        });
	
	        attrs.$observe('taggingTokens', function() {
	          if (attrs.tagging !== undefined) {
	            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];
	            $select.taggingTokens = {isActivated: true, tokens: tokens };
	          }
	        });
	
	        //Automatically gets focus when loaded
	        if (angular.isDefined(attrs.autofocus)){
	          $timeout(function(){
	            $select.setFocus();
	          });
	        }
	
	        //Gets focus based on scope event name (e.g. focus-on='SomeEventName')
	        if (angular.isDefined(attrs.focusOn)){
	          scope.$on(attrs.focusOn, function() {
	              $timeout(function(){
	                $select.setFocus();
	              });
	          });
	        }
	
	        function onDocumentClick(e) {
	          if (!$select.open) return; //Skip it if dropdown is close
	
	          var contains = false;
	
	          if (window.jQuery) {
	            // Firefox 3.6 does not support element.contains()
	            // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
	            contains = window.jQuery.contains(element[0], e.target);
	          } else {
	            contains = element[0].contains(e.target);
	          }
	
	          if (!contains && !$select.clickTriggeredSelect) {
	            //Will lose focus only with certain targets
	            var focusableControls = ['input','button','textarea','select'];
	            var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select
	            var skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select
	            if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea
	            $select.close(skipFocusser);
	            scope.$digest();
	          }
	          $select.clickTriggeredSelect = false;
	        }
	
	        // See Click everywhere but here event http://stackoverflow.com/questions/12931369
	        $document.on('click', onDocumentClick);
	
	        scope.$on('$destroy', function() {
	          $document.off('click', onDocumentClick);
	        });
	
	        // Move transcluded elements to their correct position in main template
	        transcludeFn(scope, function(clone) {
	          // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html
	
	          // One day jqLite will be replaced by jQuery and we will be able to write:
	          // var transcludedElement = clone.filter('.my-class')
	          // instead of creating a hackish DOM element:
	          var transcluded = angular.element('<div>').append(clone);
	
	          var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
	          transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr
	          transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes
	          if (transcludedMatch.length !== 1) {
	            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
	          }
	          element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);
	
	          var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
	          transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr
	          transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes
	          if (transcludedChoices.length !== 1) {
	            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
	          }
	          element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);
	        });
	
	        // Support for appending the select field to the body when its open
	        var appendToBody = scope.$eval(attrs.appendToBody);
	        if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
	          scope.$watch('$select.open', function(isOpen) {
	            if (isOpen) {
	              positionDropdown();
	            } else {
	              resetDropdown();
	            }
	          });
	
	          // Move the dropdown back to its original location when the scope is destroyed. Otherwise
	          // it might stick around when the user routes away or the select field is otherwise removed
	          scope.$on('$destroy', function() {
	            resetDropdown();
	          });
	        }
	
	        // Hold on to a reference to the .ui-select-container element for appendToBody support
	        var placeholder = null,
	            originalWidth = '';
	
	        function positionDropdown() {
	          // Remember the absolute position of the element
	          var offset = uisOffset(element);
	
	          // Clone the element into a placeholder element to take its original place in the DOM
	          placeholder = angular.element('<div class="ui-select-placeholder"></div>');
	          placeholder[0].style.width = offset.width + 'px';
	          placeholder[0].style.height = offset.height + 'px';
	          element.after(placeholder);
	
	          // Remember the original value of the element width inline style, so it can be restored
	          // when the dropdown is closed
	          originalWidth = element[0].style.width;
	
	          // Now move the actual dropdown element to the end of the body
	          $document.find('body').append(element);
	
	          element[0].style.position = 'absolute';
	          element[0].style.left = offset.left + 'px';
	          element[0].style.top = offset.top + 'px';
	          element[0].style.width = offset.width + 'px';
	        }
	
	        function resetDropdown() {
	          if (placeholder === null) {
	            // The dropdown has not actually been display yet, so there's nothing to reset
	            return;
	          }
	
	          // Move the dropdown element back to its original location in the DOM
	          placeholder.replaceWith(element);
	          placeholder = null;
	
	          element[0].style.position = '';
	          element[0].style.left = '';
	          element[0].style.top = '';
	          element[0].style.width = originalWidth;
	        }
	
	        // Hold on to a reference to the .ui-select-dropdown element for direction support.
	        var dropdown = null,
	            directionUpClassName = 'direction-up';
	
	        // Support changing the direction of the dropdown if there isn't enough space to render it.
	        scope.$watch('$select.open', function() {
	
	          if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){
	            scope.calculateDropdownPos();
	          }
	
	        });
	
	        var setDropdownPosUp = function(offset, offsetDropdown){
	
	          offset = offset || uisOffset(element);
	          offsetDropdown = offsetDropdown || uisOffset(dropdown);
	
	          dropdown[0].style.position = 'absolute';
	          dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';
	          element.addClass(directionUpClassName);
	
	        };
	
	        var setDropdownPosDown = function(offset, offsetDropdown){
	
	          element.removeClass(directionUpClassName);
	
	          offset = offset || uisOffset(element);
	          offsetDropdown = offsetDropdown || uisOffset(dropdown);
	
	          dropdown[0].style.position = '';
	          dropdown[0].style.top = '';
	
	        };
	
	        scope.calculateDropdownPos = function(){
	
	          if ($select.open) {
	            dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');
	            if (dropdown.length === 0) {
	              return;
	            }
	
	            // Hide the dropdown so there is no flicker until $timeout is done executing.
	            dropdown[0].style.opacity = 0;
	
	            // Delay positioning the dropdown until all choices have been added so its height is correct.
	            $timeout(function(){
	
	              if ($select.dropdownPosition === 'up'){
	                  //Go UP
	                  setDropdownPosUp();
	
	              }else{ //AUTO
	
	                element.removeClass(directionUpClassName);
	
	                var offset = uisOffset(element);
	                var offsetDropdown = uisOffset(dropdown);
	
	                //https://code.google.com/p/chromium/issues/detail?id=342307#c4
	                var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).
	
	                // Determine if the direction of the dropdown needs to be changed.
	                if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {
	                  //Go UP
	                  setDropdownPosUp(offset, offsetDropdown);
	                }else{
	                  //Go DOWN
	                  setDropdownPosDown(offset, offsetDropdown);
	                }
	
	              }
	
	              // Display the dropdown once it has been positioned.
	              dropdown[0].style.opacity = 1;
	            });
	          } else {
	              if (dropdown === null || dropdown.length === 0) {
	                return;
	              }
	
	              // Reset the position of the dropdown.
	              dropdown[0].style.position = '';
	              dropdown[0].style.top = '';
	              element.removeClass(directionUpClassName);
	          }
	        };
	      };
	    }
	  };
	}]);
	
	uis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {
	  return {
	    restrict: 'EA',
	    require: '^uiSelect',
	    replace: true,
	    transclude: true,
	    templateUrl: function(tElement) {
	      // Needed so the uiSelect can detect the transcluded content
	      tElement.addClass('ui-select-match');
	
	      // Gets theme attribute from parent (ui-select)
	      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
	      var multi = tElement.parent().attr('multiple');
	      return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');
	    },
	    link: function(scope, element, attrs, $select) {
	      $select.lockChoiceExpression = attrs.uiLockChoice;
	      attrs.$observe('placeholder', function(placeholder) {
	        $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
	      });
	
	      function setAllowClear(allow) {
	        $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;
	      }
	
	      attrs.$observe('allowClear', setAllowClear);
	      setAllowClear(attrs.allowClear);
	
	      if($select.multiple){
	        $select.sizeSearchInput();
	      }
	
	    }
	  };
	}]);
	
	uis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {
	  return {
	    restrict: 'EA',
	    require: ['^uiSelect', '^ngModel'],
	
	    controller: ['$scope','$timeout', function($scope, $timeout){
	
	      var ctrl = this,
	          $select = $scope.$select,
	          ngModel;
	
	      //Wait for link fn to inject it 
	      $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });
	
	      ctrl.activeMatchIndex = -1;
	
	      ctrl.updateModel = function(){
	        ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes
	        ctrl.refreshComponent();
	      };
	
	      ctrl.refreshComponent = function(){
	        //Remove already selected items
	        //e.g. When user clicks on a selection, the selected array changes and 
	        //the dropdown should remove that item
	        $select.refreshItems();
	        $select.sizeSearchInput();
	      };
	
	      // Remove item from multiple select
	      ctrl.removeChoice = function(index){
	
	        var removedChoice = $select.selected[index];
	
	        // if the choice is locked, can't remove it
	        if(removedChoice._uiSelectChoiceLocked) return;
	
	        var locals = {};
	        locals[$select.parserResult.itemName] = removedChoice;
	
	        $select.selected.splice(index, 1);
	        ctrl.activeMatchIndex = -1;
	        $select.sizeSearchInput();
	
	        // Give some time for scope propagation.
	        $timeout(function(){
	          $select.onRemoveCallback($scope, {
	            $item: removedChoice,
	            $model: $select.parserResult.modelMapper($scope, locals)
	          });
	        });
	
	        ctrl.updateModel();
	
	      };
	
	      ctrl.getPlaceholder = function(){
	        //Refactor single?
	        if($select.selected && $select.selected.length) return;
	        return $select.placeholder;
	      };
	
	
	    }],
	    controllerAs: '$selectMultiple',
	
	    link: function(scope, element, attrs, ctrls) {
	
	      var $select = ctrls[0];
	      var ngModel = scope.ngModel = ctrls[1];
	      var $selectMultiple = scope.$selectMultiple;
	
	      //$select.selected = raw selected objects (ignoring any property binding)
	
	      $select.multiple = true;
	      $select.removeSelected = true;
	
	      //Input that will handle focus
	      $select.focusInput = $select.searchInput;
	
	      //From view --> model
	      ngModel.$parsers.unshift(function () {
	        var locals = {},
	            result,
	            resultMultiple = [];
	        for (var j = $select.selected.length - 1; j >= 0; j--) {
	          locals = {};
	          locals[$select.parserResult.itemName] = $select.selected[j];
	          result = $select.parserResult.modelMapper(scope, locals);
	          resultMultiple.unshift(result);
	        }
	        return resultMultiple;
	      });
	
	      // From model --> view
	      ngModel.$formatters.unshift(function (inputValue) {
	        var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
	            locals = {},
	            result;
	        if (!data) return inputValue;
	        var resultMultiple = [];
	        var checkFnMultiple = function(list, value){
	          if (!list || !list.length) return;
	          for (var p = list.length - 1; p >= 0; p--) {
	            locals[$select.parserResult.itemName] = list[p];
	            result = $select.parserResult.modelMapper(scope, locals);
	            if($select.parserResult.trackByExp){
	                var propsItemNameMatches = /(\w*)\./.exec($select.parserResult.trackByExp);
	                var matches = /\.([^\s]+)/.exec($select.parserResult.trackByExp);
	                if(propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName){
	                  if(matches && matches.length>0 && result[matches[1]] == value[matches[1]]){
	                      resultMultiple.unshift(list[p]);
	                      return true;
	                  }
	                }
	            }
	            if (angular.equals(result,value)){
	              resultMultiple.unshift(list[p]);
	              return true;
	            }
	          }
	          return false;
	        };
	        if (!inputValue) return resultMultiple; //If ngModel was undefined
	        for (var k = inputValue.length - 1; k >= 0; k--) {
	          //Check model array of currently selected items 
	          if (!checkFnMultiple($select.selected, inputValue[k])){
	            //Check model array of all items available
	            if (!checkFnMultiple(data, inputValue[k])){
	              //If not found on previous lists, just add it directly to resultMultiple
	              resultMultiple.unshift(inputValue[k]);
	            }
	          }
	        }
	        return resultMultiple;
	      });
	      
	      //Watch for external model changes 
	      scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {
	        if (oldValue != newValue){
	          ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
	          $selectMultiple.refreshComponent();
	        }
	      });
	
	      ngModel.$render = function() {
	        // Make sure that model value is array
	        if(!angular.isArray(ngModel.$viewValue)){
	          // Have tolerance for null or undefined values
	          if(angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null){
	            $select.selected = [];
	          } else {
	            throw uiSelectMinErr('multiarr', "Expected model value to be array but got '{0}'", ngModel.$viewValue);
	          }
	        }
	        $select.selected = ngModel.$viewValue;
	        scope.$evalAsync(); //To force $digest
	      };
	
	      scope.$on('uis:select', function (event, item) {
	        if($select.selected.length >= $select.limit) {
	          return;
	        }
	        $select.selected.push(item);
	        $selectMultiple.updateModel();
	      });
	
	      scope.$on('uis:activate', function () {
	        $selectMultiple.activeMatchIndex = -1;
	      });
	
	      scope.$watch('$select.disabled', function(newValue, oldValue) {
	        // As the search input field may now become visible, it may be necessary to recompute its size
	        if (oldValue && !newValue) $select.sizeSearchInput();
	      });
	
	      $select.searchInput.on('keydown', function(e) {
	        var key = e.which;
	        scope.$apply(function() {
	          var processed = false;
	          // var tagged = false; //Checkme
	          if(KEY.isHorizontalMovement(key)){
	            processed = _handleMatchSelection(key);
	          }
	          if (processed  && key != KEY.TAB) {
	            //TODO Check si el tab selecciona aun correctamente
	            //Crear test
	            e.preventDefault();
	            e.stopPropagation();
	          }
	        });
	      });
	      function _getCaretPosition(el) {
	        if(angular.isNumber(el.selectionStart)) return el.selectionStart;
	        // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise
	        else return el.value.length;
	      }
	      // Handles selected options in "multiple" mode
	      function _handleMatchSelection(key){
	        var caretPosition = _getCaretPosition($select.searchInput[0]),
	            length = $select.selected.length,
	            // none  = -1,
	            first = 0,
	            last  = length-1,
	            curr  = $selectMultiple.activeMatchIndex,
	            next  = $selectMultiple.activeMatchIndex+1,
	            prev  = $selectMultiple.activeMatchIndex-1,
	            newIndex = curr;
	
	        if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;
	
	        $select.close();
	
	        function getNewActiveMatchIndex(){
	          switch(key){
	            case KEY.LEFT:
	              // Select previous/first item
	              if(~$selectMultiple.activeMatchIndex) return prev;
	              // Select last item
	              else return last;
	              break;
	            case KEY.RIGHT:
	              // Open drop-down
	              if(!~$selectMultiple.activeMatchIndex || curr === last){
	                $select.activate();
	                return false;
	              }
	              // Select next/last item
	              else return next;
	              break;
	            case KEY.BACKSPACE:
	              // Remove selected item and select previous/first
	              if(~$selectMultiple.activeMatchIndex){
	                $selectMultiple.removeChoice(curr);
	                return prev;
	              }
	              // Select last item
	              else return last;
	              break;
	            case KEY.DELETE:
	              // Remove selected item and select next item
	              if(~$selectMultiple.activeMatchIndex){
	                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
	                return curr;
	              }
	              else return false;
	          }
	        }
	
	        newIndex = getNewActiveMatchIndex();
	
	        if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;
	        else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));
	
	        return true;
	      }
	
	      $select.searchInput.on('keyup', function(e) {
	
	        if ( ! KEY.isVerticalMovement(e.which) ) {
	          scope.$evalAsync( function () {
	            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
	          });
	        }
	        // Push a "create new" item into array if there is a search string
	        if ( $select.tagging.isActivated && $select.search.length > 0 ) {
	
	          // return early with these keys
	          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {
	            return;
	          }
	          // always reset the activeIndex to the first item when tagging
	          $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
	          // taggingLabel === false bypasses all of this
	          if ($select.taggingLabel === false) return;
	
	          var items = angular.copy( $select.items );
	          var stashArr = angular.copy( $select.items );
	          var newItem;
	          var item;
	          var hasTag = false;
	          var dupeIndex = -1;
	          var tagItems;
	          var tagItem;
	
	          // case for object tagging via transform `$select.tagging.fct` function
	          if ( $select.tagging.fct !== undefined) {
	            tagItems = $select.$filter('filter')(items,{'isTag': true});
	            if ( tagItems.length > 0 ) {
	              tagItem = tagItems[0];
	            }
	            // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous
	            if ( items.length > 0 && tagItem ) {
	              hasTag = true;
	              items = items.slice(1,items.length);
	              stashArr = stashArr.slice(1,stashArr.length);
	            }
	            newItem = $select.tagging.fct($select.search);
	            newItem.isTag = true;
	            // verify the the tag doesn't match the value of an existing item
	            if ( stashArr.filter( function (origItem) { return angular.equals( origItem, $select.tagging.fct($select.search) ); } ).length > 0 ) {
	              return;
	            }
	            newItem.isTag = true;
	          // handle newItem string and stripping dupes in tagging string context
	          } else {
	            // find any tagging items already in the $select.items array and store them
	            tagItems = $select.$filter('filter')(items,function (item) {
	              return item.match($select.taggingLabel);
	            });
	            if ( tagItems.length > 0 ) {
	              tagItem = tagItems[0];
	            }
	            item = items[0];
	            // remove existing tag item if found (should only ever be one tag item)
	            if ( item !== undefined && items.length > 0 && tagItem ) {
	              hasTag = true;
	              items = items.slice(1,items.length);
	              stashArr = stashArr.slice(1,stashArr.length);
	            }
	            newItem = $select.search+' '+$select.taggingLabel;
	            if ( _findApproxDupe($select.selected, $select.search) > -1 ) {
	              return;
	            }
	            // verify the the tag doesn't match the value of an existing item from
	            // the searched data set or the items already selected
	            if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {
	              // if there is a tag from prev iteration, strip it / queue the change
	              // and return early
	              if ( hasTag ) {
	                items = stashArr;
	                scope.$evalAsync( function () {
	                  $select.activeIndex = 0;
	                  $select.items = items;
	                });
	              }
	              return;
	            }
	            if ( _findCaseInsensitiveDupe(stashArr) ) {
	              // if there is a tag from prev iteration, strip it
	              if ( hasTag ) {
	                $select.items = stashArr.slice(1,stashArr.length);
	              }
	              return;
	            }
	          }
	          if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);
	          // dupe found, shave the first item
	          if ( dupeIndex > -1 ) {
	            items = items.slice(dupeIndex+1,items.length-1);
	          } else {
	            items = [];
	            items.push(newItem);
	            items = items.concat(stashArr);
	          }
	          scope.$evalAsync( function () {
	            $select.activeIndex = 0;
	            $select.items = items;
	          });
	        }
	      });
	      function _findCaseInsensitiveDupe(arr) {
	        if ( arr === undefined || $select.search === undefined ) {
	          return false;
	        }
	        var hasDupe = arr.filter( function (origItem) {
	          if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {
	            return false;
	          }
	          return origItem.toUpperCase() === $select.search.toUpperCase();
	        }).length > 0;
	
	        return hasDupe;
	      }
	      function _findApproxDupe(haystack, needle) {
	        var dupeIndex = -1;
	        if(angular.isArray(haystack)) {
	          var tempArr = angular.copy(haystack);
	          for (var i = 0; i <tempArr.length; i++) {
	            // handle the simple string version of tagging
	            if ( $select.tagging.fct === undefined ) {
	              // search the array for the match
	              if ( tempArr[i]+' '+$select.taggingLabel === needle ) {
	              dupeIndex = i;
	              }
	            // handle the object tagging implementation
	            } else {
	              var mockObj = tempArr[i];
	              if (angular.isObject(mockObj)) {
	                mockObj.isTag = true;
	              }
	              if ( angular.equals(mockObj, needle) ) {
	                dupeIndex = i;
	              }
	            }
	          }
	        }
	        return dupeIndex;
	      }
	
	      $select.searchInput.on('blur', function() {
	        $timeout(function() {
	          $selectMultiple.activeMatchIndex = -1;
	        });
	      });
	
	    }
	  };
	}]);
	
	uis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {
	  return {
	    restrict: 'EA',
	    require: ['^uiSelect', '^ngModel'],
	    link: function(scope, element, attrs, ctrls) {
	
	      var $select = ctrls[0];
	      var ngModel = ctrls[1];
	
	      //From view --> model
	      ngModel.$parsers.unshift(function (inputValue) {
	        var locals = {},
	            result;
	        locals[$select.parserResult.itemName] = inputValue;
	        result = $select.parserResult.modelMapper(scope, locals);
	        return result;
	      });
	
	      //From model --> view
	      ngModel.$formatters.unshift(function (inputValue) {
	        var data = $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
	            locals = {},
	            result;
	        if (data){
	          var checkFnSingle = function(d){
	            locals[$select.parserResult.itemName] = d;
	            result = $select.parserResult.modelMapper(scope, locals);
	            return result == inputValue;
	          };
	          //If possible pass same object stored in $select.selected
	          if ($select.selected && checkFnSingle($select.selected)) {
	            return $select.selected;
	          }
	          for (var i = data.length - 1; i >= 0; i--) {
	            if (checkFnSingle(data[i])) return data[i];
	          }
	        }
	        return inputValue;
	      });
	
	      //Update viewValue if model change
	      scope.$watch('$select.selected', function(newValue) {
	        if (ngModel.$viewValue !== newValue) {
	          ngModel.$setViewValue(newValue);
	        }
	      });
	
	      ngModel.$render = function() {
	        $select.selected = ngModel.$viewValue;
	      };
	
	      scope.$on('uis:select', function (event, item) {
	        $select.selected = item;
	      });
	
	      scope.$on('uis:close', function (event, skipFocusser) {
	        $timeout(function(){
	          $select.focusser.prop('disabled', false);
	          if (!skipFocusser) $select.focusser[0].focus();
	        },0,false);
	      });
	
	      scope.$on('uis:activate', function () {
	        focusser.prop('disabled', true); //Will reactivate it on .close()
	      });
	
	      //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954
	      var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
	      $compile(focusser)(scope);
	      $select.focusser = focusser;
	
	      //Input that will handle focus
	      $select.focusInput = focusser;
	
	      element.parent().append(focusser);
	      focusser.bind("focus", function(){
	        scope.$evalAsync(function(){
	          $select.focus = true;
	        });
	      });
	      focusser.bind("blur", function(){
	        scope.$evalAsync(function(){
	          $select.focus = false;
	        });
	      });
	      focusser.bind("keydown", function(e){
	
	        if (e.which === KEY.BACKSPACE) {
	          e.preventDefault();
	          e.stopPropagation();
	          $select.select(undefined);
	          scope.$apply();
	          return;
	        }
	
	        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
	          return;
	        }
	
	        if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){
	          e.preventDefault();
	          e.stopPropagation();
	          $select.activate();
	        }
	
	        scope.$digest();
	      });
	
	      focusser.bind("keyup input", function(e){
	
	        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
	          return;
	        }
	
	        $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input
	        focusser.val('');
	        scope.$digest();
	
	      });
	
	
	    }
	  };
	}]);
	// Make multiple matches sortable
	uis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {
	  return {
	    require: '^^uiSelect',
	    link: function(scope, element, attrs, $select) {
	      if (scope[attrs.uiSelectSort] === null) {
	        throw uiSelectMinErr('sort', 'Expected a list to sort');
	      }
	
	      var options = angular.extend({
	          axis: 'horizontal'
	        },
	        scope.$eval(attrs.uiSelectSortOptions));
	
	      var axis = options.axis;
	      var draggingClassName = 'dragging';
	      var droppingClassName = 'dropping';
	      var droppingBeforeClassName = 'dropping-before';
	      var droppingAfterClassName = 'dropping-after';
	
	      scope.$watch(function(){
	        return $select.sortable;
	      }, function(newValue){
	        if (newValue) {
	          element.attr('draggable', true);
	        } else {
	          element.removeAttr('draggable');
	        }
	      });
	
	      element.on('dragstart', function(event) {
	        element.addClass(draggingClassName);
	
	        (event.dataTransfer || event.originalEvent.dataTransfer).setData('text/plain', scope.$index);
	      });
	
	      element.on('dragend', function() {
	        element.removeClass(draggingClassName);
	      });
	
	      var move = function(from, to) {
	        /*jshint validthis: true */
	        this.splice(to, 0, this.splice(from, 1)[0]);
	      };
	
	      var dragOverHandler = function(event) {
	        event.preventDefault();
	
	        var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);
	
	        if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {
	          element.removeClass(droppingAfterClassName);
	          element.addClass(droppingBeforeClassName);
	
	        } else {
	          element.removeClass(droppingBeforeClassName);
	          element.addClass(droppingAfterClassName);
	        }
	      };
	
	      var dropTimeout;
	
	      var dropHandler = function(event) {
	        event.preventDefault();
	
	        var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text/plain'), 10);
	
	        // prevent event firing multiple times in firefox
	        $timeout.cancel(dropTimeout);
	        dropTimeout = $timeout(function() {
	          _dropHandler(droppedItemIndex);
	        }, 20);
	      };
	
	      var _dropHandler = function(droppedItemIndex) {
	        var theList = scope.$eval(attrs.uiSelectSort);
	        var itemToMove = theList[droppedItemIndex];
	        var newIndex = null;
	
	        if (element.hasClass(droppingBeforeClassName)) {
	          if (droppedItemIndex < scope.$index) {
	            newIndex = scope.$index - 1;
	          } else {
	            newIndex = scope.$index;
	          }
	        } else {
	          if (droppedItemIndex < scope.$index) {
	            newIndex = scope.$index;
	          } else {
	            newIndex = scope.$index + 1;
	          }
	        }
	
	        move.apply(theList, [droppedItemIndex, newIndex]);
	
	        scope.$apply(function() {
	          scope.$emit('uiSelectSort:change', {
	            array: theList,
	            item: itemToMove,
	            from: droppedItemIndex,
	            to: newIndex
	          });
	        });
	
	        element.removeClass(droppingClassName);
	        element.removeClass(droppingBeforeClassName);
	        element.removeClass(droppingAfterClassName);
	
	        element.off('drop', dropHandler);
	      };
	
	      element.on('dragenter', function() {
	        if (element.hasClass(draggingClassName)) {
	          return;
	        }
	
	        element.addClass(droppingClassName);
	
	        element.on('dragover', dragOverHandler);
	        element.on('drop', dropHandler);
	      });
	
	      element.on('dragleave', function(event) {
	        if (event.target != element) {
	          return;
	        }
	        element.removeClass(droppingClassName);
	        element.removeClass(droppingBeforeClassName);
	        element.removeClass(droppingAfterClassName);
	
	        element.off('dragover', dragOverHandler);
	        element.off('drop', dropHandler);
	      });
	    }
	  };
	}]);
	
	/**
	 * Parses "repeat" attribute.
	 *
	 * Taken from AngularJS ngRepeat source code
	 * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211
	 *
	 * Original discussion about parsing "repeat" attribute instead of fully relying on ng-repeat:
	 * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697
	 */
	
	uis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {
	  var self = this;
	
	  /**
	   * Example:
	   * expression = "address in addresses | filter: {street: $select.search} track by $index"
	   * itemName = "address",
	   * source = "addresses | filter: {street: $select.search}",
	   * trackByExp = "$index",
	   */
	  self.parse = function(expression) {
	
	
	    var match;
	    var isObjectCollection = /\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(expression);
	    // If an array is used as collection
	
	    // if (isObjectCollection){
	      //00000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000556666660000077777777777755000000000000000000000088888880000000
	    match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(([\w\.]+)?\s*(|\s*[\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);      
	
	    // 1 Alias
	    // 2 Item
	    // 3 Key on (key,value)
	    // 4 Value on (key,value)
	    // 5 Collection expresion (only used when using an array collection)
	    // 6 Object that will be converted to Array when using (key,value) syntax
	    // 7 Filters that will be applied to #6 when using (key,value) syntax
	    // 8 Track by
	
	    if (!match) {
	      throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
	              expression);
	    }
	    if (!match[6] && isObjectCollection) {
	      throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ as (_key_, _item_) in _ObjCollection_ [ track by _id_]' but got '{0}'.",
	              expression);
	    }
	
	    return {
	      itemName: match[4] || match[2], // (lhs) Left-hand side,
	      keyName: match[3], //for (key, value) syntax
	      source: $parse(!match[3] ? match[5] : match[6]),
	      sourceName: match[6],
	      filters: match[7],
	      trackByExp: match[8],
	      modelMapper: $parse(match[1] || match[4] || match[2]),
	      repeatExpression: function (grouped) {
	        var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');
	        if (this.trackByExp) {
	          expression += ' track by ' + this.trackByExp;
	        }
	        return expression;
	      } 
	    };
	
	  };
	
	  self.getGroupNgRepeatExpression = function() {
	    return '$group in $select.groups';
	  };
	
	}]);
	
	}());
	angular.module("ui.select").run(["$templateCache", function($templateCache) {$templateCache.put("bootstrap/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" role=\"listbox\" ng-show=\"$select.items.length > 0\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><a href=\"\" class=\"ui-select-choices-row-inner\"></a></div></li></ul>");
	$templateCache.put("bootstrap/match-multiple.tpl.html","<span class=\"ui-select-match\"><span ng-repeat=\"$item in $select.selected\"><span class=\"ui-select-match-item btn btn-default btn-xs\" tabindex=\"-1\" type=\"button\" ng-disabled=\"$select.disabled\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span class=\"close ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&nbsp;&times;</span> <span uis-transclude-append=\"\"></span></span></span></span>");
	$templateCache.put("bootstrap/match.tpl.html","<div class=\"ui-select-match\" ng-hide=\"$select.open\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty()\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i></a></span></div>");
	$templateCache.put("bootstrap/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\" ng-class=\"{open: $select.open}\"><div><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"false\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" class=\"ui-select-search input-xs\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-click=\"$select.activate()\" ng-model=\"$select.search\" role=\"combobox\" aria-label=\"{{ $select.baseTitle }}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div></div>");
	$templateCache.put("bootstrap/select.tpl.html","<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"false\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"form-control ui-select-search\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.searchEnabled && $select.open\"><div class=\"ui-select-choices\"></div></div>");
	$templateCache.put("select2/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{\'select2-result-with-children\': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }\"><li role=\"option\" id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>");
	$templateCache.put("select2/match-multiple.tpl.html","<span class=\"ui-select-match\"><li class=\"ui-select-match-item select2-search-choice\" ng-repeat=\"$item in $select.selected\" ng-class=\"{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span uis-transclude-append=\"\"></span> <a href=\"javascript:;\" class=\"ui-select-match-close select2-search-choice-close\" ng-click=\"$selectMultiple.removeChoice($index)\" tabindex=\"-1\"></a></li></span>");
	$templateCache.put("select2/match.tpl.html","<a class=\"select2-choice ui-select-match\" ng-class=\"{\'select2-default\': $select.isEmpty()}\" ng-click=\"$select.toggle($event)\" aria-label=\"{{ $select.baseTitle }} select\"><span ng-show=\"$select.isEmpty()\" class=\"select2-chosen\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"select2-chosen\" ng-transclude=\"\"></span> <abbr ng-if=\"$select.allowClear && !$select.isEmpty()\" class=\"select2-search-choice-close\" ng-click=\"$select.clear($event)\"></abbr> <span class=\"select2-arrow ui-select-toggle\"><b></b></span></a>");
	$templateCache.put("select2/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}\"><ul class=\"select2-choices\"><span class=\"ui-select-match\"></span><li class=\"select2-search-field\"><input type=\"text\" autocomplete=\"false\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"select2-input ui-select-search\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-model=\"$select.search\" ng-click=\"$select.activate()\" style=\"width: 34px;\" ondrop=\"return false;\"></li></ul><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"ui-select-choices\"></div></div></div>");
	$templateCache.put("select2/select.tpl.html","<div class=\"ui-select-container select2 select2-container\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"select2-search\" ng-show=\"$select.searchEnabled\"><input type=\"text\" autocomplete=\"false\" autocorrect=\"false\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div></div></div>");
	$templateCache.put("selectize/choices.tpl.html","<div ng-show=\"$select.open\" class=\"ui-select-choices ui-select-dropdown selectize-dropdown single\"><div class=\"ui-select-choices-content selectize-dropdown-content\"><div class=\"ui-select-choices-group optgroup\" role=\"listbox\"><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label optgroup-header\" ng-bind=\"$group.name\"></div><div role=\"option\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\"><div class=\"option ui-select-choices-row-inner\" data-selectable=\"\"></div></div></div></div></div>");
	$templateCache.put("selectize/match.tpl.html","<div ng-hide=\"($select.open || $select.isEmpty())\" class=\"ui-select-match\" ng-transclude=\"\"></div>");
	$templateCache.put("selectize/select.tpl.html","<div class=\"ui-select-container selectize-control single\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\"><div class=\"ui-select-match\"></div><input type=\"text\" autocomplete=\"false\" tabindex=\"-1\" class=\"ui-select-search ui-select-toggle\" ng-click=\"$select.toggle($event)\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-hide=\"!$select.searchEnabled || ($select.selected && !$select.open)\" ng-disabled=\"$select.disabled\" aria-label=\"{{ $select.baseTitle }}\"></div><div class=\"ui-select-choices\"></div></div>");}]);

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(167);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./select.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./select.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, "/*!\n * ui-select\n * http://github.com/angular-ui/ui-select\n * Version: 0.14.6 - 2016-02-18T21:01:36.972Z\n * License: MIT\n */\n\n\n/* Style when highlighting a search. */\n.ui-select-highlight {\n  font-weight: bold;\n}\n\n.ui-select-offscreen {\n  clip: rect(0 0 0 0) !important;\n  width: 1px !important;\n  height: 1px !important;\n  border: 0 !important;\n  margin: 0 !important;\n  padding: 0 !important;\n  overflow: hidden !important;\n  position: absolute !important;\n  outline: 0 !important;\n  left: 0px !important;\n  top: 0px !important;\n}\n\n\n.ui-select-choices-row:hover {\n  background-color: #f5f5f5;\n}\n\n/* Select2 theme */\n\n/* Mark invalid Select2 */\n.ng-dirty.ng-invalid > a.select2-choice {\n    border-color: #D44950;\n}\n\n.select2-result-single {\n  padding-left: 0;\n}\n\n.select2-locked > .select2-search-choice-close{\n  display:none;\n}\n\n.select-locked > .ui-select-match-close{\n    display:none;\n}\n\nbody > .select2-container.open {\n  z-index: 9999; /* The z-index Select2 applies to the select2-drop */\n}\n\n/* Handle up direction Select2 */\n.ui-select-container[theme=\"select2\"].direction-up .ui-select-match {\n    border-radius: 4px; /* FIXME hardcoded value :-/ */\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n}\n.ui-select-container[theme=\"select2\"].direction-up .ui-select-dropdown {\n    border-radius: 4px; /* FIXME hardcoded value :-/ */\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n\n    border-top-width: 1px;  /* FIXME hardcoded value :-/ */\n    border-top-style: solid;\n\n    box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.25);\n\n    margin-top: -4px; /* FIXME hardcoded value :-/ */\n}\n.ui-select-container[theme=\"select2\"].direction-up .ui-select-dropdown .select2-search {\n    margin-top: 4px; /* FIXME hardcoded value :-/ */\n}\n.ui-select-container[theme=\"select2\"].direction-up.select2-dropdown-open .ui-select-match {\n    border-bottom-color: #5897fb;\n}\n\n/* Selectize theme */\n\n/* Helper class to show styles when focus */\n.selectize-input.selectize-focus{\n  border-color: #007FBB !important;\n}\n\n/* Fix input width for Selectize theme */\n.selectize-control > .selectize-input > input {\n  width: 100%;\n}\n\n/* Fix dropdown width for Selectize theme */\n.selectize-control > .selectize-dropdown {\n  width: 100%;\n}\n\n/* Mark invalid Selectize */\n.ng-dirty.ng-invalid > div.selectize-input {\n    border-color: #D44950;\n}\n\n/* Handle up direction Selectize */\n.ui-select-container[theme=\"selectize\"].direction-up .ui-select-dropdown {\n    box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.25);\n\n    margin-top: -2px; /* FIXME hardcoded value :-/ */\n}\n\n/* Bootstrap theme */\n\n/* Helper class to show styles when focus */\n.btn-default-focus {\n  color: #333;\n  background-color: #EBEBEB;\n  border-color: #ADADAD;\n  text-decoration: none;\n  outline: 5px auto -webkit-focus-ring-color;\n  outline-offset: -2px;\n  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 8px rgba(102, 175, 233, 0.6);\n}\n\n.ui-select-bootstrap .ui-select-toggle {\n  position: relative;\n}\n\n.ui-select-bootstrap .ui-select-toggle > .caret {\n  position: absolute;\n  height: 10px;\n  top: 50%;\n  right: 10px;\n  margin-top: -2px;\n}\n\n/* Fix Bootstrap dropdown position when inside a input-group */\n.input-group > .ui-select-bootstrap.dropdown {\n  /* Instead of relative */\n  position: static;\n}\n\n.input-group > .ui-select-bootstrap > input.ui-select-search.form-control {\n  border-radius: 4px; /* FIXME hardcoded value :-/ */\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.input-group > .ui-select-bootstrap > input.ui-select-search.form-control.direction-up {\n  border-radius: 4px !important; /* FIXME hardcoded value :-/ */\n  border-top-right-radius: 0 !important;\n  border-bottom-right-radius: 0 !important;\n}\n\n.ui-select-bootstrap > .ui-select-match > .btn{\n  /* Instead of center because of .btn */\n  text-align: left !important;\n}\n\n.ui-select-bootstrap > .ui-select-match > .caret {\n  position: absolute;\n  top: 45%;\n  right: 15px;\n}\n\n/* See Scrollable Menu with Bootstrap 3 http://stackoverflow.com/questions/19227496 */\n.ui-select-bootstrap > .ui-select-choices {\n  width: 100%;\n  height: auto;\n  max-height: 200px;\n  overflow-x: hidden;\n  margin-top: -1px;\n}\n\nbody > .ui-select-bootstrap.open {\n  z-index: 1000; /* Standard Bootstrap dropdown z-index */\n}\n\n.ui-select-multiple.ui-select-bootstrap {\n  height: auto;\n  padding: 3px 3px 0 3px;\n}\n\n.ui-select-multiple.ui-select-bootstrap input.ui-select-search {\n  background-color: transparent !important; /* To prevent double background when disabled */\n  border: none;\n  outline: none;\n  height: 1.666666em;\n  margin-bottom: 3px;\n}\n\n.ui-select-multiple.ui-select-bootstrap .ui-select-match .close {\n  font-size: 1.6em;\n  line-height: 0.75;\n}\n\n.ui-select-multiple.ui-select-bootstrap .ui-select-match-item {\n  outline: 0;\n  margin: 0 3px 3px 0;\n}\n\n.ui-select-multiple .ui-select-match-item {\n  position: relative;\n}\n\n.ui-select-multiple .ui-select-match-item.dropping-before:before {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  right: 100%;\n  height: 100%;\n  margin-right: 2px;\n  border-left: 1px solid #428bca;\n}\n\n.ui-select-multiple .ui-select-match-item.dropping-after:after {\n  content: \"\";\n  position: absolute;\n  top: 0;\n  left: 100%;\n  height: 100%;\n  margin-left: 2px;\n  border-right: 1px solid #428bca;\n}\n\n.ui-select-bootstrap .ui-select-choices-row>a {\n    display: block;\n    padding: 3px 20px;\n    clear: both;\n    font-weight: 400;\n    line-height: 1.42857143;\n    color: #333;\n    white-space: nowrap;\n}\n\n.ui-select-bootstrap .ui-select-choices-row>a:hover, .ui-select-bootstrap .ui-select-choices-row>a:focus {\n    text-decoration: none;\n    color: #262626;\n    background-color: #f5f5f5;\n}\n\n.ui-select-bootstrap .ui-select-choices-row.active>a {\n    color: #fff;\n    text-decoration: none;\n    outline: 0;\n    background-color: #428bca;\n}\n\n.ui-select-bootstrap .ui-select-choices-row.disabled>a,\n.ui-select-bootstrap .ui-select-choices-row.active.disabled>a {\n    color: #777;\n    cursor: not-allowed;\n    background-color: #fff;\n}\n\n/* fix hide/show angular animation */\n.ui-select-match.ng-hide-add,\n.ui-select-search.ng-hide-add {\n    display: none !important;\n}\n\n/* Mark invalid Bootstrap */\n.ui-select-bootstrap.ng-dirty.ng-invalid > button.btn.ui-select-match {\n    border-color: #D44950;\n}\n\n/* Handle up direction Bootstrap */\n.ui-select-container[theme=\"bootstrap\"].direction-up .ui-select-dropdown {\n    box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.25);\n}\n", ""]);
	
	// exports


/***/ },
/* 168 */
/***/ function(module, exports) {

	module.exports = "<div class=\"field\" ng-class=\"{ 'has-error': select.ngModel.$invalid }\">\r\n\t<label ng-show=\"select.selection\" class=\"show-hide angular-animate\">\r\n\t\t{{select.label}}\r\n\t</label>\r\n\t<ui-select ng-model=\"select.selection\" search-enabled=\"false\" theme=\"bootstrap\" ng-disabled=\"select.ngDisabled\">\r\n\t\t<ui-select-match placeholder=\"{{select.label}}\">{{select.getDisplayName($select.selected)}}</ui-select-match>\r\n\t\t<ui-select-choices repeat=\"option in select.options\">\r\n\t\t\t{{select.getDisplayName(option)}}\r\n\t\t</ui-select-choices>\r\n\t</ui-select>\r\n\t<span class=\"error-string\" ng-show=\"select.inputValidator.error\">{{select.inputValidator.error}}</span>\r\n\t<rl-busy loading=\"select.loading\"></rl-busy>\r\n</div>"

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var SignaturePad = __webpack_require__(13);
	exports.moduleName = 'rl.ui.components.signaturePad';
	exports.directiveName = 'rlSignaturePad';
	function signaturePad() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: "\n\t\t\t<canvas class=\"signature-pad\" ng-if=\"!ngDisabled\"></canvas>\n\t\t\t<img ng-src=\"{{ngModel.$viewValue}}\" ng-style=\"style\" ng-if=\"ngDisabled\" />\n\t\t",
	        scope: {
	            pad: '=',
	            height: '=',
	            width: '=',
	            ngDisabled: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.$watch('ngDisabled', function (disabled) {
	                scope.ngModel = ngModel;
	                if (disabled) {
	                    scope.style = {
	                        height: scope.height != null ? scope.height : 100,
	                        width: scope.width != null ? scope.width : 200,
	                    };
	                }
	                else {
	                    var canvas = element.find('.signature-pad').get(0);
	                    var options = {
	                        backgroundColor: 'rgb(255, 255, 255)',
	                    };
	                    scope.pad = new SignaturePad(canvas, options);
	                    canvas.height = scope.height != null ? scope.height : 100;
	                    canvas.width = scope.width != null ? scope.width : 200;
	                    scope.$watch(function () { return ngModel.$viewValue; }, function (value) {
	                        if (value != null) {
	                            scope.pad.fromDataURL(value);
	                        }
	                    });
	                    scope.$watch(function () { return scope.pad.toDataURL(); }, function (value) {
	                        if (value != null) {
	                            ngModel.$setViewValue(value);
	                        }
	                    });
	                }
	            });
	        },
	    };
	}
	exports.signaturePad = signaturePad;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, signaturePad);
	//# sourceMappingURL=signaturePad.js.map

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var card = __webpack_require__(171);
	exports.simpleCard = card;
	var list = __webpack_require__(173);
	exports.simpleCardList = list;
	exports.moduleName = 'rl.ui.components.simpleCardList';
	angular.module(exports.moduleName, [__observable.moduleName, __parentChild.moduleName])
	    .directive(list.directiveName, list.simpleCardList)
	    .controller(list.controllerName, list.SimpleCardListController)
	    .directive(card.directiveName, card.simpleCard)
	    .controller(card.controllerName, card.SimpleCardController);
	//# sourceMappingURL=simpleCardList.module.js.map

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	'use strict';
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	exports.directiveName = 'rlSimpleCard';
	exports.controllerName = 'SimpleCardController';
	var SimpleCardController = (function () {
	    function SimpleCardController($scope, $element, parentChild) {
	        var _this = this;
	        this.$scope = $scope;
	        this.parentChild = parentChild;
	        this.showContent = false;
	        this.autosaveLink = {};
	        this.close = function () {
	            if (_this.showContent === false || _this.alwaysOpen) {
	                return true;
	            }
	            return _this.autosave();
	        };
	        if (this.canOpen == null) {
	            this.canOpen = true;
	        }
	        this.listController = $element.controller('rlSimpleCardList');
	        if (this.listController == null) {
	            this.listController = this.noList();
	        }
	        var behavior = {
	            autosave: this.autosave.bind(this),
	            close: this.close,
	            setAlwaysOpen: function (value) {
	                _this.alwaysOpen = value;
	            },
	        };
	        this.listController.registerCard(behavior);
	        parentChild.registerChildBehavior(this.childLink, behavior);
	        $scope.$watch(function () { return _this.alwaysOpen; }, function (value) {
	            if (value) {
	                _this.showContent = true;
	            }
	            else {
	                _this.close();
	            }
	        });
	    }
	    SimpleCardController.prototype.toggleContent = function () {
	        if (this.showContent) {
	            this.close();
	        }
	        else {
	            this.open();
	        }
	    };
	    SimpleCardController.prototype.open = function () {
	        if (this.canOpen && this.listController.openCard()) {
	            this.showContent = true;
	            this.onOpen();
	        }
	    };
	    SimpleCardController.prototype.autosave = function () {
	        var _this = this;
	        return this.parentChild.triggerChildBehavior(this.autosaveLink, function (behavior) {
	            var canClose = behavior.autosave();
	            if (canClose) {
	                _this.showContent = false;
	            }
	            return canClose;
	        });
	    };
	    SimpleCardController.prototype.noList = function () {
	        return {
	            openCard: function () {
	                return true;
	            },
	            registerCard: function (behavior) {
	                return null;
	            },
	        };
	    };
	    SimpleCardController.$inject = ['$scope', '$element', __parentChild.serviceName];
	    return SimpleCardController;
	}());
	exports.SimpleCardController = SimpleCardController;
	function simpleCard() {
	    'use strict';
	    return {
	        restrict: 'E',
	        transclude: {
	            'headerSlot': '?rlCardHeader',
	            'contentSlot': '?rlCardContent',
	            'footerSlot': '?rlCardFooter',
	        },
	        require: '?^^rlSimpleCardList',
	        template: __webpack_require__(172),
	        controller: exports.controllerName,
	        controllerAs: 'card',
	        scope: {},
	        bindToController: {
	            onOpen: '&',
	            canOpen: '=?',
	            alwaysOpen: '=?',
	            childLink: '=?',
	            save: '&',
	            saveWhenInvalid: '<?',
	            cardType: '@',
	        },
	    };
	}
	exports.simpleCard = simpleCard;
	//# sourceMappingURL=simpleCard.js.map

/***/ },
/* 172 */
/***/ function(module, exports) {

	module.exports = "<div class=\"card col-xs-12 {{card.cardType}}\">\r\n\t<div class=\"header row\" ng-class=\"{ 'active': card.canOpen && !card.alwaysOpen, 'error': cardForm.$invalid }\" ng-click=\"card.toggleContent()\">\r\n\t\t<div ng-transclude=\"headerSlot\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n\r\n\t<ng-form name=\"cardForm\" rl-autosave=\"card.autosaveLink\" save=\"card.save()\" save-when-invalid=\"card.saveWhenInvalid\">\r\n\t\t<div ng-show=\"card.showContent || card.alwaysOpen\">\r\n\t\t\t<div class=\"body row\">\r\n\t\t\t\t<div ng-transclude=\"contentSlot\"></div>\r\n\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t</div>\r\n\t\t\t<div class=\"footer row\">\r\n\t\t\t\t<div ng-transclude=\"footerSlot\"></div>\r\n\t\t\t\t<div class=\"clearfix\"></div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</ng-form>\r\n</div>"

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __observable = typescript_angular_utilities_1.services.observable;
	exports.directiveName = 'rlSimpleCardList';
	exports.controllerName = 'SimpleCardListController';
	var SimpleCardListController = (function () {
	    function SimpleCardListController($scope, $attrs, $parse, observableFactory) {
	        var _this = this;
	        this.observable = observableFactory.getInstance();
	        $scope.$watch(function () { return $parse($attrs.alwaysOpen)($scope); }, function (value) {
	            _this.alwaysOpen = value;
	            _this.observable.fire('alwaysOpen', value);
	        });
	    }
	    SimpleCardListController.prototype.registerCard = function (behavior) {
	        behavior.setAlwaysOpen(this.alwaysOpen);
	        var unregisterFunctions = [];
	        unregisterFunctions.push(this.observable.register(behavior.close, 'close'));
	        unregisterFunctions.push(this.observable.register(behavior.setAlwaysOpen, 'alwaysOpen'));
	        return function () {
	            _.each(unregisterFunctions, function (unregister) {
	                unregister();
	            });
	        };
	    };
	    SimpleCardListController.prototype.openCard = function () {
	        return _.every(this.observable.fire('close'));
	    };
	    SimpleCardListController.$inject = ['$scope', '$attrs', '$parse', __observable.factoryName];
	    return SimpleCardListController;
	}());
	exports.SimpleCardListController = SimpleCardListController;
	function simpleCardList() {
	    'use strict';
	    return {
	        restrict: 'AE',
	        controller: exports.controllerName,
	    };
	}
	exports.simpleCardList = simpleCardList;
	//# sourceMappingURL=simpleCardList.js.map

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/bootstrap-touchspin/bootstrap-touchspin.d.ts' />
	// /// <reference path='../../../typings/jquery/jquery.d.ts' />
	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	__webpack_require__(175);
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __string = typescript_angular_utilities_1.services.string;
	var __number = typescript_angular_utilities_1.services.number;
	var __object = typescript_angular_utilities_1.services.object;
	var __guid = typescript_angular_utilities_1.services.guid;
	var required_1 = __webpack_require__(25);
	var componentValidator_service_1 = __webpack_require__(112);
	exports.moduleName = 'rl.ui.components.spinner';
	exports.directiveName = 'rlSpinner';
	exports.controllerName = 'SpinnerController';
	exports.defaultMaxValue = 100000000000000000000;
	var SpinnerController = (function () {
	    function SpinnerController($scope, $attrs, componentValidatorFactory) {
	        var _this = this;
	        if (__object.objectUtility.isNullOrEmpty($attrs.name)) {
	            $attrs.$set('name', 'spinner-' + __guid.guid.random());
	        }
	        var unregister = $scope.$watch(function () { return _this.ngModel; }, function (value) {
	            var validators = [];
	            if (!_.isUndefined(_this.validator)) {
	                validators.push(_this.validator);
	            }
	            if (_this.required != null) {
	                validators.push({
	                    name: 'rlRequired',
	                    validate: function () { return !__object.objectUtility.isNullOrEmpty(_this.ngModel.$viewValue); },
	                    errorMessage: _this.required.message,
	                });
	            }
	            if (_.some(validators)) {
	                _this.spinnerValidator = componentValidatorFactory.getInstance({
	                    ngModel: _this.ngModel,
	                    $scope: $scope,
	                    validators: validators,
	                });
	            }
	            unregister();
	        });
	    }
	    SpinnerController.$inject = ['$scope', '$attrs', componentValidator_service_1.factoryName];
	    return SpinnerController;
	}());
	exports.SpinnerController = SpinnerController;
	spinner.$inject = ['$timeout', __string.serviceName, __number.serviceName];
	function spinner($timeout, stringUtility, numberUtility) {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: __webpack_require__(179),
	        require: ['ngModel', '?' + required_1.directiveName],
	        controller: exports.controllerName,
	        controllerAs: 'spinner',
	        scope: {},
	        bindToController: {
	            min: '=',
	            max: '=',
	            step: '=',
	            decimals: '=',
	            prefix: '@',
	            postfix: '@',
	            roundToStep: '=',
	            ngDisabled: '=',
	            spinnerId: '@',
	            name: '@',
	            validator: '=',
	        },
	        link: function (scope, element, attrs, controllers) {
	            var spinner = scope.spinner;
	            var ngModel = controllers[0];
	            spinner.required = controllers[1];
	            spinner.ngModel = ngModel;
	            var unbindWatches;
	            scope.$watch('spinner.ngDisabled', function (disabled) {
	                if (disabled) {
	                    if (_.isFunction(unbindWatches)) {
	                        unbindWatches();
	                    }
	                }
	                else {
	                    // Initialize the spinner after $timeout to give angular a chance initialize ngModel
	                    $timeout(function () {
	                        var touchspin = element.find('input.spinner').TouchSpin({
	                            min: (spinner.min != null ? spinner.min : 0),
	                            max: (spinner.max != null ? spinner.max : exports.defaultMaxValue),
	                            step: spinner.step,
	                            prefix: spinner.prefix,
	                            postfix: spinner.postfix,
	                            decimals: spinner.decimals,
	                            initval: ngModel.$viewValue,
	                            forcestepdivisibility: spinner.roundToStep ? 'round' : 'none',
	                        });
	                        touchspin.on('change', function () {
	                            scope.$apply(function () {
	                                var spinValue = touchspin.val();
	                                ngModel.$setViewValue(stringUtility.toNumber(spinValue));
	                            });
	                        });
	                        var unbindViewWatch = scope.$watch(function () {
	                            return ngModel.$viewValue;
	                        }, function (newValue) {
	                            touchspin.val(newValue != null ? newValue.toString() : '');
	                        });
	                        var unbindModelWatch = scope.$watch(function () {
	                            return ngModel.$modelValue;
	                        }, function (newModel) {
	                            ngModel.$modelValue = round(newModel);
	                        });
	                        unbindWatches = function () {
	                            unbindViewWatch();
	                            unbindModelWatch();
	                        };
	                    });
	                }
	            });
	            function round(num) {
	                if (num != null && spinner.roundToStep) {
	                    num = numberUtility.roundToStep(num, spinner.step);
	                    num = numberUtility.preciseRound(num, spinner.decimals);
	                }
	                return num;
	            }
	        }
	    };
	}
	angular.module(exports.moduleName, [__string.moduleName, componentValidator_service_1.moduleName, __number.moduleName])
	    .directive(exports.directiveName, spinner)
	    .controller(exports.controllerName, SpinnerController);
	//# sourceMappingURL=spinner.js.map

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	jQuery = __webpack_require__(12);
	
	__webpack_require__(176);
	__webpack_require__(178);

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(177);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./jquery.bootstrap-touchspin.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./jquery.bootstrap-touchspin.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)();
	// imports
	
	
	// module
	exports.push([module.id, "/*\r\n *  Bootstrap TouchSpin - v3.0.1\r\n *  A mobile and touch friendly input spinner component for Bootstrap 3.\r\n *  http://www.virtuosoft.eu/code/bootstrap-touchspin/\r\n *\r\n *  Made by István Ujj-Mészáros\r\n *  Under Apache License v2.0 License\r\n */\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical {\r\n  position: relative;\r\n  white-space: nowrap;\r\n  width: 1%;\r\n  vertical-align: middle;\r\n  display: table-cell;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical > .btn {\r\n  display: block;\r\n  float: none;\r\n  width: 100%;\r\n  max-width: 100%;\r\n  padding: 8px 10px;\r\n  margin-left: -1px;\r\n  position: relative;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical .bootstrap-touchspin-up {\r\n  border-radius: 0;\r\n  border-top-right-radius: 4px;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical .bootstrap-touchspin-down {\r\n  margin-top: -2px;\r\n  border-radius: 0;\r\n  border-bottom-right-radius: 4px;\r\n}\r\n\r\n.bootstrap-touchspin .input-group-btn-vertical i {\r\n  position: absolute;\r\n  top: 3px;\r\n  left: 5px;\r\n  font-size: 9px;\r\n  font-weight: normal;\r\n}\r\n", ""]);
	
	// exports


/***/ },
/* 178 */
/***/ function(module, exports) {

	/*
	 *  Bootstrap TouchSpin - v3.0.1
	 *  A mobile and touch friendly input spinner component for Bootstrap 3.
	 *  http://www.virtuosoft.eu/code/bootstrap-touchspin/
	 *
	 *  Made by István Ujj-Mészáros
	 *  Under Apache License v2.0 License
	 */
	(function($) {
	  'use strict';
	
	  var _currentSpinnerId = 0;
	
	  function _scopedEventName(name, id) {
	    return name + '.touchspin_' + id;
	  }
	
	  function _scopeEventNames(names, id) {
	    return $.map(names, function(name) {
	      return _scopedEventName(name, id);
	    });
	  }
	
	  $.fn.TouchSpin = function(options) {
	
	    if (options === 'destroy') {
	      this.each(function() {
	        var originalinput = $(this),
	            originalinput_data = originalinput.data();
	        $(document).off(_scopeEventNames([
	          'mouseup',
	          'touchend',
	          'touchcancel',
	          'mousemove',
	          'touchmove',
	          'scroll',
	          'scrollstart'], originalinput_data.spinnerid).join(' '));
	      });
	      return;
	    }
	
	    var defaults = {
	      min: 0,
	      max: 100,
	      initval: '',
	      step: 1,
	      decimals: 0,
	      stepinterval: 100,
	      forcestepdivisibility: 'round', // none | floor | round | ceil
	      stepintervaldelay: 500,
	      verticalbuttons: false,
	      verticalupclass: 'glyphicon glyphicon-chevron-up',
	      verticaldownclass: 'glyphicon glyphicon-chevron-down',
	      prefix: '',
	      postfix: '',
	      prefix_extraclass: '',
	      postfix_extraclass: '',
	      booster: true,
	      boostat: 10,
	      maxboostedstep: false,
	      mousewheel: true,
	      buttondown_class: 'btn btn-default',
	      buttonup_class: 'btn btn-default',
		  buttondown_txt: '-',
		  buttonup_txt: '+'
	    };
	
	    var attributeMap = {
	      min: 'min',
	      max: 'max',
	      initval: 'init-val',
	      step: 'step',
	      decimals: 'decimals',
	      stepinterval: 'step-interval',
	      verticalbuttons: 'vertical-buttons',
	      verticalupclass: 'vertical-up-class',
	      verticaldownclass: 'vertical-down-class',
	      forcestepdivisibility: 'force-step-divisibility',
	      stepintervaldelay: 'step-interval-delay',
	      prefix: 'prefix',
	      postfix: 'postfix',
	      prefix_extraclass: 'prefix-extra-class',
	      postfix_extraclass: 'postfix-extra-class',
	      booster: 'booster',
	      boostat: 'boostat',
	      maxboostedstep: 'max-boosted-step',
	      mousewheel: 'mouse-wheel',
	      buttondown_class: 'button-down-class',
	      buttonup_class: 'button-up-class',
		  buttondown_txt: 'button-down-txt',
		  buttonup_txt: 'button-up-txt'
	    };
	
	    return this.each(function() {
	
	      var settings,
	          originalinput = $(this),
	          originalinput_data = originalinput.data(),
	          container,
	          elements,
	          value,
	          downSpinTimer,
	          upSpinTimer,
	          downDelayTimeout,
	          upDelayTimeout,
	          spincount = 0,
	          spinning = false;
	
	      init();
	
	
	      function init() {
	        if (originalinput.data('alreadyinitialized')) {
	          return;
	        }
	
	        originalinput.data('alreadyinitialized', true);
	        _currentSpinnerId += 1;
	        originalinput.data('spinnerid', _currentSpinnerId);
	
	
	        if (!originalinput.is('input')) {
	          console.log('Must be an input.');
	          return;
	        }
	
	        _initSettings();
	        _setInitval();
	        _checkValue();
	        _buildHtml();
	        _initElements();
	        _hideEmptyPrefixPostfix();
	        _bindEvents();
	        _bindEventsInterface();
	        elements.input.css('display', 'block');
	      }
	
	      function _setInitval() {
	        if (settings.initval !== '' && originalinput.val() === '') {
	          originalinput.val(settings.initval);
	        }
	      }
	
	      function changeSettings(newsettings) {
	        _updateSettings(newsettings);
	        _checkValue();
	
	        var value = elements.input.val();
	
	        if (value !== '') {
	          value = Number(elements.input.val());
	          elements.input.val(value.toFixed(settings.decimals));
	        }
	      }
	
	      function _initSettings() {
	        settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
	      }
	
	      function _parseAttributes() {
	        var data = {};
	        $.each(attributeMap, function(key, value) {
	          var attrName = 'bts-' + value + '';
	          if (originalinput.is('[data-' + attrName + ']')) {
	            data[key] = originalinput.data(attrName);
	          }
	        });
	        return data;
	      }
	
	      function _updateSettings(newsettings) {
	        settings = $.extend({}, settings, newsettings);
	      }
	
	      function _buildHtml() {
	        var initval = originalinput.val(),
	            parentelement = originalinput.parent();
	
	        if (initval !== '') {
	          initval = Number(initval).toFixed(settings.decimals);
	        }
	
	        originalinput.data('initvalue', initval).val(initval);
	        originalinput.addClass('form-control');
	
	        if (parentelement.hasClass('input-group')) {
	          _advanceInputGroup(parentelement);
	        }
	        else {
	          _buildInputGroup();
	        }
	      }
	
	      function _advanceInputGroup(parentelement) {
	        parentelement.addClass('bootstrap-touchspin');
	
	        var prev = originalinput.prev(),
	            next = originalinput.next();
	
	        var downhtml,
	            uphtml,
	            prefixhtml = '<span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span>',
	            postfixhtml = '<span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span>';
	
	        if (prev.hasClass('input-group-btn')) {
	          downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button>';
	          prev.append(downhtml);
	        }
	        else {
	          downhtml = '<span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span>';
	          $(downhtml).insertBefore(originalinput);
	        }
	
	        if (next.hasClass('input-group-btn')) {
	          uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button>';
	          next.prepend(uphtml);
	        }
	        else {
	          uphtml = '<span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span>';
	          $(uphtml).insertAfter(originalinput);
	        }
	
	        $(prefixhtml).insertBefore(originalinput);
	        $(postfixhtml).insertAfter(originalinput);
	
	        container = parentelement;
	      }
	
	      function _buildInputGroup() {
	        var html;
	
	        if (settings.verticalbuttons) {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-up" type="button"><i class="' + settings.verticalupclass + '"></i></button><button class="' + settings.buttonup_class + ' bootstrap-touchspin-down" type="button"><i class="' + settings.verticaldownclass + '"></i></button></span></div>';
	        }
	        else {
	          html = '<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span></div>';
	        }
	
	        container = $(html).insertBefore(originalinput);
	
	        $('.bootstrap-touchspin-prefix', container).after(originalinput);
	
	        if (originalinput.hasClass('input-sm')) {
	          container.addClass('input-group-sm');
	        }
	        else if (originalinput.hasClass('input-lg')) {
	          container.addClass('input-group-lg');
	        }
	      }
	
	      function _initElements() {
	        elements = {
	          down: $('.bootstrap-touchspin-down', container),
	          up: $('.bootstrap-touchspin-up', container),
	          input: $('input', container),
	          prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),
	          postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)
	        };
	      }
	
	      function _hideEmptyPrefixPostfix() {
	        if (settings.prefix === '') {
	          elements.prefix.hide();
	        }
	
	        if (settings.postfix === '') {
	          elements.postfix.hide();
	        }
	      }
	
	      function _bindEvents() {
	        originalinput.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 38) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	          else if (code === 40) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        originalinput.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 38) {
	            stopSpin();
	          }
	          else if (code === 40) {
	            stopSpin();
	          }
	        });
	
	        originalinput.on('blur', function() {
	          _checkValue();
	        });
	
	        elements.down.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            if (spinning !== 'down') {
	              downOnce();
	              startDownSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        elements.down.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });
	
	        elements.up.on('keydown', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            if (spinning !== 'up') {
	              upOnce();
	              startUpSpin();
	            }
	            ev.preventDefault();
	          }
	        });
	
	        elements.up.on('keyup', function(ev) {
	          var code = ev.keyCode || ev.which;
	
	          if (code === 32 || code === 13) {
	            stopSpin();
	          }
	        });
	
	        elements.down.on('mousedown.touchspin', function(ev) {
	          elements.down.off('touchstart.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          downOnce();
	          startDownSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.down.on('touchstart.touchspin', function(ev) {
	          elements.down.off('mousedown.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          downOnce();
	          startDownSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('mousedown.touchspin', function(ev) {
	          elements.up.off('touchstart.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          upOnce();
	          startUpSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('touchstart.touchspin', function(ev) {
	          elements.up.off('mousedown.touchspin');  // android 4 workaround
	
	          if (originalinput.is(':disabled')) {
	            return;
	          }
	
	          upOnce();
	          startUpSpin();
	
	          ev.preventDefault();
	          ev.stopPropagation();
	        });
	
	        elements.up.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          stopSpin();
	        });
	
	        elements.down.on('mouseout touchleave touchend touchcancel', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          stopSpin();
	        });
	
	        elements.down.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          ev.preventDefault();
	        });
	
	        elements.up.on('mousemove touchmove', function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.stopPropagation();
	          ev.preventDefault();
	        });
	
	        $(document).on(_scopeEventNames(['mouseup', 'touchend', 'touchcancel'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.preventDefault();
	          stopSpin();
	        });
	
	        $(document).on(_scopeEventNames(['mousemove', 'touchmove', 'scroll', 'scrollstart'], _currentSpinnerId).join(' '), function(ev) {
	          if (!spinning) {
	            return;
	          }
	
	          ev.preventDefault();
	          stopSpin();
	        });
	
	        originalinput.on('mousewheel DOMMouseScroll', function(ev) {
	          if (!settings.mousewheel || !originalinput.is(':focus')) {
	            return;
	          }
	
	          var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;
	
	          ev.stopPropagation();
	          ev.preventDefault();
	
	          if (delta < 0) {
	            downOnce();
	          }
	          else {
	            upOnce();
	          }
	        });
	      }
	
	      function _bindEventsInterface() {
	        originalinput.on('touchspin.uponce', function() {
	          stopSpin();
	          upOnce();
	        });
	
	        originalinput.on('touchspin.downonce', function() {
	          stopSpin();
	          downOnce();
	        });
	
	        originalinput.on('touchspin.startupspin', function() {
	          startUpSpin();
	        });
	
	        originalinput.on('touchspin.startdownspin', function() {
	          startDownSpin();
	        });
	
	        originalinput.on('touchspin.stopspin', function() {
	          stopSpin();
	        });
	
	        originalinput.on('touchspin.updatesettings', function(e, newsettings) {
	          changeSettings(newsettings);
	        });
	      }
	
	      function _forcestepdivisibility(value) {
	        switch (settings.forcestepdivisibility) {
	          case 'round':
	            return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'floor':
	            return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);
	          case 'ceil':
	            return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);
	          default:
	            return value;
	        }
	      }
	
	      function _checkValue() {
	        var val, parsedval, returnval;
	
	        val = originalinput.val();
	
	        if (val === '') {
	          return;
	        }
	
	        if (settings.decimals > 0 && val === '.') {
	          return;
	        }
	
	        parsedval = parseFloat(val);
	
	        if (isNaN(parsedval)) {
	          parsedval = 0;
	        }
	
	        returnval = parsedval;
	
	        if (parsedval.toString() !== val) {
	          returnval = parsedval;
	        }
	
	        if (parsedval < settings.min) {
	          returnval = settings.min;
	        }
	
	        if (parsedval > settings.max) {
	          returnval = settings.max;
	        }
	
	        returnval = _forcestepdivisibility(returnval);
	
	        if (Number(val).toString() !== returnval.toString()) {
	          originalinput.val(returnval);
	          originalinput.trigger('change');
	        }
	      }
	
	      function _getBoostedStep() {
	        if (!settings.booster) {
	          return settings.step;
	        }
	        else {
	          var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;
	
	          if (settings.maxboostedstep) {
	            if (boosted > settings.maxboostedstep) {
	              boosted = settings.maxboostedstep;
	              value = Math.round((value / boosted)) * boosted;
	            }
	          }
	
	          return Math.max(settings.step, boosted);
	        }
	      }
	
	      function upOnce() {
	        _checkValue();
	
	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }
	
	        var initvalue = value,
	            boostedstep = _getBoostedStep();
	
	        value = value + boostedstep;
	
	        if (value > settings.max) {
	          value = settings.max;
	          originalinput.trigger('touchspin.on.max');
	          stopSpin();
	        }
	
	        elements.input.val(Number(value).toFixed(settings.decimals));
	
	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }
	
	      function downOnce() {
	        _checkValue();
	
	        value = parseFloat(elements.input.val());
	        if (isNaN(value)) {
	          value = 0;
	        }
	
	        var initvalue = value,
	            boostedstep = _getBoostedStep();
	
	        value = value - boostedstep;
	
	        if (value < settings.min) {
	          value = settings.min;
	          originalinput.trigger('touchspin.on.min');
	          stopSpin();
	        }
	
	        elements.input.val(value.toFixed(settings.decimals));
	
	        if (initvalue !== value) {
	          originalinput.trigger('change');
	        }
	      }
	
	      function startDownSpin() {
	        stopSpin();
	
	        spincount = 0;
	        spinning = 'down';
	
	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startdownspin');
	
	        downDelayTimeout = setTimeout(function() {
	          downSpinTimer = setInterval(function() {
	            spincount++;
	            downOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }
	
	      function startUpSpin() {
	        stopSpin();
	
	        spincount = 0;
	        spinning = 'up';
	
	        originalinput.trigger('touchspin.on.startspin');
	        originalinput.trigger('touchspin.on.startupspin');
	
	        upDelayTimeout = setTimeout(function() {
	          upSpinTimer = setInterval(function() {
	            spincount++;
	            upOnce();
	          }, settings.stepinterval);
	        }, settings.stepintervaldelay);
	      }
	
	      function stopSpin() {
	        clearTimeout(downDelayTimeout);
	        clearTimeout(upDelayTimeout);
	        clearInterval(downSpinTimer);
	        clearInterval(upSpinTimer);
	
	        switch (spinning) {
	          case 'up':
	            originalinput.trigger('touchspin.on.stopupspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	          case 'down':
	            originalinput.trigger('touchspin.on.stopdownspin');
	            originalinput.trigger('touchspin.on.stopspin');
	            break;
	        }
	
	        spincount = 0;
	        spinning = false;
	      }
	
	    });
	
	  };
	
	})(jQuery);


/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = "<rl-generic-container selector=\"spinner.ngDisabled\">\r\n\t<template default>\r\n\t\t<div ng-class=\"{ 'error': spinner.ngModel.$invalid }\">\r\n\t\t\t<input name=\"{{spinner.name}}\" class=\"spinner\" id=\"{{spinner.spinnerId}}\" type=\"text\" />\r\n\t\t\t<span class=\"error-string\" ng-hide=\"spinner.spinnerValidator.error | isEmpty\">{{spinner.spinnerValidator.error}}</span>\r\n\t\t</div>\r\n\t</template>\r\n\t<template when-selector=\"true\">\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix != null && spinner.postfix != null\">\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.prefix}}</span>\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.postfix}}</span>\r\n\t\t</div>\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix != null && spinner.postfix == null\">\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.prefix}}</span>\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t</div>\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix == null && spinner.postfix != null\">\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t\t<span class=\"input-group-addon\">{{spinner.postfix}}</span>\r\n\t\t</div>\r\n\t\t<div class=\"input-group\" ng-show=\"spinner.prefix == null && spinner.postfix == null\">\r\n\t\t\t<input disabled=\"true\" type=\"text\" ng-model=\"spinner.ngModel.$viewValue\" class=\"form-control\" />\r\n\t\t</div>\r\n\t</template>\r\n</rl-generic-container>"

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __object = typescript_angular_utilities_1.services.object;
	exports.moduleName = 'rl.ui.components.stringWithWatermark';
	exports.directiveName = 'rlStringWithWatermark';
	exports.controllerName = 'StringWithWatermarkController';
	var StringWithWatermarkController = (function () {
	    function StringWithWatermarkController($scope, objectUtility) {
	        var _this = this;
	        $scope.$watch(function () { return _this.string; }, function (value) {
	            _this.hasString = objectUtility.isNullOrEmpty(value) === false;
	        });
	    }
	    StringWithWatermarkController.$inject = ['$scope', __object.serviceName];
	    return StringWithWatermarkController;
	}());
	exports.StringWithWatermarkController = StringWithWatermarkController;
	function stringWithWatermark() {
	    'use strict';
	    return {
	        restrict: 'E',
	        template: "\n\t\t\t<span>\n\t\t\t\t<span ng-show=\"controller.hasString\">{{controller.string}}</span>\n\t\t\t\t<span ng-hide=\"controller.hasString\" class=\"watermark\">{{controller.watermark}}</span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'controller',
	        scope: {},
	        bindToController: {
	            string: '@',
	            watermark: '@',
	        }
	    };
	}
	exports.stringWithWatermark = stringWithWatermark;
	angular.module(exports.moduleName, [__object.moduleName])
	    .directive(exports.directiveName, stringWithWatermark)
	    .controller(exports.controllerName, StringWithWatermarkController);
	//# sourceMappingURL=stringWithWatermark.js.map

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var tab_1 = __webpack_require__(182);
	exports.tabDirectiveName = tab_1.directiveName;
	exports.tab = tab_1.tab;
	exports.tabControllerName = tab_1.controllerName;
	exports.TabController = tab_1.TabController;
	var tabset_1 = __webpack_require__(184);
	exports.tabsetDirectiveName = tabset_1.directiveName;
	exports.tabset = tabset_1.tabset;
	exports.tabsetControllerName = tabset_1.controllerName;
	exports.TabsetController = tabset_1.TabsetController;
	exports.moduleName = 'rl.ui.components.tabs';
	angular.module(exports.moduleName, [])
	    .directive(tab_1.directiveName, tab_1.tab)
	    .controller(tab_1.controllerName, tab_1.TabController)
	    .directive(tabset_1.directiveName, tabset_1.tabset)
	    .controller(tabset_1.controllerName, tabset_1.TabsetController);
	//# sourceMappingURL=tabs.module.js.map

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	exports.directiveName = 'rlTab';
	exports.controllerName = 'rlTabController';
	var TabController = (function () {
	    function TabController($scope) {
	        var _this = this;
	        $scope.$watch('tabForm.$valid', function (isValid) {
	            _this.header.isValid = isValid != null ? isValid : true;
	        });
	    }
	    TabController.$inject = ['$scope'];
	    return TabController;
	}());
	exports.TabController = TabController;
	function tab() {
	    return {
	        restrict: 'E',
	        transclude: {
	            'headerSlot': '?rlTabHeader',
	            'contentSlot': '?rlTabContent',
	            'footerSlot': '?rlTabFooter',
	        },
	        require: ['^^rlTabset', 'rlTab'],
	        template: __webpack_require__(183),
	        controller: exports.controllerName,
	        controllerAs: 'tab',
	        scope: {},
	        bindToController: {},
	        link: function (scope, element, attrs, controllers, transclude) {
	            transclude(function (header) {
	                var tabset = controllers[0];
	                var tab = controllers[1];
	                tab.header = {
	                    template: header.html(),
	                    isValid: true,
	                };
	                tabset.registerTab(element, tab.header);
	            }, null, 'headerSlot');
	        },
	    };
	}
	exports.tab = tab;
	//# sourceMappingURL=tab.js.map

/***/ },
/* 183 */
/***/ function(module, exports) {

	module.exports = "<div class=\"tab-pane\" ng-class=\"{ 'active': tab.header.isVisible }\">\r\n\t<div class=\"tab-body\">\r\n\t\t<div ng-transclude=\"contentSlot\" ng-form=\"tabForm\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n\t<div class=\"tab-footer\">\r\n\t\t<div ng-transclude=\"footerSlot\"></div>\r\n\t\t<div class=\"clearfix\"></div>\r\n\t</div>\r\n</div>"

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __array = typescript_angular_utilities_1.services.array;
	exports.directiveName = 'rlTabset';
	exports.controllerName = 'rlTabsetController';
	var TabsetController = (function () {
	    function TabsetController() {
	        this.tabHeaders = [];
	    }
	    TabsetController.prototype.registerTab = function (element, header) {
	        var index = this.findPosition(element);
	        if (__array.arrayUtility.has(this.tabHeaders, index)) {
	            header.isVisible = this.tabHeaders[index].isVisible;
	        }
	        else {
	            header.isVisible = (index === 0);
	        }
	        this.tabHeaders[index] = header;
	    };
	    TabsetController.prototype.select = function (tab) {
	        _.each(this.tabHeaders, function (otherTab) {
	            otherTab.isVisible = false;
	        });
	        tab.isVisible = true;
	    };
	    return TabsetController;
	}());
	exports.TabsetController = TabsetController;
	function tabset() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(185),
	        controller: exports.controllerName,
	        controllerAs: 'tabset',
	        scope: {},
	        link: {
	            pre: function (scope, element, attrs, tabset) {
	                tabset.findPosition = function (tabElement) {
	                    // find the position of the specified element by iterating over the tabs and finding a matching element
	                    var tabs = element.find('rl-tab');
	                    var num;
	                    _.each(tabs, function (elem, index) {
	                        if (tabElement[0] === elem) {
	                            num = index;
	                            return false;
	                        }
	                    });
	                    return num;
	                };
	            },
	        },
	    };
	}
	exports.tabset = tabset;
	//# sourceMappingURL=tabset.js.map

/***/ },
/* 185 */
/***/ function(module, exports) {

	module.exports = "<div class=\"nav-tabs-dropshadow\">\r\n\t<ul class=\"nav nav-tabs\">\r\n\t\t<li ng-repeat=\"tabHeader in tabset.tabHeaders\" ng-click=\"tabset.select(tabHeader)\"\r\n\t\t\tng-class=\"{ 'active': tabHeader.isVisible, 'error': !tabHeader.isValid }\">\r\n\t\t\t<a><span ng-bind-html=\"tabHeader.template\"></span></a>\r\n\t\t</li>\r\n\t</ul>\r\n\t<div class=\"tab-content\">\r\n\t\t<div ng-transclude></div>\r\n\t</div>\r\n</div>"

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	exports.moduleName = 'rl.ui.components.templateRenderer';
	exports.componentName = 'rlTemplateRenderer';
	exports.controllerName = 'TemplateRendererController';
	var TemplateRendererController = (function () {
	    function TemplateRendererController($compile, $element) {
	        var target = $element.find('.template-target');
	        var template = target.append(this.template.template);
	        $compile(template)(this.template.scope);
	    }
	    TemplateRendererController.$inject = ['$compile', '$element'];
	    return TemplateRendererController;
	}());
	exports.TemplateRendererController = TemplateRendererController;
	var templateRenderer = {
	    template: '<div class="template-target"></div>',
	    controller: exports.controllerName,
	    controllerAs: 'controller',
	    bindings: {
	        template: '<',
	    },
	};
	angular.module(exports.moduleName, [])
	    .component(exports.componentName, templateRenderer)
	    .controller(exports.controllerName, TemplateRendererController);
	//# sourceMappingURL=templateRenderer.js.map

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var input_1 = __webpack_require__(158);
	exports.moduleName = 'rl.ui.components.textarea';
	exports.componentName = 'rlTextarea';
	var textarea = _.clone(input_1.input);
	textarea.template = __webpack_require__(188);
	var textareaBindings = textarea.bindings;
	textareaBindings.rows = '<?';
	textareaBindings.ngDisabled = '<?';
	textareaBindings.maxlength = '<?';
	angular.module(exports.moduleName, [input_1.moduleName])
	    .component(exports.componentName, textarea);
	//# sourceMappingURL=textarea.js.map

/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports = "<div class=\"field\" ng-class=\"{ 'error': input.ngModel.$invalid }\">\r\n\t<label ng-show=\"input.inputValue && input.label\" class=\"show-hide angular-animate\">{{input.label}}</label>\r\n\t<textarea class=\"form-control\" ng-model=\"input.inputValue\" rows=\"{{input.rows}}\" maxlength=\"{{input.maxlength}}\" ng-disabled=\"input.ngDisabled\" placeholder=\"{{input.label}}\"></textarea>\r\n\t<span class=\"error-string\" ng-hide=\"input.inputValidator.error | isEmpty\">{{input.inputValidator.error}}</span>\r\n</div>"

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var input_1 = __webpack_require__(158);
	exports.moduleName = 'rl.ui.components.textbox';
	exports.componentName = 'rlTextbox';
	var textbox = _.clone(input_1.input);
	textbox.template = __webpack_require__(190);
	var textboxBindings = textbox.bindings;
	textboxBindings.maxlength = '<?';
	angular.module(exports.moduleName, [input_1.moduleName])
	    .component(exports.componentName, textbox);
	//# sourceMappingURL=textbox.js.map

/***/ },
/* 190 */
/***/ function(module, exports) {

	module.exports = "<div class=\"field\" ng-class=\"{ 'error': input.ngModel.$invalid }\">\r\n\t<label ng-show=\"input.inputValue && input.label\" class=\"show-hide angular-animate\">{{input.label}}</label>\r\n\t<input  type=\"text\" class=\"form-control angular-animate\" ng-model=\"input.inputValue\" placeholder=\"{{input.label}}\" maxlength=\"{{input.maxlength}}\" />\r\n\t<span class=\"error-string\" ng-hide=\"input.inputValidator.error | isEmpty\">{{input.inputValidator.error}}</span>\r\n</div>"

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __genericSearch = typescript_angular_utilities_1.services.genericSearchFilter;
	var __objectUtility = typescript_angular_utilities_1.services.object;
	var __arrayUtility = typescript_angular_utilities_1.services.array;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	var input_1 = __webpack_require__(158);
	var componentValidator_service_1 = __webpack_require__(112);
	exports.moduleName = 'rl.ui.components.typeahead';
	exports.componentName = 'rlTypeahead';
	exports.controllerName = 'TypeaheadController';
	var TypeaheadController = (function (_super) {
	    __extends(TypeaheadController, _super);
	    function TypeaheadController($scope, $q, $attrs, $timeout, parentChild, genericSearchFactory, object, array, componentValidatorFactory) {
	        _super.call(this, $scope, $attrs, componentValidatorFactory);
	        this.$q = $q;
	        this.$timeout = $timeout;
	        this.parentChild = parentChild;
	        this.genericSearchFactory = genericSearchFactory;
	        this.object = object;
	        this.array = array;
	        this.loading = false;
	        this.collapsed = false;
	        this.hasSearchOption = false;
	        this._searchOption = {
	            __isSearchOption: true,
	        };
	        this.inputType = 'typeahead';
	    }
	    Object.defineProperty(TypeaheadController.prototype, "selection", {
	        get: function () {
	            return this.ngModel.$viewValue;
	        },
	        set: function (value) {
	            if (value != null) {
	                if (value.__isSearchOption) {
	                    value = this.create({ value: value.text });
	                }
	                this.select({ value: value });
	                if (this.collapseOnSelect) {
	                    this.collapsed = true;
	                    this.ngModel.$setViewValue(value);
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TypeaheadController.prototype.$onInit = function () {
	        var _this = this;
	        _super.prototype.$onInit.call(this);
	        this.searchFilter = this.genericSearchFactory.getInstance();
	        this.loadDelay = this.useClientSearching ? 100 : 500;
	        this.prefix = this.prefix || 'Search for';
	        this.placeholder = this.label != null ? this.prefix + ' ' + this.label.toLowerCase() : 'Search';
	        var $attrs = this.$attrs;
	        this.collapseOnSelect = this.allowCollapse || this.object.isNullOrEmpty($attrs.select);
	        this.allowCustomOption = !this.object.isNullOrEmpty($attrs.create);
	        this.$timeout(function () {
	            if (_this.collapseOnSelect && !_this.object.isNullOrEmpty(_this.ngModel.$viewValue)) {
	                _this.collapsed = true;
	            }
	        });
	        this.parentChild.registerChildBehavior(this.childLink, {
	            add: this.addItem.bind(this),
	            remove: this.removeItem.bind(this),
	        });
	        this.$scope.$watch(function () { return _this.ngModel.$viewValue; }, function (value) {
	            if (value != null && _this.collapseOnSelect) {
	                _this.collapsed = true;
	            }
	        });
	    };
	    TypeaheadController.prototype.getDisplayName = function (item) {
	        if (item != null && item.__isSearchOption) {
	            return item.text;
	        }
	        return __transform.getValue(item, this.transform);
	    };
	    TypeaheadController.prototype.refresh = function (search) {
	        var _this = this;
	        if (this.object.isNullOrEmpty(search)) {
	            this.visibleItems = [];
	            return null;
	        }
	        this.loading = true;
	        return this.loadItems(search).then(function () {
	            _this.loading = false;
	            _this._searchOption.text = search;
	            if (_this.showCustomSearch(search)) {
	                _this.hasSearchOption = true;
	                _this.visibleItems.unshift(_this._searchOption);
	            }
	        });
	    };
	    TypeaheadController.prototype.loadItems = function (search) {
	        var _this = this;
	        if (!this.useClientSearching) {
	            return this.$q.when(this.getItems({
	                search: search,
	            })).then(function (items) {
	                _this.visibleItems = items;
	            });
	        }
	        else {
	            this.searchFilter.searchText = search;
	            if (this.cachedItems != null) {
	                this.visibleItems = this.filter(this.cachedItems);
	                return this.$q.when();
	            }
	            else {
	                return this.$q.when(this.getItems()).then(function (items) {
	                    _this.cachedItems = items;
	                    _this.visibleItems = _this.filter(items);
	                });
	            }
	        }
	    };
	    TypeaheadController.prototype.clear = function () {
	        this.ngModel.$setViewValue(null);
	        this.collapsed = false;
	    };
	    TypeaheadController.prototype.showCustomSearch = function (search) {
	        var _this = this;
	        return this.allowCustomOption
	            && !this.hasSearchOption
	            && !_.find(this.visibleItems, function (item) {
	                return _this.getDisplayName(item) === search;
	            });
	    };
	    TypeaheadController.prototype.filter = function (list) {
	        var _this = this;
	        return _.filter(list, function (item) { return _this.searchFilter.filter(item); });
	    };
	    TypeaheadController.prototype.addItem = function (item) {
	        if (this.cachedItems != null) {
	            this.cachedItems.push(item);
	        }
	    };
	    TypeaheadController.prototype.removeItem = function (item) {
	        if (this.cachedItems != null) {
	            this.array.remove(this.cachedItems, item);
	        }
	    };
	    TypeaheadController.$inject = ['$scope',
	        '$q',
	        '$attrs',
	        '$timeout',
	        __parentChild.serviceName,
	        __genericSearch.factoryName,
	        __objectUtility.serviceName,
	        __arrayUtility.serviceName,
	        componentValidator_service_1.factoryName];
	    return TypeaheadController;
	}(input_1.InputController));
	exports.TypeaheadController = TypeaheadController;
	var typeahead = _.clone(input_1.input);
	typeahead.template = __webpack_require__(192);
	typeahead.controller = exports.controllerName;
	typeahead.controllerAs = 'typeahead';
	var typeaheadBindings = typeahead.bindings;
	typeaheadBindings.childLink = '=?';
	typeaheadBindings.select = '&';
	typeaheadBindings.create = '&';
	typeaheadBindings.allowCollapse = '<?';
	typeaheadBindings.transform = '<?';
	typeaheadBindings.getItems = '&';
	typeaheadBindings.prefix = '@';
	typeaheadBindings.useClientSearching = '<?';
	typeaheadBindings.ngDisabled = '<?';
	angular.module(exports.moduleName, [
	    __parentChild.moduleName,
	    __genericSearch.moduleName,
	    __objectUtility.moduleName,
	    __arrayUtility.moduleName,
	    input_1.moduleName
	])
	    .component(exports.componentName, typeahead)
	    .controller(exports.controllerName, TypeaheadController);
	//# sourceMappingURL=typeahead.js.map

/***/ },
/* 192 */
/***/ function(module, exports) {

	module.exports = "<div class=\"field\" ng-class=\"{ 'has-error': typeahead.ngModel.$invalid }\">\r\n\t<label ng-show=\"typeahead.selection\" class=\"show-hide angular-animate\">\r\n\t\t{{typeahead.label}}\r\n\t</label>\r\n\t<div ng-if=\"!typeahead.collapsed\">\r\n\t\t<ui-select ng-model=\"typeahead.selection\" theme=\"bootstrap\" ng-disabled=\"typeahead.ngDisabled\">\r\n\t\t\t<ui-select-match placeholder=\"{{typeahead.placeholder}}\">{{typeahead.getDisplayName($select.selected)}}</ui-select-match>\r\n\t\t\t<ui-select-choices repeat=\"item in typeahead.visibleItems\"\r\n\t\t\t\t\t\t\t\trefresh=\"typeahead.refresh($select.search)\"\r\n\t\t\t\t\t\t\t\trefresh-delay=\"typeahead.loadDelay\">\r\n\t\t\t\t{{typeahead.getDisplayName(item)}}\r\n\t\t\t</ui-select-choices>\r\n\t\t</ui-select>\r\n\t</div>\r\n\t<div ng-if=\"typeahead.collapsed\">\r\n\t\t<span>{{typeahead.getDisplayName(typeahead.selection)}}</span>\r\n\t\t<rl-button type=\"default flat\" action=\"typeahead.clear()\"><i class=\"fa fa-remove\"></i></rl-button>\r\n\t</div>\r\n\t<span class=\"error-string\" ng-show=\"typeahead.inputValidator.error\">{{typeahead.inputValidator.error}}</span>\r\n\t<rl-busy loading=\"typeahead.loading\"></rl-busy>\r\n</div>"

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var typescript_angular_utilities_1 = __webpack_require__(5);
	var __parentChild = typescript_angular_utilities_1.services.parentChildBehavior;
	var __array = typescript_angular_utilities_1.services.array;
	var __transform = typescript_angular_utilities_1.services.transform.transform;
	var typeaheadItem_1 = __webpack_require__(194);
	exports.moduleName = 'rl.ui.components.typeaheadList';
	exports.componentName = 'rlTypeaheadList';
	exports.controllerName = 'TypeaheadListController';
	var TypeaheadListController = (function () {
	    function TypeaheadListController($scope, $element, $transclude, parentChild) {
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$transclude = $transclude;
	        this.parentChild = parentChild;
	    }
	    TypeaheadListController.prototype.$onInit = function () {
	        var _this = this;
	        this.$scope.$remove = this.removeItem.bind(this);
	        this.$scope.$transform = function (item) {
	            return __transform.getValue(item, _this.transform);
	        };
	        this.parentChild.registerChildBehavior(this.childLink, {
	            add: this.addItem.bind(this),
	            remove: this.removeItem.bind(this),
	        });
	    };
	    TypeaheadListController.prototype.loadItems = function (search) {
	        var _this = this;
	        return this.getItems({ search: search }).then(function (data) {
	            return _.filter(data, function (item) {
	                return !_.find(_this.ngModel.$viewValue, item);
	            });
	        });
	    };
	    TypeaheadListController.prototype.addItem = function (item) {
	        this.ngModel.$viewValue.push(item);
	        this.parentChild.triggerChildBehavior(this.typeaheadLink, function (behavior) {
	            behavior.remove(item);
	        });
	        this.add({ item: item });
	    };
	    TypeaheadListController.prototype.removeItem = function (item) {
	        __array.arrayUtility.remove(this.ngModel.$viewValue, item);
	        this.parentChild.triggerChildBehavior(this.typeaheadLink, function (behavior) {
	            behavior.add(item);
	        });
	        this.remove({ item: item });
	    };
	    TypeaheadListController.$inject = ['$scope', '$element', '$transclude', __parentChild.serviceName];
	    return TypeaheadListController;
	}());
	exports.TypeaheadListController = TypeaheadListController;
	var typeaheadList = {
	    require: { ngModel: 'ngModel' },
	    transclude: {
	        headerSlot: '?rlListHeader',
	        listItemSlot: '?rlListItem',
	    },
	    template: __webpack_require__(196),
	    controller: exports.controllerName,
	    controllerAs: 'list',
	    bindings: {
	        getItems: '&',
	        add: '&',
	        remove: '&',
	        transform: '<?',
	        label: '@',
	        prefix: '@',
	        useClientSearching: '<?',
	        ngDisabled: '<?',
	        itemAs: '@',
	        childLink: '=?',
	    },
	};
	angular.module(exports.moduleName, [__parentChild.moduleName])
	    .component(exports.componentName, typeaheadList)
	    .controller(exports.controllerName, TypeaheadListController)
	    .component(typeaheadItem_1.componentName, typeaheadItem_1.typeaheadItem);
	//# sourceMappingURL=typeaheadList.js.map

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/node/node.d.ts' />
	'use strict';
	exports.componentName = 'rlTypeaheadListItem';
	var TypeaheadItemController = (function () {
	    function TypeaheadItemController($scope, $element, $compile) {
	        this.$scope = $scope;
	        this.$element = $element;
	        this.$compile = $compile;
	    }
	    TypeaheadItemController.prototype.$onInit = function () {
	        var itemScope = this.$scope.$parent.$new();
	        var contentArea = this.$element.find('.content-target');
	        if (this.transclude.isSlotFilled('listItemSlot')) {
	            this.transclude(itemScope, function (template) {
	                contentArea.append(template);
	            }, null, 'listItemSlot');
	        }
	        else {
	            var template = contentArea.append(__webpack_require__(195));
	            this.$compile(template)(itemScope);
	        }
	    };
	    TypeaheadItemController.$inject = ['$scope', '$element', '$compile'];
	    return TypeaheadItemController;
	}());
	exports.typeaheadItem = {
	    bindings: {
	        transclude: '<',
	    },
	    controller: TypeaheadItemController,
	    template: "<div class=\"content-target\"></div>",
	};
	//# sourceMappingURL=typeaheadItem.js.map

/***/ },
/* 195 */
/***/ function(module, exports) {

	module.exports = "<div class=\"col-xs-10\">{{$transform($item)}}</div>\r\n<div class=\"col-xs-2\">\r\n\t<rl-button type=\"danger\" action=\"$remove($item)\"><i class=\"fa fa-remove\"></i></rl-button>\r\n</div>"

/***/ },
/* 196 */
/***/ function(module, exports) {

	module.exports = "<rl-typeahead ng-model=\"list.model\" select=\"list.addItem(value)\" allow-collapse=\"false\"\r\n\t\t\t  transform=\"list.transform\" get-items=\"list.loadItems(search)\" label=\"{{list.label}}\"\r\n\t\t\t  prefix=\"{{list.prefix}}\" use-client-searching=\"list.useClientSearching\" ng-disabled=\"list.ngDisabled\"></rl-typeahead>\r\n<div class=\"table-container\">\r\n\t<div class=\"row table-header\">\r\n\t\t<div ng-transclude=\"headerSlot\">\r\n\t\t\t<div class=\"col-xs-12\">Name</div>\r\n\t\t</div>\r\n\t</div>\r\n\t<div class=\"row table-row\" ng-repeat=\"$item in list.ngModel.$viewValue\" rl-alias=\"$item as {{list.itemAs}}\">\r\n\t\t<rl-typeahead-list-item transclude=\"list.$transclude\"></rl-typeahead-list-item>\r\n\t</div>\r\n</div>"

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	exports.moduleName = 'rl.components.userRating';
	exports.directiveName = 'rlUserRating';
	exports.controllerName = 'UserRatingController';
	var UserRatingController = (function () {
	    function UserRatingController($scope) {
	        var _this = this;
	        this.$scope = $scope;
	        this.stars = [];
	        var rangeSize = this.$scope.range != null ? this.$scope.range : 5;
	        // css style requires the stars to show right to left. Reverse the list so the highest value is first
	        var range = _.range(1, rangeSize + 1).reverse();
	        _.each(range, function (rating) {
	            _this.stars.push({
	                value: rating,
	                filled: false,
	            });
	        });
	        var unbind = this.$scope.$watch('ngModel', function (value) {
	            _this.updateStarView(_this.$scope.ngModel.$viewValue);
	            unbind();
	        });
	    }
	    UserRatingController.prototype.setRating = function (rating) {
	        this.$scope.ngModel.$setViewValue(rating);
	        this.updateStarView(rating);
	    };
	    UserRatingController.prototype.updateStarView = function (rating) {
	        _.each(this.stars, function (star) {
	            if (star.value <= rating) {
	                star.filled = true;
	            }
	            else {
	                star.filled = false;
	            }
	        });
	    };
	    UserRatingController.$inject = ['$scope'];
	    return UserRatingController;
	}());
	exports.UserRatingController = UserRatingController;
	function userRating() {
	    'use strict';
	    return {
	        restrict: 'E',
	        require: 'ngModel',
	        template: "\n\t\t\t<span class=\"rating\">\n\t\t\t\t<span class=\"star\" ng-repeat=\"star in userRating.stars\" ng-class=\"{ 'filled': star.filled }\" ng-click=\"userRating.setRating(star.value)\"></span>\n\t\t\t</span>\n\t\t",
	        controller: exports.controllerName,
	        controllerAs: 'userRating',
	        scope: {
	            range: '=',
	        },
	        link: function (scope, element, attrs, ngModel) {
	            scope.ngModel = ngModel;
	        },
	    };
	}
	exports.userRating = userRating;
	angular.module(exports.moduleName, [])
	    .directive(exports.directiveName, userRating)
	    .controller(exports.controllerName, UserRatingController);
	//# sourceMappingURL=userRating.js.map

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	// /// <reference path='../../../typings/commonjs.d.ts' />
	'use strict';
	var angular = __webpack_require__(1);
	var _ = __webpack_require__(18);
	var componentValidator_service_1 = __webpack_require__(112);
	exports.moduleName = 'rl.ui.components.validationGroup';
	exports.directiveName = 'rlValidationGroup';
	exports.controllerName = 'ValidationGroupController';
	var ValidationGroupController = (function () {
	    function ValidationGroupController($scope, componentValidatorFactory) {
	        var _this = this;
	        var unbind = $scope.$watch('validationGroupForm', function (form) {
	            if (!_.isUndefined(_this.validator)) {
	                _this.groupValidator = componentValidatorFactory.getInstance({
	                    form: $scope.validationGroupForm,
	                    $scope: $scope,
	                    validators: [_this.validator],
	                });
	            }
	            unbind();
	        });
	    }
	    ValidationGroupController.$inject = ['$scope', componentValidator_service_1.factoryName];
	    return ValidationGroupController;
	}());
	exports.ValidationGroupController = ValidationGroupController;
	function validationGroup() {
	    return {
	        restrict: 'E',
	        transclude: true,
	        template: __webpack_require__(199),
	        controller: exports.controllerName,
	        controllerAs: 'group',
	        scope: {},
	        bindToController: {
	            validator: '=',
	        },
	    };
	}
	exports.validationGroup = validationGroup;
	angular.module(exports.moduleName, [componentValidator_service_1.moduleName])
	    .directive(exports.directiveName, validationGroup)
	    .controller(exports.controllerName, ValidationGroupController);
	//# sourceMappingURL=validationGroup.js.map

/***/ },
/* 199 */
/***/ function(module, exports) {

	module.exports = "<div class=\"content-group\" ng-form=\"validationGroupForm\">\r\n\t<div class=\"error\" ng-show=\"validationGroupForm.$error.customValidation\">\r\n\t\t<label>{{group.groupValidator.error}}</label>\r\n\t</div>\r\n\t<div ng-transclude></div>\r\n</div>"

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ngModel = __webpack_require__(201);
	exports.ngModel = ngModel;
	var viewData = __webpack_require__(202);
	exports.viewData = viewData;
	//# sourceMappingURL=types.module.js.map

/***/ },
/* 201 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=formValidators.js.map

/***/ },
/* 202 */
/***/ function(module, exports) {

	'use strict';
	//# sourceMappingURL=viewData.js.map

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNjAxOWE0OWVhZTA5Njc1Nzk2YzAiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3VpLm1vZHVsZS50cyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhbmd1bGFyXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYW5ndWxhci11aVwiIiwid2VicGFjazovLy8uL34vYW5ndWxhci1zYW5pdGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2FuZ3VsYXItc2FuaXRpemUvYW5ndWxhci1zYW5pdGl6ZS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJybF91dGlsaXRpZXNcIiIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL3NsaWRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL2Jvb3RzdHJhcC1zbGlkZXIubWluLmNzcz8wYzNlIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvYm9vdHN0cmFwLXNsaWRlci5taW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiJFwiIiwid2VicGFjazovLy8uL34vc2lnbmF0dXJlX3BhZC9zaWduYXR1cmVfcGFkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9iZWhhdmlvcnMvYmVoYXZpb3JzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvYmVoYXZpb3JzL2FsaWFzL2FsaWFzLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9iZWhhdmlvcnMvYXV0b3NhdmUvYXV0b3NhdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL2F1dG9zYXZlLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiX1wiIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZUFjdGlvbi9hdXRvc2F2ZUFjdGlvbi5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZS90cmlnZ2Vycy90cmlnZ2Vycy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9hdXRvc2F2ZS90cmlnZ2Vycy9vbkNoYW5nZVRyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL3RyaWdnZXJzL3RyaWdnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2Zvcm0vZm9ybS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9iZWhhdmlvcnMvcG9wb3Zlci9wb3BvdmVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9iZWhhdmlvcnMvcmVxdWlyZWQvcmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY29tcG9uZW50cy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnVzeS9idXN5LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2J1c3kvYnVzeS5jc3M/OTNlMCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXN5L2J1c3kuY3NzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NvbXBvbmVudHNEZWZhdWx0VGhlbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b24vYnV0dG9uLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uQXN5bmMvYnV0dG9uQXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uQXN5bmMvYnV0dG9uQXN5bmMuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25MaW5rL2J1dHRvbkxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uTGluay9idXR0b25MaW5rLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uU3VibWl0L2J1dHRvblN1Ym1pdC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25TdWJtaXQvYnV0dG9uU3VibWl0Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uVG9nZ2xlL2J1dHRvblRvZ2dsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Ub2dnbGUvYnV0dG9uVG9nZ2xlLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvY2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvaGVhZGVyQ29sdW1uL2hlYWRlckNvbHVtbi5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9oZWFkZXJDb2x1bW4uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9zaXplRm9yQnJlYWtwb2ludHMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2NhcmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRTZWFyY2gvY2FyZFNlYXJjaC5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY29sdW1uSGVhZGVyL2NvbHVtbkhlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnREaXJlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0cy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9tZXJnZVNvcnQvbWVyZ2VTb3J0LnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0ZXIvc29ydGVyLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvY2xpZW50U2VydmVyRGF0YVNvdXJjZS9jbGllbnRTZXJ2ZXJEYXRhU291cmNlLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9hc3luY0RhdGFTb3VyY2Uuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlRXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVBhZ2VyL2RhdGFQYWdlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvZGF0YVNlcnZpY2VEYXRhU291cmNlL2RhdGFTZXJ2aWNlRGF0YVNvdXJjZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvc2VydmVyU2lkZURhdGFTb3VyY2Uvc2VydmVyU2lkZURhdGFTb3VyY2Uuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL3NpbXBsZURhdGFTb3VyY2Uvc2ltcGxlRGF0YVNvdXJjZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvc21hcnREYXRhU291cmNlL3NtYXJ0RGF0YVNvdXJjZS5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9kYXRlRmlsdGVyL2RhdGVGaWx0ZXIubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9kYXRlRmlsdGVyL2RhdGVGaWx0ZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJtb21lbnRcIiIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZGF0ZUZpbHRlci9kYXRlRmlsdGVyLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZGF0ZUZpbHRlci9kYXRlRmlsdGVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyT3B0aW9uL2ZpbHRlck9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyT3B0aW9uL2ZpbHRlck9wdGlvbi5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9tb2RlRmlsdGVyR3JvdXAvbW9kZUZpbHRlckdyb3VwLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL3JhbmdlRmlsdGVyR3JvdXAvcmFuZ2VGaWx0ZXJHcm91cC5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJHcm91cC5kaXJlY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZS5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9zZWxlY3RGaWx0ZXIvc2VsZWN0RmlsdGVyLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9zZWxlY3RGaWx0ZXIvc2VsZWN0RmlsdGVyLmNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9jYXJkQ29udGFpbmVyRmlsdGVycy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvY2FyZENvbnRhaW5lckZpbHRlcnMuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2l0ZW1Db3VudC9pdGVtQ291bnQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9pdGVtQ291bnQvaXRlbUNvdW50Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlci9wYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3BhZ2VyL3BhZ2VyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlU2l6ZS9wYWdlU2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3BhZ2VTaXplL3BhZ2VTaXplLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyQnVpbGRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGVmYXVsdENvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kZWZhdWx0Q2FyZENvbnRhaW5lckhlYWRlci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGVmYXVsdENhcmRDb250YWluZXJGb290ZXIuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jc3M/NDkwYiIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jc3MiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvY2hlY2tib3gvY2hlY2tib3guaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9jb21tYUxpc3QvY29tbWFMaXN0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2RhdGVUaW1lL2RhdGVUaW1lLmpzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzPzYzNGUiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvZGF0ZVRpbWUvZGF0ZVRpbWUuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9kYXRlVGltZVN0YXRpYy9kYXRlVGltZVN0YXRpYy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9kYXRlVGltZVN0YXRpYy9kYXRlVGltZVN0YXRpYy5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2RpYWxvZy9kaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9kaWFsb2cuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nLmNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9ib290c3RyYXBNb2RhbERpYWxvZy9ib290c3RyYXBNb2RhbERpYWxvZy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvcHJvbXB0RGlhbG9nLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvZGlhbG9nL2RpYWxvZy5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2RpYWxvZy9hdXRvc2F2ZURpYWxvZ0Zvb3Rlci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9nZW5lcmljQ29udGFpbmVyL2dlbmVyaWNDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9sYXp5TG9hZC9sYXp5TG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9sb25nQ2xpY2tCdXR0b24vbG9uZ0NsaWNrQnV0dG9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL2xvbmdDbGlja0J1dHRvbi9sb25nQ2xpY2tCdXR0b24uaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9tZXNzYWdlTG9nL21lc3NhZ2VMb2cubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5kaXJlY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL3NlcnZpY2VzL3NlcnZpY2VzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy93aW5kb3dXcmFwcGVyL3dpbmRvd1dyYXBwZXIuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvdmlzaWJsZUJyZWFrcG9pbnQuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMuc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2Uvc2VydmljZXMvY29udGVudFByb3ZpZGVyL2NvbnRlbnRQcm92aWRlci5zZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9zZXJ2aWNlcy9kb2N1bWVudFdyYXBwZXIvZG9jdW1lbnRXcmFwcGVyLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nRWRpdERpYWxvZy5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvbWVzc2FnZUxvZy5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL21lc3NhZ2VMb2cvZWRpdGFibGVNZXNzYWdlTG9nLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL211bHRpU3RlcEluZGljYXRvci9tdWx0aVN0ZXBJbmRpY2F0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvbXVsdGlTdGVwSW5kaWNhdG9yL211bHRpU3RlcEluZGljYXRvci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JhZGlvL3JhZGlvLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yYWRpby9yYWRpb0dyb3VwLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JhZGlvL3JhZGlvLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JhdGluZ0Jhci9yYXRpbmdCYXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmF0aW5nQmFyL3JhdGluZ0JhckJhY2tncm91bmRzLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmF0aW5nQmFyL3JhdGluZ0JhckNsYXNzLnNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvcmljaFRleHRFZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9uZy13aWcvZGlzdC9jc3Mvbmctd2lnLmNzcz9iZmI0Iiwid2VicGFjazovLy8uL34vbmctd2lnL2Rpc3QvY3NzL25nLXdpZy5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9uZy13aWcvZGlzdC9uZy13aWcuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvZWRpdG9yQnV0dG9ucy5jc3M/MWVlYyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9lZGl0b3JCdXR0b25zLmNzcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9pbnB1dC9pbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvaGVhZGVyQnV0dG9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3BhcmFncmFwaEJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi91aS1zZWxlY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuY3NzP2QyNzQiLCJ3ZWJwYWNrOi8vLy4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuY3NzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zaWduYXR1cmVQYWQvc2lnbmF0dXJlUGFkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmRMaXN0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NpbXBsZUNhcmRMaXN0L3NpbXBsZUNhcmQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy9zcGlubmVyL3NwaW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzPzRjNzEiLCJ3ZWJwYWNrOi8vLy4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzIiwid2VicGFjazovLy8uL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3N0cmluZ1dpdGhXYXRlcm1hcmsvc3RyaW5nV2l0aFdhdGVybWFyay5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90YWJzL3RhYnMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFiLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFiLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdGFicy90YWJzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdGFicy90YWJzZXQuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90ZW1wbGF0ZVJlbmRlcmVyL3RlbXBsYXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdGV4dGFyZWEvdGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdGV4dGFyZWEvdGV4dGFyZWEuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0Ym94L3RleHRib3guanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdGV4dGJveC90ZXh0Ym94Lmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLmh0bWwiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2NvbXBvbmVudHMvdHlwZWFoZWFkTGlzdC90eXBlYWhlYWRMaXN0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZExpc3QvdHlwZWFoZWFkSXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWRMaXN0L2RlZmF1bHRMaXN0SXRlbS5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZExpc3QvdHlwZWFoZWFkTGlzdC5odG1sIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3VzZXJSYXRpbmcvdXNlclJhdGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvY29tcG9uZW50cy92YWxpZGF0aW9uR3JvdXAvdmFsaWRhdGlvbkdyb3VwLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9jb21wb25lbnRzL3ZhbGlkYXRpb25Hcm91cC92YWxpZGF0aW9uR3JvdXAuaHRtbCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvdHlwZXMvdHlwZXMubW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS90eXBlcy9mb3JtVmFsaWRhdG9ycy5qcyIsIndlYnBhY2s6Ly8v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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFrQiwrQ0FBK0M7QUFDakUsbUJBQWtCLCtDQUErQzs7QUFFakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLGlDQUFpQzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQSxFQUFDOzs7Ozs7O0FDcFlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9ELCtCQUErQixFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxvQzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSx5Qzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEOzs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWdE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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQzs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwyQzs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBa0UsYUFBYTtBQUMvRSxpRUFBZ0UsYUFBYTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEOzs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxvRDs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRDs7Ozs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkM7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUQ7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTJGLGNBQWM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQzs7Ozs7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QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0Q7Ozs7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRDs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7QUM5UEEsZ1RBQStTLDBDQUEwQyw4aUNBQThpQyx5NkU7Ozs7OztBQ0F2NEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RDs7Ozs7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7OztBQ1ZBLDJPOzs7Ozs7QUNBQSx3Z0I7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFxQztBQUNyQyw0Q0FBMkM7O0FBRTNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVixVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELHNCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQSxXQUFVO0FBQ1Ysc0JBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLHdDQUF1Qyx1RUFBdUU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQiw4Q0FBOEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsT0FBTztBQUM1QjtBQUNBLHVCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsT0FBTztBQUM1QjtBQUNBLHVCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0Esc0JBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0I7QUFDQSxzQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxXQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLDJFQUEwRTtBQUMxRSw4RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFdBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkMscUJBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7QUNyR0Esd0dBQXVHLGFBQWEsR0FBRyxhQUFhLCtTQUErUyxhQUFhLFVBQVUsbUJBQW1CLHFUOzs7Ozs7QUNBN2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQzs7Ozs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsOERBQThEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLDBEQUEwRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMseUNBQXlDLEVBQUU7QUFDOUU7QUFDQSxVQUFTO0FBQ1Qsb0NBQW1DLDRDQUE0QyxFQUFFO0FBQ2pGO0FBQ0EsVUFBUztBQUNULG9DQUFtQyw2Q0FBNkMsRUFBRTtBQUNsRjtBQUNBLFVBQVM7QUFDVCxvQ0FBbUMsOEJBQThCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Qsb0NBQW1DLHNCQUFzQixFQUFFO0FBQzNEO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEOzs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDOzs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBLGtEOzs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxzRDs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTs7QUFFQSxXQUFVLG1kQUFtZCxxcUJBQXFxQjtBQUNsb0MsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLGtCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7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QzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscURBQW9EOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG9EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxtREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0Esa0RBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0EsdUM7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7Ozs7O0FDM0NBLG9MQUFtTCw0QkFBNEIsOEQ7Ozs7OztBQ0EvTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7OztBQ0xBO0FBQ0EsMkM7Ozs7OztBQ0RBO0FBQ0EscUMiLCJmaWxlIjoiY29tcG9uZW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIm91dHB1dFwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNjAxOWE0OWVhZTA5Njc1Nzk2YzBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgKiBhcyBhbmd1bGFyIGZyb20gJ2FuZ3VsYXInO1xyXG5cclxuaW1wb3J0ICdhbmd1bGFyLXVpLWJvb3RzdHJhcCc7XHJcbmltcG9ydCAnYW5ndWxhci1zYW5pdGl6ZSc7XHJcblxyXG5pbXBvcnQgeyBuYW1lIGFzIHV0aWxpdGllc01vZHVsZSB9IGZyb20gJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnO1xyXG5cclxuaW1wb3J0ICcuLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL3NsaWRlcic7XHJcblxyXG5pbXBvcnQgJ3NpZ25hdHVyZV9wYWQnO1xyXG5cclxuaW1wb3J0ICogYXMgYmVoYXZpb3JzIGZyb20gJy4vYmVoYXZpb3JzL2JlaGF2aW9ycy5tb2R1bGUnO1xyXG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vY29tcG9uZW50cy9jb21wb25lbnRzLm1vZHVsZSc7XHJcbmltcG9ydCAqIGFzIHNlcnZpY2VzIGZyb20gJy4vc2VydmljZXMvc2VydmljZXMubW9kdWxlJztcclxuaW1wb3J0ICogYXMgdHlwZXMgZnJvbSAnLi90eXBlcy90eXBlcy5tb2R1bGUnO1xyXG5cclxuZXhwb3J0IHsgYmVoYXZpb3JzLCBjb21wb25lbnRzLCBzZXJ2aWNlcywgdHlwZXMgfTtcclxuXHJcbmV4cG9ydCB2YXIgbW9kdWxlTmFtZTogc3RyaW5nID0gJ3JsLnVpJztcclxuXHJcbmFuZ3VsYXIubW9kdWxlKG1vZHVsZU5hbWUsIFtcclxuXHQndWkuYm9vdHN0cmFwJyxcclxuXHQndWkuYm9vdHN0cmFwLXNsaWRlcicsXHJcblx0J25nU2FuaXRpemUnLFxyXG5cdHV0aWxpdGllc01vZHVsZSxcclxuXHJcblx0YmVoYXZpb3JzLm1vZHVsZU5hbWUsXHJcblx0Y29tcG9uZW50cy5tb2R1bGVOYW1lLFxyXG5cdHNlcnZpY2VzLm1vZHVsZU5hbWUsXHJcbl0pO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NvdXJjZS91aS5tb2R1bGUudHNcbiAqKi8iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcImFuZ3VsYXJcIl07IH0oKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImFuZ3VsYXJcIlxuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzW1wiYW5ndWxhci11aVwiXTsgfSgpKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiYW5ndWxhci11aVwiXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9hbmd1bGFyLXNhbml0aXplJyk7XG5tb2R1bGUuZXhwb3J0cyA9ICduZ1Nhbml0aXplJztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FuZ3VsYXItc2FuaXRpemUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS41LjBcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgQW55IGNvbW1pdHMgdG8gdGhpcyBmaWxlIHNob3VsZCBiZSByZXZpZXdlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuICAqXG4gKiAgIENoYW5nZXMgdG8gdGhpcyBmaWxlIGNhbiBwb3RlbnRpYWxseSBjcmVhdGUgc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzLiAqXG4gKiAgICAgICAgICBBbiBhcHByb3ZhbCBmcm9tIDIgQ29yZSBtZW1iZXJzIHdpdGggaGlzdG9yeSBvZiBtb2RpZnlpbmcgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGZpbGUgaXMgcmVxdWlyZWQuICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiAgRG9lcyB0aGUgY2hhbmdlIHNvbWVob3cgYWxsb3cgZm9yIGFyYml0cmFyeSBqYXZhc2NyaXB0IHRvIGJlIGV4ZWN1dGVkPyAqXG4gKiAgICBPciBhbGxvd3MgZm9yIHNvbWVvbmUgdG8gY2hhbmdlIHRoZSBwcm90b3R5cGUgb2YgYnVpbHQtaW4gb2JqZWN0cz8gICAqXG4gKiAgICAgT3IgZ2l2ZXMgdW5kZXNpcmVkIGFjY2VzcyB0byB2YXJpYWJsZXMgbGlrZXMgZG9jdW1lbnQgb3Igd2luZG93PyAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG52YXIgJHNhbml0aXplTWluRXJyID0gYW5ndWxhci4kJG1pbkVycignJHNhbml0aXplJyk7XG5cbi8qKlxuICogQG5nZG9jIG1vZHVsZVxuICogQG5hbWUgbmdTYW5pdGl6ZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogIyBuZ1Nhbml0aXplXG4gKlxuICogVGhlIGBuZ1Nhbml0aXplYCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byBzYW5pdGl6ZSBIVE1MLlxuICpcbiAqXG4gKiA8ZGl2IGRvYy1tb2R1bGUtY29tcG9uZW50cz1cIm5nU2FuaXRpemVcIj48L2Rpdj5cbiAqXG4gKiBTZWUge0BsaW5rIG5nU2FuaXRpemUuJHNhbml0aXplIGAkc2FuaXRpemVgfSBmb3IgdXNhZ2UuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJHNhbml0aXplXG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogICBTYW5pdGl6ZXMgYW4gaHRtbCBzdHJpbmcgYnkgc3RyaXBwaW5nIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgdG9rZW5zLlxuICpcbiAqICAgVGhlIGlucHV0IGlzIHNhbml0aXplZCBieSBwYXJzaW5nIHRoZSBIVE1MIGludG8gdG9rZW5zLiBBbGwgc2FmZSB0b2tlbnMgKGZyb20gYSB3aGl0ZWxpc3QpIGFyZVxuICogICB0aGVuIHNlcmlhbGl6ZWQgYmFjayB0byBwcm9wZXJseSBlc2NhcGVkIGh0bWwgc3RyaW5nLiBUaGlzIG1lYW5zIHRoYXQgbm8gdW5zYWZlIGlucHV0IGNhbiBtYWtlXG4gKiAgIGl0IGludG8gdGhlIHJldHVybmVkIHN0cmluZy5cbiAqXG4gKiAgIFRoZSB3aGl0ZWxpc3QgZm9yIFVSTCBzYW5pdGl6YXRpb24gb2YgYXR0cmlidXRlIHZhbHVlcyBpcyBjb25maWd1cmVkIHVzaW5nIHRoZSBmdW5jdGlvbnNcbiAqICAgYGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0YCBhbmQgYGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdGAgb2Yge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXJcbiAqICAgYCRjb21waWxlUHJvdmlkZXJgfS5cbiAqXG4gKiAgIFRoZSBpbnB1dCBtYXkgYWxzbyBjb250YWluIFNWRyBtYXJrdXAgaWYgdGhpcyBpcyBlbmFibGVkIHZpYSB7QGxpbmsgJHNhbml0aXplUHJvdmlkZXJ9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIEhUTUwgaW5wdXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYW5pdGl6ZWQgSFRNTC5cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGV4YW1wbGUgbW9kdWxlPVwic2FuaXRpemVFeGFtcGxlXCIgZGVwcz1cImFuZ3VsYXItc2FuaXRpemUuanNcIj5cbiAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgIDxzY3JpcHQ+XG4gICAgICAgICBhbmd1bGFyLm1vZHVsZSgnc2FuaXRpemVFeGFtcGxlJywgWyduZ1Nhbml0aXplJ10pXG4gICAgICAgICAgIC5jb250cm9sbGVyKCdFeGFtcGxlQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRzY2UnLCBmdW5jdGlvbigkc2NvcGUsICRzY2UpIHtcbiAgICAgICAgICAgICAkc2NvcGUuc25pcHBldCA9XG4gICAgICAgICAgICAgICAnPHAgc3R5bGU9XCJjb2xvcjpibHVlXCI+YW4gaHRtbFxcbicgK1xuICAgICAgICAgICAgICAgJzxlbSBvbm1vdXNlb3Zlcj1cInRoaXMudGV4dENvbnRlbnQ9XFwnUFdOM0QhXFwnXCI+Y2xpY2sgaGVyZTwvZW0+XFxuJyArXG4gICAgICAgICAgICAgICAnc25pcHBldDwvcD4nO1xuICAgICAgICAgICAgICRzY29wZS5kZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAkc2NlLnRydXN0QXNIdG1sKCRzY29wZS5zbmlwcGV0KTtcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9XSk7XG4gICAgIDwvc2NyaXB0PlxuICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJFeGFtcGxlQ29udHJvbGxlclwiPlxuICAgICAgICBTbmlwcGV0OiA8dGV4dGFyZWEgbmctbW9kZWw9XCJzbmlwcGV0XCIgY29scz1cIjYwXCIgcm93cz1cIjNcIj48L3RleHRhcmVhPlxuICAgICAgIDx0YWJsZT5cbiAgICAgICAgIDx0cj5cbiAgICAgICAgICAgPHRkPkRpcmVjdGl2ZTwvdGQ+XG4gICAgICAgICAgIDx0ZD5Ib3c8L3RkPlxuICAgICAgICAgICA8dGQ+U291cmNlPC90ZD5cbiAgICAgICAgICAgPHRkPlJlbmRlcmVkPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWh0bWwtd2l0aC1zYW5pdGl6ZVwiPlxuICAgICAgICAgICA8dGQ+bmctYmluZC1odG1sPC90ZD5cbiAgICAgICAgICAgPHRkPkF1dG9tYXRpY2FsbHkgdXNlcyAkc2FuaXRpemU8L3RkPlxuICAgICAgICAgICA8dGQ+PHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRcIiZndDs8YnIvPiZsdDsvZGl2Jmd0OzwvcHJlPjwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImJpbmQtaHRtbC13aXRoLXRydXN0XCI+XG4gICAgICAgICAgIDx0ZD5uZy1iaW5kLWh0bWw8L3RkPlxuICAgICAgICAgICA8dGQ+QnlwYXNzICRzYW5pdGl6ZSBieSBleHBsaWNpdGx5IHRydXN0aW5nIHRoZSBkYW5nZXJvdXMgdmFsdWU8L3RkPlxuICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJkZWxpYmVyYXRlbHlUcnVzdERhbmdlcm91c1NuaXBwZXQoKVwiJmd0O1xuJmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgIDx0ZD48ZGl2IG5nLWJpbmQtaHRtbD1cImRlbGliZXJhdGVseVRydXN0RGFuZ2Vyb3VzU25pcHBldCgpXCI+PC9kaXY+PC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJiaW5kLWRlZmF1bHRcIj5cbiAgICAgICAgICAgPHRkPm5nLWJpbmQ8L3RkPlxuICAgICAgICAgICA8dGQ+QXV0b21hdGljYWxseSBlc2NhcGVzPC90ZD5cbiAgICAgICAgICAgPHRkPjxwcmU+Jmx0O2RpdiBuZy1iaW5kPVwic25pcHBldFwiJmd0Ozxici8+Jmx0Oy9kaXYmZ3Q7PC9wcmU+PC90ZD5cbiAgICAgICAgICAgPHRkPjxkaXYgbmctYmluZD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICA8L3RhYmxlPlxuICAgICAgIDwvZGl2PlxuICAgPC9maWxlPlxuICAgPGZpbGUgbmFtZT1cInByb3RyYWN0b3IuanNcIiB0eXBlPVwicHJvdHJhY3RvclwiPlxuICAgICBpdCgnc2hvdWxkIHNhbml0aXplIHRoZSBodG1sIHNuaXBwZXQgYnkgZGVmYXVsdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXNhbml0aXplIGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKCc8cD5hbiBodG1sXFxuPGVtPmNsaWNrIGhlcmU8L2VtPlxcbnNuaXBwZXQ8L3A+Jyk7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgaW5saW5lIHJhdyBzbmlwcGV0IGlmIGJvdW5kIHRvIGEgdHJ1c3RlZCB2YWx1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXRydXN0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKFwiPHAgc3R5bGU9XFxcImNvbG9yOmJsdWVcXFwiPmFuIGh0bWxcXG5cIiArXG4gICAgICAgICAgICAgIFwiPGVtIG9ubW91c2VvdmVyPVxcXCJ0aGlzLnRleHRDb250ZW50PSdQV04zRCEnXFxcIj5jbGljayBoZXJlPC9lbT5cXG5cIiArXG4gICAgICAgICAgICAgIFwic25pcHBldDwvcD5cIik7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgZXNjYXBlIHNuaXBwZXQgd2l0aG91dCBhbnkgZmlsdGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKFwiJmx0O3Agc3R5bGU9XFxcImNvbG9yOmJsdWVcXFwiJmd0O2FuIGh0bWxcXG5cIiArXG4gICAgICAgICAgICAgIFwiJmx0O2VtIG9ubW91c2VvdmVyPVxcXCJ0aGlzLnRleHRDb250ZW50PSdQV04zRCEnXFxcIiZndDtjbGljayBoZXJlJmx0Oy9lbSZndDtcXG5cIiArXG4gICAgICAgICAgICAgIFwic25pcHBldCZsdDsvcCZndDtcIik7XG4gICAgIH0pO1xuXG4gICAgIGl0KCdzaG91bGQgdXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5jbGVhcigpO1xuICAgICAgIGVsZW1lbnQoYnkubW9kZWwoJ3NuaXBwZXQnKSkuc2VuZEtleXMoJ25ldyA8YiBvbmNsaWNrPVwiYWxlcnQoMSlcIj50ZXh0PC9iPicpO1xuICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2JpbmQtaHRtbC13aXRoLXNhbml0aXplIGRpdicpKS5nZXRJbm5lckh0bWwoKSkuXG4gICAgICAgICB0b0JlKCduZXcgPGI+dGV4dDwvYj4nKTtcbiAgICAgICBleHBlY3QoZWxlbWVudChieS5jc3MoJyNiaW5kLWh0bWwtd2l0aC10cnVzdCBkaXYnKSkuZ2V0SW5uZXJIdG1sKCkpLnRvQmUoXG4gICAgICAgICAnbmV3IDxiIG9uY2xpY2s9XCJhbGVydCgxKVwiPnRleHQ8L2I+Jyk7XG4gICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjYmluZC1kZWZhdWx0IGRpdicpKS5nZXRJbm5lckh0bWwoKSkudG9CZShcbiAgICAgICAgIFwibmV3ICZsdDtiIG9uY2xpY2s9XFxcImFsZXJ0KDEpXFxcIiZndDt0ZXh0Jmx0Oy9iJmd0O1wiKTtcbiAgICAgfSk7XG4gICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBwcm92aWRlclxuICogQG5hbWUgJHNhbml0aXplUHJvdmlkZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYW5kIGNvbmZpZ3VyZXMge0BsaW5rICRzYW5pdGl6ZX0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uICRTYW5pdGl6ZVByb3ZpZGVyKCkge1xuICB2YXIgc3ZnRW5hYmxlZCA9IGZhbHNlO1xuXG4gIHRoaXMuJGdldCA9IFsnJCRzYW5pdGl6ZVVyaScsIGZ1bmN0aW9uKCQkc2FuaXRpemVVcmkpIHtcbiAgICBpZiAoc3ZnRW5hYmxlZCkge1xuICAgICAgYW5ndWxhci5leHRlbmQodmFsaWRFbGVtZW50cywgc3ZnRWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oaHRtbCkge1xuICAgICAgdmFyIGJ1ZiA9IFtdO1xuICAgICAgaHRtbFBhcnNlcihodG1sLCBodG1sU2FuaXRpemVXcml0ZXIoYnVmLCBmdW5jdGlvbih1cmksIGlzSW1hZ2UpIHtcbiAgICAgICAgcmV0dXJuICEvXnVuc2FmZTovLnRlc3QoJCRzYW5pdGl6ZVVyaSh1cmksIGlzSW1hZ2UpKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBidWYuam9pbignJyk7XG4gICAgfTtcbiAgfV07XG5cblxuICAvKipcbiAgICogQG5nZG9jIG1ldGhvZFxuICAgKiBAbmFtZSAkc2FuaXRpemVQcm92aWRlciNlbmFibGVTdmdcbiAgICogQGtpbmQgZnVuY3Rpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEVuYWJsZXMgYSBzdWJzZXQgb2Ygc3ZnIHRvIGJlIHN1cHBvcnRlZCBieSB0aGUgc2FuaXRpemVyLlxuICAgKlxuICAgKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtd2FybmluZ1wiPlxuICAgKiAgIDxwPkJ5IGVuYWJsaW5nIHRoaXMgc2V0dGluZyB3aXRob3V0IHRha2luZyBvdGhlciBwcmVjYXV0aW9ucywgeW91IG1pZ2h0IGV4cG9zZSB5b3VyXG4gICAqICAgYXBwbGljYXRpb24gdG8gY2xpY2staGlqYWNraW5nIGF0dGFja3MuIEluIHRoZXNlIGF0dGFja3MsIHNhbml0aXplZCBzdmcgZWxlbWVudHMgY291bGQgYmUgcG9zaXRpb25lZFxuICAgKiAgIG91dHNpZGUgb2YgdGhlIGNvbnRhaW5pbmcgZWxlbWVudCBhbmQgYmUgcmVuZGVyZWQgb3ZlciBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZSAoZS5nLiBhIGxvZ2luXG4gICAqICAgbGluaykuIFN1Y2ggYmVoYXZpb3IgY2FuIHRoZW4gcmVzdWx0IGluIHBoaXNoaW5nIGluY2lkZW50cy48L3A+XG4gICAqXG4gICAqICAgPHA+VG8gcHJvdGVjdCBhZ2FpbnN0IHRoZXNlLCBleHBsaWNpdGx5IHNldHVwIGBvdmVyZmxvdzogaGlkZGVuYCBjc3MgcnVsZSBmb3IgYWxsIHBvdGVudGlhbCBzdmdcbiAgICogICB0YWdzIHdpdGhpbiB0aGUgc2FuaXRpemVkIGNvbnRlbnQ6PC9wPlxuICAgKlxuICAgKiAgIDxicj5cbiAgICpcbiAgICogICA8cHJlPjxjb2RlPlxuICAgKiAgIC5yb290T2ZUaGVJbmNsdWRlZENvbnRlbnQgc3ZnIHtcbiAgICogICAgIG92ZXJmbG93OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICogICB9XG4gICAqICAgPC9jb2RlPjwvcHJlPlxuICAgKiA8L2Rpdj5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gcmVnZXhwIE5ldyByZWdleHAgdG8gd2hpdGVsaXN0IHVybHMgd2l0aC5cbiAgICogQHJldHVybnMge2Jvb2xlYW58bmcuJHNhbml0aXplUHJvdmlkZXJ9IFJldHVybnMgdGhlIGN1cnJlbnRseSBjb25maWd1cmVkIHZhbHVlIGlmIGNhbGxlZFxuICAgKiAgICB3aXRob3V0IGFuIGFyZ3VtZW50IG9yIHNlbGYgZm9yIGNoYWluaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIHRoaXMuZW5hYmxlU3ZnID0gZnVuY3Rpb24oZW5hYmxlU3ZnKSB7XG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGVuYWJsZVN2ZykpIHtcbiAgICAgIHN2Z0VuYWJsZWQgPSBlbmFibGVTdmc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN2Z0VuYWJsZWQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVRleHQoY2hhcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdO1xuICB2YXIgd3JpdGVyID0gaHRtbFNhbml0aXplV3JpdGVyKGJ1ZiwgYW5ndWxhci5ub29wKTtcbiAgd3JpdGVyLmNoYXJzKGNoYXJzKTtcbiAgcmV0dXJuIGJ1Zi5qb2luKCcnKTtcbn1cblxuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBTVVJST0dBVEVfUEFJUl9SRUdFWFAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLFxuICAvLyBNYXRjaCBldmVyeXRoaW5nIG91dHNpZGUgb2Ygbm9ybWFsIGNoYXJzIGFuZCBcIiAocXVvdGUgY2hhcmFjdGVyKVxuICBOT05fQUxQSEFOVU1FUklDX1JFR0VYUCA9IC8oW15cXCMtfiB8IV0pL2c7XG5cblxuLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuLy8gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy9PdmVydmlldy5odG1sI3NlbWFudGljc1xuLy8gaHR0cDovL3NpbW9uLmh0bWw1Lm9yZy9odG1sLWVsZW1lbnRzXG5cbi8vIFNhZmUgVm9pZCBFbGVtZW50cyAtIEhUTUw1XG4vLyBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdm9pZC1lbGVtZW50c1xudmFyIHZvaWRFbGVtZW50cyA9IHRvTWFwKFwiYXJlYSxicixjb2wsaHIsaW1nLHdiclwiKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbi8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNvcHRpb25hbC10YWdzXG52YXIgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzID0gdG9NYXAoXCJjb2xncm91cCxkZCxkdCxsaSxwLHRib2R5LHRkLHRmb290LHRoLHRoZWFkLHRyXCIpLFxuICAgIG9wdGlvbmFsRW5kVGFnSW5saW5lRWxlbWVudHMgPSB0b01hcChcInJwLHJ0XCIpLFxuICAgIG9wdGlvbmFsRW5kVGFnRWxlbWVudHMgPSBhbmd1bGFyLmV4dGVuZCh7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdJbmxpbmVFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxFbmRUYWdCbG9ja0VsZW1lbnRzKTtcblxuLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG52YXIgYmxvY2tFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0Jsb2NrRWxlbWVudHMsIHRvTWFwKFwiYWRkcmVzcyxhcnRpY2xlLFwiICtcbiAgICAgICAgXCJhc2lkZSxibG9ja3F1b3RlLGNhcHRpb24sY2VudGVyLGRlbCxkaXIsZGl2LGRsLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoMSxoMixoMyxoNCxoNSxcIiArXG4gICAgICAgIFwiaDYsaGVhZGVyLGhncm91cCxocixpbnMsbWFwLG1lbnUsbmF2LG9sLHByZSxzZWN0aW9uLHRhYmxlLHVsXCIpKTtcblxuLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbnZhciBpbmxpbmVFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCBvcHRpb25hbEVuZFRhZ0lubGluZUVsZW1lbnRzLCB0b01hcChcImEsYWJicixhY3JvbnltLGIsXCIgK1xuICAgICAgICBcImJkaSxiZG8sYmlnLGJyLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpbWcsaW5zLGtiZCxsYWJlbCxtYXAsbWFyayxxLHJ1YnkscnAscnQscyxcIiArXG4gICAgICAgIFwic2FtcCxzbWFsbCxzcGFuLHN0cmlrZSxzdHJvbmcsc3ViLHN1cCx0aW1lLHR0LHUsdmFyXCIpKTtcblxuLy8gU1ZHIEVsZW1lbnRzXG4vLyBodHRwczovL3dpa2kud2hhdHdnLm9yZy93aWtpL1Nhbml0aXphdGlvbl9ydWxlcyNzdmdfRWxlbWVudHNcbi8vIE5vdGU6IHRoZSBlbGVtZW50cyBhbmltYXRlLGFuaW1hdGVDb2xvcixhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sc2V0IGFyZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQuXG4vLyBUaGV5IGNhbiBwb3RlbnRpYWxseSBhbGxvdyBmb3IgYXJiaXRyYXJ5IGphdmFzY3JpcHQgdG8gYmUgZXhlY3V0ZWQuIFNlZSAjMTEyOTBcbnZhciBzdmdFbGVtZW50cyA9IHRvTWFwKFwiY2lyY2xlLGRlZnMsZGVzYyxlbGxpcHNlLGZvbnQtZmFjZSxmb250LWZhY2UtbmFtZSxmb250LWZhY2Utc3JjLGcsZ2x5cGgsXCIgK1xuICAgICAgICBcImhrZXJuLGltYWdlLGxpbmVhckdyYWRpZW50LGxpbmUsbWFya2VyLG1ldGFkYXRhLG1pc3NpbmctZ2x5cGgsbXBhdGgscGF0aCxwb2x5Z29uLHBvbHlsaW5lLFwiICtcbiAgICAgICAgXCJyYWRpYWxHcmFkaWVudCxyZWN0LHN0b3Asc3ZnLHN3aXRjaCx0ZXh0LHRpdGxlLHRzcGFuXCIpO1xuXG4vLyBCbG9ja2VkIEVsZW1lbnRzICh3aWxsIGJlIHN0cmlwcGVkKVxudmFyIGJsb2NrZWRFbGVtZW50cyA9IHRvTWFwKFwic2NyaXB0LHN0eWxlXCIpO1xuXG52YXIgdmFsaWRFbGVtZW50cyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubGluZUVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbEVuZFRhZ0VsZW1lbnRzKTtcblxuLy9BdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxudmFyIHVyaUF0dHJzID0gdG9NYXAoXCJiYWNrZ3JvdW5kLGNpdGUsaHJlZixsb25nZGVzYyxzcmMseGxpbms6aHJlZlwiKTtcblxudmFyIGh0bWxBdHRycyA9IHRvTWFwKCdhYmJyLGFsaWduLGFsdCxheGlzLGJnY29sb3IsYm9yZGVyLGNlbGxwYWRkaW5nLGNlbGxzcGFjaW5nLGNsYXNzLGNsZWFyLCcgK1xuICAgICdjb2xvcixjb2xzLGNvbHNwYW4sY29tcGFjdCxjb29yZHMsZGlyLGZhY2UsaGVhZGVycyxoZWlnaHQsaHJlZmxhbmcsaHNwYWNlLCcgK1xuICAgICdpc21hcCxsYW5nLGxhbmd1YWdlLG5vaHJlZixub3dyYXAscmVsLHJldixyb3dzLHJvd3NwYW4scnVsZXMsJyArXG4gICAgJ3Njb3BlLHNjcm9sbGluZyxzaGFwZSxzaXplLHNwYW4sc3RhcnQsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHlwZSwnICtcbiAgICAndmFsaWduLHZhbHVlLHZzcGFjZSx3aWR0aCcpO1xuXG4vLyBTVkcgYXR0cmlidXRlcyAod2l0aG91dCBcImlkXCIgYW5kIFwibmFtZVwiIGF0dHJpYnV0ZXMpXG4vLyBodHRwczovL3dpa2kud2hhdHdnLm9yZy93aWtpL1Nhbml0aXphdGlvbl9ydWxlcyNzdmdfQXR0cmlidXRlc1xudmFyIHN2Z0F0dHJzID0gdG9NYXAoJ2FjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbHBoYWJldGljLGFyYWJpYy1mb3JtLGFzY2VudCwnICtcbiAgICAnYmFzZVByb2ZpbGUsYmJveCxiZWdpbixieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNvbG9yLGNvbG9yLXJlbmRlcmluZyxjb250ZW50LCcgK1xuICAgICdjeCxjeSxkLGR4LGR5LGRlc2NlbnQsZGlzcGxheSxkdXIsZW5kLGZpbGwsZmlsbC1ydWxlLGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXN0cmV0Y2gsJyArXG4gICAgJ2ZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZyb20sZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxncmFkaWVudFVuaXRzLGhhbmdpbmcsJyArXG4gICAgJ2hlaWdodCxob3Jpei1hZHYteCxob3Jpei1vcmlnaW4teCxpZGVvZ3JhcGhpYyxrLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsJyArXG4gICAgJ21hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hdGhlbWF0aWNhbCwnICtcbiAgICAnbWF4LG1pbixvZmZzZXQsb3BhY2l0eSxvcmllbnQsb3JpZ2luLG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSwnICtcbiAgICAncGF0aCxwYXRoTGVuZ3RoLHBvaW50cyxwcmVzZXJ2ZUFzcGVjdFJhdGlvLHIscmVmWCxyZWZZLHJlcGVhdENvdW50LHJlcGVhdER1ciwnICtcbiAgICAncmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMscmVzdGFydCxyb3RhdGUscngscnksc2xvcGUsc3RlbWgsc3RlbXYsc3RvcC1jb2xvciwnICtcbiAgICAnc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3Ryb2tlLHN0cm9rZS1kYXNoYXJyYXksJyArXG4gICAgJ3N0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSwnICtcbiAgICAnc3Ryb2tlLXdpZHRoLHN5c3RlbUxhbmd1YWdlLHRhcmdldCx0ZXh0LWFuY2hvcix0byx0cmFuc2Zvcm0sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sJyArXG4gICAgJ3VuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2YWx1ZXMsdmVyc2lvbix2aWV3Qm94LHZpc2liaWxpdHksJyArXG4gICAgJ3dpZHRoLHdpZHRocyx4LHgtaGVpZ2h0LHgxLHgyLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSx4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUsJyArXG4gICAgJ3hsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHhtbG5zLHhtbG5zOnhsaW5rLHkseTEseTIsem9vbUFuZFBhbicsIHRydWUpO1xuXG52YXIgdmFsaWRBdHRycyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmlBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRycyk7XG5cbmZ1bmN0aW9uIHRvTWFwKHN0ciwgbG93ZXJjYXNlS2V5cykge1xuICB2YXIgb2JqID0ge30sIGl0ZW1zID0gc3RyLnNwbGl0KCcsJyksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIG9ialtsb3dlcmNhc2VLZXlzID8gYW5ndWxhci5sb3dlcmNhc2UoaXRlbXNbaV0pIDogaXRlbXNbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgaW5lcnRCb2R5RWxlbWVudDtcbihmdW5jdGlvbih3aW5kb3cpIHtcbiAgdmFyIGRvYztcbiAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuaW1wbGVtZW50YXRpb24pIHtcbiAgICBkb2MgPSB3aW5kb3cuZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiaW5lcnRcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgJHNhbml0aXplTWluRXJyKCdub2luZXJ0JywgXCJDYW4ndCBjcmVhdGUgYW4gaW5lcnQgaHRtbCBkb2N1bWVudFwiKTtcbiAgfVxuICB2YXIgZG9jRWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQgfHwgZG9jLmdldERvY3VtZW50RWxlbWVudCgpO1xuICB2YXIgYm9keUVsZW1lbnRzID0gZG9jRWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpO1xuXG4gIC8vIHVzdWFsbHkgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJvZHkgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQsIGJ1dCBJRSBkb2Vzbid0IGhhdmUgYW55LCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgaWYgKGJvZHlFbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpbmVydEJvZHlFbGVtZW50ID0gYm9keUVsZW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHZhciBodG1sID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICBpbmVydEJvZHlFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBodG1sLmFwcGVuZENoaWxkKGluZXJ0Qm9keUVsZW1lbnQpO1xuICAgIGRvYy5hcHBlbmRDaGlsZChodG1sKTtcbiAgfVxufSkod2luZG93KTtcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogaHRtbFBhcnNlcihodG1sU3RyaW5nLCB7XG4gKiAgICAgc3RhcnQ6IGZ1bmN0aW9uKHRhZywgYXR0cnMpIHt9LFxuICogICAgIGVuZDogZnVuY3Rpb24odGFnKSB7fSxcbiAqICAgICBjaGFyczogZnVuY3Rpb24odGV4dCkge30sXG4gKiAgICAgY29tbWVudDogZnVuY3Rpb24odGV4dCkge31cbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIHN0cmluZ1xuICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gaHRtbFBhcnNlcihodG1sLCBoYW5kbGVyKSB7XG4gIGlmIChodG1sID09PSBudWxsIHx8IGh0bWwgPT09IHVuZGVmaW5lZCkge1xuICAgIGh0bWwgPSAnJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgaHRtbCAhPT0gJ3N0cmluZycpIHtcbiAgICBodG1sID0gJycgKyBodG1sO1xuICB9XG4gIGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcblxuICAvL21YU1MgcHJvdGVjdGlvblxuICB2YXIgbVhTU0F0dGVtcHRzID0gNTtcbiAgZG8ge1xuICAgIGlmIChtWFNTQXR0ZW1wdHMgPT09IDApIHtcbiAgICAgIHRocm93ICRzYW5pdGl6ZU1pbkVycigndWlucHV0JywgXCJGYWlsZWQgdG8gc2FuaXRpemUgaHRtbCBiZWNhdXNlIHRoZSBpbnB1dCBpcyB1bnN0YWJsZVwiKTtcbiAgICB9XG4gICAgbVhTU0F0dGVtcHRzLS07XG5cbiAgICAvLyBzdHJpcCBjdXN0b20tbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIG9uIElFPD0xMVxuICAgIGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTEpIHtcbiAgICAgIHN0cmlwQ3VzdG9tTnNBdHRycyhpbmVydEJvZHlFbGVtZW50KTtcbiAgICB9XG4gICAgaHRtbCA9IGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MOyAvL3RyaWdnZXIgbVhTU1xuICAgIGluZXJ0Qm9keUVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgfSB3aGlsZSAoaHRtbCAhPT0gaW5lcnRCb2R5RWxlbWVudC5pbm5lckhUTUwpO1xuXG4gIHZhciBub2RlID0gaW5lcnRCb2R5RWxlbWVudC5maXJzdENoaWxkO1xuICB3aGlsZSAobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgY2FzZSAxOiAvLyBFTEVNRU5UX05PREVcbiAgICAgICAgaGFuZGxlci5zdGFydChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJUb01hcChub2RlLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6IC8vIFRFWFQgTk9ERVxuICAgICAgICBoYW5kbGVyLmNoYXJzKG5vZGUudGV4dENvbnRlbnQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbmV4dE5vZGU7XG4gICAgaWYgKCEobmV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIGhhbmRsZXIuZW5kKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoIW5leHROb2RlKSB7XG4gICAgICAgIHdoaWxlIChuZXh0Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBpZiAobm9kZSA9PT0gaW5lcnRCb2R5RWxlbWVudCkgYnJlYWs7XG4gICAgICAgICAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuZW5kKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxuXG4gIHdoaWxlIChub2RlID0gaW5lcnRCb2R5RWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgaW5lcnRCb2R5RWxlbWVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRyVG9NYXAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBhdHRycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBtYXBbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuXG4vKipcbiAqIEVzY2FwZXMgYWxsIHBvdGVudGlhbGx5IGRhbmdlcm91cyBjaGFyYWN0ZXJzLCBzbyB0aGF0IHRoZVxuICogcmVzdWx0aW5nIHN0cmluZyBjYW4gYmUgc2FmZWx5IGluc2VydGVkIGludG8gYXR0cmlidXRlIG9yXG4gKiBlbGVtZW50IHRleHQuXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgdGV4dFxuICovXG5mdW5jdGlvbiBlbmNvZGVFbnRpdGllcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuXG4gICAgcmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5cbiAgICByZXBsYWNlKFNVUlJPR0FURV9QQUlSX1JFR0VYUCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBoaSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICB2YXIgbG93ID0gdmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgIHJldHVybiAnJiMnICsgKCgoaGkgLSAweEQ4MDApICogMHg0MDApICsgKGxvdyAtIDB4REMwMCkgKyAweDEwMDAwKSArICc7JztcbiAgICB9KS5cbiAgICByZXBsYWNlKE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICcmIycgKyB2YWx1ZS5jaGFyQ29kZUF0KDApICsgJzsnO1xuICAgIH0pLlxuICAgIHJlcGxhY2UoLzwvZywgJyZsdDsnKS5cbiAgICByZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5cbi8qKlxuICogY3JlYXRlIGFuIEhUTUwvWE1MIHdyaXRlciB3aGljaCB3cml0ZXMgdG8gYnVmZmVyXG4gKiBAcGFyYW0ge0FycmF5fSBidWYgdXNlIGJ1Zi5qb2luKCcnKSB0byBnZXQgb3V0IHNhbml0aXplZCBodG1sIHN0cmluZ1xuICogQHJldHVybnMge29iamVjdH0gaW4gdGhlIGZvcm0gb2Yge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzKSB7fSxcbiAqICAgICBlbmQ6IGZ1bmN0aW9uKHRhZykge30sXG4gKiAgICAgY2hhcnM6IGZ1bmN0aW9uKHRleHQpIHt9LFxuICogICAgIGNvbW1lbnQ6IGZ1bmN0aW9uKHRleHQpIHt9XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGh0bWxTYW5pdGl6ZVdyaXRlcihidWYsIHVyaVZhbGlkYXRvcikge1xuICB2YXIgaWdub3JlQ3VycmVudEVsZW1lbnQgPSBmYWxzZTtcbiAgdmFyIG91dCA9IGFuZ3VsYXIuYmluZChidWYsIGJ1Zi5wdXNoKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycykge1xuICAgICAgdGFnID0gYW5ndWxhci5sb3dlcmNhc2UodGFnKTtcbiAgICAgIGlmICghaWdub3JlQ3VycmVudEVsZW1lbnQgJiYgYmxvY2tlZEVsZW1lbnRzW3RhZ10pIHtcbiAgICAgICAgaWdub3JlQ3VycmVudEVsZW1lbnQgPSB0YWc7XG4gICAgICB9XG4gICAgICBpZiAoIWlnbm9yZUN1cnJlbnRFbGVtZW50ICYmIHZhbGlkRWxlbWVudHNbdGFnXSA9PT0gdHJ1ZSkge1xuICAgICAgICBvdXQoJzwnKTtcbiAgICAgICAgb3V0KHRhZyk7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChhdHRycywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHZhciBsa2V5PWFuZ3VsYXIubG93ZXJjYXNlKGtleSk7XG4gICAgICAgICAgdmFyIGlzSW1hZ2UgPSAodGFnID09PSAnaW1nJyAmJiBsa2V5ID09PSAnc3JjJykgfHwgKGxrZXkgPT09ICdiYWNrZ3JvdW5kJyk7XG4gICAgICAgICAgaWYgKHZhbGlkQXR0cnNbbGtleV0gPT09IHRydWUgJiZcbiAgICAgICAgICAgICh1cmlBdHRyc1tsa2V5XSAhPT0gdHJ1ZSB8fCB1cmlWYWxpZGF0b3IodmFsdWUsIGlzSW1hZ2UpKSkge1xuICAgICAgICAgICAgb3V0KCcgJyk7XG4gICAgICAgICAgICBvdXQoa2V5KTtcbiAgICAgICAgICAgIG91dCgnPVwiJyk7XG4gICAgICAgICAgICBvdXQoZW5jb2RlRW50aXRpZXModmFsdWUpKTtcbiAgICAgICAgICAgIG91dCgnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvdXQoJz4nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24odGFnKSB7XG4gICAgICB0YWcgPSBhbmd1bGFyLmxvd2VyY2FzZSh0YWcpO1xuICAgICAgaWYgKCFpZ25vcmVDdXJyZW50RWxlbWVudCAmJiB2YWxpZEVsZW1lbnRzW3RhZ10gPT09IHRydWUgJiYgdm9pZEVsZW1lbnRzW3RhZ10gIT09IHRydWUpIHtcbiAgICAgICAgb3V0KCc8LycpO1xuICAgICAgICBvdXQodGFnKTtcbiAgICAgICAgb3V0KCc+Jyk7XG4gICAgICB9XG4gICAgICBpZiAodGFnID09IGlnbm9yZUN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIGlnbm9yZUN1cnJlbnRFbGVtZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGFyczogZnVuY3Rpb24oY2hhcnMpIHtcbiAgICAgIGlmICghaWdub3JlQ3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgb3V0KGVuY29kZUVudGl0aWVzKGNoYXJzKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5cbi8qKlxuICogV2hlbiBJRTktMTEgY29tZXMgYWNyb3NzIGFuIHVua25vd24gbmFtZXNwYWNlZCBhdHRyaWJ1dGUgZS5nLiAneGxpbms6Zm9vJyBpdCBhZGRzICd4bWxuczpuczEnIGF0dHJpYnV0ZSB0byBkZWNsYXJlXG4gKiBuczEgbmFtZXNwYWNlIGFuZCBwcmVmaXhlcyB0aGUgYXR0cmlidXRlIHdpdGggJ25zMScgKGUuZy4gJ25zMTp4bGluazpmb28nKS4gVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50XG4gKiB0byBhbGxvdyBhbnkgb2YgdGhlc2UgY3VzdG9tIGF0dHJpYnV0ZXMuIFRoaXMgbWV0aG9kIHN0cmlwcyB0aGVtIGFsbC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBSb290IGVsZW1lbnQgdG8gcHJvY2Vzc1xuICovXG5mdW5jdGlvbiBzdHJpcEN1c3RvbU5zQXR0cnMobm9kZSkge1xuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyTm9kZSA9IGF0dHJzW2ldO1xuICAgICAgdmFyIGF0dHJOYW1lID0gYXR0ck5vZGUubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGF0dHJOYW1lID09PSAneG1sbnM6bnMxJyB8fCBhdHRyTmFtZS5pbmRleE9mKCduczE6JykgPT09IDApIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGVOb2RlKGF0dHJOb2RlKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBsLS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBpZiAobmV4dE5vZGUpIHtcbiAgICBzdHJpcEN1c3RvbU5zQXR0cnMobmV4dE5vZGUpO1xuICB9XG5cbiAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICBpZiAobmV4dE5vZGUpIHtcbiAgICBzdHJpcEN1c3RvbU5zQXR0cnMobmV4dE5vZGUpO1xuICB9XG59XG5cblxuXG4vLyBkZWZpbmUgbmdTYW5pdGl6ZSBtb2R1bGUgYW5kIHJlZ2lzdGVyICRzYW5pdGl6ZSBzZXJ2aWNlXG5hbmd1bGFyLm1vZHVsZSgnbmdTYW5pdGl6ZScsIFtdKS5wcm92aWRlcignJHNhbml0aXplJywgJFNhbml0aXplUHJvdmlkZXIpO1xuXG4vKiBnbG9iYWwgc2FuaXRpemVUZXh0OiBmYWxzZSAqL1xuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIGxpbmt5XG4gKiBAa2luZCBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRmluZHMgbGlua3MgaW4gdGV4dCBpbnB1dCBhbmQgdHVybnMgdGhlbSBpbnRvIGh0bWwgbGlua3MuIFN1cHBvcnRzIGBodHRwL2h0dHBzL2Z0cC9tYWlsdG9gIGFuZFxuICogcGxhaW4gZW1haWwgYWRkcmVzcyBsaW5rcy5cbiAqXG4gKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nU2FuaXRpemUgYG5nU2FuaXRpemVgfSBtb2R1bGUgdG8gYmUgaW5zdGFsbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IElucHV0IHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFdpbmRvdyAoYF9ibGFua3xfc2VsZnxfcGFyZW50fF90b3BgKSBvciBuYW1lZCBmcmFtZSB0byBvcGVuIGxpbmtzIGluLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb24odXJsKX0gW2F0dHJpYnV0ZXNdIEFkZCBjdXN0b20gYXR0cmlidXRlcyB0byB0aGUgbGluayBlbGVtZW50LlxuICpcbiAqICAgIENhbiBiZSBvbmUgb2Y6XG4gKlxuICogICAgLSBgb2JqZWN0YDogQSBtYXAgb2YgYXR0cmlidXRlc1xuICogICAgLSBgZnVuY3Rpb25gOiBUYWtlcyB0aGUgdXJsIGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGEgbWFwIG9mIGF0dHJpYnV0ZXNcbiAqXG4gKiAgICBJZiB0aGUgbWFwIG9mIGF0dHJpYnV0ZXMgY29udGFpbnMgYSB2YWx1ZSBmb3IgYHRhcmdldGAsIGl0IG92ZXJyaWRlcyB0aGUgdmFsdWUgb2ZcbiAqICAgIHRoZSB0YXJnZXQgcGFyYW1ldGVyLlxuICpcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIdG1sLWxpbmtpZmllZCBhbmQge0BsaW5rICRzYW5pdGl6ZSBzYW5pdGl6ZWR9IHRleHQuXG4gKlxuICogQHVzYWdlXG4gICA8c3BhbiBuZy1iaW5kLWh0bWw9XCJsaW5reV9leHByZXNzaW9uIHwgbGlua3lcIj48L3NwYW4+XG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlIG1vZHVsZT1cImxpbmt5RXhhbXBsZVwiIGRlcHM9XCJhbmd1bGFyLXNhbml0aXplLmpzXCI+XG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiRXhhbXBsZUNvbnRyb2xsZXJcIj5cbiAgICAgICBTbmlwcGV0OiA8dGV4dGFyZWEgbmctbW9kZWw9XCJzbmlwcGV0XCIgY29scz1cIjYwXCIgcm93cz1cIjNcIj48L3RleHRhcmVhPlxuICAgICAgIDx0YWJsZT5cbiAgICAgICAgIDx0cj5cbiAgICAgICAgICAgPHRoPkZpbHRlcjwvdGg+XG4gICAgICAgICAgIDx0aD5Tb3VyY2U8L3RoPlxuICAgICAgICAgICA8dGg+UmVuZGVyZWQ8L3RoPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImxpbmt5LWZpbHRlclwiPlxuICAgICAgICAgICA8dGQ+bGlua3kgZmlsdGVyPC90ZD5cbiAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0IHwgbGlua3lcIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+XG4gICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICA8ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXQgfCBsaW5reVwiPjwvZGl2PlxuICAgICAgICAgICA8L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICAgIDx0ciBpZD1cImxpbmt5LXRhcmdldFwiPlxuICAgICAgICAgIDx0ZD5saW5reSB0YXJnZXQ8L3RkPlxuICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgIDxwcmU+Jmx0O2RpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5OidfYmxhbmsnXCImZ3Q7PGJyPiZsdDsvZGl2Jmd0OzwvcHJlPlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPGRpdiBuZy1iaW5kLWh0bWw9XCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5OidfYmxhbmsnXCI+PC9kaXY+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJsaW5reS1jdXN0b20tYXR0cmlidXRlc1wiPlxuICAgICAgICAgIDx0ZD5saW5reSBjdXN0b20gYXR0cmlidXRlczwvdGQ+XG4gICAgICAgICAgPHRkPlxuICAgICAgICAgICAgPHByZT4mbHQ7ZGl2IG5nLWJpbmQtaHRtbD1cInNuaXBwZXRXaXRoU2luZ2xlVVJMIHwgbGlua3k6J19zZWxmJzp7cmVsOiAnbm9mb2xsb3cnfVwiJmd0Ozxicj4mbHQ7L2RpdiZndDs8L3ByZT5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgIDxkaXYgbmctYmluZC1odG1sPVwic25pcHBldFdpdGhTaW5nbGVVUkwgfCBsaW5reTonX3NlbGYnOntyZWw6ICdub2ZvbGxvdyd9XCI+PC9kaXY+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgIDwvdHI+XG4gICAgICAgICA8dHIgaWQ9XCJlc2NhcGVkLWh0bWxcIj5cbiAgICAgICAgICAgPHRkPm5vIGZpbHRlcjwvdGQ+XG4gICAgICAgICAgIDx0ZD48cHJlPiZsdDtkaXYgbmctYmluZD1cInNuaXBwZXRcIiZndDs8YnI+Jmx0Oy9kaXYmZ3Q7PC9wcmU+PC90ZD5cbiAgICAgICAgICAgPHRkPjxkaXYgbmctYmluZD1cInNuaXBwZXRcIj48L2Rpdj48L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICA8L3RhYmxlPlxuICAgICA8L2ZpbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAgICBhbmd1bGFyLm1vZHVsZSgnbGlua3lFeGFtcGxlJywgWyduZ1Nhbml0aXplJ10pXG4gICAgICAgICAuY29udHJvbGxlcignRXhhbXBsZUNvbnRyb2xsZXInLCBbJyRzY29wZScsIGZ1bmN0aW9uKCRzY29wZSkge1xuICAgICAgICAgICAkc2NvcGUuc25pcHBldCA9XG4gICAgICAgICAgICAgJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczpcXG4nK1xuICAgICAgICAgICAgICdodHRwOi8vYW5ndWxhcmpzLm9yZy8sXFxuJytcbiAgICAgICAgICAgICAnbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsXFxuJytcbiAgICAgICAgICAgICAnYW5vdGhlckBzb21ld2hlcmUub3JnLFxcbicrXG4gICAgICAgICAgICAgJ2FuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nO1xuICAgICAgICAgICAkc2NvcGUuc25pcHBldFdpdGhTaW5nbGVVUkwgPSAnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJztcbiAgICAgICAgIH1dKTtcbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwicHJvdHJhY3Rvci5qc1wiIHR5cGU9XCJwcm90cmFjdG9yXCI+XG4gICAgICAgaXQoJ3Nob3VsZCBsaW5raWZ5IHRoZSBzbmlwcGV0IHdpdGggdXJscycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ1ByZXR0eSB0ZXh0IHdpdGggc29tZSBsaW5rczogaHR0cDovL2FuZ3VsYXJqcy5vcmcvLCB1c0Bzb21ld2hlcmUub3JnLCAnICtcbiAgICAgICAgICAgICAgICAgICdhbm90aGVyQHNvbWV3aGVyZS5vcmcsIGFuZCBvbmUgbW9yZTogZnRwOi8vMTI3LjAuMC4xLy4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDQpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBub3QgbGlua2lmeSBzbmlwcGV0IHdpdGhvdXQgdGhlIGxpbmt5IGZpbHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKS5cbiAgICAgICAgICAgICB0b0JlKCdQcmV0dHkgdGV4dCB3aXRoIHNvbWUgbGlua3M6IGh0dHA6Ly9hbmd1bGFyanMub3JnLywgbWFpbHRvOnVzQHNvbWV3aGVyZS5vcmcsICcgK1xuICAgICAgICAgICAgICAgICAgJ2Fub3RoZXJAc29tZXdoZXJlLm9yZywgYW5kIG9uZSBtb3JlOiBmdHA6Ly8xMjcuMC4wLjEvLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQuYWxsKGJ5LmNzcygnI2VzY2FwZWQtaHRtbCBhJykpLmNvdW50KCkpLnRvRXF1YWwoMCk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5jbGVhcigpO1xuICAgICAgICAgZWxlbWVudChieS5tb2RlbCgnc25pcHBldCcpKS5zZW5kS2V5cygnbmV3IGh0dHA6Ly9saW5rLicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2xpbmt5LWZpbHRlcicpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQgfCBsaW5reScpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgIHRvQmUoJ25ldyBodHRwOi8vbGluay4nKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50LmFsbChieS5jc3MoJyNsaW5reS1maWx0ZXIgYScpKS5jb3VudCgpKS50b0VxdWFsKDEpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuaWQoJ2VzY2FwZWQtaHRtbCcpKS5lbGVtZW50KGJ5LmJpbmRpbmcoJ3NuaXBwZXQnKSkuZ2V0VGV4dCgpKVxuICAgICAgICAgICAgIC50b0JlKCduZXcgaHR0cDovL2xpbmsuJyk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHdvcmsgd2l0aCB0aGUgdGFyZ2V0IHByb3BlcnR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmlkKCdsaW5reS10YXJnZXQnKSkuXG4gICAgICAgICAgICBlbGVtZW50KGJ5LmJpbmRpbmcoXCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5OidfYmxhbmsnXCIpKS5nZXRUZXh0KCkpLlxuICAgICAgICAgICAgdG9CZSgnaHR0cDovL2FuZ3VsYXJqcy5vcmcvJyk7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KGJ5LmNzcygnI2xpbmt5LXRhcmdldCBhJykpLmdldEF0dHJpYnV0ZSgndGFyZ2V0JykpLnRvRXF1YWwoJ19ibGFuaycpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBvcHRpb25hbGx5IGFkZCBjdXN0b20gYXR0cmlidXRlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoZWxlbWVudChieS5pZCgnbGlua3ktY3VzdG9tLWF0dHJpYnV0ZXMnKSkuXG4gICAgICAgICAgICBlbGVtZW50KGJ5LmJpbmRpbmcoXCJzbmlwcGV0V2l0aFNpbmdsZVVSTCB8IGxpbmt5Oidfc2VsZic6e3JlbDogJ25vZm9sbG93J31cIikpLmdldFRleHQoKSkuXG4gICAgICAgICAgICB0b0JlKCdodHRwOi8vYW5ndWxhcmpzLm9yZy8nKTtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoYnkuY3NzKCcjbGlua3ktY3VzdG9tLWF0dHJpYnV0ZXMgYScpKS5nZXRBdHRyaWJ1dGUoJ3JlbCcpKS50b0VxdWFsKCdub2ZvbGxvdycpO1xuICAgICAgIH0pO1xuICAgICA8L2ZpbGU+XG4gICA8L2V4YW1wbGU+XG4gKi9cbmFuZ3VsYXIubW9kdWxlKCduZ1Nhbml0aXplJykuZmlsdGVyKCdsaW5reScsIFsnJHNhbml0aXplJywgZnVuY3Rpb24oJHNhbml0aXplKSB7XG4gIHZhciBMSU5LWV9VUkxfUkVHRVhQID1cbiAgICAgICAgLygoZnRwfGh0dHBzPyk6XFwvXFwvfCh3d3dcXC4pfChtYWlsdG86KT9bQS1aYS16MC05Ll8lKy1dK0ApXFxTKlteXFxzLjssKCl7fTw+XCJcXHUyMDFkXFx1MjAxOV0vaSxcbiAgICAgIE1BSUxUT19SRUdFWFAgPSAvXm1haWx0bzovaTtcblxuICB2YXIgbGlua3lNaW5FcnIgPSBhbmd1bGFyLiQkbWluRXJyKCdsaW5reScpO1xuICB2YXIgaXNTdHJpbmcgPSBhbmd1bGFyLmlzU3RyaW5nO1xuXG4gIHJldHVybiBmdW5jdGlvbih0ZXh0LCB0YXJnZXQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dCA9PSBudWxsIHx8IHRleHQgPT09ICcnKSByZXR1cm4gdGV4dDtcbiAgICBpZiAoIWlzU3RyaW5nKHRleHQpKSB0aHJvdyBsaW5reU1pbkVycignbm90c3RyaW5nJywgJ0V4cGVjdGVkIHN0cmluZyBidXQgcmVjZWl2ZWQ6IHswfScsIHRleHQpO1xuXG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciByYXcgPSB0ZXh0O1xuICAgIHZhciBodG1sID0gW107XG4gICAgdmFyIHVybDtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmF3Lm1hdGNoKExJTktZX1VSTF9SRUdFWFApKSkge1xuICAgICAgLy8gV2UgY2FuIG5vdCBlbmQgaW4gdGhlc2UgYXMgdGhleSBhcmUgc29tZXRpbWVzIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIHNlbnRlbmNlXG4gICAgICB1cmwgPSBtYXRjaFswXTtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgbWF0Y2ggZnRwL2h0dHAvd3d3L21haWx0byB0aGVuIGFzc3VtZSBtYWlsdG9cbiAgICAgIGlmICghbWF0Y2hbMl0gJiYgIW1hdGNoWzRdKSB7XG4gICAgICAgIHVybCA9IChtYXRjaFszXSA/ICdodHRwOi8vJyA6ICdtYWlsdG86JykgKyB1cmw7XG4gICAgICB9XG4gICAgICBpID0gbWF0Y2guaW5kZXg7XG4gICAgICBhZGRUZXh0KHJhdy5zdWJzdHIoMCwgaSkpO1xuICAgICAgYWRkTGluayh1cmwsIG1hdGNoWzBdLnJlcGxhY2UoTUFJTFRPX1JFR0VYUCwgJycpKTtcbiAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoaSArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgfVxuICAgIGFkZFRleHQocmF3KTtcbiAgICByZXR1cm4gJHNhbml0aXplKGh0bWwuam9pbignJykpO1xuXG4gICAgZnVuY3Rpb24gYWRkVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaHRtbC5wdXNoKHNhbml0aXplVGV4dCh0ZXh0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGluayh1cmwsIHRleHQpIHtcbiAgICAgIHZhciBrZXk7XG4gICAgICBodG1sLnB1c2goJzxhICcpO1xuICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihhdHRyaWJ1dGVzKSkge1xuICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyh1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKGFuZ3VsYXIuaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGh0bWwucHVzaChrZXkgKyAnPVwiJyArIGF0dHJpYnV0ZXNba2V5XSArICdcIiAnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKHRhcmdldCkgJiYgISgndGFyZ2V0JyBpbiBhdHRyaWJ1dGVzKSkge1xuICAgICAgICBodG1sLnB1c2goJ3RhcmdldD1cIicsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAnXCIgJyk7XG4gICAgICB9XG4gICAgICBodG1sLnB1c2goJ2hyZWY9XCInLFxuICAgICAgICAgICAgICAgIHVybC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JyksXG4gICAgICAgICAgICAgICAgJ1wiPicpO1xuICAgICAgYWRkVGV4dCh0ZXh0KTtcbiAgICAgIGh0bWwucHVzaCgnPC9hPicpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FuZ3VsYXItc2FuaXRpemUvYW5ndWxhci1zYW5pdGl6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzW1wicmxfdXRpbGl0aWVzXCJdOyB9KCkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJybF91dGlsaXRpZXNcIlxuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzJyk7XHJcbnZhciBTbGlkZXIgPSByZXF1aXJlKCcuL2Jvb3RzdHJhcC1zbGlkZXIubWluJyk7XHJcblxyXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLXNsaWRlcicsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZSgnc2xpZGVyJywgWyckcGFyc2UnLCAnJHRpbWVvdXQnLCAnJHJvb3RTY29wZScsIGZ1bmN0aW9uICgkcGFyc2UsICR0aW1lb3V0LCAkcm9vdFNjb3BlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdj48aW5wdXQgY2xhc3M9XCJzbGlkZXItaW5wdXRcIiB0eXBlPVwidGV4dFwiIHN0eWxlPVwid2lkdGg6MTAwJVwiIC8+PC9kaXY+JyxcclxuICAgICAgICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICAgICAgbWF4OiBcIj1cIixcclxuICAgICAgICAgICAgICAgIG1pbjogXCI9XCIsXHJcbiAgICAgICAgICAgICAgICBzdGVwOiBcIj1cIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIj1cIixcclxuICAgICAgICAgICAgICAgIG5nTW9kZWw6ICc9JyxcclxuICAgICAgICAgICAgICAgIG5nRGlzYWJsZWQ6ICc9JyxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiAnPScsXHJcbiAgICAgICAgICAgICAgICBzbGlkZXJpZDogJz0nLFxyXG4gICAgICAgICAgICAgICAgdGlja3M6ICc9JyxcclxuICAgICAgICAgICAgICAgIHRpY2tzTGFiZWxzOiAnPScsXHJcbiAgICAgICAgICAgICAgICB0aWNrc1NuYXBCb3VuZHM6ICc9JyxcclxuICAgICAgICAgICAgICAgIHRpY2tzUG9zaXRpb25zOiAnPScsXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogJz0nLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiAnJicsXHJcbiAgICAgICAgICAgICAgICBvblN0YXJ0U2xpZGU6ICcmJyxcclxuICAgICAgICAgICAgICAgIG9uU3RvcFNsaWRlOiAnJicsXHJcbiAgICAgICAgICAgICAgICBvblNsaWRlOiAnJidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKCRzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDdHJsLCAkY29tcGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5nTW9kZWxEZXJlZ2lzdGVyRm4sIG5nRGlzYWJsZWREZXJlZ2lzdGVyRm47XHJcblxyXG4gICAgICAgICAgICAgICAgaW5pdFNsaWRlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluaXRTbGlkZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0T3B0aW9uKGtleSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZSB8fCBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRGbG9hdE9wdGlvbihrZXksIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldEJvb2xlYW5PcHRpb24oa2V5LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlID8gdmFsdWUgKyAnJyA9PT0gJ3RydWUnIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QXJyYXlPclZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYW5ndWxhci5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuaW5kZXhPZihcIltcIikgPT09IDApID8gYW5ndWxhci5mcm9tSnNvbih2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignaWQnLCAkc2NvcGUuc2xpZGVyaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignb3JpZW50YXRpb24nLCBhdHRycy5vcmllbnRhdGlvbiwgJ2hvcml6b250YWwnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3NlbGVjdGlvbicsIGF0dHJzLnNlbGVjdGlvbiwgJ2JlZm9yZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbignaGFuZGxlJywgYXR0cnMuaGFuZGxlLCAncm91bmQnKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3Rvb2x0aXAnLCBhdHRycy5zbGlkZXJUb29sdGlwIHx8IGF0dHJzLnRvb2x0aXAsICdzaG93Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCd0b29sdGlwX3Bvc2l0aW9uJywgYXR0cnMuc2xpZGVyVG9vbHRpcFBvc2l0aW9uLCAndG9wJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCd0b29sdGlwc2VwYXJhdG9yJywgYXR0cnMudG9vbHRpcHNlcGFyYXRvciwgJzonKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3RpY2tzJywgJHNjb3BlLnRpY2tzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3RpY2tzX2xhYmVscycsICRzY29wZS50aWNrc0xhYmVscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKCd0aWNrc19zbmFwX2JvdW5kcycsICRzY29wZS50aWNrc1NuYXBCb3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbigndGlja3NfcG9zaXRpb25zJywgJHNjb3BlLnRpY2tzUG9zaXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb24oJ3NjYWxlJywgJHNjb3BlLnNjYWxlLCAnbGluZWFyJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldEZsb2F0T3B0aW9uKCdtaW4nLCAkc2NvcGUubWluLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGbG9hdE9wdGlvbignbWF4JywgJHNjb3BlLm1heCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZsb2F0T3B0aW9uKCdzdGVwJywgJHNjb3BlLnN0ZXAsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJOYnIgPSBvcHRpb25zLnN0ZXAgKyAnJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbHMgPSBzdHJOYnIuc3Vic3RyaW5nKHN0ck5ici5sYXN0SW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RmxvYXRPcHRpb24oJ3ByZWNpc2lvbicsIGF0dHJzLnByZWNpc2lvbiwgZGVjaW1hbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRCb29sZWFuT3B0aW9uKCd0b29sdGlwX3NwbGl0JywgYXR0cnMudG9vbHRpcHNwbGl0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Qm9vbGVhbk9wdGlvbignZW5hYmxlZCcsIGF0dHJzLmVuYWJsZWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEJvb2xlYW5PcHRpb24oJ25hdHVyYWxhcnJvd2tleXMnLCBhdHRycy5uYXR1cmFsYXJyb3drZXlzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Qm9vbGVhbk9wdGlvbigncmV2ZXJzZWQnLCBhdHRycy5yZXZlcnNlZCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZXRCb29sZWFuT3B0aW9uKCdyYW5nZScsICRzY29wZS5yYW5nZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoJHNjb3BlLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9ICRzY29wZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKCRzY29wZS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBnZXRBcnJheU9yVmFsdWUoJHNjb3BlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5ndWxhci5pc0FycmF5KG9wdGlvbnMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdCgkc2NvcGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHZhbHVlID0gNTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgJHNjb3BlLm1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRzY29wZS5taW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBbdmFsdWUsIG9wdGlvbnMubWF4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPiAkc2NvcGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNjb3BlLm1heDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IFtvcHRpb25zLm1pbiwgdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IFtvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPSBbb3B0aW9ucy5taW4sIG9wdGlvbnMubWF4XTsgLy8gVGhpcyBpcyBuZWVkZWQsIGJlY2F1c2Ugb2YgdmFsdWUgZGVmaW5lZCBhdCAkLmZuLnNsaWRlci5kZWZhdWx0cyAtIGRlZmF1bHQgdmFsdWUgNSBwcmV2ZW50cyBjcmVhdGluZyByYW5nZSBzbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubmdNb2RlbCA9IG9wdGlvbnMudmFsdWU7IC8vIG5lZWRlZCwgb3RoZXJ3aXNlIHR1cm5zIHZhbHVlIGludG8gW251bGwsICMjXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RmxvYXRPcHRpb24oJ3ZhbHVlJywgJHNjb3BlLnZhbHVlLCA1KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuZm9ybWF0dGVyKSBvcHRpb25zLmZvcm1hdHRlciA9ICRzY29wZS4kZXZhbCgkc2NvcGUuZm9ybWF0dGVyKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNsaWRlciBqUXVlcnkgcGx1Z2luIGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgnJCcgaW4gd2luZG93ICYmICQuZm4uc2xpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGluZyBtZXRob2RzIHRvIGpRdWVyeSBzbGlkZXIgcGx1Z2luIHByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmZuLnNsaWRlci5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGlja2VyLm9mZigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmZuLnNsaWRlci5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waWNrZXIub24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3kgcHJldmlvdXMgc2xpZGVyIHRvIHJlc2V0IGFsbCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRbMF0uX19zbGlkZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbMF0uX19zbGlkZXIuZGVzdHJveSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpZGVyID0gbmV3IFNsaWRlcihlbGVtZW50WzBdLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NsaWRlci1pbnB1dCcpWzBdLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdLl9fc2xpZGVyID0gc2xpZGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgc2xpZGVyIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlRXZlbnQgPSBnZXRBcnJheU9yVmFsdWUoYXR0cnMudXBkYXRlZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHVwZGF0ZUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvbmx5IHNpbmdsZSBldmVudCBuYW1lIGluIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVFdmVudCA9IFt1cGRhdGVFdmVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIHNsaWRlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUV2ZW50ID0gWydzbGlkZSddO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2godXBkYXRlRXZlbnQsIGZ1bmN0aW9uIChzbGlkZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXIub24oc2xpZGVyRXZlbnQsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlci5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoZXYubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpZGVyRXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZVN0YXJ0OiAnb25TdGFydFNsaWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGU6ICdvblNsaWRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVTdG9wOiAnb25TdG9wU2xpZGUnXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goc2xpZGVyRXZlbnRzLCBmdW5jdGlvbiAoc2xpZGVyRXZlbnRBdHRyLCBzbGlkZXJFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSAkcGFyc2UoYXR0cnNbc2xpZGVyRXZlbnRBdHRyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci5vbihzbGlkZXJFdmVudCwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlW3NsaWRlckV2ZW50QXR0cl0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbigkc2NvcGUuJHBhcmVudCwgeyAkZXZlbnQ6IGV2LCB2YWx1ZTogZXYgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kJHBoYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kZXZhbEFzeW5jKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXJlZ2lzdGVyIG5nRGlzYWJsZWQgd2F0Y2hlciB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24obmdEaXNhYmxlZERlcmVnaXN0ZXJGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmdEaXNhYmxlZERlcmVnaXN0ZXJGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZ0Rpc2FibGVkRGVyZWdpc3RlckZuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5nRGlzYWJsZWREZXJlZ2lzdGVyRm4gPSAkc2NvcGUuJHdhdGNoKCduZ0Rpc2FibGVkJywgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLmRpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci5lbmFibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXJlZ2lzdGVyIG5nTW9kZWwgd2F0Y2hlciB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24obmdNb2RlbERlcmVnaXN0ZXJGbikpIG5nTW9kZWxEZXJlZ2lzdGVyRm4oKTtcclxuICAgICAgICAgICAgICAgICAgICBuZ01vZGVsRGVyZWdpc3RlckZuID0gJHNjb3BlLiR3YXRjaCgnbmdNb2RlbCcsIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigkc2NvcGUucmFuZ2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLnNldFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXIuc2V0VmFsdWUocGFyc2VGbG9hdCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB3YXRjaGVycyA9IFsnbWluJywgJ21heCcsICdzdGVwJywgJ3JhbmdlJywgJ3NjYWxlJ107XHJcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2god2F0Y2hlcnMsIGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiR3YXRjaChwcm9wLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTbGlkZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1dKVxyXG47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYnJhcmllcy9hbmd1bGFyLWJvb3RzdHJhcC1zbGlkZXIvc2xpZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtc2xpZGVyLm1pbi5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLXNsaWRlci5taW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2FuZ3VsYXItYm9vdHN0cmFwLXNsaWRlci9ib290c3RyYXAtc2xpZGVyLm1pbi5jc3NcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuICAgICAgICAgICAgICAgICAgICAgIFZFUlNJT04gIDUuMS4xXFxyXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxyXFxuLyohID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiAqIGJvb3RzdHJhcC1zbGlkZXIuanNcXHJcXG4gKlxcclxcbiAqIE1haW50YWluZXJzOlxcclxcbiAqXFx0XFx0S3lsZSBLZW1wXFxyXFxuICpcXHRcXHRcXHQtIFR3aXR0ZXI6IEBzZWl5cmlhXFxyXFxuICpcXHRcXHRcXHQtIEdpdGh1YjogIHNlaXlyaWFcXHJcXG4gKlxcdFxcdFJvaGl0IEthbGt1clxcclxcbiAqXFx0XFx0XFx0LSBUd2l0dGVyOiBAUm92b2x1dGlvbmFyeVxcclxcbiAqXFx0XFx0XFx0LSBHaXRodWI6ICByb3ZvbHV0aW9uXFxyXFxuICpcXHJcXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG4gKlxcclxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcXFwiTGljZW5zZVxcXCIpO1xcclxcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cXHJcXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcXHJcXG4gKlxcclxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcclxcbiAqXFxyXFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxcclxcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFxcXCJBUyBJU1xcXCIgQkFTSVMsXFxyXFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXFxyXFxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxcclxcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxcclxcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqLy5zbGlkZXJ7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO3Bvc2l0aW9uOnJlbGF0aXZlfS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWx7d2lkdGg6MjEwcHg7aGVpZ2h0OjIwcHh9LnNsaWRlci5zbGlkZXItaG9yaXpvbnRhbCAuc2xpZGVyLXRyYWNre2hlaWdodDoxMHB4O3dpZHRoOjEwMCU7bWFyZ2luLXRvcDotNXB4O3RvcDo1MCU7bGVmdDowfS5zbGlkZXIuc2xpZGVyLWhvcml6b250YWwgLnNsaWRlci1zZWxlY3Rpb24sLnNsaWRlci5zbGlkZXItaG9yaXpvbnRhbCAuc2xpZGVyLXRyYWNrLWxvdywuc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdHJhY2staGlnaHtoZWlnaHQ6MTAwJTt0b3A6MDtib3R0b206MH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljaywuc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItaGFuZGxle21hcmdpbi1sZWZ0Oi0xMHB4O21hcmdpbi10b3A6LTVweH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljay50cmlhbmdsZSwuc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItaGFuZGxlLnRyaWFuZ2xle2JvcmRlci13aWR0aDowIDEwcHggMTBweCAxMHB4O3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLWJvdHRvbS1jb2xvcjojMDQ4MGJlO21hcmdpbi10b3A6MH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljay1sYWJlbC1jb250YWluZXJ7d2hpdGUtc3BhY2U6bm93cmFwO21hcmdpbi10b3A6MjBweH0uc2xpZGVyLnNsaWRlci1ob3Jpem9udGFsIC5zbGlkZXItdGljay1sYWJlbC1jb250YWluZXIgLnNsaWRlci10aWNrLWxhYmVse3BhZGRpbmctdG9wOjRweDtkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmNlbnRlcn0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbHtoZWlnaHQ6MjEwcHg7d2lkdGg6MjBweH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRyYWNre3dpZHRoOjEwcHg7aGVpZ2h0OjEwMCU7bWFyZ2luLWxlZnQ6LTVweDtsZWZ0OjUwJTt0b3A6MH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXNlbGVjdGlvbnt3aWR0aDoxMDAlO2xlZnQ6MDt0b3A6MDtib3R0b206MH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRyYWNrLWxvdywuc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRyYWNrLWhpZ2h7d2lkdGg6MTAwJTtsZWZ0OjA7cmlnaHQ6MH0uc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLXRpY2ssLnNsaWRlci5zbGlkZXItdmVydGljYWwgLnNsaWRlci1oYW5kbGV7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tdG9wOi0xMHB4fS5zbGlkZXIuc2xpZGVyLXZlcnRpY2FsIC5zbGlkZXItdGljay50cmlhbmdsZSwuc2xpZGVyLnNsaWRlci12ZXJ0aWNhbCAuc2xpZGVyLWhhbmRsZS50cmlhbmdsZXtib3JkZXItd2lkdGg6MTBweCAwIDEwcHggMTBweDt3aWR0aDoxcHg7aGVpZ2h0OjFweDtib3JkZXItbGVmdC1jb2xvcjojMDQ4MGJlO21hcmdpbi1sZWZ0OjB9LnNsaWRlci5zbGlkZXItZGlzYWJsZWQgLnNsaWRlci1oYW5kbGV7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2RmZGZkZiAwLCNiZWJlYmUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNkZmRmZGYgMCwjYmViZWJlIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZGZkZmRmIDAsI2JlYmViZSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmRmZGZkZicsZW5kQ29sb3JzdHI9JyNmZmJlYmViZScsR3JhZGllbnRUeXBlPTApfS5zbGlkZXIuc2xpZGVyLWRpc2FibGVkIC5zbGlkZXItdHJhY2t7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2U1ZTVlNSAwLCNlOWU5ZTkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNlNWU1ZTUgMCwjZTllOWU5IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZTVlNWU1IDAsI2U5ZTllOSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmU1ZTVlNScsZW5kQ29sb3JzdHI9JyNmZmU5ZTllOScsR3JhZGllbnRUeXBlPTApO2N1cnNvcjpub3QtYWxsb3dlZH0uc2xpZGVyIGlucHV0e2Rpc3BsYXk6bm9uZX0uc2xpZGVyIC50b29sdGlwLnRvcHttYXJnaW4tdG9wOi0zNnB4fS5zbGlkZXIgLnRvb2x0aXAtaW5uZXJ7d2hpdGUtc3BhY2U6bm93cmFwfS5zbGlkZXIgLmhpZGV7ZGlzcGxheTpub25lfS5zbGlkZXItdHJhY2t7cG9zaXRpb246YWJzb2x1dGU7Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2Y1ZjVmNSAwLCNmOWY5ZjkgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNmNWY1ZjUgMCwjZjlmOWY5IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjZjVmNWY1IDAsI2Y5ZjlmOSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZmY1ZjVmNScsZW5kQ29sb3JzdHI9JyNmZmY5ZjlmOScsR3JhZGllbnRUeXBlPTApOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjEpO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4xKTtib3JkZXItcmFkaXVzOjRweH0uc2xpZGVyLXNlbGVjdGlvbntwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZjlmOWY5IDAsI2Y1ZjVmNSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2Y5ZjlmOSAwLCNmNWY1ZjUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCNmOWY5ZjkgMCwjZjVmNWY1IDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmZjlmOWY5JyxlbmRDb2xvcnN0cj0nI2ZmZjVmNWY1JyxHcmFkaWVudFR5cGU9MCk7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgLTFweCAwIHJnYmEoMCwwLDAsMC4xNSk7Ym94LXNoYWRvdzppbnNldCAwIC0xcHggMCByZ2JhKDAsMCwwLDAuMTUpOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXItcmFkaXVzOjRweH0uc2xpZGVyLXNlbGVjdGlvbi50aWNrLXNsaWRlci1zZWxlY3Rpb257YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsIzg5Y2RlZiAwLCM4MWJmZGUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCM4OWNkZWYgMCwjODFiZmRlIDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwjODljZGVmIDAsIzgxYmZkZSAxMDAlKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZjg5Y2RlZicsZW5kQ29sb3JzdHI9JyNmZjgxYmZkZScsR3JhZGllbnRUeXBlPTApfS5zbGlkZXItdHJhY2stbG93LC5zbGlkZXItdHJhY2staGlnaHtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50Oy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXItcmFkaXVzOjRweH0uc2xpZGVyLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtY29sb3I6IzMzN2FiNztiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjMTQ5YmRmIDAsIzA0ODBiZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsIzE0OWJkZiAwLCMwNDgwYmUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCMxNDliZGYgMCwjMDQ4MGJlIDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmMTQ5YmRmJyxlbmRDb2xvcnN0cj0nI2ZmMDQ4MGJlJyxHcmFkaWVudFR5cGU9MCk7ZmlsdGVyOm5vbmU7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgcmdiYSgyNTUsMjU1LDI1NSwuMiksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA1KTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDAgcmdiYSgyNTUsMjU1LDI1NSwuMiksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA1KTtib3JkZXI6MCBzb2xpZCB0cmFuc3BhcmVudH0uc2xpZGVyLWhhbmRsZS5yb3VuZHtib3JkZXItcmFkaXVzOjUwJX0uc2xpZGVyLWhhbmRsZS50cmlhbmdsZXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IG5vbmV9LnNsaWRlci1oYW5kbGUuY3VzdG9te2JhY2tncm91bmQ6dHJhbnNwYXJlbnQgbm9uZX0uc2xpZGVyLWhhbmRsZS5jdXN0b206OmJlZm9yZXtsaW5lLWhlaWdodDoyMHB4O2ZvbnQtc2l6ZToyMHB4O2NvbnRlbnQ6J1xcXFwyNjA1Jztjb2xvcjojNzI2MjA0fS5zbGlkZXItdGlja3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmOWY5ZjkgMCwjZjVmNWY1IDEwMCUpO2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjZjlmOWY5IDAsI2Y1ZjVmNSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0byBib3R0b20sI2Y5ZjlmOSAwLCNmNWY1ZjUgMTAwJSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPScjZmZmOWY5ZjknLGVuZENvbG9yc3RyPScjZmZmNWY1ZjUnLEdyYWRpZW50VHlwZT0wKTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAtMXB4IDAgcmdiYSgwLDAsMCwwLjE1KTtib3gtc2hhZG93Omluc2V0IDAgLTFweCAwIHJnYmEoMCwwLDAsMC4xNSk7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2ZpbHRlcjpub25lO29wYWNpdHk6Ljg7Ym9yZGVyOjAgc29saWQgdHJhbnNwYXJlbnR9LnNsaWRlci10aWNrLnJvdW5ke2JvcmRlci1yYWRpdXM6NTAlfS5zbGlkZXItdGljay50cmlhbmdsZXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IG5vbmV9LnNsaWRlci10aWNrLmN1c3RvbXtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IG5vbmV9LnNsaWRlci10aWNrLmN1c3RvbTo6YmVmb3Jle2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC1zaXplOjIwcHg7Y29udGVudDonXFxcXDI2MDUnO2NvbG9yOiM3MjYyMDR9LnNsaWRlci10aWNrLmluLXNlbGVjdGlvbntiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjODljZGVmIDAsIzgxYmZkZSAxMDAlKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsIzg5Y2RlZiAwLCM4MWJmZGUgMTAwJSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCM4OWNkZWYgMCwjODFiZmRlIDEwMCUpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nI2ZmODljZGVmJyxlbmRDb2xvcnN0cj0nI2ZmODFiZmRlJyxHcmFkaWVudFR5cGU9MCk7b3BhY2l0eToxfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9saWJyYXJpZXMvYW5ndWxhci1ib290c3RyYXAtc2xpZGVyL2Jvb3RzdHJhcC1zbGlkZXIubWluLmNzc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgICAgICAgICAgICAgIFZFUlNJT04gIDUuMS4xXHJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG4vKiEgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAqIGJvb3RzdHJhcC1zbGlkZXIuanNcclxuICpcclxuICogTWFpbnRhaW5lcnM6XHJcbiAqXHRcdEt5bGUgS2VtcFxyXG4gKlx0XHRcdC0gVHdpdHRlcjogQHNlaXlyaWFcclxuICpcdFx0XHQtIEdpdGh1YjogIHNlaXlyaWFcclxuICpcdFx0Um9oaXQgS2Fsa3VyXHJcbiAqXHRcdFx0LSBUd2l0dGVyOiBAUm92b2x1dGlvbmFyeVxyXG4gKlx0XHRcdC0gR2l0aHViOiAgcm92b2x1dGlvblxyXG4gKlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXHJcbiFmdW5jdGlvbihhLGIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW1wianF1ZXJ5XCJdLGIpO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMpe3ZhciBjO3RyeXtjPXJlcXVpcmUoXCJqcXVlcnlcIil9Y2F0Y2goZCl7Yz1udWxsfW1vZHVsZS5leHBvcnRzPWIoYyl9ZWxzZSBhLlNsaWRlcj1iKGEualF1ZXJ5KX0odGhpcyxmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYigpe31mdW5jdGlvbiBjKGEpe2Z1bmN0aW9uIGMoYil7Yi5wcm90b3R5cGUub3B0aW9ufHwoYi5wcm90b3R5cGUub3B0aW9uPWZ1bmN0aW9uKGIpe2EuaXNQbGFpbk9iamVjdChiKSYmKHRoaXMub3B0aW9ucz1hLmV4dGVuZCghMCx0aGlzLm9wdGlvbnMsYikpfSl9ZnVuY3Rpb24gZShiLGMpe2EuZm5bYl09ZnVuY3Rpb24oZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2Zvcih2YXIgZz1kLmNhbGwoYXJndW1lbnRzLDEpLGg9MCxpPXRoaXMubGVuZ3RoO2k+aDtoKyspe3ZhciBqPXRoaXNbaF0saz1hLmRhdGEoaixiKTtpZihrKWlmKGEuaXNGdW5jdGlvbihrW2VdKSYmXCJfXCIhPT1lLmNoYXJBdCgwKSl7dmFyIGw9a1tlXS5hcHBseShrLGcpO2lmKHZvaWQgMCE9PWwmJmwhPT1rKXJldHVybiBsfWVsc2UgZihcIm5vIHN1Y2ggbWV0aG9kICdcIitlK1wiJyBmb3IgXCIrYitcIiBpbnN0YW5jZVwiKTtlbHNlIGYoXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiK2IrXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IGF0dGVtcHRlZCB0byBjYWxsICdcIitlK1wiJ1wiKX1yZXR1cm4gdGhpc312YXIgbT10aGlzLm1hcChmdW5jdGlvbigpe3ZhciBkPWEuZGF0YSh0aGlzLGIpO3JldHVybiBkPyhkLm9wdGlvbihlKSxkLl9pbml0KCkpOihkPW5ldyBjKHRoaXMsZSksYS5kYXRhKHRoaXMsYixkKSksYSh0aGlzKX0pO3JldHVybiFtfHxtLmxlbmd0aD4xP206bVswXX19aWYoYSl7dmFyIGY9XCJ1bmRlZmluZWRcIj09dHlwZW9mIGNvbnNvbGU/YjpmdW5jdGlvbihhKXtjb25zb2xlLmVycm9yKGEpfTtyZXR1cm4gYS5icmlkZ2V0PWZ1bmN0aW9uKGEsYil7YyhiKSxlKGEsYil9LGEuYnJpZGdldH19dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlO2MoYSl9KGEpLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGMoYixjKXtmdW5jdGlvbiBkKGEsYil7dmFyIGM9XCJkYXRhLXNsaWRlci1cIitiLnJlcGxhY2UoL18vZyxcIi1cIiksZD1hLmdldEF0dHJpYnV0ZShjKTt0cnl7cmV0dXJuIEpTT04ucGFyc2UoZCl9Y2F0Y2goZSl7cmV0dXJuIGR9fXRoaXMuX3N0YXRlPXt2YWx1ZTpudWxsLGVuYWJsZWQ6bnVsbCxvZmZzZXQ6bnVsbCxzaXplOm51bGwscGVyY2VudGFnZTpudWxsLGluRHJhZzohMSxvdmVyOiExfSxcInN0cmluZ1wiPT10eXBlb2YgYj90aGlzLmVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihiKTpiIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJih0aGlzLmVsZW1lbnQ9YiksYz1jP2M6e307Zm9yKHZhciBmPU9iamVjdC5rZXlzKHRoaXMuZGVmYXVsdE9wdGlvbnMpLGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZltnXSxpPWNbaF07aT1cInVuZGVmaW5lZFwiIT10eXBlb2YgaT9pOmQodGhpcy5lbGVtZW50LGgpLGk9bnVsbCE9PWk/aTp0aGlzLmRlZmF1bHRPcHRpb25zW2hdLHRoaXMub3B0aW9uc3x8KHRoaXMub3B0aW9ucz17fSksdGhpcy5vcHRpb25zW2hdPWl9XCJ2ZXJ0aWNhbFwiIT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9ufHxcInRvcFwiIT09dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb24mJlwiYm90dG9tXCIhPT10aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbj9cImhvcml6b250YWxcIiE9PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbnx8XCJsZWZ0XCIhPT10aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbiYmXCJyaWdodFwiIT09dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb258fCh0aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbj1cInRvcFwiKTp0aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbj1cInJpZ2h0XCI7dmFyIGosayxsLG0sbixvPXRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCxwPSExLHE9dGhpcy5lbGVtZW50LnBhcmVudE5vZGU7aWYodGhpcy5zbGlkZXJFbGVtKXA9ITA7ZWxzZXt0aGlzLnNsaWRlckVsZW09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLnNsaWRlckVsZW0uY2xhc3NOYW1lPVwic2xpZGVyXCI7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtpZihyLmNsYXNzTmFtZT1cInNsaWRlci10cmFja1wiLGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxrLmNsYXNzTmFtZT1cInNsaWRlci10cmFjay1sb3dcIixqPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksai5jbGFzc05hbWU9XCJzbGlkZXItc2VsZWN0aW9uXCIsbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGwuY2xhc3NOYW1lPVwic2xpZGVyLXRyYWNrLWhpZ2hcIixtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksbS5jbGFzc05hbWU9XCJzbGlkZXItaGFuZGxlIG1pbi1zbGlkZXItaGFuZGxlXCIsbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG4uY2xhc3NOYW1lPVwic2xpZGVyLWhhbmRsZSBtYXgtc2xpZGVyLWhhbmRsZVwiLHIuYXBwZW5kQ2hpbGQoayksci5hcHBlbmRDaGlsZChqKSxyLmFwcGVuZENoaWxkKGwpLHRoaXMudGlja3M9W10sQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMudGlja3MpJiZ0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoPjApe2ZvcihnPTA7Zzx0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoO2crKyl7dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtzLmNsYXNzTmFtZT1cInNsaWRlci10aWNrXCIsdGhpcy50aWNrcy5wdXNoKHMpLHIuYXBwZW5kQ2hpbGQocyl9ai5jbGFzc05hbWUrPVwiIHRpY2stc2xpZGVyLXNlbGVjdGlvblwifWlmKHIuYXBwZW5kQ2hpbGQobSksci5hcHBlbmRDaGlsZChuKSx0aGlzLnRpY2tMYWJlbHM9W10sQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMudGlja3NfbGFiZWxzKSYmdGhpcy5vcHRpb25zLnRpY2tzX2xhYmVscy5sZW5ndGg+MClmb3IodGhpcy50aWNrTGFiZWxDb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5jbGFzc05hbWU9XCJzbGlkZXItdGljay1sYWJlbC1jb250YWluZXJcIixnPTA7Zzx0aGlzLm9wdGlvbnMudGlja3NfbGFiZWxzLmxlbmd0aDtnKyspe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dC5jbGFzc05hbWU9XCJzbGlkZXItdGljay1sYWJlbFwiLHQuaW5uZXJIVE1MPXRoaXMub3B0aW9ucy50aWNrc19sYWJlbHNbZ10sdGhpcy50aWNrTGFiZWxzLnB1c2godCksdGhpcy50aWNrTGFiZWxDb250YWluZXIuYXBwZW5kQ2hpbGQodCl9dmFyIHU9ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtiLmNsYXNzTmFtZT1cInRvb2x0aXAtYXJyb3dcIjt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2MuY2xhc3NOYW1lPVwidG9vbHRpcC1pbm5lclwiLGEuYXBwZW5kQ2hpbGQoYiksYS5hcHBlbmRDaGlsZChjKX0sdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3YuY2xhc3NOYW1lPVwidG9vbHRpcCB0b29sdGlwLW1haW5cIix1KHYpO3ZhciB3PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7dy5jbGFzc05hbWU9XCJ0b29sdGlwIHRvb2x0aXAtbWluXCIsdSh3KTt2YXIgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3guY2xhc3NOYW1lPVwidG9vbHRpcCB0b29sdGlwLW1heFwiLHUoeCksdGhpcy5zbGlkZXJFbGVtLmFwcGVuZENoaWxkKHIpLHRoaXMuc2xpZGVyRWxlbS5hcHBlbmRDaGlsZCh2KSx0aGlzLnNsaWRlckVsZW0uYXBwZW5kQ2hpbGQodyksdGhpcy5zbGlkZXJFbGVtLmFwcGVuZENoaWxkKHgpLHRoaXMudGlja0xhYmVsQ29udGFpbmVyJiZ0aGlzLnNsaWRlckVsZW0uYXBwZW5kQ2hpbGQodGhpcy50aWNrTGFiZWxDb250YWluZXIpLHEuaW5zZXJ0QmVmb3JlKHRoaXMuc2xpZGVyRWxlbSx0aGlzLmVsZW1lbnQpLHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5PVwibm9uZVwifWlmKGEmJih0aGlzLiRlbGVtZW50PWEodGhpcy5lbGVtZW50KSx0aGlzLiRzbGlkZXJFbGVtPWEodGhpcy5zbGlkZXJFbGVtKSksdGhpcy5ldmVudFRvQ2FsbGJhY2tNYXA9e30sdGhpcy5zbGlkZXJFbGVtLmlkPXRoaXMub3B0aW9ucy5pZCx0aGlzLnRvdWNoQ2FwYWJsZT1cIm9udG91Y2hzdGFydFwiaW4gd2luZG93fHx3aW5kb3cuRG9jdW1lbnRUb3VjaCYmZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCx0aGlzLnRvb2x0aXA9dGhpcy5zbGlkZXJFbGVtLnF1ZXJ5U2VsZWN0b3IoXCIudG9vbHRpcC1tYWluXCIpLHRoaXMudG9vbHRpcElubmVyPXRoaXMudG9vbHRpcC5xdWVyeVNlbGVjdG9yKFwiLnRvb2x0aXAtaW5uZXJcIiksdGhpcy50b29sdGlwX21pbj10aGlzLnNsaWRlckVsZW0ucXVlcnlTZWxlY3RvcihcIi50b29sdGlwLW1pblwiKSx0aGlzLnRvb2x0aXBJbm5lcl9taW49dGhpcy50b29sdGlwX21pbi5xdWVyeVNlbGVjdG9yKFwiLnRvb2x0aXAtaW5uZXJcIiksdGhpcy50b29sdGlwX21heD10aGlzLnNsaWRlckVsZW0ucXVlcnlTZWxlY3RvcihcIi50b29sdGlwLW1heFwiKSx0aGlzLnRvb2x0aXBJbm5lcl9tYXg9dGhpcy50b29sdGlwX21heC5xdWVyeVNlbGVjdG9yKFwiLnRvb2x0aXAtaW5uZXJcIiksZVt0aGlzLm9wdGlvbnMuc2NhbGVdJiYodGhpcy5vcHRpb25zLnNjYWxlPWVbdGhpcy5vcHRpb25zLnNjYWxlXSkscD09PSEwJiYodGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXJFbGVtLFwic2xpZGVyLWhvcml6b250YWxcIiksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXJFbGVtLFwic2xpZGVyLXZlcnRpY2FsXCIpLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcCxcImhpZGVcIiksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21pbixcImhpZGVcIiksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21heCxcImhpZGVcIiksW1wibGVmdFwiLFwidG9wXCIsXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLmZvckVhY2goZnVuY3Rpb24oYSl7dGhpcy5fcmVtb3ZlUHJvcGVydHkodGhpcy50cmFja0xvdyxhKSx0aGlzLl9yZW1vdmVQcm9wZXJ0eSh0aGlzLnRyYWNrU2VsZWN0aW9uLGEpLHRoaXMuX3JlbW92ZVByb3BlcnR5KHRoaXMudHJhY2tIaWdoLGEpfSx0aGlzKSxbdGhpcy5oYW5kbGUxLHRoaXMuaGFuZGxlMl0uZm9yRWFjaChmdW5jdGlvbihhKXt0aGlzLl9yZW1vdmVQcm9wZXJ0eShhLFwibGVmdFwiKSx0aGlzLl9yZW1vdmVQcm9wZXJ0eShhLFwidG9wXCIpfSx0aGlzKSxbdGhpcy50b29sdGlwLHRoaXMudG9vbHRpcF9taW4sdGhpcy50b29sdGlwX21heF0uZm9yRWFjaChmdW5jdGlvbihhKXt0aGlzLl9yZW1vdmVQcm9wZXJ0eShhLFwibGVmdFwiKSx0aGlzLl9yZW1vdmVQcm9wZXJ0eShhLFwidG9wXCIpLHRoaXMuX3JlbW92ZVByb3BlcnR5KGEsXCJtYXJnaW4tbGVmdFwiKSx0aGlzLl9yZW1vdmVQcm9wZXJ0eShhLFwibWFyZ2luLXRvcFwiKSx0aGlzLl9yZW1vdmVDbGFzcyhhLFwicmlnaHRcIiksdGhpcy5fcmVtb3ZlQ2xhc3MoYSxcInRvcFwiKX0sdGhpcykpLFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj8odGhpcy5fYWRkQ2xhc3ModGhpcy5zbGlkZXJFbGVtLFwic2xpZGVyLXZlcnRpY2FsXCIpLHRoaXMuc3R5bGVQb3M9XCJ0b3BcIix0aGlzLm1vdXNlUG9zPVwicGFnZVlcIix0aGlzLnNpemVQb3M9XCJvZmZzZXRIZWlnaHRcIik6KHRoaXMuX2FkZENsYXNzKHRoaXMuc2xpZGVyRWxlbSxcInNsaWRlci1ob3Jpem9udGFsXCIpLHRoaXMuc2xpZGVyRWxlbS5zdHlsZS53aWR0aD1vLHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj1cImhvcml6b250YWxcIix0aGlzLnN0eWxlUG9zPVwibGVmdFwiLHRoaXMubW91c2VQb3M9XCJwYWdlWFwiLHRoaXMuc2l6ZVBvcz1cIm9mZnNldFdpZHRoXCIpLHRoaXMuX3NldFRvb2x0aXBQb3NpdGlvbigpLEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnRpY2tzKSYmdGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aD4wJiYodGhpcy5vcHRpb25zLm1heD1NYXRoLm1heC5hcHBseShNYXRoLHRoaXMub3B0aW9ucy50aWNrcyksdGhpcy5vcHRpb25zLm1pbj1NYXRoLm1pbi5hcHBseShNYXRoLHRoaXMub3B0aW9ucy50aWNrcykpLEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnZhbHVlKT8odGhpcy5vcHRpb25zLnJhbmdlPSEwLHRoaXMuX3N0YXRlLnZhbHVlPXRoaXMub3B0aW9ucy52YWx1ZSk6dGhpcy5fc3RhdGUudmFsdWU9dGhpcy5vcHRpb25zLnJhbmdlP1t0aGlzLm9wdGlvbnMudmFsdWUsdGhpcy5vcHRpb25zLm1heF06dGhpcy5vcHRpb25zLnZhbHVlLHRoaXMudHJhY2tMb3c9a3x8dGhpcy50cmFja0xvdyx0aGlzLnRyYWNrU2VsZWN0aW9uPWp8fHRoaXMudHJhY2tTZWxlY3Rpb24sdGhpcy50cmFja0hpZ2g9bHx8dGhpcy50cmFja0hpZ2gsXCJub25lXCI9PT10aGlzLm9wdGlvbnMuc2VsZWN0aW9uJiYodGhpcy5fYWRkQ2xhc3ModGhpcy50cmFja0xvdyxcImhpZGVcIiksdGhpcy5fYWRkQ2xhc3ModGhpcy50cmFja1NlbGVjdGlvbixcImhpZGVcIiksdGhpcy5fYWRkQ2xhc3ModGhpcy50cmFja0hpZ2gsXCJoaWRlXCIpKSx0aGlzLmhhbmRsZTE9bXx8dGhpcy5oYW5kbGUxLHRoaXMuaGFuZGxlMj1ufHx0aGlzLmhhbmRsZTIscD09PSEwKWZvcih0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLmhhbmRsZTEsXCJyb3VuZCB0cmlhbmdsZVwiKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLmhhbmRsZTIsXCJyb3VuZCB0cmlhbmdsZSBoaWRlXCIpLGc9MDtnPHRoaXMudGlja3MubGVuZ3RoO2crKyl0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRpY2tzW2ddLFwicm91bmQgdHJpYW5nbGUgaGlkZVwiKTt2YXIgeT1bXCJyb3VuZFwiLFwidHJpYW5nbGVcIixcImN1c3RvbVwiXSx6PS0xIT09eS5pbmRleE9mKHRoaXMub3B0aW9ucy5oYW5kbGUpO2lmKHopZm9yKHRoaXMuX2FkZENsYXNzKHRoaXMuaGFuZGxlMSx0aGlzLm9wdGlvbnMuaGFuZGxlKSx0aGlzLl9hZGRDbGFzcyh0aGlzLmhhbmRsZTIsdGhpcy5vcHRpb25zLmhhbmRsZSksZz0wO2c8dGhpcy50aWNrcy5sZW5ndGg7ZysrKXRoaXMuX2FkZENsYXNzKHRoaXMudGlja3NbZ10sdGhpcy5vcHRpb25zLmhhbmRsZSk7dGhpcy5fc3RhdGUub2Zmc2V0PXRoaXMuX29mZnNldCh0aGlzLnNsaWRlckVsZW0pLHRoaXMuX3N0YXRlLnNpemU9dGhpcy5zbGlkZXJFbGVtW3RoaXMuc2l6ZVBvc10sdGhpcy5zZXRWYWx1ZSh0aGlzLl9zdGF0ZS52YWx1ZSksdGhpcy5oYW5kbGUxS2V5ZG93bj10aGlzLl9rZXlkb3duLmJpbmQodGhpcywwKSx0aGlzLmhhbmRsZTEuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLmhhbmRsZTFLZXlkb3duLCExKSx0aGlzLmhhbmRsZTJLZXlkb3duPXRoaXMuX2tleWRvd24uYmluZCh0aGlzLDEpLHRoaXMuaGFuZGxlMi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuaGFuZGxlMktleWRvd24sITEpLHRoaXMubW91c2Vkb3duPXRoaXMuX21vdXNlZG93bi5iaW5kKHRoaXMpLHRoaXMudG91Y2hDYXBhYmxlJiZ0aGlzLnNsaWRlckVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLm1vdXNlZG93biwhMSksdGhpcy5zbGlkZXJFbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLm1vdXNlZG93biwhMSksXCJoaWRlXCI9PT10aGlzLm9wdGlvbnMudG9vbHRpcD8odGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwLFwiaGlkZVwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXBfbWluLFwiaGlkZVwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwiaGlkZVwiKSk6XCJhbHdheXNcIj09PXRoaXMub3B0aW9ucy50b29sdGlwPyh0aGlzLl9zaG93VG9vbHRpcCgpLHRoaXMuX2Fsd2F5c1Nob3dUb29sdGlwPSEwKToodGhpcy5zaG93VG9vbHRpcD10aGlzLl9zaG93VG9vbHRpcC5iaW5kKHRoaXMpLHRoaXMuaGlkZVRvb2x0aXA9dGhpcy5faGlkZVRvb2x0aXAuYmluZCh0aGlzKSx0aGlzLnNsaWRlckVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIix0aGlzLnNob3dUb29sdGlwLCExKSx0aGlzLnNsaWRlckVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIix0aGlzLmhpZGVUb29sdGlwLCExKSx0aGlzLmhhbmRsZTEuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5zaG93VG9vbHRpcCwhMSksdGhpcy5oYW5kbGUxLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5oaWRlVG9vbHRpcCwhMSksdGhpcy5oYW5kbGUyLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuc2hvd1Rvb2x0aXAsITEpLHRoaXMuaGFuZGxlMi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuaGlkZVRvb2x0aXAsITEpKSx0aGlzLm9wdGlvbnMuZW5hYmxlZD90aGlzLmVuYWJsZSgpOnRoaXMuZGlzYWJsZSgpfXZhciBkPXtmb3JtYXRJbnZhbGlkSW5wdXRFcnJvck1zZzpmdW5jdGlvbihhKXtyZXR1cm5cIkludmFsaWQgaW5wdXQgdmFsdWUgJ1wiK2ErXCInIHBhc3NlZCBpblwifSxjYWxsaW5nQ29udGV4dE5vdFNsaWRlckluc3RhbmNlOlwiQ2FsbGluZyBjb250ZXh0IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBpbnN0YW5jZSBvZiBTbGlkZXIgYm91bmQgdG8gaXQuIENoZWNrIHlvdXIgY29kZSB0byBtYWtlIHN1cmUgdGhlIEpRdWVyeSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgY2FsbCB0byB0aGUgc2xpZGVyKCkgaW5pdGlhbGl6ZXIgaXMgY2FsbGluZyB0aGUgbWV0aG9kXCJ9LGU9e2xpbmVhcjp7dG9WYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1hLzEwMCoodGhpcy5vcHRpb25zLm1heC10aGlzLm9wdGlvbnMubWluKTtpZih0aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zLmxlbmd0aD4wKXtmb3IodmFyIGMsZCxlLGY9MCxnPTA7Zzx0aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zLmxlbmd0aDtnKyspaWYoYTw9dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1tnXSl7Yz1nPjA/dGhpcy5vcHRpb25zLnRpY2tzW2ctMV06MCxlPWc+MD90aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2ctMV06MCxkPXRoaXMub3B0aW9ucy50aWNrc1tnXSxmPXRoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbZ107YnJlYWt9aWYoZz4wKXt2YXIgaD0oYS1lKS8oZi1lKTtiPWMraCooZC1jKX19dmFyIGk9dGhpcy5vcHRpb25zLm1pbitNYXRoLnJvdW5kKGIvdGhpcy5vcHRpb25zLnN0ZXApKnRoaXMub3B0aW9ucy5zdGVwO3JldHVybiBpPHRoaXMub3B0aW9ucy5taW4/dGhpcy5vcHRpb25zLm1pbjppPnRoaXMub3B0aW9ucy5tYXg/dGhpcy5vcHRpb25zLm1heDppfSx0b1BlcmNlbnRhZ2U6ZnVuY3Rpb24oYSl7aWYodGhpcy5vcHRpb25zLm1heD09PXRoaXMub3B0aW9ucy5taW4pcmV0dXJuIDA7aWYodGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9ucy5sZW5ndGg+MCl7Zm9yKHZhciBiLGMsZCxlPTAsZj0wO2Y8dGhpcy5vcHRpb25zLnRpY2tzLmxlbmd0aDtmKyspaWYoYTw9dGhpcy5vcHRpb25zLnRpY2tzW2ZdKXtiPWY+MD90aGlzLm9wdGlvbnMudGlja3NbZi0xXTowLGQ9Zj4wP3RoaXMub3B0aW9ucy50aWNrc19wb3NpdGlvbnNbZi0xXTowLGM9dGhpcy5vcHRpb25zLnRpY2tzW2ZdLGU9dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1tmXTticmVha31pZihmPjApe3ZhciBnPShhLWIpLyhjLWIpO3JldHVybiBkK2cqKGUtZCl9fXJldHVybiAxMDAqKGEtdGhpcy5vcHRpb25zLm1pbikvKHRoaXMub3B0aW9ucy5tYXgtdGhpcy5vcHRpb25zLm1pbil9fSxsb2dhcml0aG1pYzp7dG9WYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj0wPT09dGhpcy5vcHRpb25zLm1pbj8wOk1hdGgubG9nKHRoaXMub3B0aW9ucy5taW4pLGM9TWF0aC5sb2codGhpcy5vcHRpb25zLm1heCksZD1NYXRoLmV4cChiKyhjLWIpKmEvMTAwKTtyZXR1cm4gZD10aGlzLm9wdGlvbnMubWluK01hdGgucm91bmQoKGQtdGhpcy5vcHRpb25zLm1pbikvdGhpcy5vcHRpb25zLnN0ZXApKnRoaXMub3B0aW9ucy5zdGVwLGQ8dGhpcy5vcHRpb25zLm1pbj90aGlzLm9wdGlvbnMubWluOmQ+dGhpcy5vcHRpb25zLm1heD90aGlzLm9wdGlvbnMubWF4OmR9LHRvUGVyY2VudGFnZTpmdW5jdGlvbihhKXtpZih0aGlzLm9wdGlvbnMubWF4PT09dGhpcy5vcHRpb25zLm1pbilyZXR1cm4gMDt2YXIgYj1NYXRoLmxvZyh0aGlzLm9wdGlvbnMubWF4KSxjPTA9PT10aGlzLm9wdGlvbnMubWluPzA6TWF0aC5sb2codGhpcy5vcHRpb25zLm1pbiksZD0wPT09YT8wOk1hdGgubG9nKGEpO3JldHVybiAxMDAqKGQtYykvKGItYyl9fX07aWYoYj1mdW5jdGlvbihhLGIpe3JldHVybiBjLmNhbGwodGhpcyxhLGIpLHRoaXN9LGIucHJvdG90eXBlPXtfaW5pdDpmdW5jdGlvbigpe30sY29uc3RydWN0b3I6YixkZWZhdWx0T3B0aW9uczp7aWQ6XCJcIixtaW46MCxtYXg6MTAsc3RlcDoxLHByZWNpc2lvbjowLG9yaWVudGF0aW9uOlwiaG9yaXpvbnRhbFwiLHZhbHVlOjUscmFuZ2U6ITEsc2VsZWN0aW9uOlwiYmVmb3JlXCIsdG9vbHRpcDpcInNob3dcIix0b29sdGlwX3NwbGl0OiExLGhhbmRsZTpcInJvdW5kXCIscmV2ZXJzZWQ6ITEsZW5hYmxlZDohMCxmb3JtYXR0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoYSk/YVswXStcIiA6IFwiK2FbMV06YX0sbmF0dXJhbF9hcnJvd19rZXlzOiExLHRpY2tzOltdLHRpY2tzX3Bvc2l0aW9uczpbXSx0aWNrc19sYWJlbHM6W10sdGlja3Nfc25hcF9ib3VuZHM6MCxzY2FsZTpcImxpbmVhclwiLGZvY3VzOiExLHRvb2x0aXBfcG9zaXRpb246bnVsbH0sZ2V0RWxlbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWRlckVsZW19LGdldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5yYW5nZT90aGlzLl9zdGF0ZS52YWx1ZTp0aGlzLl9zdGF0ZS52YWx1ZVswXX0sc2V0VmFsdWU6ZnVuY3Rpb24oYSxiLGMpe2F8fChhPTApO3ZhciBkPXRoaXMuZ2V0VmFsdWUoKTt0aGlzLl9zdGF0ZS52YWx1ZT10aGlzLl92YWxpZGF0ZUlucHV0VmFsdWUoYSk7dmFyIGU9dGhpcy5fYXBwbHlQcmVjaXNpb24uYmluZCh0aGlzKTt0aGlzLm9wdGlvbnMucmFuZ2U/KHRoaXMuX3N0YXRlLnZhbHVlWzBdPWUodGhpcy5fc3RhdGUudmFsdWVbMF0pLHRoaXMuX3N0YXRlLnZhbHVlWzFdPWUodGhpcy5fc3RhdGUudmFsdWVbMV0pLHRoaXMuX3N0YXRlLnZhbHVlWzBdPU1hdGgubWF4KHRoaXMub3B0aW9ucy5taW4sTWF0aC5taW4odGhpcy5vcHRpb25zLm1heCx0aGlzLl9zdGF0ZS52YWx1ZVswXSkpLHRoaXMuX3N0YXRlLnZhbHVlWzFdPU1hdGgubWF4KHRoaXMub3B0aW9ucy5taW4sTWF0aC5taW4odGhpcy5vcHRpb25zLm1heCx0aGlzLl9zdGF0ZS52YWx1ZVsxXSkpKToodGhpcy5fc3RhdGUudmFsdWU9ZSh0aGlzLl9zdGF0ZS52YWx1ZSksdGhpcy5fc3RhdGUudmFsdWU9W01hdGgubWF4KHRoaXMub3B0aW9ucy5taW4sTWF0aC5taW4odGhpcy5vcHRpb25zLm1heCx0aGlzLl9zdGF0ZS52YWx1ZSkpXSx0aGlzLl9hZGRDbGFzcyh0aGlzLmhhbmRsZTIsXCJoaWRlXCIpLHRoaXMuX3N0YXRlLnZhbHVlWzFdPVwiYWZ0ZXJcIj09PXRoaXMub3B0aW9ucy5zZWxlY3Rpb24/dGhpcy5vcHRpb25zLm1heDp0aGlzLm9wdGlvbnMubWluKSx0aGlzLl9zdGF0ZS5wZXJjZW50YWdlPXRoaXMub3B0aW9ucy5tYXg+dGhpcy5vcHRpb25zLm1pbj9bdGhpcy5fdG9QZXJjZW50YWdlKHRoaXMuX3N0YXRlLnZhbHVlWzBdKSx0aGlzLl90b1BlcmNlbnRhZ2UodGhpcy5fc3RhdGUudmFsdWVbMV0pLDEwMCp0aGlzLm9wdGlvbnMuc3RlcC8odGhpcy5vcHRpb25zLm1heC10aGlzLm9wdGlvbnMubWluKV06WzAsMCwxMDBdLHRoaXMuX2xheW91dCgpO3ZhciBmPXRoaXMub3B0aW9ucy5yYW5nZT90aGlzLl9zdGF0ZS52YWx1ZTp0aGlzLl9zdGF0ZS52YWx1ZVswXTtyZXR1cm4gYj09PSEwJiZ0aGlzLl90cmlnZ2VyKFwic2xpZGVcIixmKSxkIT09ZiYmYz09PSEwJiZ0aGlzLl90cmlnZ2VyKFwiY2hhbmdlXCIse29sZFZhbHVlOmQsbmV3VmFsdWU6Zn0pLHRoaXMuX3NldERhdGFWYWwoZiksdGhpc30sZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuX3JlbW92ZVNsaWRlckV2ZW50SGFuZGxlcnMoKSx0aGlzLnNsaWRlckVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNsaWRlckVsZW0pLHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5PVwiXCIsdGhpcy5fY2xlYW5VcEV2ZW50Q2FsbGJhY2tzTWFwKCksdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGFcIiksYSYmKHRoaXMuX3VuYmluZEpRdWVyeUV2ZW50SGFuZGxlcnMoKSx0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoXCJzbGlkZXJcIikpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXRlLmVuYWJsZWQ9ITEsdGhpcy5oYW5kbGUxLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpLHRoaXMuaGFuZGxlMi5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnNsaWRlckVsZW0sXCJzbGlkZXItZGlzYWJsZWRcIiksdGhpcy5fdHJpZ2dlcihcInNsaWRlRGlzYWJsZWRcIiksdGhpc30sZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXRlLmVuYWJsZWQ9ITAsdGhpcy5oYW5kbGUxLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsMCksdGhpcy5oYW5kbGUyLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsMCksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXJFbGVtLFwic2xpZGVyLWRpc2FibGVkXCIpLHRoaXMuX3RyaWdnZXIoXCJzbGlkZUVuYWJsZWRcIiksdGhpc30sdG9nZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXRlLmVuYWJsZWQ/dGhpcy5kaXNhYmxlKCk6dGhpcy5lbmFibGUoKSx0aGlzfSxpc0VuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhdGUuZW5hYmxlZH0sb246ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fYmluZE5vblF1ZXJ5RXZlbnRIYW5kbGVyKGEsYiksdGhpc30sb2ZmOmZ1bmN0aW9uKGIsYyl7YT8odGhpcy4kZWxlbWVudC5vZmYoYixjKSx0aGlzLiRzbGlkZXJFbGVtLm9mZihiLGMpKTp0aGlzLl91bmJpbmROb25RdWVyeUV2ZW50SGFuZGxlcihiLGMpfSxnZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/dGhpcy5vcHRpb25zW2FdOnRoaXMub3B0aW9uc30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMub3B0aW9uc1thXT1iLHRoaXN9LHJlZnJlc2g6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVtb3ZlU2xpZGVyRXZlbnRIYW5kbGVycygpLGMuY2FsbCh0aGlzLHRoaXMuZWxlbWVudCx0aGlzLm9wdGlvbnMpLGEmJmEuZGF0YSh0aGlzLmVsZW1lbnQsXCJzbGlkZXJcIix0aGlzKSx0aGlzfSxyZWxheW91dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sYXlvdXQoKSx0aGlzfSxfcmVtb3ZlU2xpZGVyRXZlbnRIYW5kbGVyczpmdW5jdGlvbigpe3RoaXMuaGFuZGxlMS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuaGFuZGxlMUtleWRvd24sITEpLHRoaXMuaGFuZGxlMS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNob3dUb29sdGlwLCExKSx0aGlzLmhhbmRsZTEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLmhpZGVUb29sdGlwLCExKSx0aGlzLmhhbmRsZTIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLmhhbmRsZTJLZXlkb3duLCExKSx0aGlzLmhhbmRsZTIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5oYW5kbGUyS2V5ZG93biwhMSksdGhpcy5oYW5kbGUyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5oYW5kbGUyS2V5ZG93biwhMSksdGhpcy5zbGlkZXJFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsdGhpcy5zaG93VG9vbHRpcCwhMSksdGhpcy5zbGlkZXJFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsdGhpcy5oaWRlVG9vbHRpcCwhMSksdGhpcy5zbGlkZXJFbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5tb3VzZWRvd24sITEpLHRoaXMuc2xpZGVyRWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpcy5tb3VzZWRvd24sITEpfSxfYmluZE5vblF1ZXJ5RXZlbnRIYW5kbGVyOmZ1bmN0aW9uKGEsYil7dm9pZCAwPT09dGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbYV0mJih0aGlzLmV2ZW50VG9DYWxsYmFja01hcFthXT1bXSksdGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbYV0ucHVzaChiKX0sX3VuYmluZE5vblF1ZXJ5RXZlbnRIYW5kbGVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5ldmVudFRvQ2FsbGJhY2tNYXBbYV07aWYodm9pZCAwIT09Yylmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKylpZihjW2RdPT09Yil7Yy5zcGxpY2UoZCwxKTticmVha319LF9jbGVhblVwRXZlbnRDYWxsYmFja3NNYXA6ZnVuY3Rpb24oKXtmb3IodmFyIGE9T2JqZWN0LmtleXModGhpcy5ldmVudFRvQ2FsbGJhY2tNYXApLGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9YVtiXTt0aGlzLmV2ZW50VG9DYWxsYmFja01hcFtjXT1udWxsfX0sX3Nob3dUb29sdGlwOmZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLnRvb2x0aXBfc3BsaXQ9PT0hMT8odGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwLFwiaW5cIiksdGhpcy50b29sdGlwX21pbi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMudG9vbHRpcF9tYXguc3R5bGUuZGlzcGxheT1cIm5vbmVcIik6KHRoaXMuX2FkZENsYXNzKHRoaXMudG9vbHRpcF9taW4sXCJpblwiKSx0aGlzLl9hZGRDbGFzcyh0aGlzLnRvb2x0aXBfbWF4LFwiaW5cIiksdGhpcy50b29sdGlwLnN0eWxlLmRpc3BsYXk9XCJub25lXCIpLHRoaXMuX3N0YXRlLm92ZXI9ITB9LF9oaWRlVG9vbHRpcDpmdW5jdGlvbigpe3RoaXMuX3N0YXRlLmluRHJhZz09PSExJiZ0aGlzLmFsd2F5c1Nob3dUb29sdGlwIT09ITAmJih0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXAsXCJpblwiKSx0aGlzLl9yZW1vdmVDbGFzcyh0aGlzLnRvb2x0aXBfbWluLFwiaW5cIiksdGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy50b29sdGlwX21heCxcImluXCIpKSx0aGlzLl9zdGF0ZS5vdmVyPSExfSxfbGF5b3V0OmZ1bmN0aW9uKCl7dmFyIGE7aWYoYT10aGlzLm9wdGlvbnMucmV2ZXJzZWQ/WzEwMC10aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLHRoaXMub3B0aW9ucy5yYW5nZT8xMDAtdGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXTp0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdXTpbdGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSx0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdXSx0aGlzLmhhbmRsZTEuc3R5bGVbdGhpcy5zdHlsZVBvc109YVswXStcIiVcIix0aGlzLmhhbmRsZTIuc3R5bGVbdGhpcy5zdHlsZVBvc109YVsxXStcIiVcIixBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy50aWNrcykmJnRoaXMub3B0aW9ucy50aWNrcy5sZW5ndGg+MCl7dmFyIGI9TWF0aC5tYXguYXBwbHkoTWF0aCx0aGlzLm9wdGlvbnMudGlja3MpLGM9TWF0aC5taW4uYXBwbHkoTWF0aCx0aGlzLm9wdGlvbnMudGlja3MpLGQ9XCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uP1wiaGVpZ2h0XCI6XCJ3aWR0aFwiLGU9XCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uP1wibWFyZ2luVG9wXCI6XCJtYXJnaW5MZWZ0XCIsZj10aGlzLl9zdGF0ZS5zaXplLyh0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoLTEpO2lmKHRoaXMudGlja0xhYmVsQ29udGFpbmVyKXt2YXIgZz0wO2lmKDA9PT10aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zLmxlbmd0aCl0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5zdHlsZVtlXT0tZi8yK1wicHhcIixnPXRoaXMudGlja0xhYmVsQ29udGFpbmVyLm9mZnNldEhlaWdodDtlbHNlIGZvcihoPTA7aDx0aGlzLnRpY2tMYWJlbENvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aDtoKyspdGhpcy50aWNrTGFiZWxDb250YWluZXIuY2hpbGROb2Rlc1toXS5vZmZzZXRIZWlnaHQ+ZyYmKGc9dGhpcy50aWNrTGFiZWxDb250YWluZXIuY2hpbGROb2Rlc1toXS5vZmZzZXRIZWlnaHQpO1wiaG9yaXpvbnRhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uJiYodGhpcy5zbGlkZXJFbGVtLnN0eWxlLm1hcmdpbkJvdHRvbT1nK1wicHhcIil9Zm9yKHZhciBoPTA7aDx0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoO2grKyl7dmFyIGk9dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1toXXx8MTAwKih0aGlzLm9wdGlvbnMudGlja3NbaF0tYykvKGItYyk7dGhpcy50aWNrc1toXS5zdHlsZVt0aGlzLnN0eWxlUG9zXT1pK1wiJVwiLHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudGlja3NbaF0sXCJpbi1zZWxlY3Rpb25cIiksdGhpcy5vcHRpb25zLnJhbmdlP2k+PWFbMF0mJmk8PWFbMV0mJnRoaXMuX2FkZENsYXNzKHRoaXMudGlja3NbaF0sXCJpbi1zZWxlY3Rpb25cIik6XCJhZnRlclwiPT09dGhpcy5vcHRpb25zLnNlbGVjdGlvbiYmaT49YVswXT90aGlzLl9hZGRDbGFzcyh0aGlzLnRpY2tzW2hdLFwiaW4tc2VsZWN0aW9uXCIpOlwiYmVmb3JlXCI9PT10aGlzLm9wdGlvbnMuc2VsZWN0aW9uJiZpPD1hWzBdJiZ0aGlzLl9hZGRDbGFzcyh0aGlzLnRpY2tzW2hdLFwiaW4tc2VsZWN0aW9uXCIpLHRoaXMudGlja0xhYmVsc1toXSYmKHRoaXMudGlja0xhYmVsc1toXS5zdHlsZVtkXT1mK1wicHhcIix2b2lkIDAhPT10aGlzLm9wdGlvbnMudGlja3NfcG9zaXRpb25zW2hdJiYodGhpcy50aWNrTGFiZWxzW2hdLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLnRpY2tMYWJlbHNbaF0uc3R5bGVbdGhpcy5zdHlsZVBvc109dGhpcy5vcHRpb25zLnRpY2tzX3Bvc2l0aW9uc1toXStcIiVcIix0aGlzLnRpY2tMYWJlbHNbaF0uc3R5bGVbZV09LWYvMitcInB4XCIpKX19dmFyIGo7aWYodGhpcy5vcHRpb25zLnJhbmdlKXtqPXRoaXMub3B0aW9ucy5mb3JtYXR0ZXIodGhpcy5fc3RhdGUudmFsdWUpLHRoaXMuX3NldFRleHQodGhpcy50b29sdGlwSW5uZXIsaiksdGhpcy50b29sdGlwLnN0eWxlW3RoaXMuc3R5bGVQb3NdPShhWzFdK2FbMF0pLzIrXCIlXCIsXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uP3RoaXMuX2Nzcyh0aGlzLnRvb2x0aXAsXCJtYXJnaW4tdG9wXCIsLXRoaXMudG9vbHRpcC5vZmZzZXRIZWlnaHQvMitcInB4XCIpOnRoaXMuX2Nzcyh0aGlzLnRvb2x0aXAsXCJtYXJnaW4tbGVmdFwiLC10aGlzLnRvb2x0aXAub2Zmc2V0V2lkdGgvMitcInB4XCIpLFwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5vcmllbnRhdGlvbj90aGlzLl9jc3ModGhpcy50b29sdGlwLFwibWFyZ2luLXRvcFwiLC10aGlzLnRvb2x0aXAub2Zmc2V0SGVpZ2h0LzIrXCJweFwiKTp0aGlzLl9jc3ModGhpcy50b29sdGlwLFwibWFyZ2luLWxlZnRcIiwtdGhpcy50b29sdGlwLm9mZnNldFdpZHRoLzIrXCJweFwiKTt2YXIgaz10aGlzLm9wdGlvbnMuZm9ybWF0dGVyKHRoaXMuX3N0YXRlLnZhbHVlWzBdKTt0aGlzLl9zZXRUZXh0KHRoaXMudG9vbHRpcElubmVyX21pbixrKTt2YXIgbD10aGlzLm9wdGlvbnMuZm9ybWF0dGVyKHRoaXMuX3N0YXRlLnZhbHVlWzFdKTt0aGlzLl9zZXRUZXh0KHRoaXMudG9vbHRpcElubmVyX21heCxsKSx0aGlzLnRvb2x0aXBfbWluLnN0eWxlW3RoaXMuc3R5bGVQb3NdPWFbMF0rXCIlXCIsXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uP3RoaXMuX2Nzcyh0aGlzLnRvb2x0aXBfbWluLFwibWFyZ2luLXRvcFwiLC10aGlzLnRvb2x0aXBfbWluLm9mZnNldEhlaWdodC8yK1wicHhcIik6dGhpcy5fY3NzKHRoaXMudG9vbHRpcF9taW4sXCJtYXJnaW4tbGVmdFwiLC10aGlzLnRvb2x0aXBfbWluLm9mZnNldFdpZHRoLzIrXCJweFwiKSx0aGlzLnRvb2x0aXBfbWF4LnN0eWxlW3RoaXMuc3R5bGVQb3NdPWFbMV0rXCIlXCIsXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uP3RoaXMuX2Nzcyh0aGlzLnRvb2x0aXBfbWF4LFwibWFyZ2luLXRvcFwiLC10aGlzLnRvb2x0aXBfbWF4Lm9mZnNldEhlaWdodC8yK1wicHhcIik6dGhpcy5fY3NzKHRoaXMudG9vbHRpcF9tYXgsXCJtYXJnaW4tbGVmdFwiLC10aGlzLnRvb2x0aXBfbWF4Lm9mZnNldFdpZHRoLzIrXCJweFwiKX1lbHNlIGo9dGhpcy5vcHRpb25zLmZvcm1hdHRlcih0aGlzLl9zdGF0ZS52YWx1ZVswXSksdGhpcy5fc2V0VGV4dCh0aGlzLnRvb2x0aXBJbm5lcixqKSx0aGlzLnRvb2x0aXAuc3R5bGVbdGhpcy5zdHlsZVBvc109YVswXStcIiVcIixcInZlcnRpY2FsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24/dGhpcy5fY3NzKHRoaXMudG9vbHRpcCxcIm1hcmdpbi10b3BcIiwtdGhpcy50b29sdGlwLm9mZnNldEhlaWdodC8yK1wicHhcIik6dGhpcy5fY3NzKHRoaXMudG9vbHRpcCxcIm1hcmdpbi1sZWZ0XCIsLXRoaXMudG9vbHRpcC5vZmZzZXRXaWR0aC8yK1wicHhcIik7aWYoXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uKXRoaXMudHJhY2tMb3cuc3R5bGUudG9wPVwiMFwiLHRoaXMudHJhY2tMb3cuc3R5bGUuaGVpZ2h0PU1hdGgubWluKGFbMF0sYVsxXSkrXCIlXCIsdGhpcy50cmFja1NlbGVjdGlvbi5zdHlsZS50b3A9TWF0aC5taW4oYVswXSxhWzFdKStcIiVcIix0aGlzLnRyYWNrU2VsZWN0aW9uLnN0eWxlLmhlaWdodD1NYXRoLmFicyhhWzBdLWFbMV0pK1wiJVwiLHRoaXMudHJhY2tIaWdoLnN0eWxlLmJvdHRvbT1cIjBcIix0aGlzLnRyYWNrSGlnaC5zdHlsZS5oZWlnaHQ9MTAwLU1hdGgubWluKGFbMF0sYVsxXSktTWF0aC5hYnMoYVswXS1hWzFdKStcIiVcIjtlbHNle3RoaXMudHJhY2tMb3cuc3R5bGUubGVmdD1cIjBcIix0aGlzLnRyYWNrTG93LnN0eWxlLndpZHRoPU1hdGgubWluKGFbMF0sYVsxXSkrXCIlXCIsdGhpcy50cmFja1NlbGVjdGlvbi5zdHlsZS5sZWZ0PU1hdGgubWluKGFbMF0sYVsxXSkrXCIlXCIsdGhpcy50cmFja1NlbGVjdGlvbi5zdHlsZS53aWR0aD1NYXRoLmFicyhhWzBdLWFbMV0pK1wiJVwiLHRoaXMudHJhY2tIaWdoLnN0eWxlLnJpZ2h0PVwiMFwiLHRoaXMudHJhY2tIaWdoLnN0eWxlLndpZHRoPTEwMC1NYXRoLm1pbihhWzBdLGFbMV0pLU1hdGguYWJzKGFbMF0tYVsxXSkrXCIlXCI7dmFyIG09dGhpcy50b29sdGlwX21pbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuPXRoaXMudG9vbHRpcF9tYXguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bS5yaWdodD5uLmxlZnQ/KHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJ0b3BcIiksdGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21heCxcImJvdHRvbVwiKSx0aGlzLnRvb2x0aXBfbWF4LnN0eWxlLnRvcD1cIjE4cHhcIik6KHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMudG9vbHRpcF9tYXgsXCJib3R0b21cIiksdGhpcy5fYWRkQ2xhc3ModGhpcy50b29sdGlwX21heCxcInRvcFwiKSx0aGlzLnRvb2x0aXBfbWF4LnN0eWxlLnRvcD10aGlzLnRvb2x0aXBfbWluLnN0eWxlLnRvcCl9fSxfcmVtb3ZlUHJvcGVydHk6ZnVuY3Rpb24oYSxiKXthLnN0eWxlLnJlbW92ZVByb3BlcnR5P2Euc3R5bGUucmVtb3ZlUHJvcGVydHkoYik6YS5zdHlsZS5yZW1vdmVBdHRyaWJ1dGUoYil9LF9tb3VzZWRvd246ZnVuY3Rpb24oYSl7aWYoIXRoaXMuX3N0YXRlLmVuYWJsZWQpcmV0dXJuITE7dGhpcy5fc3RhdGUub2Zmc2V0PXRoaXMuX29mZnNldCh0aGlzLnNsaWRlckVsZW0pLHRoaXMuX3N0YXRlLnNpemU9dGhpcy5zbGlkZXJFbGVtW3RoaXMuc2l6ZVBvc107dmFyIGI9dGhpcy5fZ2V0UGVyY2VudGFnZShhKTtpZih0aGlzLm9wdGlvbnMucmFuZ2Upe3ZhciBjPU1hdGguYWJzKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0tYiksZD1NYXRoLmFicyh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdLWIpO3RoaXMuX3N0YXRlLmRyYWdnZWQ9ZD5jPzA6MX1lbHNlIHRoaXMuX3N0YXRlLmRyYWdnZWQ9MDt0aGlzLl9zdGF0ZS5wZXJjZW50YWdlW3RoaXMuX3N0YXRlLmRyYWdnZWRdPWIsdGhpcy5fbGF5b3V0KCksdGhpcy50b3VjaENhcGFibGUmJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5tb3VzZW1vdmUsITEpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMubW91c2V1cCwhMSkpLHRoaXMubW91c2Vtb3ZlJiZkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsdGhpcy5tb3VzZW1vdmUsITEpLHRoaXMubW91c2V1cCYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLm1vdXNldXAsITEpLHRoaXMubW91c2Vtb3ZlPXRoaXMuX21vdXNlbW92ZS5iaW5kKHRoaXMpLHRoaXMubW91c2V1cD10aGlzLl9tb3VzZXVwLmJpbmQodGhpcyksdGhpcy50b3VjaENhcGFibGUmJihkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5tb3VzZW1vdmUsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMubW91c2V1cCwhMSkpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLm1vdXNldXAsITEpLHRoaXMuX3N0YXRlLmluRHJhZz0hMDt2YXIgZT10aGlzLl9jYWxjdWxhdGVWYWx1ZSgpO3JldHVybiB0aGlzLl90cmlnZ2VyKFwic2xpZGVTdGFydFwiLGUpLHRoaXMuX3NldERhdGFWYWwoZSksdGhpcy5zZXRWYWx1ZShlLCExLCEwKSx0aGlzLl9wYXVzZUV2ZW50KGEpLHRoaXMub3B0aW9ucy5mb2N1cyYmdGhpcy5fdHJpZ2dlckZvY3VzT25IYW5kbGUodGhpcy5fc3RhdGUuZHJhZ2dlZCksITB9LF90cmlnZ2VyRm9jdXNPbkhhbmRsZTpmdW5jdGlvbihhKXswPT09YSYmdGhpcy5oYW5kbGUxLmZvY3VzKCksMT09PWEmJnRoaXMuaGFuZGxlMi5mb2N1cygpfSxfa2V5ZG93bjpmdW5jdGlvbihhLGIpe2lmKCF0aGlzLl9zdGF0ZS5lbmFibGVkKXJldHVybiExO3ZhciBjO3N3aXRjaChiLmtleUNvZGUpe2Nhc2UgMzc6Y2FzZSA0MDpjPS0xO2JyZWFrO2Nhc2UgMzk6Y2FzZSAzODpjPTF9aWYoYyl7aWYodGhpcy5vcHRpb25zLm5hdHVyYWxfYXJyb3dfa2V5cyl7dmFyIGQ9XCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uJiYhdGhpcy5vcHRpb25zLnJldmVyc2VkLGU9XCJob3Jpem9udGFsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb24mJnRoaXMub3B0aW9ucy5yZXZlcnNlZDsoZHx8ZSkmJihjPS1jKX12YXIgZj10aGlzLl9zdGF0ZS52YWx1ZVthXStjKnRoaXMub3B0aW9ucy5zdGVwO3JldHVybiB0aGlzLm9wdGlvbnMucmFuZ2UmJihmPVthP3RoaXMuX3N0YXRlLnZhbHVlWzBdOmYsYT9mOnRoaXMuX3N0YXRlLnZhbHVlWzFdXSksdGhpcy5fdHJpZ2dlcihcInNsaWRlU3RhcnRcIixmKSx0aGlzLl9zZXREYXRhVmFsKGYpLHRoaXMuc2V0VmFsdWUoZiwhMCwhMCksdGhpcy5fc2V0RGF0YVZhbChmKSx0aGlzLl90cmlnZ2VyKFwic2xpZGVTdG9wXCIsZiksdGhpcy5fbGF5b3V0KCksdGhpcy5fcGF1c2VFdmVudChiKSwhMX19LF9wYXVzZUV2ZW50OmZ1bmN0aW9uKGEpe2Euc3RvcFByb3BhZ2F0aW9uJiZhLnN0b3BQcm9wYWdhdGlvbigpLGEucHJldmVudERlZmF1bHQmJmEucHJldmVudERlZmF1bHQoKSxhLmNhbmNlbEJ1YmJsZT0hMCxhLnJldHVyblZhbHVlPSExfSxfbW91c2Vtb3ZlOmZ1bmN0aW9uKGEpe2lmKCF0aGlzLl9zdGF0ZS5lbmFibGVkKXJldHVybiExO3ZhciBiPXRoaXMuX2dldFBlcmNlbnRhZ2UoYSk7dGhpcy5fYWRqdXN0UGVyY2VudGFnZUZvclJhbmdlU2xpZGVycyhiKSx0aGlzLl9zdGF0ZS5wZXJjZW50YWdlW3RoaXMuX3N0YXRlLmRyYWdnZWRdPWIsdGhpcy5fbGF5b3V0KCk7dmFyIGM9dGhpcy5fY2FsY3VsYXRlVmFsdWUoITApO3JldHVybiB0aGlzLnNldFZhbHVlKGMsITAsITApLCExfSxfYWRqdXN0UGVyY2VudGFnZUZvclJhbmdlU2xpZGVyczpmdW5jdGlvbihhKXtpZih0aGlzLm9wdGlvbnMucmFuZ2Upe3ZhciBiPXRoaXMuX2dldE51bURpZ2l0c0FmdGVyRGVjaW1hbFBsYWNlKGEpO2I9Yj9iLTE6MDt2YXIgYz10aGlzLl9hcHBseVRvRml4ZWRBbmRQYXJzZUZsb2F0KGEsYik7MD09PXRoaXMuX3N0YXRlLmRyYWdnZWQmJnRoaXMuX2FwcGx5VG9GaXhlZEFuZFBhcnNlRmxvYXQodGhpcy5fc3RhdGUucGVyY2VudGFnZVsxXSxiKTxjPyh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdPXRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV0sdGhpcy5fc3RhdGUuZHJhZ2dlZD0xKToxPT09dGhpcy5fc3RhdGUuZHJhZ2dlZCYmdGhpcy5fYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdCh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdLGIpPmMmJih0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdPXRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0sdGhpcy5fc3RhdGUuZHJhZ2dlZD0wKX19LF9tb3VzZXVwOmZ1bmN0aW9uKCl7aWYoIXRoaXMuX3N0YXRlLmVuYWJsZWQpcmV0dXJuITE7dGhpcy50b3VjaENhcGFibGUmJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5tb3VzZW1vdmUsITEpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHRoaXMubW91c2V1cCwhMSkpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0aGlzLm1vdXNldXAsITEpLHRoaXMuX3N0YXRlLmluRHJhZz0hMSx0aGlzLl9zdGF0ZS5vdmVyPT09ITEmJnRoaXMuX2hpZGVUb29sdGlwKCk7dmFyIGE9dGhpcy5fY2FsY3VsYXRlVmFsdWUoITApO3JldHVybiB0aGlzLl9sYXlvdXQoKSx0aGlzLl9zZXREYXRhVmFsKGEpLHRoaXMuX3RyaWdnZXIoXCJzbGlkZVN0b3BcIixhKSwhMX0sX2NhbGN1bGF0ZVZhbHVlOmZ1bmN0aW9uKGEpe3ZhciBiO2lmKHRoaXMub3B0aW9ucy5yYW5nZT8oYj1bdGhpcy5vcHRpb25zLm1pbix0aGlzLm9wdGlvbnMubWF4XSwwIT09dGhpcy5fc3RhdGUucGVyY2VudGFnZVswXSYmKGJbMF09dGhpcy5fdG9WYWx1ZSh0aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzBdKSxiWzBdPXRoaXMuX2FwcGx5UHJlY2lzaW9uKGJbMF0pKSwxMDAhPT10aGlzLl9zdGF0ZS5wZXJjZW50YWdlWzFdJiYoYlsxXT10aGlzLl90b1ZhbHVlKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMV0pLGJbMV09dGhpcy5fYXBwbHlQcmVjaXNpb24oYlsxXSkpKTooYj10aGlzLl90b1ZhbHVlKHRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMF0pLGI9cGFyc2VGbG9hdChiKSxiPXRoaXMuX2FwcGx5UHJlY2lzaW9uKGIpKSxhKXtmb3IodmFyIGM9W2IsMS8wXSxkPTA7ZDx0aGlzLm9wdGlvbnMudGlja3MubGVuZ3RoO2QrKyl7dmFyIGU9TWF0aC5hYnModGhpcy5vcHRpb25zLnRpY2tzW2RdLWIpO2U8PWNbMV0mJihjPVt0aGlzLm9wdGlvbnMudGlja3NbZF0sZV0pfWlmKGNbMV08PXRoaXMub3B0aW9ucy50aWNrc19zbmFwX2JvdW5kcylyZXR1cm4gY1swXX1yZXR1cm4gYn0sX2FwcGx5UHJlY2lzaW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucy5wcmVjaXNpb258fHRoaXMuX2dldE51bURpZ2l0c0FmdGVyRGVjaW1hbFBsYWNlKHRoaXMub3B0aW9ucy5zdGVwKTtyZXR1cm4gdGhpcy5fYXBwbHlUb0ZpeGVkQW5kUGFyc2VGbG9hdChhLGIpfSxfZ2V0TnVtRGlnaXRzQWZ0ZXJEZWNpbWFsUGxhY2U6ZnVuY3Rpb24oYSl7dmFyIGI9KFwiXCIrYSkubWF0Y2goLyg/OlxcLihcXGQrKSk/KD86W2VFXShbKy1dP1xcZCspKT8kLyk7cmV0dXJuIGI/TWF0aC5tYXgoMCwoYlsxXT9iWzFdLmxlbmd0aDowKS0oYlsyXT8rYlsyXTowKSk6MH0sX2FwcGx5VG9GaXhlZEFuZFBhcnNlRmxvYXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnRvRml4ZWQoYik7cmV0dXJuIHBhcnNlRmxvYXQoYyl9LF9nZXRQZXJjZW50YWdlOmZ1bmN0aW9uKGEpeyF0aGlzLnRvdWNoQ2FwYWJsZXx8XCJ0b3VjaHN0YXJ0XCIhPT1hLnR5cGUmJlwidG91Y2htb3ZlXCIhPT1hLnR5cGV8fChhPWEudG91Y2hlc1swXSk7dmFyIGI9YVt0aGlzLm1vdXNlUG9zXSxjPXRoaXMuX3N0YXRlLm9mZnNldFt0aGlzLnN0eWxlUG9zXSxkPWItYyxlPWQvdGhpcy5fc3RhdGUuc2l6ZSoxMDA7cmV0dXJuIGU9TWF0aC5yb3VuZChlL3RoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMl0pKnRoaXMuX3N0YXRlLnBlcmNlbnRhZ2VbMl0sdGhpcy5vcHRpb25zLnJldmVyc2VkJiYoZT0xMDAtZSksTWF0aC5tYXgoMCxNYXRoLm1pbigxMDAsZSkpfSxfdmFsaWRhdGVJbnB1dFZhbHVlOmZ1bmN0aW9uKGEpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXJldHVybiBhO2lmKEFycmF5LmlzQXJyYXkoYSkpcmV0dXJuIHRoaXMuX3ZhbGlkYXRlQXJyYXkoYSksYTt0aHJvdyBuZXcgRXJyb3IoZC5mb3JtYXRJbnZhbGlkSW5wdXRFcnJvck1zZyhhKSl9LF92YWxpZGF0ZUFycmF5OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBjKXRocm93IG5ldyBFcnJvcihkLmZvcm1hdEludmFsaWRJbnB1dEVycm9yTXNnKGMpKX19LF9zZXREYXRhVmFsOmZ1bmN0aW9uKGEpe3RoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsYSksdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYSksdGhpcy5lbGVtZW50LnZhbHVlPWF9LF90cmlnZ2VyOmZ1bmN0aW9uKGIsYyl7Yz1jfHwwPT09Yz9jOnZvaWQgMDt2YXIgZD10aGlzLmV2ZW50VG9DYWxsYmFja01hcFtiXTtpZihkJiZkLmxlbmd0aClmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9ZFtlXTtmKGMpfWEmJnRoaXMuX3RyaWdnZXJKUXVlcnlFdmVudChiLGMpfSxfdHJpZ2dlckpRdWVyeUV2ZW50OmZ1bmN0aW9uKGEsYil7dmFyIGM9e3R5cGU6YSx2YWx1ZTpifTt0aGlzLiRlbGVtZW50LnRyaWdnZXIoYyksdGhpcy4kc2xpZGVyRWxlbS50cmlnZ2VyKGMpfSxfdW5iaW5kSlF1ZXJ5RXZlbnRIYW5kbGVyczpmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQub2ZmKCksdGhpcy4kc2xpZGVyRWxlbS5vZmYoKX0sX3NldFRleHQ6ZnVuY3Rpb24oYSxiKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5pbm5lclRleHQ/YS5pbm5lclRleHQ9YjpcInVuZGVmaW5lZFwiIT10eXBlb2YgYS50ZXh0Q29udGVudCYmKGEudGV4dENvbnRlbnQ9Yil9LF9yZW1vdmVDbGFzczpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1iLnNwbGl0KFwiIFwiKSxkPWEuY2xhc3NOYW1lLGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9Y1tlXSxnPW5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiK2YrXCIoPzpcXFxcc3wkKVwiKTtkPWQucmVwbGFjZShnLFwiIFwiKX1hLmNsYXNzTmFtZT1kLnRyaW0oKX0sX2FkZENsYXNzOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWIuc3BsaXQoXCIgXCIpLGQ9YS5jbGFzc05hbWUsZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgZj1jW2VdLGc9bmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIrZitcIig/OlxcXFxzfCQpXCIpLGg9Zy50ZXN0KGQpO2h8fChkKz1cIiBcIitmKX1hLmNsYXNzTmFtZT1kLnRyaW0oKX0sX29mZnNldExlZnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdH0sX29mZnNldFRvcDpmdW5jdGlvbihhKXtmb3IodmFyIGI9YS5vZmZzZXRUb3A7KGE9YS5vZmZzZXRQYXJlbnQpJiYhaXNOYU4oYS5vZmZzZXRUb3ApOyliKz1hLm9mZnNldFRvcDtyZXR1cm4gYn0sX29mZnNldDpmdW5jdGlvbihhKXtyZXR1cm57bGVmdDp0aGlzLl9vZmZzZXRMZWZ0KGEpLHRvcDp0aGlzLl9vZmZzZXRUb3AoYSl9fSxfY3NzOmZ1bmN0aW9uKGIsYyxkKXtpZihhKWEuc3R5bGUoYixjLGQpO2Vsc2V7dmFyIGU9Yy5yZXBsYWNlKC9eLW1zLS8sXCJtcy1cIikucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50b1VwcGVyQ2FzZSgpfSk7Yi5zdHlsZVtlXT1kfX0sX3RvVmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMub3B0aW9ucy5zY2FsZS50b1ZhbHVlLmFwcGx5KHRoaXMsW2FdKX0sX3RvUGVyY2VudGFnZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5vcHRpb25zLnNjYWxlLnRvUGVyY2VudGFnZS5hcHBseSh0aGlzLFthXSl9LF9zZXRUb29sdGlwUG9zaXRpb246ZnVuY3Rpb24oKXt2YXIgYT1bdGhpcy50b29sdGlwLHRoaXMudG9vbHRpcF9taW4sdGhpcy50b29sdGlwX21heF07aWYoXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLm9yaWVudGF0aW9uKXt2YXIgYj10aGlzLm9wdGlvbnMudG9vbHRpcF9wb3NpdGlvbnx8XCJyaWdodFwiLGM9XCJsZWZ0XCI9PT1iP1wicmlnaHRcIjpcImxlZnRcIjthLmZvckVhY2goZnVuY3Rpb24oYSl7dGhpcy5fYWRkQ2xhc3MoYSxiKSxhLnN0eWxlW2NdPVwiMTAwJVwifS5iaW5kKHRoaXMpKX1lbHNlIGEuZm9yRWFjaChcImJvdHRvbVwiPT09dGhpcy5vcHRpb25zLnRvb2x0aXBfcG9zaXRpb24/ZnVuY3Rpb24oYSl7dGhpcy5fYWRkQ2xhc3MoYSxcImJvdHRvbVwiKSxhLnN0eWxlLnRvcD1cIjIycHhcIn0uYmluZCh0aGlzKTpmdW5jdGlvbihhKXt0aGlzLl9hZGRDbGFzcyhhLFwidG9wXCIpLGEuc3R5bGUudG9wPS10aGlzLnRvb2x0aXAub3V0ZXJIZWlnaHQtMTQrXCJweFwifS5iaW5kKHRoaXMpKX19LGEpe3ZhciBmPWEuZm4uc2xpZGVyP1wiYm9vdHN0cmFwU2xpZGVyXCI6XCJzbGlkZXJcIjthLmJyaWRnZXQoZixiKX19KGEpLGJ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2FuZ3VsYXItYm9vdHN0cmFwLXNsaWRlci9ib290c3RyYXAtc2xpZGVyLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIiRcIl07IH0oKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIiRcIlxuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSB1bmxlc3MgYW1kTW9kdWxlSWQgaXMgc2V0XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHJvb3RbJ1NpZ25hdHVyZVBhZCddID0gZmFjdG9yeSgpKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAvLyBsaWtlIE5vZGUuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdFsnU2lnbmF0dXJlUGFkJ10gPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vKiFcbiAqIFNpZ25hdHVyZSBQYWQgdjEuNS4zXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL3NpZ25hdHVyZV9wYWRcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNiBTenltb24gTm93YWtcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICpcbiAqIFRoZSBtYWluIGlkZWEgYW5kIHNvbWUgcGFydHMgb2YgdGhlIGNvZGUgKGUuZy4gZHJhd2luZyB2YXJpYWJsZSB3aWR0aCBCw6l6aWVyIGN1cnZlKSBhcmUgdGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly9jb3JuZXIuc3F1YXJldXAuY29tLzIwMTIvMDcvc21vb3RoZXItc2lnbmF0dXJlcy5odG1sXG4gKlxuICogSW1wbGVtZW50YXRpb24gb2YgaW50ZXJwb2xhdGlvbiB1c2luZyBjdWJpYyBCw6l6aWVyIGN1cnZlcyBpcyB0YWtlbiBmcm9tOlxuICogaHR0cDovL2Jlbmtub3dzY29kZS53b3JkcHJlc3MuY29tLzIwMTIvMDkvMTQvcGF0aC1pbnRlcnBvbGF0aW9uLXVzaW5nLWN1YmljLWJlemllci1hbmQtY29udHJvbC1wb2ludC1lc3RpbWF0aW9uLWluLWphdmFzY3JpcHRcbiAqXG4gKiBBbGdvcml0aG0gZm9yIGFwcHJveGltYXRlZCBsZW5ndGggb2YgYSBCw6l6aWVyIGN1cnZlIGlzIHRha2VuIGZyb206XG4gKiBodHRwOi8vd3d3LmxlbW9kYS5uZXQvbWF0aHMvYmV6aWVyLWxlbmd0aC9pbmRleC5odG1sXG4gKlxuICovXG52YXIgU2lnbmF0dXJlUGFkID0gKGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIFNpZ25hdHVyZVBhZCA9IGZ1bmN0aW9uIChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCA9IG9wdHMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgfHwgMC43O1xuICAgICAgICB0aGlzLm1pbldpZHRoID0gb3B0cy5taW5XaWR0aCB8fCAwLjU7XG4gICAgICAgIHRoaXMubWF4V2lkdGggPSBvcHRzLm1heFdpZHRoIHx8IDIuNTtcbiAgICAgICAgdGhpcy5kb3RTaXplID0gb3B0cy5kb3RTaXplIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5taW5XaWR0aCArIHRoaXMubWF4V2lkdGgpIC8gMjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wZW5Db2xvciA9IG9wdHMucGVuQ29sb3IgfHwgXCJibGFja1wiO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yIHx8IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICB0aGlzLm9uRW5kID0gb3B0cy5vbkVuZDtcbiAgICAgICAgdGhpcy5vbkJlZ2luID0gb3B0cy5vbkJlZ2luO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgYWRkIHRoZXNlIGlubGluZSBzbyB0aGV5IGFyZSBhdmFpbGFibGUgdG8gdW5iaW5kIHdoaWxlIHN0aWxsIGhhdmluZ1xuICAgICAgICAvLyAgYWNjZXNzIHRvICdzZWxmJyB3ZSBjb3VsZCB1c2UgXy5iaW5kIGJ1dCBpdCdzIG5vdCB3b3J0aCBhZGRpbmcgYSBkZXBlbmRlbmN5XG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fbW91c2VCdXR0b25Eb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLl9zdHJva2VCZWdpbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbW91c2VCdXR0b25Eb3duKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fc3Ryb2tlVXBkYXRlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEgJiYgc2VsZi5fbW91c2VCdXR0b25Eb3duKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fbW91c2VCdXR0b25Eb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5fc3Ryb2tlRW5kKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIHNlbGYuX3N0cm9rZUJlZ2luKHRvdWNoKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZy5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG4gICAgICAgICAgICBzZWxmLl9zdHJva2VVcGRhdGUodG91Y2gpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgd2FzQ2FudmFzVG91Y2hlZCA9IGV2ZW50LnRhcmdldCA9PT0gc2VsZi5fY2FudmFzO1xuICAgICAgICAgICAgaWYgKHdhc0NhbnZhc1RvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VFdmVudHMoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hFdmVudHMoKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCxcbiAgICAgICAgICAgIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUudG9EYXRhVVJMID0gZnVuY3Rpb24gKGltYWdlVHlwZSwgcXVhbGl0eSkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTC5hcHBseShjYW52YXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuZnJvbURhdGFVUkwgPSBmdW5jdGlvbiAoZGF0YVVybCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpLFxuICAgICAgICAgICAgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGggLyByYXRpbyxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgLyByYXRpbztcblxuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICBpbWFnZS5zcmMgPSBkYXRhVXJsO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLl9jdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VVcGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5fY3JlYXRlUG9pbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZUJlZ2luID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgIHRoaXMuX3N0cm9rZVVwZGF0ZShldmVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkJlZ2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uQmVnaW4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZURyYXcgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eCxcbiAgICAgICAgICAgIGRvdFNpemUgPSB0eXBlb2YodGhpcy5kb3RTaXplKSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuZG90U2l6ZSgpIDogdGhpcy5kb3RTaXplO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fZHJhd1BvaW50KHBvaW50LngsIHBvaW50LnksIGRvdFNpemUpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZUVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgY2FuRHJhd0N1cnZlID0gdGhpcy5wb2ludHMubGVuZ3RoID4gMixcbiAgICAgICAgICAgIHBvaW50ID0gdGhpcy5wb2ludHNbMF07XG5cbiAgICAgICAgaWYgKCFjYW5EcmF3Q3VydmUgJiYgcG9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZURyYXcocG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbkVuZChldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5faGFuZGxlTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vdXNlQnV0dG9uRG93biA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9oYW5kbGVUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFzcyB0b3VjaCBldmVudHMgdG8gY2FudmFzIGVsZW1lbnQgb24gbW9iaWxlIElFMTEgYW5kIEVkZ2UuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2hhbmRsZVRvdWNoRW5kKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VFdmVudHMoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlVG91Y2hFdmVudHMoKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRW1wdHk7XG4gICAgfTtcblxuICAgIFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0VmVsb2NpdHkgPSAwO1xuICAgICAgICB0aGlzLl9sYXN0V2lkdGggPSAodGhpcy5taW5XaWR0aCArIHRoaXMubWF4V2lkdGgpIC8gMjtcbiAgICAgICAgdGhpcy5faXNFbXB0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLnBlbkNvbG9yO1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9jcmVhdGVQb2ludCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgICAgYzIsIGMzLFxuICAgICAgICAgICAgY3VydmUsIHRtcDtcblxuICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG5cbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAvLyBUbyByZWR1Y2UgdGhlIGluaXRpYWwgbGFnIG1ha2UgaXQgd29yayB3aXRoIDMgcG9pbnRzXG4gICAgICAgICAgICAvLyBieSBjb3B5aW5nIHRoZSBmaXJzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDMpIHBvaW50cy51bnNoaWZ0KHBvaW50c1swXSk7XG5cbiAgICAgICAgICAgIHRtcCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdKTtcbiAgICAgICAgICAgIGMyID0gdG1wLmMyO1xuICAgICAgICAgICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgYzMgPSB0bXAuYzE7XG4gICAgICAgICAgICBjdXJ2ZSA9IG5ldyBCZXppZXIocG9pbnRzWzFdLCBjMiwgYzMsIHBvaW50c1syXSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRDdXJ2ZShjdXJ2ZSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBsaXN0LFxuICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBhbHdheXMgaGF2ZSBubyBtb3JlIHRoYW4gNCBwb2ludHMgaW4gcG9pbnRzIGFycmF5LlxuICAgICAgICAgICAgcG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKHMxLCBzMiwgczMpIHtcbiAgICAgICAgdmFyIGR4MSA9IHMxLnggLSBzMi54LCBkeTEgPSBzMS55IC0gczIueSxcbiAgICAgICAgICAgIGR4MiA9IHMyLnggLSBzMy54LCBkeTIgPSBzMi55IC0gczMueSxcblxuICAgICAgICAgICAgbTEgPSB7eDogKHMxLnggKyBzMi54KSAvIDIuMCwgeTogKHMxLnkgKyBzMi55KSAvIDIuMH0sXG4gICAgICAgICAgICBtMiA9IHt4OiAoczIueCArIHMzLngpIC8gMi4wLCB5OiAoczIueSArIHMzLnkpIC8gMi4wfSxcblxuICAgICAgICAgICAgbDEgPSBNYXRoLnNxcnQoZHgxKmR4MSArIGR5MSpkeTEpLFxuICAgICAgICAgICAgbDIgPSBNYXRoLnNxcnQoZHgyKmR4MiArIGR5MipkeTIpLFxuXG4gICAgICAgICAgICBkeG0gPSAobTEueCAtIG0yLngpLFxuICAgICAgICAgICAgZHltID0gKG0xLnkgLSBtMi55KSxcblxuICAgICAgICAgICAgayA9IGwyIC8gKGwxICsgbDIpLFxuICAgICAgICAgICAgY20gPSB7eDogbTIueCArIGR4bSprLCB5OiBtMi55ICsgZHltKmt9LFxuXG4gICAgICAgICAgICB0eCA9IHMyLnggLSBjbS54LFxuICAgICAgICAgICAgdHkgPSBzMi55IC0gY20ueTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzE6IG5ldyBQb2ludChtMS54ICsgdHgsIG0xLnkgKyB0eSksXG4gICAgICAgICAgICBjMjogbmV3IFBvaW50KG0yLnggKyB0eCwgbTIueSArIHR5KVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBTaWduYXR1cmVQYWQucHJvdG90eXBlLl9hZGRDdXJ2ZSA9IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IGN1cnZlLnN0YXJ0UG9pbnQsXG4gICAgICAgICAgICBlbmRQb2ludCA9IGN1cnZlLmVuZFBvaW50LFxuICAgICAgICAgICAgdmVsb2NpdHksIG5ld1dpZHRoO1xuXG4gICAgICAgIHZlbG9jaXR5ID0gZW5kUG9pbnQudmVsb2NpdHlGcm9tKHN0YXJ0UG9pbnQpO1xuICAgICAgICB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQgKiB2ZWxvY2l0eVxuICAgICAgICAgICAgKyAoMSAtIHRoaXMudmVsb2NpdHlGaWx0ZXJXZWlnaHQpICogdGhpcy5fbGFzdFZlbG9jaXR5O1xuXG4gICAgICAgIG5ld1dpZHRoID0gdGhpcy5fc3Ryb2tlV2lkdGgodmVsb2NpdHkpO1xuICAgICAgICB0aGlzLl9kcmF3Q3VydmUoY3VydmUsIHRoaXMuX2xhc3RXaWR0aCwgbmV3V2lkdGgpO1xuXG4gICAgICAgIHRoaXMuX2xhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgICB0aGlzLl9sYXN0V2lkdGggPSBuZXdXaWR0aDtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZHJhd1BvaW50ID0gZnVuY3Rpb24gKHgsIHksIHNpemUpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjdHguYXJjKHgsIHksIHNpemUsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2lzRW1wdHkgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZHJhd0N1cnZlID0gZnVuY3Rpb24gKGN1cnZlLCBzdGFydFdpZHRoLCBlbmRXaWR0aCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgICAgICAgd2lkdGhEZWx0YSA9IGVuZFdpZHRoIC0gc3RhcnRXaWR0aCxcbiAgICAgICAgICAgIGRyYXdTdGVwcywgd2lkdGgsIGksIHQsIHR0LCB0dHQsIHUsIHV1LCB1dXUsIHgsIHk7XG5cbiAgICAgICAgZHJhd1N0ZXBzID0gTWF0aC5mbG9vcihjdXJ2ZS5sZW5ndGgoKSk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRyYXdTdGVwczsgaSsrKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIEJlemllciAoeCwgeSkgY29vcmRpbmF0ZSBmb3IgdGhpcyBzdGVwLlxuICAgICAgICAgICAgdCA9IGkgLyBkcmF3U3RlcHM7XG4gICAgICAgICAgICB0dCA9IHQgKiB0O1xuICAgICAgICAgICAgdHR0ID0gdHQgKiB0O1xuICAgICAgICAgICAgdSA9IDEgLSB0O1xuICAgICAgICAgICAgdXUgPSB1ICogdTtcbiAgICAgICAgICAgIHV1dSA9IHV1ICogdTtcblxuICAgICAgICAgICAgeCA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueDtcbiAgICAgICAgICAgIHggKz0gMyAqIHV1ICogdCAqIGN1cnZlLmNvbnRyb2wxLng7XG4gICAgICAgICAgICB4ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi54O1xuICAgICAgICAgICAgeCArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC54O1xuXG4gICAgICAgICAgICB5ID0gdXV1ICogY3VydmUuc3RhcnRQb2ludC55O1xuICAgICAgICAgICAgeSArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueTtcbiAgICAgICAgICAgIHkgKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLnk7XG4gICAgICAgICAgICB5ICs9IHR0dCAqIGN1cnZlLmVuZFBvaW50Lnk7XG5cbiAgICAgICAgICAgIHdpZHRoID0gc3RhcnRXaWR0aCArIHR0dCAqIHdpZHRoRGVsdGE7XG4gICAgICAgICAgICB0aGlzLl9kcmF3UG9pbnQoeCwgeSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9O1xuXG4gICAgU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlV2lkdGggPSBmdW5jdGlvbiAodmVsb2NpdHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWF4V2lkdGggLyAodmVsb2NpdHkgKyAxKSwgdGhpcy5taW5XaWR0aCk7XG4gICAgfTtcblxuXG4gICAgdmFyIFBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHRpbWUpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgUG9pbnQucHJvdG90eXBlLnZlbG9jaXR5RnJvbSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGltZSAhPT0gc3RhcnQudGltZSkgPyB0aGlzLmRpc3RhbmNlVG8oc3RhcnQpIC8gKHRoaXMudGltZSAtIHN0YXJ0LnRpbWUpIDogMTtcbiAgICB9O1xuXG4gICAgUG9pbnQucHJvdG90eXBlLmRpc3RhbmNlVG8gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHN0YXJ0LnksIDIpKTtcbiAgICB9O1xuXG4gICAgdmFyIEJlemllciA9IGZ1bmN0aW9uIChzdGFydFBvaW50LCBjb250cm9sMSwgY29udHJvbDIsIGVuZFBvaW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gICAgICAgIHRoaXMuY29udHJvbDEgPSBjb250cm9sMTtcbiAgICAgICAgdGhpcy5jb250cm9sMiA9IGNvbnRyb2wyO1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYXBwcm94aW1hdGVkIGxlbmd0aC5cbiAgICBCZXppZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gMTAsXG4gICAgICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICAgICAgaSwgdCwgY3gsIGN5LCBweCwgcHksIHhkaWZmLCB5ZGlmZjtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSBpIC8gc3RlcHM7XG4gICAgICAgICAgICBjeCA9IHRoaXMuX3BvaW50KHQsIHRoaXMuc3RhcnRQb2ludC54LCB0aGlzLmNvbnRyb2wxLngsIHRoaXMuY29udHJvbDIueCwgdGhpcy5lbmRQb2ludC54KTtcbiAgICAgICAgICAgIGN5ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeGRpZmYgPSBjeCAtIHB4O1xuICAgICAgICAgICAgICAgIHlkaWZmID0gY3kgLSBweTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHB4ID0gY3g7XG4gICAgICAgICAgICBweSA9IGN5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfTtcblxuICAgIEJlemllci5wcm90b3R5cGUuX3BvaW50ID0gZnVuY3Rpb24gKHQsIHN0YXJ0LCBjMSwgYzIsIGVuZCkge1xuICAgICAgICByZXR1cm4gICAgICAgICAgc3RhcnQgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgICogKDEuMCAtIHQpXG4gICAgICAgICAgICAgICArIDMuMCAqICBjMSAgICAqICgxLjAgLSB0KSAqICgxLjAgLSB0KSAgKiB0XG4gICAgICAgICAgICAgICArIDMuMCAqICBjMiAgICAqICgxLjAgLSB0KSAqIHQgICAgICAgICAgKiB0XG4gICAgICAgICAgICAgICArICAgICAgICBlbmQgICAqIHQgICAgICAgICAqIHQgICAgICAgICAgKiB0O1xuICAgIH07XG5cbiAgICByZXR1cm4gU2lnbmF0dXJlUGFkO1xufSkoZG9jdW1lbnQpO1xuXG5yZXR1cm4gU2lnbmF0dXJlUGFkO1xuXG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zaWduYXR1cmVfcGFkL3NpZ25hdHVyZV9wYWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgYWxpYXMgPSByZXF1aXJlKCcuL2FsaWFzL2FsaWFzJyk7XHJcbmV4cG9ydHMuYWxpYXMgPSBhbGlhcztcclxudmFyIGF1dG9zYXZlID0gcmVxdWlyZSgnLi9hdXRvc2F2ZS9hdXRvc2F2ZScpO1xyXG5leHBvcnRzLmF1dG9zYXZlID0gYXV0b3NhdmU7XHJcbnZhciBwb3BvdmVyID0gcmVxdWlyZSgnLi9wb3BvdmVyL3BvcG92ZXInKTtcclxuZXhwb3J0cy5wb3BvdmVyID0gcG9wb3ZlcjtcclxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgnLi9yZXF1aXJlZC9yZXF1aXJlZCcpO1xyXG5leHBvcnRzLnJlcXVpcmVkID0gcmVxdWlyZWQ7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5iZWhhdmlvcnMnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIGFsaWFzLm1vZHVsZU5hbWUsXHJcbiAgICBhdXRvc2F2ZS5tb2R1bGVOYW1lLFxyXG4gICAgcG9wb3Zlci5tb2R1bGVOYW1lLFxyXG4gICAgcmVxdWlyZWQubW9kdWxlTmFtZSxcclxuXSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlaGF2aW9ycy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9iZWhhdmlvcnMvYmVoYXZpb3JzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuYmVoYXZpb3JzLmFsaWFzJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQWxpYXMnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0FsaWFzQ29udHJvbGxlcic7XHJcbnZhciBBbGlhc0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWxpYXNDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuJGF0dHJzID0gJGF0dHJzO1xyXG4gICAgICAgIHRoaXMuJHBhcnNlID0gJHBhcnNlO1xyXG4gICAgICAgIHRoaXMuJGludGVycG9sYXRlID0gJGludGVycG9sYXRlO1xyXG4gICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlQWxpYXMoaW5pdGlhbFZhbHVlKTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKHRoaXMuZ2V0VmFsdWUuYmluZCh0aGlzKSwgdGhpcy5yZXNvbHZlQWxpYXMuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBBbGlhc0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHRoaXMuJGF0dHJzLnJsQWxpYXMuc3BsaXQoJyBhcyAnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy4kcGFyc2UodGhpcy5leHByZXNzaW9uWzBdKSh0aGlzLiRzY29wZSk7XHJcbiAgICB9O1xyXG4gICAgQWxpYXNDb250cm9sbGVyLnByb3RvdHlwZS5yZXNvbHZlQWxpYXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgYWxpYXMgPSB0aGlzLiRpbnRlcnBvbGF0ZSh0aGlzLmV4cHJlc3Npb25bMV0pKHRoaXMuJHNjb3BlKTtcclxuICAgICAgICBpZiAoYWxpYXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLiRzY29wZVthbGlhc10gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWxpYXNDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJyRpbnRlcnBvbGF0ZSddO1xyXG4gICAgcmV0dXJuIEFsaWFzQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5BbGlhc0NvbnRyb2xsZXIgPSBBbGlhc0NvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGFsaWFzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuYWxpYXMgPSBhbGlhcztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBhbGlhcylcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIEFsaWFzQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsaWFzLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvYmVoYXZpb3JzL2FsaWFzL2FsaWFzLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBfX29iamVjdFV0aWxpdHkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgYXV0b3NhdmVfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvYXV0b3NhdmUvYXV0b3NhdmUuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuYmVoYXZpb3JzLmF1dG9zYXZlJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQXV0b3NhdmUnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0F1dG9zYXZlQ29udHJvbGxlcic7XHJcbnZhciBBdXRvc2F2ZUNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXV0b3NhdmVDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsICRlbGVtZW50LCAkdGltZW91dCwgYXV0b3NhdmVGYWN0b3J5LCBwYXJlbnRDaGlsZEJlaGF2aW9yLCBvYmplY3RVdGlsaXR5KSB7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy4kYXR0cnMgPSAkYXR0cnM7XHJcbiAgICAgICAgdGhpcy4kcGFyc2UgPSAkcGFyc2U7XHJcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuJHRpbWVvdXQgPSAkdGltZW91dDtcclxuICAgICAgICB0aGlzLmF1dG9zYXZlRmFjdG9yeSA9IGF1dG9zYXZlRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkQmVoYXZpb3IgPSBwYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG4gICAgICAgIHRoaXMub2JqZWN0VXRpbGl0eSA9IG9iamVjdFV0aWxpdHk7XHJcbiAgICB9XHJcbiAgICBBdXRvc2F2ZUNvbnRyb2xsZXIucHJvdG90eXBlLiRvbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmtleXVwTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQub24oJ2tleXVwJywgZnVuY3Rpb24gKCkgeyBfdGhpcy4kc2NvcGUuJGFwcGx5KGNhbGxiYWNrKTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5vZmYoJ2tleXVwJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2F2ZUV4cHJlc3Npb24gPSB0aGlzLiRwYXJzZSh0aGlzLiRhdHRycy5zYXZlKTtcclxuICAgICAgICB2YXIgc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNhdmVFeHByZXNzaW9uKF90aGlzLiRzY29wZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZGVib3VuY2UgPSB0aGlzLiRwYXJzZSh0aGlzLiRhdHRycy5kZWJvdW5jZUR1cmF0aW9uKSh0aGlzLiRzY29wZSk7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZSA9IHRoaXMuYXV0b3NhdmVGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgc2F2ZTogc2F2ZSxcclxuICAgICAgICAgICAgY29udGVudEZvcm06IHRoaXMuZm9ybSxcclxuICAgICAgICAgICAgZGVib3VuY2VEdXJhdGlvbjogZGVib3VuY2UsXHJcbiAgICAgICAgICAgIHRyaWdnZXJzOiB0aGlzLiRhdHRycy50cmlnZ2VycyxcclxuICAgICAgICAgICAgc2V0Q2hhbmdlTGlzdGVuZXI6IHRoaXMua2V5dXBMaXN0ZW5lcixcclxuICAgICAgICAgICAgc2F2ZVdoZW5JbnZhbGlkOiB0aGlzLiRwYXJzZSh0aGlzLiRhdHRycy5zYXZlV2hlbkludmFsaWQpKHRoaXMuJHNjb3BlKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgYmVoYXZpb3IgPSB7XHJcbiAgICAgICAgICAgIGF1dG9zYXZlOiB0aGlzLmF1dG9zYXZlLmF1dG9zYXZlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gcmVnaXN0ZXIgYXV0b3NhdmUgYmVoYXZpb3IgYW5kIGFzc2lnbiB0aGUgdmFsdWUgYmFjayB0byB0aGUgcGFyZW50XHJcbiAgICAgICAgdmFyIGNoaWxkTGluayA9IHRoaXMuJHBhcnNlKHRoaXMuJGF0dHJzLnJsQXV0b3NhdmUpKHRoaXMuJHNjb3BlKTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkQmVoYXZpb3IucmVnaXN0ZXJDaGlsZEJlaGF2aW9yKGNoaWxkTGluaywgYmVoYXZpb3IpO1xyXG4gICAgfTtcclxuICAgIEF1dG9zYXZlQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLFxyXG4gICAgICAgICckYXR0cnMnLFxyXG4gICAgICAgICckcGFyc2UnLFxyXG4gICAgICAgICckZWxlbWVudCcsXHJcbiAgICAgICAgJyR0aW1lb3V0JyxcclxuICAgICAgICBhdXRvc2F2ZV9zZXJ2aWNlXzEuZmFjdG9yeU5hbWUsXHJcbiAgICAgICAgX19wYXJlbnRDaGlsZC5zZXJ2aWNlTmFtZSxcclxuICAgICAgICBfX29iamVjdFV0aWxpdHkuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIEF1dG9zYXZlQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5BdXRvc2F2ZUNvbnRyb2xsZXIgPSBBdXRvc2F2ZUNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGF1dG9zYXZlKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICAgIHByaW9yaXR5OiAxMDAwLFxyXG4gICAgICAgIHJlcXVpcmU6IHsgZm9ybTogJz9mb3JtJyB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjogdHJ1ZSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5hdXRvc2F2ZSA9IGF1dG9zYXZlO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIGF1dG9zYXZlX3NlcnZpY2VfMS5tb2R1bGVOYW1lLFxyXG4gICAgX19vYmplY3RVdGlsaXR5Lm1vZHVsZU5hbWUsXHJcbiAgICBfX3BhcmVudENoaWxkLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYXV0b3NhdmUpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBBdXRvc2F2ZUNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2JlaGF2aW9ycy9hdXRvc2F2ZS9hdXRvc2F2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19ub3RpZmljYXRpb24gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMubm90aWZpY2F0aW9uO1xyXG52YXIgYXV0b3NhdmVBY3Rpb25fc2VydmljZV8xID0gcmVxdWlyZSgnLi4vYXV0b3NhdmVBY3Rpb24vYXV0b3NhdmVBY3Rpb24uc2VydmljZScpO1xyXG52YXIgdHJpZ2dlcnMgPSByZXF1aXJlKCcuL3RyaWdnZXJzL3RyaWdnZXJzLnNlcnZpY2UnKTtcclxuZXhwb3J0cy50cmlnZ2VycyA9IHRyaWdnZXJzO1xyXG52YXIgZm9ybV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9mb3JtL2Zvcm0uc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMuYXV0b3NhdmUnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ2F1dG9zYXZlRmFjdG9yeSc7XHJcbnZhciBBdXRvc2F2ZVNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXV0b3NhdmVTZXJ2aWNlKG5vdGlmaWNhdGlvbiwgYXV0b3NhdmVTZXJ2aWNlLCBvcHRpb25zLCB0cmlnZ2VyU2VydmljZUZhY3RvcnksIGZvcm1TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcclxuICAgICAgICB0aGlzLmF1dG9zYXZlU2VydmljZSA9IGF1dG9zYXZlU2VydmljZTtcclxuICAgICAgICB0aGlzLmZvcm1TZXJ2aWNlID0gZm9ybVNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGRhdGFbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLnZhbGlkYXRlQW5kU2F2ZS5hcHBseShfdGhpcywgZGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChfLmlzQm9vbGVhbihyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXV0b3NhdmVTZXJ2aWNlLnRyaWdnZXIocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRGb3JtID0gb3B0aW9ucy5jb250ZW50Rm9ybSB8fCB0aGlzLm51bGxGb3JtKCk7XHJcbiAgICAgICAgdGhpcy5zYXZlID0gb3B0aW9ucy5zYXZlO1xyXG4gICAgICAgIHRoaXMuc2F2ZVdoZW5JbnZhbGlkID0gb3B0aW9ucy5zYXZlV2hlbkludmFsaWQ7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VydmljZSA9IHRyaWdnZXJTZXJ2aWNlRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJlVHJpZ2dlcnMob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VydmljZS5zZXRUcmlnZ2VycyhvcHRpb25zLnRyaWdnZXJzLCB0aGlzLmF1dG9zYXZlKTtcclxuICAgIH1cclxuICAgIEF1dG9zYXZlU2VydmljZS5wcm90b3R5cGUudmFsaWRhdGVBbmRTYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBkYXRhW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb250ZW50Rm9ybS4kcHJpc3RpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRGb3JtLiR2YWxpZCB8fCB0aGlzLnNhdmVXaGVuSW52YWxpZCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuc2F2ZS5hcHBseSh0aGlzLCBkYXRhKTtcclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udGVudEZvcm0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250ZW50Rm9ybS4kc2V0UHJpc3RpbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZpY2F0aW9uLndhcm5pbmcodGhpcy5mb3JtU2VydmljZS5nZXRBZ2dyZWdhdGVFcnJvcih0aGlzLmNvbnRlbnRGb3JtKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXV0b3NhdmVTZXJ2aWNlLnByb3RvdHlwZS5jb25maWd1cmVUcmlnZ2VycyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyU2VydmljZS50cmlnZ2Vycy5vbkNoYW5nZS5jb25maWd1cmUoe1xyXG4gICAgICAgICAgICBmb3JtOiBvcHRpb25zLmNvbnRlbnRGb3JtLFxyXG4gICAgICAgICAgICBzZXRDaGFuZ2VMaXN0ZW5lcjogb3B0aW9ucy5zZXRDaGFuZ2VMaXN0ZW5lcixcclxuICAgICAgICAgICAgZGVib3VuY2VEdXJhdGlvbjogb3B0aW9ucy5kZWJvdW5jZUR1cmF0aW9uLFxyXG4gICAgICAgICAgICBzYXZlV2hlbkludmFsaWQ6IG9wdGlvbnMuc2F2ZVdoZW5JbnZhbGlkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEF1dG9zYXZlU2VydmljZS5wcm90b3R5cGUubnVsbEZvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJHByaXN0aW5lOiBmYWxzZSxcclxuICAgICAgICAgICAgJGRpcnR5OiB0cnVlLFxyXG4gICAgICAgICAgICAkdmFsaWQ6IHRydWUsXHJcbiAgICAgICAgICAgICRzZXRQcmlzdGluZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEF1dG9zYXZlU2VydmljZTtcclxufSgpKTtcclxuYXV0b3NhdmVTZXJ2aWNlRmFjdG9yeS4kaW5qZWN0ID0gW19fbm90aWZpY2F0aW9uLnNlcnZpY2VOYW1lLCBhdXRvc2F2ZUFjdGlvbl9zZXJ2aWNlXzEuc2VydmljZU5hbWUsIHRyaWdnZXJzLmZhY3RvcnlOYW1lLCBmb3JtX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIGF1dG9zYXZlU2VydmljZUZhY3Rvcnkobm90aWZpY2F0aW9uLCBhdXRvc2F2ZVNlcnZpY2UsIHRyaWdnZXJTZXJ2aWNlRmFjdG9yeSwgZm9ybVNlcnZpY2UpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXV0b3NhdmVTZXJ2aWNlKG5vdGlmaWNhdGlvbiwgYXV0b3NhdmVTZXJ2aWNlLCBvcHRpb25zLCB0cmlnZ2VyU2VydmljZUZhY3RvcnksIGZvcm1TZXJ2aWNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fbm90aWZpY2F0aW9uLm1vZHVsZU5hbWUsIGF1dG9zYXZlQWN0aW9uX3NlcnZpY2VfMS5tb2R1bGVOYW1lLCB0cmlnZ2Vycy5tb2R1bGVOYW1lLCBmb3JtX3NlcnZpY2VfMS5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIGF1dG9zYXZlU2VydmljZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZS5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmUvYXV0b3NhdmUuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gdGhpc1tcIl9cIl07IH0oKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcIl9cIlxuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBuZyA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnV0aWxpdGllcy5zZXJ2aWNlcy5hdXRvc2F2ZUFjdGlvbic7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnYXV0b3NhdmVBY3Rpb24nO1xyXG52YXIgQXV0b3NhdmVBY3Rpb25TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1dG9zYXZlQWN0aW9uU2VydmljZSgkdGltZW91dCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVNZXNzYWdlRHVyYXRpb24gPSAxMDAwO1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVTdWNjZXNzZnVsID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVBdXRvc2F2ZShkYXRhLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVGYWlsZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZUF1dG9zYXZlKGRhdGEsIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZUF1dG9zYXZlID0gZnVuY3Rpb24gKGRhdGEsIHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuX3NhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5fY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5fc3VjY2Vzc2Z1bCA9IHN1Y2Nlc3M7XHJcbiAgICAgICAgICAgIF90aGlzLiR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCBfdGhpcy5jb21wbGV0ZU1lc3NhZ2VEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXV0b3NhdmVBY3Rpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJzYXZpbmdcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2aW5nO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1dG9zYXZlQWN0aW9uU2VydmljZS5wcm90b3R5cGUsIFwiY29tcGxldGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXV0b3NhdmVBY3Rpb25TZXJ2aWNlLnByb3RvdHlwZSwgXCJzdWNjZXNzZnVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1Y2Nlc3NmdWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBdXRvc2F2ZUFjdGlvblNlcnZpY2UucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xyXG4gICAgICAgIHRoaXMuX3NhdmluZyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbih0aGlzLmF1dG9zYXZlU3VjY2Vzc2Z1bClcclxuICAgICAgICAgICAgLmNhdGNoKHRoaXMuYXV0b3NhdmVGYWlsZWQpO1xyXG4gICAgfTtcclxuICAgIEF1dG9zYXZlQWN0aW9uU2VydmljZS4kaW5qZWN0ID0gWyckdGltZW91dCddO1xyXG4gICAgcmV0dXJuIEF1dG9zYXZlQWN0aW9uU2VydmljZTtcclxufSgpKTtcclxubmcubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBBdXRvc2F2ZUFjdGlvblNlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2F2ZUFjdGlvbi5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYXV0b3NhdmVBY3Rpb24vYXV0b3NhdmVBY3Rpb24uc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIG9uQ2hhbmdlVHJpZ2dlcl8xID0gcmVxdWlyZSgnLi9vbkNoYW5nZVRyaWdnZXInKTtcclxudmFyIHRyaWdnZXJfMSA9IHJlcXVpcmUoJy4vdHJpZ2dlcicpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL29uQ2hhbmdlVHJpZ2dlcicpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi90cmlnZ2VyJykpO1xyXG5leHBvcnRzLmRlZmF1bHRUcmlnZ2VycyA9ICdvbkNoYW5nZSc7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5hdXRvc2F2ZS50cmlnZ2Vycyc7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnYXV0b3NhdmVUcmlnZ2Vycyc7XHJcbnZhciBUcmlnZ2VyU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmlnZ2VyU2VydmljZSgkcm9vdFNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcnMgPSB7XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBuZXcgb25DaGFuZ2VUcmlnZ2VyXzEuT25DaGFuZ2VUcmlnZ2VyKCRyb290U2NvcGUsICR0aW1lb3V0KSxcclxuICAgICAgICAgICAgbm9uZTogbmV3IHRyaWdnZXJfMS5UcmlnZ2VyKCdub25lJyksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFRyaWdnZXJTZXJ2aWNlLnByb3RvdHlwZS5zZXRUcmlnZ2VycyA9IGZ1bmN0aW9uICh0cmlnZ2VyU3RyaW5nLCBhdXRvc2F2ZSkge1xyXG4gICAgICAgIGlmICh0cmlnZ2VyU3RyaW5nID09IG51bGwpIHtcclxuICAgICAgICAgICAgdHJpZ2dlclN0cmluZyA9IGV4cG9ydHMuZGVmYXVsdFRyaWdnZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfLmVhY2godGhpcy50cmlnZ2VycywgZnVuY3Rpb24gKHRyaWdnZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRyaWdnZXIuaGFzTWF0Y2godHJpZ2dlclN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIuc2V0VHJpZ2dlcihhdXRvc2F2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJpZ2dlclNlcnZpY2U7XHJcbn0oKSk7XHJcbnRyaWdnZXJTZXJ2aWNlRmFjdG9yeS4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJywgJyR0aW1lb3V0J107XHJcbmZ1bmN0aW9uIHRyaWdnZXJTZXJ2aWNlRmFjdG9yeSgkcm9vdFNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyaWdnZXJTZXJ2aWNlKCRyb290U2NvcGUsICR0aW1lb3V0KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgdHJpZ2dlclNlcnZpY2VGYWN0b3J5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpZ2dlcnMuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL3RyaWdnZXJzL3RyaWdnZXJzLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHJpZ2dlcl8xID0gcmVxdWlyZSgnLi90cmlnZ2VyJyk7XHJcbnZhciBPbkNoYW5nZVRyaWdnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9uQ2hhbmdlVHJpZ2dlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9uQ2hhbmdlVHJpZ2dlcigkcm9vdFNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdvbkNoYW5nZScpO1xyXG4gICAgICAgIHRoaXMuJHJvb3RTY29wZSA9ICRyb290U2NvcGU7XHJcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xyXG4gICAgICAgIHRoaXMuZGVib3VuY2VEdXJhdGlvbiA9IDEwMDA7XHJcbiAgICB9XHJcbiAgICBPbkNoYW5nZVRyaWdnZXIucHJvdG90eXBlLnNldFRyaWdnZXIgPSBmdW5jdGlvbiAoYXV0b3NhdmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMuc2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXR0aW5ncy5mb3JtICE9IG51bGxcclxuICAgICAgICAgICAgICAgID8gX3RoaXMuc2V0dGluZ3MuZm9ybS4kZGlydHlcclxuICAgICAgICAgICAgICAgIDogZmFsc2U7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyBfdGhpcy50cmlnZ2VyU2F2ZUFjdGlvbihhdXRvc2F2ZSk7IH0pO1xyXG4gICAgICAgIHRoaXMuJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0dGluZ3MuZm9ybSAhPSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IF90aGlzLnNldHRpbmdzLmZvcm0uJHZhbGlkXHJcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgX3RoaXMudHJpZ2dlclNhdmVBY3Rpb24oYXV0b3NhdmUpOyB9KTtcclxuICAgIH07XHJcbiAgICBPbkNoYW5nZVRyaWdnZXIucHJvdG90eXBlLnRyaWdnZXJTYXZlQWN0aW9uID0gZnVuY3Rpb24gKGF1dG9zYXZlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5mb3JtLiRkaXJ0eSAmJiAodGhpcy5zZXR0aW5ncy5mb3JtLiR2YWxpZCB8fCB0aGlzLnNldHRpbmdzLnNhdmVXaGVuSW52YWxpZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUaW1lcihhdXRvc2F2ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJMaXN0ZW5lciA9IHRoaXMuc2V0TGlzdGVuZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VGltZXIoYXV0b3NhdmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT25DaGFuZ2VUcmlnZ2VyLnByb3RvdHlwZS5zZXRUaW1lciA9IGZ1bmN0aW9uIChhdXRvc2F2ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLiR0aW1lb3V0LmNhbmNlbCh0aGlzLnRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHRoaXMuJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5jbGVhckxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIGF1dG9zYXZlKCk7XHJcbiAgICAgICAgfSwgdGhpcy5kZWJvdW5jZUR1cmF0aW9uKTtcclxuICAgIH07XHJcbiAgICBPbkNoYW5nZVRyaWdnZXIucHJvdG90eXBlLmluaXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRMaXN0ZW5lciA9IHRoaXMuc2V0dGluZ3Muc2V0Q2hhbmdlTGlzdGVuZXIgfHwgdGhpcy5udWxsU2V0TGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVyID0gdGhpcy5udWxsQ2xlYXJMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICBPbkNoYW5nZVRyaWdnZXIucHJvdG90eXBlLm51bGxTZXRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnTm8gY2hhbmdlIGxpc3RlbmVyIGF2YWlsYWJsZScpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bGxDbGVhckxpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIE9uQ2hhbmdlVHJpZ2dlci5wcm90b3R5cGUubnVsbENsZWFyTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ05vIGNoYW5nZSBsaXN0ZW5lciByZWdpc3RlcicpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBPbkNoYW5nZVRyaWdnZXI7XHJcbn0odHJpZ2dlcl8xLlRyaWdnZXIpKTtcclxuZXhwb3J0cy5PbkNoYW5nZVRyaWdnZXIgPSBPbkNoYW5nZVRyaWdnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uQ2hhbmdlVHJpZ2dlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL3RyaWdnZXJzL29uQ2hhbmdlVHJpZ2dlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciBUcmlnZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyaWdnZXIoYWxpYXNlcywgdHJpZ2dlckFjdGlvbikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckFjdGlvbiA9IHRyaWdnZXJBY3Rpb247XHJcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gYWxpYXNlcy5zcGxpdCgnICcpO1xyXG4gICAgfVxyXG4gICAgVHJpZ2dlci5wcm90b3R5cGUuc2V0VHJpZ2dlciA9IGZ1bmN0aW9uIChhdXRvc2F2ZSkge1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy50cmlnZ2VyQWN0aW9uKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJBY3Rpb24odGhpcy5zZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRyaWdnZXIucHJvdG90eXBlLmhhc01hdGNoID0gZnVuY3Rpb24gKHRyaWdnZXJzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdHJpZ2dlckxpc3QgPSB0cmlnZ2Vycy5zcGxpdCgnICcpO1xyXG4gICAgICAgIHJldHVybiBfLnNvbWUodHJpZ2dlckxpc3QsIGZ1bmN0aW9uICh0cmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnNvbWUoX3RoaXMuYWxpYXNlcywgZnVuY3Rpb24gKGFsaWFzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJpZ2dlciA9PT0gYWxpYXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRyaWdnZXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJpZ2dlcjtcclxufSgpKTtcclxuZXhwb3J0cy5UcmlnZ2VyID0gVHJpZ2dlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJpZ2dlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2F1dG9zYXZlL3RyaWdnZXJzL3RyaWdnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLnNlcnZpY2VzLmZvcm0nO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ2Zvcm1TZXJ2aWNlJztcclxudmFyIEZvcm1TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZvcm1TZXJ2aWNlKCkge1xyXG4gICAgfVxyXG4gICAgRm9ybVNlcnZpY2UucHJvdG90eXBlLmdldEFnZ3JlZ2F0ZUVycm9yID0gZnVuY3Rpb24gKGZvcm0pIHtcclxuICAgICAgICB2YXIgZmlsdGVyZWRGb3JtID0gXy5maWx0ZXIoZm9ybSwgZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3AgIT0gbnVsbCAmJiBwcm9wLnJsRXJyb3JNZXNzYWdlICE9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGVycm9ycyA9IF8ubWFwVmFsdWVzKGZpbHRlcmVkRm9ybSwgJ3JsRXJyb3JNZXNzYWdlJyk7XHJcbiAgICAgICAgcmV0dXJuIF8uZmlyc3QoZXJyb3JzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRm9ybVNlcnZpY2U7XHJcbn0oKSk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBGb3JtU2VydmljZSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm0uc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2Zvcm0vZm9ybS5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX2d1aWQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZ3VpZDtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmJlaGF2aW9ycy5wb3BvdmVyJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsUG9wb3Zlcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUG9wb3ZlckNvbnRyb2xsZXInO1xyXG52YXIgUG9wb3ZlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9wb3ZlckNvbnRyb2xsZXIoJGF0dHJzLCAkZWxlbWVudCwgJGNvbXBpbGUsICRzY29wZSwgJHBhcnNlLCAkdGVtcGxhdGVDYWNoZSwgZ3VpZCkge1xyXG4gICAgICAgIHRoaXMuJGF0dHJzID0gJGF0dHJzO1xyXG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcclxuICAgICAgICB0aGlzLiRjb21waWxlID0gJGNvbXBpbGU7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy4kcGFyc2UgPSAkcGFyc2U7XHJcbiAgICAgICAgdGhpcy4kdGVtcGxhdGVDYWNoZSA9ICR0ZW1wbGF0ZUNhY2hlO1xyXG4gICAgICAgIHRoaXMuZ3VpZCA9IGd1aWQ7XHJcbiAgICB9XHJcbiAgICBQb3BvdmVyQ29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy4kcGFyc2UodGhpcy4kYXR0cnMudGV4dE9ubHkpKHRoaXMuJHNjb3BlKSkge1xyXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3VpYi1wb3BvdmVyJywgdGhpcy4kYXR0cnMucmxQb3BvdmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVBhdGggPSB0aGlzLmd1aWQucmFuZG9tKCkgKyAnLmh0bWwnO1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVDb250ZW50ID0gJzxkaXY+JyArIHRoaXMuJHBhcnNlKHRoaXMuJGF0dHJzLnJsUG9wb3ZlcikodGhpcy4kc2NvcGUpICsgJzwvZGl2Pic7XHJcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZUNvbnRlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kdGVtcGxhdGVDYWNoZS5wdXQodGVtcGxhdGVQYXRoLCB0ZW1wbGF0ZUNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCd1aWItcG9wb3Zlci10ZW1wbGF0ZScsICdcXCcnICsgdGVtcGxhdGVQYXRoICsgJ1xcJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cigncmwtcG9wb3ZlcicpO1xyXG4gICAgICAgIHRoaXMuJGNvbXBpbGUodGhpcy4kZWxlbWVudCkodGhpcy4kc2NvcGUpO1xyXG4gICAgfTtcclxuICAgIFBvcG92ZXJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRhdHRycycsXHJcbiAgICAgICAgJyRlbGVtZW50JyxcclxuICAgICAgICAnJGNvbXBpbGUnLFxyXG4gICAgICAgICckc2NvcGUnLFxyXG4gICAgICAgICckcGFyc2UnLFxyXG4gICAgICAgICckdGVtcGxhdGVDYWNoZScsXHJcbiAgICAgICAgX19ndWlkLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBQb3BvdmVyQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Qb3BvdmVyQ29udHJvbGxlciA9IFBvcG92ZXJDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBwb3BvdmVyKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0EnLFxyXG4gICAgICAgIHByaW9yaXR5OiAzMDAsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5wb3BvdmVyID0gcG9wb3ZlcjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBwb3BvdmVyKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgUG9wb3ZlckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BvdmVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvYmVoYXZpb3JzL3BvcG92ZXIvcG9wb3Zlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuYmVoYXZpb3JzLnJlcXVpcmVkJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsUmVxdWlyZWQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1JlcXVpcmVkQ29udHJvbGxlcic7XHJcbnZhciBSZXF1aXJlZENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVxdWlyZWRDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCAkaW50ZXJwb2xhdGUpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLiRhdHRycyA9ICRhdHRycztcclxuICAgICAgICB0aGlzLiRpbnRlcnBvbGF0ZSA9ICRpbnRlcnBvbGF0ZTtcclxuICAgIH1cclxuICAgIFJlcXVpcmVkQ29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLiRpbnRlcnBvbGF0ZSh0aGlzLiRhdHRycy5ybFJlcXVpcmVkKSh0aGlzLiRzY29wZSk7XHJcbiAgICB9O1xyXG4gICAgUmVxdWlyZWRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckYXR0cnMnLCAnJGludGVycG9sYXRlJ107XHJcbiAgICByZXR1cm4gUmVxdWlyZWRDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlJlcXVpcmVkQ29udHJvbGxlciA9IFJlcXVpcmVkQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gcmVxdWlyZWQoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnQScsXHJcbiAgICAgICAgcHJpb3JpdHk6IDIwMCxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHJlcXVpcmVkKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgUmVxdWlyZWRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWlyZWQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9iZWhhdmlvcnMvcmVxdWlyZWQvcmVxdWlyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIGJ1c3kgPSByZXF1aXJlKCcuL2J1c3kvYnVzeScpO1xyXG5leHBvcnRzLmJ1c3kgPSBidXN5O1xyXG52YXIgYnV0dG9uID0gcmVxdWlyZSgnLi9idXR0b24vYnV0dG9uJyk7XHJcbmV4cG9ydHMuYnV0dG9uID0gYnV0dG9uO1xyXG52YXIgYnV0dG9uQXN5bmMgPSByZXF1aXJlKCcuL2J1dHRvbkFzeW5jL2J1dHRvbkFzeW5jJyk7XHJcbmV4cG9ydHMuYnV0dG9uQXN5bmMgPSBidXR0b25Bc3luYztcclxudmFyIGJ1dHRvbkxpbmsgPSByZXF1aXJlKCcuL2J1dHRvbkxpbmsvYnV0dG9uTGluaycpO1xyXG5leHBvcnRzLmJ1dHRvbkxpbmsgPSBidXR0b25MaW5rO1xyXG52YXIgYnV0dG9uU3VibWl0ID0gcmVxdWlyZSgnLi9idXR0b25TdWJtaXQvYnV0dG9uU3VibWl0Jyk7XHJcbmV4cG9ydHMuYnV0dG9uU3VibWl0ID0gYnV0dG9uU3VibWl0O1xyXG52YXIgYnV0dG9uVG9nZ2xlID0gcmVxdWlyZSgnLi9idXR0b25Ub2dnbGUvYnV0dG9uVG9nZ2xlJyk7XHJcbmV4cG9ydHMuYnV0dG9uVG9nZ2xlID0gYnV0dG9uVG9nZ2xlO1xyXG52YXIgY2FyZENvbnRhaW5lciA9IHJlcXVpcmUoJy4vY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLm1vZHVsZScpO1xyXG5leHBvcnRzLmNhcmRDb250YWluZXIgPSBjYXJkQ29udGFpbmVyO1xyXG52YXIgY2hlY2tib3ggPSByZXF1aXJlKCcuL2NoZWNrYm94L2NoZWNrYm94Jyk7XHJcbmV4cG9ydHMuY2hlY2tib3ggPSBjaGVja2JveDtcclxudmFyIGNvbW1hTGlzdCA9IHJlcXVpcmUoJy4vY29tbWFMaXN0L2NvbW1hTGlzdCcpO1xyXG5leHBvcnRzLmNvbW1hTGlzdCA9IGNvbW1hTGlzdDtcclxudmFyIGRhdGVUaW1lID0gcmVxdWlyZSgnLi9kYXRlVGltZS9kYXRlVGltZScpO1xyXG5leHBvcnRzLmRhdGVUaW1lID0gZGF0ZVRpbWU7XHJcbnZhciBkYXRlVGltZVN0YXRpYyA9IHJlcXVpcmUoJy4vZGF0ZVRpbWVTdGF0aWMvZGF0ZVRpbWVTdGF0aWMnKTtcclxuZXhwb3J0cy5kYXRlVGltZVN0YXRpYyA9IGRhdGVUaW1lU3RhdGljO1xyXG52YXIgZGlhbG9nID0gcmVxdWlyZSgnLi9kaWFsb2cvZGlhbG9nJyk7XHJcbmV4cG9ydHMuZGlhbG9nID0gZGlhbG9nO1xyXG52YXIgZm9ybSA9IHJlcXVpcmUoJy4vZm9ybS9mb3JtJyk7XHJcbmV4cG9ydHMuZm9ybSA9IGZvcm07XHJcbnZhciBnZW5lcmljQ29udGFpbmVyID0gcmVxdWlyZSgnLi9nZW5lcmljQ29udGFpbmVyL2dlbmVyaWNDb250YWluZXInKTtcclxuZXhwb3J0cy5nZW5lcmljQ29udGFpbmVyID0gZ2VuZXJpY0NvbnRhaW5lcjtcclxudmFyIGxhenlMb2FkID0gcmVxdWlyZSgnLi9sYXp5TG9hZC9sYXp5TG9hZCcpO1xyXG5leHBvcnRzLmxhenlMb2FkID0gbGF6eUxvYWQ7XHJcbnZhciBsb25nQ2xpY2tCdXR0b24gPSByZXF1aXJlKCcuL2xvbmdDbGlja0J1dHRvbi9sb25nQ2xpY2tCdXR0b24nKTtcclxuZXhwb3J0cy5sb25nQ2xpY2tCdXR0b24gPSBsb25nQ2xpY2tCdXR0b247XHJcbnZhciBtZXNzYWdlTG9nID0gcmVxdWlyZSgnLi9tZXNzYWdlTG9nL21lc3NhZ2VMb2cubW9kdWxlJyk7XHJcbmV4cG9ydHMubWVzc2FnZUxvZyA9IG1lc3NhZ2VMb2c7XHJcbnZhciBtdWx0aVN0ZXBJbmRpY2F0b3IgPSByZXF1aXJlKCcuL211bHRpU3RlcEluZGljYXRvci9tdWx0aVN0ZXBJbmRpY2F0b3InKTtcclxuZXhwb3J0cy5tdWx0aVN0ZXBJbmRpY2F0b3IgPSBtdWx0aVN0ZXBJbmRpY2F0b3I7XHJcbnZhciByYWRpbyA9IHJlcXVpcmUoJy4vcmFkaW8vcmFkaW8ubW9kdWxlJyk7XHJcbmV4cG9ydHMucmFkaW8gPSByYWRpbztcclxudmFyIHJhdGluZ0JhciA9IHJlcXVpcmUoJy4vcmF0aW5nQmFyL3JhdGluZ0JhcicpO1xyXG5leHBvcnRzLnJhdGluZ0JhciA9IHJhdGluZ0JhcjtcclxudmFyIHJpY2hUZXh0RWRpdG9yID0gcmVxdWlyZSgnLi9yaWNoVGV4dEVkaXRvci9yaWNoVGV4dEVkaXRvcicpO1xyXG5leHBvcnRzLnJpY2hUZXh0RWRpdG9yID0gcmljaFRleHRFZGl0b3I7XHJcbnZhciBzZWxlY3QgPSByZXF1aXJlKCcuL3NlbGVjdC9zZWxlY3QnKTtcclxuZXhwb3J0cy5zZWxlY3QgPSBzZWxlY3Q7XHJcbnZhciBzaWduYXR1cmVQYWQgPSByZXF1aXJlKCcuL3NpZ25hdHVyZVBhZC9zaWduYXR1cmVQYWQnKTtcclxuZXhwb3J0cy5zaWduYXR1cmVQYWQgPSBzaWduYXR1cmVQYWQ7XHJcbnZhciBzaW1wbGVDYXJkTGlzdCA9IHJlcXVpcmUoJy4vc2ltcGxlQ2FyZExpc3Qvc2ltcGxlQ2FyZExpc3QubW9kdWxlJyk7XHJcbmV4cG9ydHMuc2ltcGxlQ2FyZExpc3QgPSBzaW1wbGVDYXJkTGlzdDtcclxudmFyIHNwaW5uZXIgPSByZXF1aXJlKCcuL3NwaW5uZXIvc3Bpbm5lcicpO1xyXG5leHBvcnRzLnNwaW5uZXIgPSBzcGlubmVyO1xyXG52YXIgc3RyaW5nV2l0aFdhdGVybWFyayA9IHJlcXVpcmUoJy4vc3RyaW5nV2l0aFdhdGVybWFyay9zdHJpbmdXaXRoV2F0ZXJtYXJrJyk7XHJcbmV4cG9ydHMuc3RyaW5nV2l0aFdhdGVybWFyayA9IHN0cmluZ1dpdGhXYXRlcm1hcms7XHJcbnZhciB0YWJzID0gcmVxdWlyZSgnLi90YWJzL3RhYnMubW9kdWxlJyk7XHJcbmV4cG9ydHMudGFicyA9IHRhYnM7XHJcbnZhciB0ZW1wbGF0ZVJlbmRlcmVyID0gcmVxdWlyZSgnLi90ZW1wbGF0ZVJlbmRlcmVyL3RlbXBsYXRlUmVuZGVyZXInKTtcclxuZXhwb3J0cy50ZW1wbGF0ZVJlbmRlcmVyID0gdGVtcGxhdGVSZW5kZXJlcjtcclxudmFyIHRleHRhcmVhID0gcmVxdWlyZSgnLi90ZXh0YXJlYS90ZXh0YXJlYScpO1xyXG5leHBvcnRzLnRleHRhcmVhID0gdGV4dGFyZWE7XHJcbnZhciB0ZXh0Ym94ID0gcmVxdWlyZSgnLi90ZXh0Ym94L3RleHRib3gnKTtcclxuZXhwb3J0cy50ZXh0Ym94ID0gdGV4dGJveDtcclxudmFyIHR5cGVhaGVhZCA9IHJlcXVpcmUoJy4vdHlwZWFoZWFkL3R5cGVhaGVhZCcpO1xyXG5leHBvcnRzLnR5cGVhaGVhZCA9IHR5cGVhaGVhZDtcclxudmFyIHR5cGVhaGVhZExpc3QgPSByZXF1aXJlKCcuL3R5cGVhaGVhZExpc3QvdHlwZWFoZWFkTGlzdCcpO1xyXG5leHBvcnRzLnR5cGVhaGVhZExpc3QgPSB0eXBlYWhlYWRMaXN0O1xyXG52YXIgdXNlclJhdGluZyA9IHJlcXVpcmUoJy4vdXNlclJhdGluZy91c2VyUmF0aW5nJyk7XHJcbmV4cG9ydHMudXNlclJhdGluZyA9IHVzZXJSYXRpbmc7XHJcbnZhciB2YWxpZGF0aW9uR3JvdXAgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb25Hcm91cC92YWxpZGF0aW9uR3JvdXAnKTtcclxuZXhwb3J0cy52YWxpZGF0aW9uR3JvdXAgPSB2YWxpZGF0aW9uR3JvdXA7XHJcbnZhciBjb21wb25lbnRzRGVmYXVsdFRoZW1lXzEgPSByZXF1aXJlKCcuL2NvbXBvbmVudHNEZWZhdWx0VGhlbWUnKTtcclxuZXhwb3J0cy5kZWZhdWx0VGhlbWVWYWx1ZU5hbWUgPSBjb21wb25lbnRzRGVmYXVsdFRoZW1lXzEuZGVmYXVsdFRoZW1lVmFsdWVOYW1lO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgYnVzeS5tb2R1bGVOYW1lLFxyXG4gICAgYnV0dG9uLm1vZHVsZU5hbWUsXHJcbiAgICBidXR0b25Bc3luYy5tb2R1bGVOYW1lLFxyXG4gICAgYnV0dG9uTGluay5tb2R1bGVOYW1lLFxyXG4gICAgYnV0dG9uU3VibWl0Lm1vZHVsZU5hbWUsXHJcbiAgICBidXR0b25Ub2dnbGUubW9kdWxlTmFtZSxcclxuICAgIGNhcmRDb250YWluZXIubW9kdWxlTmFtZSxcclxuICAgIGNoZWNrYm94Lm1vZHVsZU5hbWUsXHJcbiAgICBjb21tYUxpc3QubW9kdWxlTmFtZSxcclxuICAgIGRhdGVUaW1lLm1vZHVsZU5hbWUsXHJcbiAgICBkYXRlVGltZVN0YXRpYy5tb2R1bGVOYW1lLFxyXG4gICAgZGlhbG9nLm1vZHVsZU5hbWUsXHJcbiAgICBmb3JtLm1vZHVsZU5hbWUsXHJcbiAgICBnZW5lcmljQ29udGFpbmVyLm1vZHVsZU5hbWUsXHJcbiAgICBsYXp5TG9hZC5tb2R1bGVOYW1lLFxyXG4gICAgbG9uZ0NsaWNrQnV0dG9uLm1vZHVsZU5hbWUsXHJcbiAgICBtZXNzYWdlTG9nLm1vZHVsZU5hbWUsXHJcbiAgICBtdWx0aVN0ZXBJbmRpY2F0b3IubW9kdWxlTmFtZSxcclxuICAgIHJhZGlvLm1vZHVsZU5hbWUsXHJcbiAgICByYXRpbmdCYXIubW9kdWxlTmFtZSxcclxuICAgIHJpY2hUZXh0RWRpdG9yLm1vZHVsZU5hbWUsXHJcbiAgICBzZWxlY3QubW9kdWxlTmFtZSxcclxuICAgIHNpZ25hdHVyZVBhZC5tb2R1bGVOYW1lLFxyXG4gICAgc2ltcGxlQ2FyZExpc3QubW9kdWxlTmFtZSxcclxuICAgIHNwaW5uZXIubW9kdWxlTmFtZSxcclxuICAgIHN0cmluZ1dpdGhXYXRlcm1hcmsubW9kdWxlTmFtZSxcclxuICAgIHRhYnMubW9kdWxlTmFtZSxcclxuICAgIHRlbXBsYXRlUmVuZGVyZXIubW9kdWxlTmFtZSxcclxuICAgIHRleHRhcmVhLm1vZHVsZU5hbWUsXHJcbiAgICB0ZXh0Ym94Lm1vZHVsZU5hbWUsXHJcbiAgICB0eXBlYWhlYWQubW9kdWxlTmFtZSxcclxuICAgIHR5cGVhaGVhZExpc3QubW9kdWxlTmFtZSxcclxuICAgIHVzZXJSYXRpbmcubW9kdWxlTmFtZSxcclxuICAgIHZhbGlkYXRpb25Hcm91cC5tb2R1bGVOYW1lLFxyXG5dKVxyXG4gICAgLnZhbHVlKGNvbXBvbmVudHNEZWZhdWx0VGhlbWVfMS5kZWZhdWx0VGhlbWVWYWx1ZU5hbWUsIGNvbXBvbmVudHNEZWZhdWx0VGhlbWVfMS5kZWZhdWx0VGhlbWVWYWx1ZSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudHMubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jb21wb25lbnRzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnJlcXVpcmUoJy4vYnVzeS5jc3MnKTtcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBjb21wb25lbnRzRGVmYXVsdFRoZW1lXzEgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzRGVmYXVsdFRoZW1lJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmJ1c3knO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxCdXN5JztcclxuYnVzeS4kaW5qZWN0ID0gW2NvbXBvbmVudHNEZWZhdWx0VGhlbWVfMS5kZWZhdWx0VGhlbWVWYWx1ZU5hbWVdO1xyXG5mdW5jdGlvbiBidXN5KHVzZURlZmF1bHRUaGVtZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpIGNsYXNzPVxcXCJidXN5IHJsLXt7c2l6ZX19XFxcIiBuZy1jbGFzcz1cXFwieyAnZGVmYXVsdC10aGVtZSc6IHVzZURlZmF1bHRUaGVtZSB9XFxcIiBuZy1zaG93PVxcXCJsb2FkaW5nXFxcIj48L2k+XCIsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgbG9hZGluZzogJz0nLFxyXG4gICAgICAgICAgICAvLyBWYWxpZCB2YWx1ZXMgYXJlOlxyXG4gICAgICAgICAgICAvLyBgbGdgLCBgMnhgLCBgM3hgLCBgNHhgLCBhbmQgYDV4YFxyXG4gICAgICAgICAgICBzaXplOiAnQCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgc2NvcGUudXNlRGVmYXVsdFRoZW1lID0gdXNlRGVmYXVsdFRoZW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYnVzeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1c3kuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1c3kvYnVzeS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2J1c3kuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2J1c3kuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYnVzeS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXN5L2J1c3kuY3NzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmRlZmF1bHQtdGhlbWUuYnVzeSB7XFxyXFxuXFx0LXdlYmtpdC1hbmltYXRpb246IGZhLXNwaW4gMnMgaW5maW5pdGUgbGluZWFyO1xcclxcblxcdGFuaW1hdGlvbjogZmEtc3BpbiAycyBpbmZpbml0ZSBsaW5lYXI7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdGZvbnQtc2l6ZTogaW5oZXJpdDtcXHJcXG5cXHRmb250LXN0eWxlOiBub3JtYWw7XFxyXFxuXFx0Zm9udC1mYW1pbHk6IEZvbnRBd2Vzb21lO1xcclxcbn1cXHJcXG5cXHJcXG4uZGVmYXVsdC10aGVtZS5idXN5OmJlZm9yZSB7XFxyXFxuXFx0Y29udGVudDogXFxcIlxcXFxGMTEwXFxcIjsgLyogZmEtc3Bpbm5lciAqL1xcclxcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vc291cmNlL2NvbXBvbmVudHMvYnVzeS9idXN5LmNzc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcclxuZXhwb3J0cy5kZWZhdWx0VGhlbWVWYWx1ZU5hbWUgPSAndXNlRGVmYXVsdFRoZW1lJztcclxuZXhwb3J0cy5kZWZhdWx0VGhlbWVWYWx1ZSA9IHRydWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudHNEZWZhdWx0VGhlbWUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NvbXBvbmVudHNEZWZhdWx0VGhlbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5idXR0b24nO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxCdXR0b24nO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0J1dHRvbkNvbnRyb2xsZXInO1xyXG52YXIgQnV0dG9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCdXR0b25Db250cm9sbGVyKCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSAhPSBudWxsID8gdGhpcy50eXBlIDogJ2RlZmF1bHQnO1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJlZFNpemUgPSB0aGlzLnNpemUgIT0gbnVsbCA/ICdidG4tJyArIHRoaXMuc2l6ZSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQnV0dG9uQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5CdXR0b25Db250cm9sbGVyID0gQnV0dG9uQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gYnV0dG9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYnV0dG9uLmh0bWwnKSxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBhY3Rpb246ICcmJyxcclxuICAgICAgICAgICAgdHlwZTogJ0AnLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgICAgIHNpemU6ICdAJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnYnV0dG9uJyxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5idXR0b24gPSBidXR0b247XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgYnV0dG9uKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQnV0dG9uQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXt7YnV0dG9uLnR5cGV9fSB7e2J1dHRvbi5jb25maWd1cmVkU2l6ZX19XFxcIiBuZy1jbGljaz1cXFwiYnV0dG9uLmFjdGlvbigpXFxcIiBuZy1kaXNhYmxlZD1cXFwiYnV0dG9uLm5nRGlzYWJsZWRcXFwiPlxcclxcblxcdDxzcGFuIG5nLXRyYW5zY2x1ZGU+PC9zcGFuPlxcclxcbjwvYnV0dG9uPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvbi9idXR0b24uaHRtbFxuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wcm9taXNlVXRpbGl0eSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5idXR0b25Bc3luYyc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEJ1dHRvbkFzeW5jJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdCdXR0b25Bc3luY0NvbnRyb2xsZXInO1xyXG52YXIgQnV0dG9uQXN5bmNDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1dHRvbkFzeW5jQ29udHJvbGxlcihwcm9taXNlVXRpbGl0eSkge1xyXG4gICAgICAgIHRoaXMucHJvbWlzZVV0aWxpdHkgPSBwcm9taXNlVXRpbGl0eTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLnR5cGUgIT0gbnVsbCA/IHRoaXMudHlwZSA6ICdkZWZhdWx0JztcclxuICAgICAgICB0aGlzLnNpemVDbGFzcyA9IHRoaXMuc2l6ZSAhPSBudWxsID8gJ2J0bi0nICsgdGhpcy5zaXplIDogbnVsbDtcclxuICAgIH1cclxuICAgIEJ1dHRvbkFzeW5jQ29udHJvbGxlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5idXN5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVzeSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFjdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9taXNlVXRpbGl0eS5pc1Byb21pc2UocmVzdWx0KSAmJiBfLmlzRnVuY3Rpb24ocmVzdWx0LmZpbmFsbHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZmluYWxseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdXR0b25Bc3luY0NvbnRyb2xsZXIuJGluamVjdCA9IFtfX3Byb21pc2VVdGlsaXR5LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBCdXR0b25Bc3luY0NvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQnV0dG9uQXN5bmNDb250cm9sbGVyID0gQnV0dG9uQXN5bmNDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBidXR0b25Bc3luYygpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2J1dHRvbkFzeW5jLmh0bWwnKSxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBidXN5OiAnPT8nLFxyXG4gICAgICAgICAgICBhY3Rpb246ICcmJyxcclxuICAgICAgICAgICAgdHlwZTogJ0AnLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPT8nLFxyXG4gICAgICAgICAgICByaWdodEFsaWduZWQ6ICc9PycsXHJcbiAgICAgICAgICAgIHNpemU6ICdAJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnYnV0dG9uJyxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19wcm9taXNlVXRpbGl0eS5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBidXR0b25Bc3luYylcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIEJ1dHRvbkFzeW5jQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbkFzeW5jLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Bc3luYy9idXR0b25Bc3luYy5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXt7YnV0dG9uLnR5cGV9fSB7e2J1dHRvbi5zaXplQ2xhc3N9fVxcXCIgbmctY2xpY2s9XFxcImJ1dHRvbi50cmlnZ2VyKClcXFwiIG5nLWRpc2FibGVkPVxcXCJidXR0b24uYnVzeSB8fCBidXR0b24ubmdEaXNhYmxlZFxcXCI+XFxyXFxuXFx0PHJsLWJ1c3kgbmctc2hvdz1cXFwiYnV0dG9uLnJpZ2h0QWxpZ25lZFxcXCIgbG9hZGluZz1cXFwiYnV0dG9uLmJ1c3lcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHQ8c3BhbiBuZy10cmFuc2NsdWRlPjwvc3Bhbj5cXHJcXG5cXHQ8cmwtYnVzeSBuZy1oaWRlPVxcXCJidXR0b24ucmlnaHRBbGlnbmVkXFxcIiBsb2FkaW5nPVxcXCJidXR0b24uYnVzeVxcXCI+PC9ybC1idXN5PlxcclxcbjwvYnV0dG9uPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvbkFzeW5jL2J1dHRvbkFzeW5jLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5idXR0b25MaW5rJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQnV0dG9uTGluayc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQnV0dG9uTGlua0NvbnRyb2xsZXInO1xyXG52YXIgQnV0dG9uTGlua0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnV0dG9uTGlua0NvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy50eXBlICE9IG51bGwgPyB0aGlzLnR5cGUgOiAnZGVmYXVsdCc7XHJcbiAgICAgICAgdGhpcy5jb25maWd1cmVkU2l6ZSA9IHRoaXMuc2l6ZSAhPSBudWxsID8gJ2J0bi0nICsgdGhpcy5zaXplIDogbnVsbDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMubmV3VGFiID8gJ19ibGFuaycgOiAnX3NlbGYnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJ1dHRvbkxpbmtDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkJ1dHRvbkxpbmtDb250cm9sbGVyID0gQnV0dG9uTGlua0NvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGJ1dHRvbkxpbmsoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9idXR0b25MaW5rLmh0bWwnKSxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBsaW5rOiAnQCcsXHJcbiAgICAgICAgICAgIHR5cGU6ICdAJyxcclxuICAgICAgICAgICAgbmdEaXNhYmxlZDogJz0nLFxyXG4gICAgICAgICAgICBzaXplOiAnQCcsXHJcbiAgICAgICAgICAgIG5ld1RhYjogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdidXR0b24nLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmJ1dHRvbkxpbmsgPSBidXR0b25MaW5rO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGJ1dHRvbkxpbmspXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBCdXR0b25MaW5rQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbkxpbmsuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvbkxpbmsvYnV0dG9uTGluay5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGEgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b24udHlwZX19IHt7YnV0dG9uLmNvbmZpZ3VyZWRTaXplfX1cXFwiIG5nLWhyZWY9XFxcInt7YnV0dG9uLmxpbmt9fVxcXCIgbmctZGlzYWJsZWQ9XFxcImJ1dHRvbi5uZ0Rpc2FibGVkXFxcIiB0YXJnZXQ9XFxcInt7YnV0dG9uLnRhcmdldH19XFxcIj5cXHJcXG5cXHQ8c3BhbiBuZy10cmFuc2NsdWRlPjwvc3Bhbj5cXHJcXG48L2E+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uTGluay9idXR0b25MaW5rLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5idXR0b25TdWJtaXQnO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxCdXR0b25TdWJtaXQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0J1dHRvblN1Ym1pdENvbnRyb2xsZXInO1xyXG52YXIgQnV0dG9uU3VibWl0Q29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCdXR0b25TdWJtaXRDb250cm9sbGVyKCRlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSAhPSBudWxsID8gdGhpcy50eXBlIDogJ2RlZmF1bHQnO1xyXG4gICAgICAgIHRoaXMuY29uZmlndXJlZFNpemUgPSB0aGlzLnNpemUgIT0gbnVsbCA/ICdidG4tJyArIHRoaXMuc2l6ZSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBCdXR0b25TdWJtaXRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRlbGVtZW50J107XHJcbiAgICByZXR1cm4gQnV0dG9uU3VibWl0Q29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5CdXR0b25TdWJtaXRDb250cm9sbGVyID0gQnV0dG9uU3VibWl0Q29udHJvbGxlcjtcclxudmFyIGJ1dHRvblN1Ym1pdCA9IHtcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9idXR0b25TdWJtaXQuaHRtbCcpLFxyXG4gICAgYmluZGluZ3M6IHtcclxuICAgICAgICB0eXBlOiAnQCcsXHJcbiAgICAgICAgbmdEaXNhYmxlZDogJzw/JyxcclxuICAgICAgICBzaXplOiAnQCcsXHJcbiAgICAgICAgcmlnaHRBbGlnbmVkOiAnPD8nLFxyXG4gICAgICAgIHNhdmluZzogJzw/JyxcclxuICAgIH0sXHJcbiAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgY29udHJvbGxlckFzOiAnYnV0dG9uJyxcclxufTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5jb21wb25lbnQoZXhwb3J0cy5jb21wb25lbnROYW1lLCBidXR0b25TdWJtaXQpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBCdXR0b25TdWJtaXRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uU3VibWl0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25TdWJtaXQvYnV0dG9uU3VibWl0LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b24udHlwZX19IHt7YnV0dG9uLmNvbmZpZ3VyZWRTaXplfX1cXFwiIG5nLWRpc2FibGVkPVxcXCJidXR0b24uc2F2aW5nIHx8IGJ1dHRvbi5uZ0Rpc2FibGVkXFxcIj5cXHJcXG5cXHQ8cmwtYnVzeSBuZy1zaG93PVxcXCJidXR0b24ucmlnaHRBbGlnbmVkXFxcIiBsb2FkaW5nPVxcXCJidXR0b24uc2F2aW5nXFxcIj48L3JsLWJ1c3k+XFxyXFxuXFx0PHNwYW4gbmctdHJhbnNjbHVkZT48L3NwYW4+XFxyXFxuXFx0PHJsLWJ1c3kgbmctaGlkZT1cXFwiYnV0dG9uLnJpZ2h0QWxpZ25lZFxcXCIgbG9hZGluZz1cXFwiYnV0dG9uLnNhdmluZ1xcXCI+PC9ybC1idXN5PlxcclxcbjwvYnV0dG9uPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2J1dHRvblN1Ym1pdC9idXR0b25TdWJtaXQuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19ib29sZWFuID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmJvb2xlYW47XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmJ1dHRvblRvZ2dsZSc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybEJ1dHRvblRvZ2dsZSc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQnV0dG9uVG9nZ2xlQ29udHJvbGxlcic7XHJcbnZhciBCdXR0b25Ub2dnbGVDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1dHRvblRvZ2dsZUNvbnRyb2xsZXIoJHNjb3BlLCBib29sKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzID0gJHNjb3BlLnR5cGUgIT0gbnVsbCA/ICRzY29wZS50eXBlIDogJ2RlZmF1bHQnO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uU2l6ZSA9ICRzY29wZS5zaXplICE9IG51bGwgPyAnYnRuLScgKyAkc2NvcGUuc2l6ZSA6IG51bGw7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaCgnbmdNb2RlbC4kbW9kZWxWYWx1ZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGJvb2wudG9Cb29sKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgXy5pc0Z1bmN0aW9uKCRzY29wZS5vblRvZ2dsZSkpIHtcclxuICAgICAgICAgICAgICAgICRzY29wZS5vblRvZ2dsZSh7IHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgQnV0dG9uVG9nZ2xlQ29udHJvbGxlci5wcm90b3R5cGUuY2xpY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLiRzY29wZS5uZ01vZGVsLiRzZXRWaWV3VmFsdWUoIXRoaXMuJHNjb3BlLm5nTW9kZWwuJHZpZXdWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQnV0dG9uVG9nZ2xlQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCBfX2Jvb2xlYW4uc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIEJ1dHRvblRvZ2dsZUNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGJ1dHRvblRvZ2dsZSgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICByZXF1aXJlOiAnXm5nTW9kZWwnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYnV0dG9uVG9nZ2xlLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2J1dHRvblRvZ2dsZScsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgdHlwZTogJ0AnLFxyXG4gICAgICAgICAgICBzaXplOiAnQCcsXHJcbiAgICAgICAgICAgIG9uVG9nZ2xlOiAnJicsXHJcbiAgICAgICAgICAgIGRpc2FibGVkOiAnPW5nRGlzYWJsZWQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xyXG4gICAgICAgICAgICBzY29wZS5uZ01vZGVsID0gbmdNb2RlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fYm9vbGVhbi5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBidXR0b25Ub2dnbGUpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBCdXR0b25Ub2dnbGVDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uVG9nZ2xlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9idXR0b25Ub2dnbGUvYnV0dG9uVG9nZ2xlLmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b25Ub2dnbGUuYnV0dG9uQ2xhc3N9fSB7e2J1dHRvblRvZ2dsZS5idXR0b25TaXplfX1cXFwiIFxcclxcblxcdFxcdG5nLWNsYXNzPVxcXCJ7IGFjdGl2ZSA6IGJ1dHRvblRvZ2dsZS5pc0FjdGl2ZSB9XFxcIiBuZy1jbGljaz1cXFwiYnV0dG9uVG9nZ2xlLmNsaWNrZWQoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRpc2FibGVkXFxcIj5cXHJcXG5cXHQ8aSBuZy1zaG93PVxcXCJidXR0b25Ub2dnbGUuaXNBY3RpdmVcXFwiIGNsYXNzPVxcXCJmYSBmYS1jaGVjayBjb21wbGV0ZWRcXFwiPjwvaT4gPHNwYW4gbmctdHJhbnNjbHVkZT48L3NwYW4+XFxyXFxuPC9idXR0b24+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvYnV0dG9uVG9nZ2xlL2J1dHRvblRvZ2dsZS5odG1sXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX19hcnJheSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIF9fcGFyZW50Q2hpbGQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucGFyZW50Q2hpbGRCZWhhdmlvcjtcclxudmFyIF9fZ2VuZXJpY1NlYXJjaEZpbHRlciA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5nZW5lcmljU2VhcmNoRmlsdGVyO1xyXG52YXIgY2FyZCA9IHJlcXVpcmUoJy4vY2FyZC9jYXJkJyk7XHJcbmV4cG9ydHMuY2FyZCA9IGNhcmQ7XHJcbnZhciBjYXJkU2VhcmNoID0gcmVxdWlyZSgnLi9jYXJkU2VhcmNoL2NhcmRTZWFyY2gnKTtcclxuZXhwb3J0cy5jYXJkU2VhcmNoID0gY2FyZFNlYXJjaDtcclxudmFyIGNvbHVtbkhlYWRlciA9IHJlcXVpcmUoJy4vY29sdW1uSGVhZGVyL2NvbHVtbkhlYWRlcicpO1xyXG5leHBvcnRzLmNvbHVtbkhlYWRlciA9IGNvbHVtbkhlYWRlcjtcclxudmFyIGRhdGFTb3VyY2VzID0gcmVxdWlyZSgnLi9kYXRhU291cmNlcy9kYXRhU291cmNlcy5tb2R1bGUnKTtcclxuZXhwb3J0cy5kYXRhU291cmNlcyA9IGRhdGFTb3VyY2VzO1xyXG52YXIgZmlsdGVycyA9IHJlcXVpcmUoJy4vZmlsdGVycy9maWx0ZXJzLm1vZHVsZScpO1xyXG5leHBvcnRzLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG52YXIgaXRlbUNvdW50ID0gcmVxdWlyZSgnLi9pdGVtQ291bnQvaXRlbUNvdW50Jyk7XHJcbmV4cG9ydHMuaXRlbUNvdW50ID0gaXRlbUNvdW50O1xyXG52YXIgcGFnZXIgPSByZXF1aXJlKCcuL3BhZ2VyL3BhZ2VyJyk7XHJcbmV4cG9ydHMucGFnZXIgPSBwYWdlcjtcclxudmFyIHBhZ2VTaXplID0gcmVxdWlyZSgnLi9wYWdlU2l6ZS9wYWdlU2l6ZScpO1xyXG5leHBvcnRzLnBhZ2VTaXplID0gcGFnZVNpemU7XHJcbnZhciBzZWxlY3Rpb25Db250cm9sID0gcmVxdWlyZSgnLi9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wnKTtcclxuZXhwb3J0cy5zZWxlY3Rpb25Db250cm9sID0gc2VsZWN0aW9uQ29udHJvbDtcclxudmFyIHNvcnRzID0gcmVxdWlyZSgnLi9zb3J0cy9zb3J0cy5tb2R1bGUnKTtcclxuZXhwb3J0cy5zb3J0cyA9IHNvcnRzO1xyXG52YXIgY2FyZENvbnRhaW5lcl8xID0gcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyJyk7XHJcbnZhciBidWlsZGVyID0gcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyQnVpbGRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuYnVpbGRlciA9IGJ1aWxkZXI7XHJcbnZhciBkZWZhdWx0Q29tcG9uZW50c18xID0gcmVxdWlyZSgnLi9kZWZhdWx0Q29tcG9uZW50cycpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2NhcmRDb250YWluZXInKSk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXInO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIC8vIGRlcGVuZGVuY2llc1xyXG4gICAgZGF0YVNvdXJjZXMuZGF0YVBhZ2VyLm1vZHVsZU5hbWUsXHJcbiAgICBfX29iamVjdC5tb2R1bGVOYW1lLFxyXG4gICAgX19hcnJheS5tb2R1bGVOYW1lLFxyXG4gICAgX19wYXJlbnRDaGlsZC5tb2R1bGVOYW1lLFxyXG4gICAgX19nZW5lcmljU2VhcmNoRmlsdGVyLm1vZHVsZU5hbWUsXHJcbiAgICAvLyBjb21wb25lbnRzXHJcbiAgICBjYXJkLm1vZHVsZU5hbWUsXHJcbiAgICBjYXJkU2VhcmNoLm1vZHVsZU5hbWUsXHJcbiAgICBjb2x1bW5IZWFkZXIubW9kdWxlTmFtZSxcclxuICAgIGl0ZW1Db3VudC5tb2R1bGVOYW1lLFxyXG4gICAgcGFnZXIubW9kdWxlTmFtZSxcclxuICAgIHBhZ2VTaXplLm1vZHVsZU5hbWUsXHJcbiAgICBzZWxlY3Rpb25Db250cm9sLm1vZHVsZU5hbWUsXHJcbiAgICAvLyBzdWJtb2R1bGVzXHJcbiAgICBkYXRhU291cmNlcy5tb2R1bGVOYW1lLFxyXG4gICAgZmlsdGVycy5tb2R1bGVOYW1lLFxyXG4gICAgc29ydHMubW9kdWxlTmFtZSxcclxuXSlcclxuICAgIC5jb21wb25lbnQoY2FyZENvbnRhaW5lcl8xLmNvbXBvbmVudE5hbWUsIGNhcmRDb250YWluZXJfMS5jYXJkQ29udGFpbmVyKVxyXG4gICAgLmNvbnRyb2xsZXIoY2FyZENvbnRhaW5lcl8xLmNvbnRyb2xsZXJOYW1lLCBjYXJkQ29udGFpbmVyXzEuQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIpXHJcbiAgICAuZmFjdG9yeShidWlsZGVyLmZhY3RvcnlOYW1lLCBidWlsZGVyLmNhcmRDb250YWluZXJCdWlsZGVyRmFjdG9yeSlcclxuICAgIC5jb21wb25lbnQoZGVmYXVsdENvbXBvbmVudHNfMS5oZWFkZXJDb21wb25lbnROYW1lLCBkZWZhdWx0Q29tcG9uZW50c18xLmRlZmF1bHRDb250YWluZXJIZWFkZXIpXHJcbiAgICAuY29tcG9uZW50KGRlZmF1bHRDb21wb25lbnRzXzEuZm9vdGVyQ29tcG9uZW50TmFtZSwgZGVmYXVsdENvbXBvbmVudHNfMS5kZWZhdWx0Q29udGFpbmVyRm9vdGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZENvbnRhaW5lci5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY2FyZENvbnRhaW5lci5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vLi4vdHlwaW5ncy9qcXVlcnkvanF1ZXJ5LmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBoZWFkZXJDb2x1bW5fbW9kdWxlXzEgPSByZXF1aXJlKCcuL2hlYWRlckNvbHVtbi9oZWFkZXJDb2x1bW4ubW9kdWxlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuY2FyZCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRDb250cm9sbGVyJztcclxudmFyIENhcmRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhcmRDb250cm9sbGVyKCRzY29wZSwgJGNvbnRyb2xsZXIsICRxLCBwYXJlbnRDaGlsZCwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLiRxID0gJHE7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZCA9IHBhcmVudENoaWxkO1xyXG4gICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZUxpbmsgPSB7fTtcclxuICAgICAgICB0aGlzLmF1dG9zYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2hvd0NvbnRlbnQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucGFyZW50Q2hpbGQudHJpZ2dlckNoaWxkQmVoYXZpb3IoX3RoaXMuYXV0b3NhdmVMaW5rLCBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvci5hdXRvc2F2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5jYXJkQXMpIHtcclxuICAgICAgICAgICAgJHNjb3BlW3RoaXMuY2FyZEFzXSA9IHRoaXMuaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHNjb3BlLmNvbGxhcHNlID0gdGhpcy5hdXRvc2F2ZTtcclxuICAgICAgICAkc2NvcGUuc2V0U2VsZWN0ZWQgPSB0aGlzLnNldFNlbGVjdGVkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgJHNjb3BlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdjYXJkLnJlZnJlc2gnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgICRzY29wZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZS5yZW1vdmUoX3RoaXMuaXRlbSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAkc2NvcGUuY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YTtcclxuICAgICAgICBpZiAob2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSh0aGlzLmNhcmRDb250cm9sbGVyKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSAkY29udHJvbGxlcih0aGlzLmNhcmRDb250cm9sbGVyLCB7ICRzY29wZTogJHNjb3BlIH0pO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZSh0aGlzLmNhcmRDb250cm9sbGVyQXMpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgJHNjb3BlW3RoaXMuY2FyZENvbnRyb2xsZXJBc10gPSBjb250cm9sbGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmVudENoaWxkLnJlZ2lzdGVyQ2hpbGRCZWhhdmlvcih0aGlzLml0ZW0sIHtcclxuICAgICAgICAgICAgY2xvc2U6IHRoaXMuYXV0b3NhdmUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLl9fc2V0SGFzQm9keSA9IGZ1bmN0aW9uIChoYXNCb2R5KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhc0JvZHkgPSBoYXNCb2R5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgJHNjb3BlLl9fc2V0SGFzRm9vdGVyID0gZnVuY3Rpb24gKGhhc0Zvb3Rlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5oYXNGb290ZXIgPSBoYXNGb290ZXI7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIENhcmRDb250cm9sbGVyLnByb3RvdHlwZS50b2dnbGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG93Q29udGVudCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0b3NhdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLnZhbGlkYXRlQ2FyZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLnBhcmVudENoaWxkLmdldENoaWxkQmVoYXZpb3IodGhpcy5pdGVtKTtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGJlaGF2aW9yLnZhbGlkYXRlQ2FyZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlaGF2aW9yLnZhbGlkYXRlQ2FyZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250cm9sbGVyLnByb3RvdHlwZS5zYXZlQ2FyZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLnBhcmVudENoaWxkLmdldENoaWxkQmVoYXZpb3IodGhpcy5pdGVtKTtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGJlaGF2aW9yLnNhdmVDYXJkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmVoYXZpb3Iuc2F2ZUNhcmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLndoZW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLmNsaWNrQ2FyZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkLnRyaWdnZXJDaGlsZEJlaGF2aW9yKHRoaXMuaXRlbSwgZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYmVoYXZpb3IuY2xpY2tDYXJkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlaGF2aW9yLmNsaWNrQ2FyZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZC50cmlnZ2VyQ2hpbGRCZWhhdmlvcih0aGlzLml0ZW0sIGZ1bmN0aW9uIChiZWhhdmlvcikge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGJlaGF2aW9yLmluaXRDYXJkKSkge1xyXG4gICAgICAgICAgICAgICAgYmVoYXZpb3IuaW5pdENhcmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLiRzY29wZS5fX3JsQ2FyZENvbnRhaW5lci5vcGVuQ2FyZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkQ29udHJvbGxlci5wcm90b3R5cGUuc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLml0ZW0udmlld0RhdGEpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbS52aWV3RGF0YSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLml0ZW0udmlld0RhdGEuc2VsZWN0ZWQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGNvbnRyb2xsZXInLCAnJHEnLCBfX3BhcmVudENoaWxkLnNlcnZpY2VOYW1lLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQ2FyZENvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ2FyZENvbnRyb2xsZXIgPSBDYXJkQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gY2FyZCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYXJkLmh0bWwnKSxcclxuICAgICAgICByZXF1aXJlOiAnXl5ybENhcmRDb250YWluZXInLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnX19jYXJkJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBjb2x1bW5zOiAnPScsXHJcbiAgICAgICAgICAgIGl0ZW06ICc9JyxcclxuICAgICAgICAgICAgY2xpY2thYmxlOiAnPScsXHJcbiAgICAgICAgICAgIHNvdXJjZTogJz0nLFxyXG4gICAgICAgICAgICBjb250YWluZXJEYXRhOiAnPScsXHJcbiAgICAgICAgICAgIGNhcmRDb250cm9sbGVyOiAnPScsXHJcbiAgICAgICAgICAgIGNhcmRDb250cm9sbGVyQXM6ICc9JyxcclxuICAgICAgICAgICAgY2FyZEFzOiAnPScsXHJcbiAgICAgICAgICAgIHBlcm1hbmVudEZvb3RlcjogJz0nLFxyXG4gICAgICAgICAgICBzZWxlY3RhYmxlOiAnPScsXHJcbiAgICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQ6ICcmJyxcclxuICAgICAgICAgICAgc2F2ZVdoZW5JbnZhbGlkOiAnPD8nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgcmxDYXJkQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLl9fcmxDYXJkQ29udGFpbmVyID0gcmxDYXJkQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBybENhcmRDb250YWluZXIubWFrZUNhcmQoc2NvcGUsIGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudEFyZWEgPSBlbGVtZW50LmZpbmQoJy5jb250ZW50LXRlbXBsYXRlJyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50QXJlYS5hcHBlbmQoY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzQm9keSA9IGNvbnRlbnQubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgIHNjb3BlLl9fc2V0SGFzQm9keShoYXNCb2R5KTtcclxuICAgICAgICAgICAgfSwgbnVsbCwgJ2NvbnRlbnRTbG90Jyk7XHJcbiAgICAgICAgICAgIHJsQ2FyZENvbnRhaW5lci5tYWtlQ2FyZChzY29wZSwgZnVuY3Rpb24gKGZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0Zvb3RlciA9IChmb290ZXIubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRm9vdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvb3RlckFyZWEgPSBlbGVtZW50LmZpbmQoJy5mb290ZXItdGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICBmb290ZXJBcmVhLmFwcGVuZChmb290ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2NvcGUuX19zZXRIYXNGb290ZXIoaGFzRm9vdGVyKTtcclxuICAgICAgICAgICAgfSwgbnVsbCwgJ2Zvb3RlclNsb3QnKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNhcmQgPSBjYXJkO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIF9fcGFyZW50Q2hpbGQubW9kdWxlTmFtZSxcclxuICAgIF9fb2JqZWN0Lm1vZHVsZU5hbWUsXHJcbiAgICBoZWFkZXJDb2x1bW5fbW9kdWxlXzEubW9kdWxlTmFtZSxcclxuXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBjYXJkKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQ2FyZENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvY2FyZC5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgaGVhZGVyQ29sdW1uXzEgPSByZXF1aXJlKCcuL2hlYWRlckNvbHVtbicpO1xyXG52YXIgc2l6ZUZvckJyZWFrcG9pbnRzXzEgPSByZXF1aXJlKCcuL3NpemVGb3JCcmVha3BvaW50cycpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmNhcmQuaGVhZGVyQ29sdW1uJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3RyaW5nLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuZGlyZWN0aXZlKHNpemVGb3JCcmVha3BvaW50c18xLnNpemVGb3JCcmVha3BvaW50c05hbWUsIHNpemVGb3JCcmVha3BvaW50c18xLnNpemVGb3JCcmVha3BvaW50cylcclxuICAgIC5kaXJlY3RpdmUoaGVhZGVyQ29sdW1uXzEuZGlyZWN0aXZlTmFtZSwgaGVhZGVyQ29sdW1uXzEuaGVhZGVyQ29sdW1uKVxyXG4gICAgLmNvbnRyb2xsZXIoaGVhZGVyQ29sdW1uXzEuY29udHJvbGxlck5hbWUsIGhlYWRlckNvbHVtbl8xLkhlYWRlckNvbHVtbkNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXJDb2x1bW4ubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvaGVhZGVyQ29sdW1uL2hlYWRlckNvbHVtbi5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy9qcXVlcnkvanF1ZXJ5LmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fdHJhbnNmb3JtID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnRyYW5zZm9ybS50cmFuc2Zvcm07XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmRIZWFkZXJDb2x1bW4nO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRIZWFkZXJDb2x1bW5Db250cm9sbGVyJztcclxudmFyIEhlYWRlckNvbHVtbkNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGVhZGVyQ29sdW1uQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IF9fdHJhbnNmb3JtLmdldFZhbHVlKF90aGlzLml0ZW0sIF90aGlzLmNvbHVtbi5nZXRWYWx1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICRzY29wZS4kb24oJ2NhcmQucmVmcmVzaCcsIHRoaXMudXBkYXRlKTsgLy8qZXZlbnQ/XHJcbiAgICB9XHJcbiAgICBIZWFkZXJDb2x1bW5Db250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIEhlYWRlckNvbHVtbkNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSGVhZGVyQ29sdW1uQ29udHJvbGxlciA9IEhlYWRlckNvbHVtbkNvbnRyb2xsZXI7XHJcbmhlYWRlckNvbHVtbi4kaW5qZWN0ID0gWyckY29tcGlsZSddO1xyXG5mdW5jdGlvbiBoZWFkZXJDb2x1bW4oJGNvbXBpbGUpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8ZGl2IHJsLXNpemUtZm9yLWJyZWFrcG9pbnRzPVxcXCJoZWFkZXIuY29sdW1uLnNpemVcXFwiIHRpdGxlPVxcXCJ7ezo6aGVhZGVyLmNvbHVtbi5kZXNjcmlwdGlvbn19XFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJ0ZW1wbGF0ZS1jb250YWluZXJcXFwiPjwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnaGVhZGVyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBjb2x1bW46ICc8JyxcclxuICAgICAgICAgICAgaXRlbTogJzwnLFxyXG4gICAgICAgICAgICBhbGlhczogJzwnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcHJlOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBoZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLmFsaWFzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVbaGVhZGVyLmFsaWFzXSA9IGhlYWRlci5pdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gaGVhZGVyLmNvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnRlbXBsYXRlVXJsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLnJlbmRlcmVkVGVtcGxhdGUgPSAkY29tcGlsZSgnPGRpdiBuZy1pbmNsdWRlPVwiXFwnJyArIGNvbHVtbi50ZW1wbGF0ZVVybCArICdcXCdcIj48L2Rpdj4nKShzY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbHVtbi50ZW1wbGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5yZW5kZXJlZFRlbXBsYXRlID0gJGNvbXBpbGUoY29sdW1uLnRlbXBsYXRlKShzY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIucmVuZGVyZWRUZW1wbGF0ZSA9ICRjb21waWxlKCc8c3Bhbj57e2hlYWRlci52YWx1ZX19PC9zcGFuPicpKHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcG9zdDogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGVsZW1lbnQuZmluZCgnLnRlbXBsYXRlLWNvbnRhaW5lcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmQoaGVhZGVyLnJlbmRlcmVkVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmhlYWRlckNvbHVtbiA9IGhlYWRlckNvbHVtbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyQ29sdW1uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvaGVhZGVyQ29sdW1uL2hlYWRlckNvbHVtbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3N0cmluZyA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5zdHJpbmc7XHJcbnZhciBicmVha3BvaW50XzEgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50Jyk7XHJcbmV4cG9ydHMuc2l6ZUZvckJyZWFrcG9pbnRzTmFtZSA9ICdybFNpemVGb3JCcmVha3BvaW50cyc7XHJcbnNpemVGb3JCcmVha3BvaW50cy4kaW5qZWN0ID0gWyckcGFyc2UnLCBfX3N0cmluZy5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIHNpemVGb3JCcmVha3BvaW50cygkcGFyc2UsIHN0cmluZ1V0aWxpdHkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBJyxcclxuICAgICAgICBsaW5rOiBsaW5rRGlyZWN0aXZlLFxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGxpbmtEaXJlY3RpdmUoc2NvcGUsIGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICB2YXIgc2l6ZXMgPSAkcGFyc2UoYXR0cmlidXRlcy5ybFNpemVGb3JCcmVha3BvaW50cykoc2NvcGUpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gW107XHJcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGdldENvbHVtbkNsYXNzKHNpemVzLCBicmVha3BvaW50XzEueHMpKTtcclxuICAgICAgICBjbGFzc2VzLnB1c2goZ2V0Q29sdW1uQ2xhc3Moc2l6ZXMsIGJyZWFrcG9pbnRfMS5zbSkpO1xyXG4gICAgICAgIGNsYXNzZXMucHVzaChnZXRDb2x1bW5DbGFzcyhzaXplcywgYnJlYWtwb2ludF8xLm1kKSk7XHJcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGdldENvbHVtbkNsYXNzKHNpemVzLCBicmVha3BvaW50XzEubGcpKTtcclxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKGNsYXNzZXMuam9pbignICcpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbHVtbkNsYXNzKGNvbHVtblNpemVzLCBicmVha3BvaW50KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gY29sdW1uU2l6ZXNbYnJlYWtwb2ludF07XHJcbiAgICAgICAgaWYgKHZhbHVlID4gMCAmJiB2YWx1ZSAhPT0gJ2hpZGRlbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1V0aWxpdHkuc3Vic3RpdHV0ZSgnY29sLXswfS17MX0nLCBicmVha3BvaW50LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2hpZGRlbi0nICsgYnJlYWtwb2ludDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zaXplRm9yQnJlYWtwb2ludHMgPSBzaXplRm9yQnJlYWtwb2ludHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpemVGb3JCcmVha3BvaW50cy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkL2hlYWRlckNvbHVtbi9zaXplRm9yQnJlYWtwb2ludHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmxnID0gJ2xnJztcclxuZXhwb3J0cy5tZCA9ICdtZCc7XHJcbmV4cG9ydHMuc20gPSAnc20nO1xyXG5leHBvcnRzLnhzID0gJ3hzJztcclxuZXhwb3J0cy5hbGwgPSBbZXhwb3J0cy54cywgZXhwb3J0cy5zbSwgZXhwb3J0cy5tZCwgZXhwb3J0cy5sZ107XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFrcG9pbnQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9icmVha3BvaW50cy9icmVha3BvaW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8cmwtZ2VuZXJpYy1jb250YWluZXIgc2VsZWN0b3I9XFxcIl9fY2FyZC5zZWxlY3RhYmxlXFxcIj5cXHJcXG5cXHQ8dGVtcGxhdGUgd2hlbi1zZWxlY3Rvcj1cXFwiZmFsc2VcXFwiIGRlZmF1bHQ+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZFxcXCIgbmctY2xhc3M9XFxcInsgJ3NlbGVjdGVkJzogX19jYXJkLml0ZW0udmlld0RhdGEuc2VsZWN0ZWQgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIiBuZy1jbGljaz1cXFwiX19jYXJkLnRvZ2dsZUNvbnRlbnQoKVxcXCIgbmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IF9fY2FyZC5oYXNCb2R5IHx8ICFfX2NhcmQucGVybWFuZW50Rm9vdGVyIH1cXFwiPlxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1yZXBlYXQ9XFxcImNvbHVtbiBpbiBfX2NhcmQuY29sdW1uc1xcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHJsLWNhcmQtaGVhZGVyLWNvbHVtbiBjb2x1bW49XFxcImNvbHVtblxcXCIgaXRlbT1cXFwiX19jYXJkLml0ZW1cXFwiIGFsaWFzPVxcXCJfX2NhcmQuY2FyZEFzXFxcIj48L3JsLWNhcmQtaGVhZGVyLWNvbHVtbj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcIl9fY2FyZC5zaG93Q29udGVudFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PG5nLWZvcm0gcmwtYXV0b3NhdmU9XFxcIl9fY2FyZC5hdXRvc2F2ZUxpbmtcXFwiIHNhdmU9XFxcIl9fY2FyZC5zYXZlQ2FyZCgpXFxcIiBzYXZlLXdoZW4taW52YWxpZD1cXFwiX19jYXJkLnNhdmVXaGVuSW52YWxpZFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiYm9keVxcXCIgbmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IF9fY2FyZC5jbGlja2FibGUgfVxcXCIgbmctY2xpY2s9XFxcIl9fY2FyZC5jbGlja0NhcmQoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDwvbmctZm9ybT5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcIl9fY2FyZC5oYXNGb290ZXIgJiYgKF9fY2FyZC5zaG93Q29udGVudCB8fCBfX2NhcmQucGVybWFuZW50Rm9vdGVyKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9vdGVyXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb290ZXItdGVtcGxhdGVcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3RlbXBsYXRlPlxcclxcblxcdDx0ZW1wbGF0ZSB3aGVuLXNlbGVjdG9yPVxcXCJ0cnVlXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtZ3JvdXBcXFwiPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInNlbGVjdC1jb2x1bW5cXFwiPlxcclxcblxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgY2xhc3M9XFxcInN0YW5kLWFsb25lLWNoZWNrYm94XFxcIiBuZy1tb2RlbD1cXFwiX19jYXJkLml0ZW0udmlld0RhdGEuc2VsZWN0ZWRcXFwiIG5nLWNoYW5nZT1cXFwiX19jYXJkLnNlbGVjdGlvbkNoYW5nZWQoKVxcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHQgICBuZy1kaXNhYmxlZD1cXFwiX19jYXJkLml0ZW0udmlld0RhdGEuZGlzYWJsZWRTZWxlY3Rpb25cXFwiIHRpdGxlPVxcXCJ7e19fY2FyZC5pdGVtLnZpZXdEYXRhLnNlbGVjdGlvblRpdGxlfX1cXFwiIC8+XFxyXFxuXFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic2VsZWN0LWNvbnRlbnRcXFwiPlxcclxcblxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQgc2VsZWN0YWJsZVxcXCIgbmctY2xhc3M9XFxcInsgJ3NlbGVjdGVkJzogX19jYXJkLml0ZW0udmlld0RhdGEuc2VsZWN0ZWQgfVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaGVhZGVyIGFjdGl2ZVxcXCIgbmctY2xpY2s9XFxcIl9fY2FyZC50b2dnbGVDb250ZW50KClcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1yZXBlYXQ9XFxcImNvbHVtbiBpbiBfX2NhcmQuY29sdW1uc1xcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PHJsLWNhcmQtaGVhZGVyLWNvbHVtbiBjb2x1bW49XFxcImNvbHVtblxcXCIgaXRlbT1cXFwiX19jYXJkLml0ZW1cXFwiPjwvcmwtY2FyZC1oZWFkZXItY29sdW1uPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwiX19jYXJkLnNob3dDb250ZW50XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8bmctZm9ybSBybC1hdXRvc2F2ZT1cXFwiX19jYXJkLmF1dG9zYXZlTGlua1xcXCIgc2F2ZT1cXFwiX19jYXJkLnNhdmVDYXJkKClcXFwiIHNhdmUtd2hlbi1pbnZhbGlkPVxcXCJfX2NhcmQuc2F2ZVdoZW5JbnZhbGlkXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJib2R5XFxcIiBuZy1jbGFzcz1cXFwieyAnYWN0aXZlJzogX19jYXJkLmNsaWNrYWJsZSB9XFxcIiBuZy1jbGljaz1cXFwiX19jYXJkLmNsaWNrQ2FyZCgpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb250ZW50LXRlbXBsYXRlXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9uZy1mb3JtPlxcclxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctc2hvdz1cXFwiX19jYXJkLmhhc0Zvb3RlciAmJiAoX19jYXJkLnNob3dDb250ZW50IHx8IF9fY2FyZC5wZXJtYW5lbnRGb290ZXIpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmb290ZXJcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImZvb3Rlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvdGVtcGxhdGU+XFxyXFxuPC9ybC1nZW5lcmljLWNvbnRhaW5lcj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmQvY2FyZC5odG1sXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuY2FyZFNlYXJjaCc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybENhcmRTZWFyY2gnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0NhcmRTZWFyY2hDb250cm9sbGVyJztcclxuZXhwb3J0cy5kZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXIgPSAnU2VhcmNoJztcclxuZXhwb3J0cy5kZWZhdWx0U2VhcmNoRGVsYXkgPSAxMDAwO1xyXG52YXIgQ2FyZFNlYXJjaENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZFNlYXJjaENvbnRyb2xsZXIoJHNjb3BlLCAkdGltZW91dCkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuJHRpbWVvdXQgPSAkdGltZW91dDtcclxuICAgICAgICB0aGlzLnNlYXJjaExlbmd0aEVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oYXNTZWFyY2hGaWx0ZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgQ2FyZFNlYXJjaENvbnRyb2xsZXIucHJvdG90eXBlLiRvbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5jYXJkQ29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1pblNlYXJjaEVycm9yID0gJ1lvdSBtdXN0IGVudGVyIGF0IGxlYXN0IHt7Y2FyZFNlYXJjaC5taW5TZWFyY2hMZW5ndGh9fSBjaGFyYWN0ZXJzIHRvIHBlcmZvcm0gYSBzZWFyY2gnO1xyXG4gICAgICAgIGlmICh0aGlzLnNlYXJjaEZpbHRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmNhcmRDb250YWluZXIuc2VhcmNoRmlsdGVyO1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEZpbHRlciA9IGZpbHRlcjtcclxuICAgICAgICAgICAgaWYgKGZpbHRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1NlYXJjaEZpbHRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhhc1NlYXJjaEZpbHRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaFBsYWNlaG9sZGVyID0gZXhwb3J0cy5kZWZhdWx0U2VhcmNoUGxhY2Vob2xkZXI7XHJcbiAgICAgICAgICAgIHZhciBkYXRhU291cmNlID0gdGhpcy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2U7XHJcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMuZGVsYXkgIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRlbGF5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9ydHMuZGVmYXVsdFNlYXJjaERlbGF5O1xyXG4gICAgICAgICAgICB2YXIgdGltZXI7XHJcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWFyY2hUZXh0OyB9LCBmdW5jdGlvbiAoc2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dCA9IHNlYXJjaDtcclxuICAgICAgICAgICAgICAgIF90aGlzLm1pblNlYXJjaExlbmd0aCA9IF90aGlzLnNlYXJjaEZpbHRlci5taW5TZWFyY2hMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YWxpZGF0ZVNlYXJjaExlbmd0aChzZWFyY2gsIF90aGlzLm1pblNlYXJjaExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLiR0aW1lb3V0LmNhbmNlbCh0aW1lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aW1lciA9IF90aGlzLiR0aW1lb3V0KGRhdGFTb3VyY2UucmVmcmVzaC5iaW5kKGRhdGFTb3VyY2UpLCBkZWxheSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLiRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlYXJjaEZpbHRlci5zZWFyY2hUZXh0O1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWFyY2hUZXh0ID0gX3RoaXMuc2VhcmNoRmlsdGVyLnNlYXJjaFRleHQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkU2VhcmNoQ29udHJvbGxlci5wcm90b3R5cGUudmFsaWRhdGVTZWFyY2hMZW5ndGggPSBmdW5jdGlvbiAoc2VhcmNoLCBtaW5MZW5ndGgpIHtcclxuICAgICAgICAvLyBzaG93IGVycm9yIGlmIHNlYXJjaCBzdHJpbmcgZXhpc3RzIGJ1dCBpcyBiZWxvdyBtaW5pbXVtIHNpemVcclxuICAgICAgICB0aGlzLnNlYXJjaExlbmd0aEVycm9yID0gc2VhcmNoICE9IG51bGxcclxuICAgICAgICAgICAgJiYgc2VhcmNoLmxlbmd0aCA+IDBcclxuICAgICAgICAgICAgJiYgc2VhcmNoLmxlbmd0aCA8IG1pbkxlbmd0aDtcclxuICAgIH07XHJcbiAgICBDYXJkU2VhcmNoQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJHRpbWVvdXQnXTtcclxuICAgIHJldHVybiBDYXJkU2VhcmNoQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5DYXJkU2VhcmNoQ29udHJvbGxlciA9IENhcmRTZWFyY2hDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBjYXJkU2VhcmNoKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6IHsgY2FyZENvbnRhaW5lcjogJz9eXnJsQ2FyZENvbnRhaW5lcicgfSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYXJkU2VhcmNoLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2NhcmRTZWFyY2gnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGRlbGF5OiAnPXNlYXJjaERlbGF5JyxcclxuICAgICAgICAgICAgc2VhcmNoRmlsdGVyOiAnPT8nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY2FyZFNlYXJjaCA9IGNhcmRTZWFyY2g7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgY2FyZFNlYXJjaClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIENhcmRTZWFyY2hDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZFNlYXJjaC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkU2VhcmNoL2NhcmRTZWFyY2guanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIiBuZy1zaG93PVxcXCJjYXJkU2VhcmNoLmhhc1NlYXJjaEZpbHRlclxcXCIgbmctY2xhc3M9XFxcInsgJ2hhcy1lcnJvcic6IGNhcmRTZWFyY2guc2VhcmNoTGVuZ3RoRXJyb3IgfVxcXCI+XFxyXFxuXFx0PGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7e2NhcmRTZWFyY2guc2VhcmNoUGxhY2Vob2xkZXJ9fVxcXCIgbmctbW9kZWw9XFxcImNhcmRTZWFyY2guc2VhcmNoVGV4dFxcXCJcXHJcXG5cXHRcXHQgICBybC1wb3BvdmVyPVxcXCJjYXJkU2VhcmNoLm1pblNlYXJjaEVycm9yXFxcIiBwb3BvdmVyLXRyaWdnZXI9XFxcIm1vdXNlZW50ZXJcXFwiIHBvcG92ZXItZW5hYmxlPVxcXCJjYXJkU2VhcmNoLnNlYXJjaExlbmd0aEVycm9yXFxcIiAvPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxyXFxuXFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWRpc2FibGVkPVxcXCJjYXJkU2VhcmNoLnNlYXJjaFRleHQgfCBpc0VtcHR5XFxcIiBuZy1jbGljaz1cXFwiY2FyZFNlYXJjaC5zZWFyY2hUZXh0ID0gbnVsbFxcXCI+XFxyXFxuXFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzXFxcIj48L2k+XFxyXFxuXFx0XFx0PC9idXR0b24+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkU2VhcmNoL2NhcmRTZWFyY2guaHRtbFxuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi90eXBpbmdzL2pxdWVyeS9qcXVlcnkuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHNvcnREaXJlY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3NvcnRzL3NvcnREaXJlY3Rpb24nKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5jb2x1bW5IZWFkZXInO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxDb2x1bW5IZWFkZXInO1xyXG5jYXJkQ29sdW1uSGVhZGVyLiRpbmplY3QgPSBbJyRjb21waWxlJ107XHJcbmZ1bmN0aW9uIGNhcmRDb2x1bW5IZWFkZXIoJGNvbXBpbGUpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8ZGl2IHJsLXNpemUtZm9yLWJyZWFrcG9pbnRzPVxcXCJjb2x1bW4uc2l6ZVxcXCIgbmctY2xpY2s9XFxcInNvcnQoKVxcXCIgdGl0bGU9XFxcInt7Ojpjb2x1bW4uZGVzY3JpcHRpb259fVxcXCJcXG5cXHRcXHRcXHRcXHRcXHRjbGFzcz1cXFwiY29sdW1uLWhlYWRlclxcXCI+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwidGVtcGxhdGUtY29udGFpbmVyXFxcIj48L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8aSBuZy1zaG93PVxcXCJzb3J0aW5nID09PSBzb3J0RGlyZWN0aW9uLmFzY2VuZGluZ1xcXCIgY2xhc3M9XFxcImZhIGZhLXNvcnQtYXNjXFxcIj48L2k+XFxuXFx0XFx0XFx0XFx0PGkgbmctc2hvdz1cXFwic29ydGluZyA9PT0gc29ydERpcmVjdGlvbi5kZXNjZW5kaW5nXFxcIiBjbGFzcz1cXFwiZmEgZmEtc29ydC1kZXNjXFxcIj48L2k+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgY29sdW1uOiAnPScsXHJcbiAgICAgICAgICAgIHNvcnRpbmc6ICc9JyxcclxuICAgICAgICAgICAgc29ydDogJyYnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcHJlOiBmdW5jdGlvbiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gc2NvcGUuY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uaGVhZGVyVGVtcGxhdGVVcmwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5yZW5kZXJlZFRlbXBsYXRlID0gJGNvbXBpbGUoJzxkaXYgbmctaW5jbHVkZT1cIlxcJycgKyBjb2x1bW4uaGVhZGVyVGVtcGxhdGVVcmwgKyAnXFwnXCI+PC9kaXY+Jykoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2x1bW4uaGVhZGVyVGVtcGxhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5yZW5kZXJlZFRlbXBsYXRlID0gJGNvbXBpbGUoY29sdW1uLmhlYWRlclRlbXBsYXRlKShzY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5yZW5kZXJlZFRlbXBsYXRlID0gKCc8aDU+JyArIGNvbHVtbi5sYWJlbCArICc8L2g1Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHBvc3Q6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5jb2x1bW4uZGlzcGxheUNvbHVtbkhlYWRlciAhPSBudWxsICYmIHNjb3BlLmNvbHVtbi5kaXNwbGF5Q29sdW1uSGVhZGVyID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBlbGVtZW50LmZpbmQoJy50ZW1wbGF0ZS1jb250YWluZXInKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKHNjb3BlLnJlbmRlcmVkVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnNvcnREaXJlY3Rpb24gPSBzb3J0RGlyZWN0aW9uXzEuU29ydERpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNhcmRDb2x1bW5IZWFkZXIgPSBjYXJkQ29sdW1uSGVhZGVyO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGNhcmRDb2x1bW5IZWFkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2x1bW5IZWFkZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvY29sdW1uSGVhZGVyL2NvbHVtbkhlYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBTb3J0RGlyZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNvcnREaXJlY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBTb3J0RGlyZWN0aW9uLnRvZ2dsZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBTb3J0RGlyZWN0aW9uLmFzY2VuZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gU29ydERpcmVjdGlvbi5kZXNjZW5kaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFNvcnREaXJlY3Rpb24uZGVzY2VuZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gU29ydERpcmVjdGlvbi5ub25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnREaXJlY3Rpb24uYXNjZW5kaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTb3J0RGlyZWN0aW9uLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBTb3J0RGlyZWN0aW9uLmFzY2VuZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gU29ydERpcmVjdGlvbi5kZXNjZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGVzY2VuZGluZyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTb3J0RGlyZWN0aW9uLm5vbmUgPSBuZXcgU29ydERpcmVjdGlvbigwKTtcclxuICAgIFNvcnREaXJlY3Rpb24uYXNjZW5kaW5nID0gbmV3IFNvcnREaXJlY3Rpb24oMSk7XHJcbiAgICBTb3J0RGlyZWN0aW9uLmRlc2NlbmRpbmcgPSBuZXcgU29ydERpcmVjdGlvbigyKTtcclxuICAgIHJldHVybiBTb3J0RGlyZWN0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLlNvcnREaXJlY3Rpb24gPSBTb3J0RGlyZWN0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0RGlyZWN0aW9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnREaXJlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIHNvcnRzX21vZHVsZV8xID0gcmVxdWlyZSgnLi4vc29ydHMvc29ydHMubW9kdWxlJyk7XHJcbnZhciBjbGllbnRTZXJ2ZXJEYXRhU291cmNlID0gcmVxdWlyZSgnLi9jbGllbnRTZXJ2ZXJEYXRhU291cmNlL2NsaWVudFNlcnZlckRhdGFTb3VyY2Uuc2VydmljZScpO1xyXG5leHBvcnRzLmNsaWVudFNlcnZlckRhdGFTb3VyY2UgPSBjbGllbnRTZXJ2ZXJEYXRhU291cmNlO1xyXG52YXIgZGF0YVBhZ2VyID0gcmVxdWlyZSgnLi9kYXRhUGFnZXIvZGF0YVBhZ2VyLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kYXRhUGFnZXIgPSBkYXRhUGFnZXI7XHJcbnZhciBkYXRhU2VydmljZURhdGFTb3VyY2UgPSByZXF1aXJlKCcuL2RhdGFTZXJ2aWNlRGF0YVNvdXJjZS9kYXRhU2VydmljZURhdGFTb3VyY2Uuc2VydmljZScpO1xyXG5leHBvcnRzLmRhdGFTZXJ2aWNlRGF0YVNvdXJjZSA9IGRhdGFTZXJ2aWNlRGF0YVNvdXJjZTtcclxudmFyIHNlcnZlclNpZGVEYXRhU291cmNlID0gcmVxdWlyZSgnLi9zZXJ2ZXJTaWRlRGF0YVNvdXJjZS9zZXJ2ZXJTaWRlRGF0YVNvdXJjZS5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuc2VydmVyU2lkZURhdGFTb3VyY2UgPSBzZXJ2ZXJTaWRlRGF0YVNvdXJjZTtcclxudmFyIHNpbXBsZURhdGFTb3VyY2UgPSByZXF1aXJlKCcuL3NpbXBsZURhdGFTb3VyY2Uvc2ltcGxlRGF0YVNvdXJjZS5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuc2ltcGxlRGF0YVNvdXJjZSA9IHNpbXBsZURhdGFTb3VyY2U7XHJcbnZhciBzbWFydERhdGFTb3VyY2UgPSByZXF1aXJlKCcuL3NtYXJ0RGF0YVNvdXJjZS9zbWFydERhdGFTb3VyY2Uuc2VydmljZScpO1xyXG5leHBvcnRzLnNtYXJ0RGF0YVNvdXJjZSA9IHNtYXJ0RGF0YVNvdXJjZTtcclxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vZGF0YVNvdXJjZUV2ZW50cycpO1xyXG5leHBvcnRzLmV2ZW50cyA9IGV2ZW50cztcclxudmFyIGRhdGFTb3VyY2VQcm9jZXNzb3IgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZScpO1xyXG5leHBvcnRzLmRhdGFTb3VyY2VQcm9jZXNzb3IgPSBkYXRhU291cmNlUHJvY2Vzc29yO1xyXG52YXIgZGF0YVNvdXJjZUJhc2UgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kYXRhU291cmNlQmFzZSA9IGRhdGFTb3VyY2VCYXNlO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2VzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0Lm1vZHVsZU5hbWUsXHJcbiAgICBzb3J0c19tb2R1bGVfMS5tb2R1bGVOYW1lLFxyXG4gICAgY2xpZW50U2VydmVyRGF0YVNvdXJjZS5tb2R1bGVOYW1lLFxyXG4gICAgZGF0YVBhZ2VyLm1vZHVsZU5hbWUsXHJcbiAgICBkYXRhU2VydmljZURhdGFTb3VyY2UubW9kdWxlTmFtZSxcclxuICAgIHNlcnZlclNpZGVEYXRhU291cmNlLm1vZHVsZU5hbWUsXHJcbiAgICBzaW1wbGVEYXRhU291cmNlLm1vZHVsZU5hbWUsXHJcbiAgICBzbWFydERhdGFTb3VyY2UubW9kdWxlTmFtZSxcclxuXSlcclxuICAgIC5zZXJ2aWNlKGRhdGFTb3VyY2VQcm9jZXNzb3IucHJvY2Vzc29yU2VydmljZU5hbWUsIGRhdGFTb3VyY2VQcm9jZXNzb3IuRGF0YVNvdXJjZVByb2Nlc3Nvcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFTb3VyY2VzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlcy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBtZXJnZVNvcnQgPSByZXF1aXJlKCcuL21lcmdlU29ydC9tZXJnZVNvcnQuc2VydmljZScpO1xyXG5leHBvcnRzLm1lcmdlU29ydCA9IG1lcmdlU29ydDtcclxudmFyIHNvcnRlciA9IHJlcXVpcmUoJy4vc29ydGVyL3NvcnRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuc29ydGVyID0gc29ydGVyO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NvcnQnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vc29ydERpcmVjdGlvbicpKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5zb3J0cyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgbWVyZ2VTb3J0Lm1vZHVsZU5hbWUsXHJcbiAgICBzb3J0ZXIubW9kdWxlTmFtZSxcclxuXSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0cy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5zb3J0cy5tZXJnZVNvcnQnO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ21lcmdlU29ydCc7XHJcbnZhciBNZXJnZVNvcnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWVyZ2VTb3J0KCkge1xyXG4gICAgfVxyXG4gICAgTWVyZ2VTb3J0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGRhdGEsIGNvbXBhcmUpIHtcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcGFyZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbXBhcmUgPSB0aGlzLmRlZmF1bHRDb21wYXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWlkO1xyXG4gICAgICAgIHZhciBsZWZ0O1xyXG4gICAgICAgIHZhciByaWdodDtcclxuICAgICAgICBtaWQgPSBkYXRhLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgbGVmdCA9IHRoaXMuc29ydChkYXRhLnNsaWNlKDAsIG1pZCksIGNvbXBhcmUpO1xyXG4gICAgICAgIHJpZ2h0ID0gdGhpcy5zb3J0KGRhdGEuc2xpY2UobWlkLCBkYXRhLmxlbmd0aCksIGNvbXBhcmUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJlKTtcclxuICAgIH07XHJcbiAgICBNZXJnZVNvcnQucHJvdG90eXBlLmRlZmF1bHRDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSA8IGJcclxuICAgICAgICAgICAgPyB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5sZXNzXHJcbiAgICAgICAgICAgIDogKGEgPiBiID8gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZ3JlYXRlciA6IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0LmVxdWFsKTtcclxuICAgIH07XHJcbiAgICBNZXJnZVNvcnQucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChsZWZ0Lmxlbmd0aCAmJiByaWdodC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmUobGVmdFswXSwgcmlnaHRbMF0pID09PSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEudHlwZXMuQ29tcGFyZVJlc3VsdC5ncmVhdGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyaWdodC5zaGlmdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIGVxdWFsIGl0IHNob3VsZCBwcmVzZXJ2ZSBzYW1lIG9yZGVyIChzdGFibGUpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsZWZ0LnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZWZ0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmlnaHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNZXJnZVNvcnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTWVyZ2VTb3J0ID0gTWVyZ2VTb3J0O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLnNlcnZpY2UoZXhwb3J0cy5zZXJ2aWNlTmFtZSwgTWVyZ2VTb3J0KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VTb3J0LnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvc29ydHMvbWVyZ2VTb3J0L21lcmdlU29ydC5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3RyYW5zZm9ybSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy50cmFuc2Zvcm0udHJhbnNmb3JtO1xyXG52YXIgc29ydERpcmVjdGlvbl8xID0gcmVxdWlyZSgnLi4vc29ydERpcmVjdGlvbicpO1xyXG52YXIgbWVyZ2VTb3J0X3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL21lcmdlU29ydC9tZXJnZVNvcnQuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnNvcnRzLnNvcnRlcic7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAnc29ydGVyJztcclxudmFyIFNvcnRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTb3J0ZXIobWVyZ2VTb3J0KSB7XHJcbiAgICAgICAgdGhpcy5tZXJnZVNvcnQgPSBtZXJnZVNvcnQ7XHJcbiAgICB9XHJcbiAgICBTb3J0ZXIucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZGF0YSwgc29ydCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHNvcnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfLmlzQXJyYXkoc29ydCkpIHtcclxuICAgICAgICAgICAgdmFyIHJldmVyc2VTb3J0cyA9IF8uY2xvbmUoc29ydCk7XHJcbiAgICAgICAgICAgIHJldmVyc2VTb3J0cy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnJlZHVjZShyZXZlcnNlU29ydHMsIGZ1bmN0aW9uIChzb3J0ZWREYXRhLCBuZXh0U29ydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNpbmdsZVNvcnQoc29ydGVkRGF0YSwgbmV4dFNvcnQpO1xyXG4gICAgICAgICAgICB9LCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2luZ2xlU29ydChkYXRhLCBzb3J0KTtcclxuICAgIH07XHJcbiAgICBTb3J0ZXIucHJvdG90eXBlLnNpbmdsZVNvcnQgPSBmdW5jdGlvbiAoZGF0YSwgc29ydCkge1xyXG4gICAgICAgIHZhciBjb21wYXJlRnVuY3Rpb24gPSB0aGlzLmJ1aWxkU29ydEZ1bmN0aW9uKHNvcnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlU29ydC5zb3J0KGRhdGEsIGNvbXBhcmVGdW5jdGlvbik7XHJcbiAgICB9O1xyXG4gICAgU29ydGVyLnByb3RvdHlwZS5idWlsZFNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChzb3J0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3J0LmRpcmVjdGlvbiA9PT0gc29ydERpcmVjdGlvbl8xLlNvcnREaXJlY3Rpb24ubm9uZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0LmVxdWFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU9mQSA9IF9fdHJhbnNmb3JtLmdldFZhbHVlKGEsIHNvcnQuY29sdW1uLmdldFZhbHVlKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlT2ZCID0gX190cmFuc2Zvcm0uZ2V0VmFsdWUoYiwgc29ydC5jb2x1bW4uZ2V0VmFsdWUpO1xyXG4gICAgICAgICAgICB2YXIgZ3JlYXRlclJlc3VsdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0LmdyZWF0ZXI7XHJcbiAgICAgICAgICAgIHZhciBsZXNzUmVzdWx0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQubGVzcztcclxuICAgICAgICAgICAgdmFyIGRlc2NlbmRpbmdTb3J0ID0gKHNvcnQuZGlyZWN0aW9uID09PSBzb3J0RGlyZWN0aW9uXzEuU29ydERpcmVjdGlvbi5kZXNjZW5kaW5nKTtcclxuICAgICAgICAgICAgdmFyIGZsaXAgPSBzb3J0LmNvbHVtbi5mbGlwU29ydDtcclxuICAgICAgICAgICAgLy8gRXhjbHVzaXZlIE9SLi4uIGlmIGZsaXBwaW5nIGEgZGVzY2VuZGluZyBzb3J0LCB5b3UgZ2V0IGFuIGFzY2VuZGluZyBzb3J0XHJcbiAgICAgICAgICAgIGlmICgoZGVzY2VuZGluZ1NvcnQgfHwgZmxpcCkgJiYgIShkZXNjZW5kaW5nU29ydCAmJiBmbGlwKSkge1xyXG4gICAgICAgICAgICAgICAgZ3JlYXRlclJlc3VsdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0Lmxlc3M7XHJcbiAgICAgICAgICAgICAgICBsZXNzUmVzdWx0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnR5cGVzLkNvbXBhcmVSZXN1bHQuZ3JlYXRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVPZkEgPiB2YWx1ZU9mQlxyXG4gICAgICAgICAgICAgICAgPyBncmVhdGVyUmVzdWx0XHJcbiAgICAgICAgICAgICAgICA6ICh2YWx1ZU9mQSA8IHZhbHVlT2ZCID8gbGVzc1Jlc3VsdCA6IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS50eXBlcy5Db21wYXJlUmVzdWx0LmVxdWFsKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNvcnRlci4kaW5qZWN0ID0gW21lcmdlU29ydF9zZXJ2aWNlXzEuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFNvcnRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Tb3J0ZXIgPSBTb3J0ZXI7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBTb3J0ZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0ZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zb3J0cy9zb3J0ZXIvc29ydGVyLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuX19leHBvcnQocmVxdWlyZSgnLi9zb3J0RGlyZWN0aW9uJykpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NvcnRzL3NvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgX19hcnJheSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fc3luY2hyb25pemVkUmVxdWVzdHMgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3luY2hyb25pemVkUmVxdWVzdHM7XHJcbnZhciBhc3luY0RhdGFTb3VyY2Vfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vYXN5bmNEYXRhU291cmNlLnNlcnZpY2UnKTtcclxudmFyIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMuY2xpZW50U2VydmVyRGF0YVNvdXJjZSc7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnY2xpZW50U2VydmVyRGF0YVNvdXJjZSc7XHJcbnZhciBDbGllbnRTZXJ2ZXJEYXRhU291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDbGllbnRTZXJ2ZXJEYXRhU291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2xpZW50U2VydmVyRGF0YVNvdXJjZShnZXREYXRhU2V0LCBzZWFyY2hGaWx0ZXIsIGdldEZpbHRlck1vZGVsLCB2YWxpZGF0ZU1vZGVsLCBvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksIG9iamVjdCwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZ2V0RGF0YVNldCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBzeW5jaHJvbml6ZWRSZXF1ZXN0c0ZhY3RvcnkpO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoRmlsdGVyID0gc2VhcmNoRmlsdGVyO1xyXG4gICAgICAgIHRoaXMuZ2V0RmlsdGVyTW9kZWwgPSBnZXRGaWx0ZXJNb2RlbDtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlTW9kZWwgPSB2YWxpZGF0ZU1vZGVsO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMubWluU2VhcmNoTGVuZ3RoID0gNDtcclxuICAgICAgICB0aGlzLmdldEZpbHRlck1vZGVsID0gdGhpcy5nZXRGaWx0ZXJNb2RlbCB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVNb2RlbCA9IHRoaXMudmFsaWRhdGVNb2RlbCB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xyXG4gICAgICAgIHRoaXMuY291bnRGaWx0ZXJHcm91cHMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2VhcmNoRmlsdGVyLnNlYXJjaFRleHQ7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJNb2RlbCA9IF8uY2xvbmUodGhpcy5nZXRGaWx0ZXJNb2RlbCgpKTtcclxuICAgICAgICBzZWFyY2hGaWx0ZXIubWluU2VhcmNoTGVuZ3RoID0gdGhpcy5taW5TZWFyY2hMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBDbGllbnRTZXJ2ZXJEYXRhU291cmNlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlYXJjaEZpbHRlci5zZWFyY2hUZXh0ICE9PSB0aGlzLnNlYXJjaFxyXG4gICAgICAgICAgICB8fCB0aGlzLmZpbHRlck1vZGVsQ2hhbmdlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlZnJlc2guY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2xpZW50U2VydmVyRGF0YVNvdXJjZS5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2VhcmNoID0gdGhpcy5zZWFyY2hGaWx0ZXIuc2VhcmNoVGV4dDtcclxuICAgICAgICB0aGlzLmZpbHRlck1vZGVsID0gXy5jbG9uZSh0aGlzLmdldEZpbHRlck1vZGVsKCkpO1xyXG4gICAgICAgIHZhciBoYXNWYWxpZFNlYXJjaCA9ICF0aGlzLm9iamVjdC5pc051bGxPckVtcHR5KHRoaXMuc2VhcmNoKSAmJiB0aGlzLnNlYXJjaC5sZW5ndGggPj0gdGhpcy5taW5TZWFyY2hMZW5ndGg7XHJcbiAgICAgICAgdmFyIGhhc1ZhbGlkRmlsdGVyTW9kZWwgPSB0aGlzLmZpbHRlck1vZGVsICE9IG51bGwgJiYgdGhpcy52YWxpZGF0ZU1vZGVsKHRoaXMuZmlsdGVyTW9kZWwpO1xyXG4gICAgICAgIGlmICghaGFzVmFsaWRTZWFyY2ggJiYgIWhhc1ZhbGlkRmlsdGVyTW9kZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlUmVsb2FkKG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVsb2FkLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgQ2xpZW50U2VydmVyRGF0YVNvdXJjZS5wcm90b3R5cGUuZmlsdGVyTW9kZWxDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5vYmplY3QuYXJlRXF1YWwodGhpcy5nZXRGaWx0ZXJNb2RlbCgpLCB0aGlzLmZpbHRlck1vZGVsKTtcclxuICAgIH07XHJcbiAgICBDbGllbnRTZXJ2ZXJEYXRhU291cmNlLnByb3RvdHlwZS5nZXRQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlYXJjaE1vZGVsID0gdGhpcy5nZXRGaWx0ZXJNb2RlbCgpO1xyXG4gICAgICAgIGlmIChzZWFyY2hNb2RlbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaE1vZGVsLnNlYXJjaCA9IHRoaXMuc2VhcmNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VhcmNoTW9kZWwgPSB0aGlzLnNlYXJjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaE1vZGVsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDbGllbnRTZXJ2ZXJEYXRhU291cmNlO1xyXG59KGFzeW5jRGF0YVNvdXJjZV9zZXJ2aWNlXzEuQXN5bmNEYXRhU291cmNlKSk7XHJcbmV4cG9ydHMuQ2xpZW50U2VydmVyRGF0YVNvdXJjZSA9IENsaWVudFNlcnZlckRhdGFTb3VyY2U7XHJcbmNsaWVudFNlcnZlckRhdGFTb3VyY2VGYWN0b3J5LiRpbmplY3QgPSBbX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lLCBkYXRhU291cmNlUHJvY2Vzc29yX3NlcnZpY2VfMS5wcm9jZXNzb3JTZXJ2aWNlTmFtZSwgX19hcnJheS5zZXJ2aWNlTmFtZSwgX19vYmplY3Quc2VydmljZU5hbWUsIF9fc3luY2hyb25pemVkUmVxdWVzdHMuZmFjdG9yeU5hbWVdO1xyXG5mdW5jdGlvbiBjbGllbnRTZXJ2ZXJEYXRhU291cmNlRmFjdG9yeShvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksIG9iamVjdCwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENsaWVudFNlcnZlckRhdGFTb3VyY2UoZ2V0RGF0YVNldCwgc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jbGllbnRTZXJ2ZXJEYXRhU291cmNlRmFjdG9yeSA9IGNsaWVudFNlcnZlckRhdGFTb3VyY2VGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZSwgX19hcnJheS5tb2R1bGVOYW1lLCBfX29iamVjdC5tb2R1bGVOYW1lLCBfX3N5bmNocm9uaXplZFJlcXVlc3RzLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgY2xpZW50U2VydmVyRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnRTZXJ2ZXJEYXRhU291cmNlLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvY2xpZW50U2VydmVyRGF0YVNvdXJjZS9jbGllbnRTZXJ2ZXJEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgZGF0YVNvdXJjZUJhc2Vfc2VydmljZV8xID0gcmVxdWlyZSgnLi9kYXRhU291cmNlQmFzZS5zZXJ2aWNlJyk7XHJcbnZhciBldmVudHMgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VFdmVudHMnKTtcclxudmFyIEFzeW5jRGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXN5bmNEYXRhU291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXN5bmNEYXRhU291cmNlKGdldERhdGFTZXQsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5KTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUuYWxsb3dhYmxlRXZlbnRzID0gZXZlbnRzLmFzeW5jLmFsbDtcclxuICAgICAgICB0aGlzLnN5bmNocm9uaXplZFJlcXVlc3RzID0gc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5LmdldEluc3RhbmNlKGdldERhdGFTZXQsIHRoaXMucmVzb2x2ZVJlbG9hZC5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3luY0RhdGFTb3VyY2UucHJvdG90eXBlLCBcImdldERhdGFTZXRcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3luY2hyb25pemVkUmVxdWVzdHMuZGF0YVByb3ZpZGVyID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBBc3luY0RhdGFTb3VyY2UucHJvdG90eXBlLnJlbG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRhdGFTZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nRGF0YVNldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZWRSZXF1ZXN0cy5nZXREYXRhKHRoaXMuZ2V0UGFyYW1zKCkpO1xyXG4gICAgfTtcclxuICAgIEFzeW5jRGF0YVNvdXJjZS5wcm90b3R5cGUucmVzb2x2ZVJlbG9hZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nRGF0YVNldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmF3RGF0YVNldCA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKGV2ZW50cy5hc3luYy5yZWxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoZXZlbnRzLnJlZHJhd2luZyk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoZXZlbnRzLmNoYW5nZWQpO1xyXG4gICAgfTtcclxuICAgIC8vIG92ZXJyaWRlIHdpdGggcGFyYW1zIGZvciBnZXREYXRhU2V0XHJcbiAgICBBc3luY0RhdGFTb3VyY2UucHJvdG90eXBlLmdldFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXN5bmNEYXRhU291cmNlO1xyXG59KGRhdGFTb3VyY2VCYXNlX3NlcnZpY2VfMS5EYXRhU291cmNlQmFzZSkpO1xyXG5leHBvcnRzLkFzeW5jRGF0YVNvdXJjZSA9IEFzeW5jRGF0YVNvdXJjZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmNEYXRhU291cmNlLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGF0YVNvdXJjZXMvYXN5bmNEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi9kYXRhU291cmNlRXZlbnRzJyk7XHJcbnZhciBEYXRhU291cmNlQmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhU291cmNlQmFzZShvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXkpIHtcclxuICAgICAgICB0aGlzLmRhdGFTb3VyY2VQcm9jZXNzb3IgPSBkYXRhU291cmNlUHJvY2Vzc29yO1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxuICAgICAgICB0aGlzLnNvcnRzID0gW107XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5jb3VudEZpbHRlckdyb3VwcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9hZGluZ0RhdGFTZXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5hbGxvd2FibGVFdmVudHMgPSBldmVudHMuYWxsO1xyXG4gICAgfVxyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKGFjdGlvbiwgZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlLnJlZ2lzdGVyKGFjdGlvbiwgZXZlbnQpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhU291cmNlQmFzZS5wcm90b3R5cGUsIFwibmVlZHNSZWZpbmVkU2VhcmNoXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5vSXRlbXNEaXNwbGF5ZWQgPSBfX29iamVjdC5vYmplY3RVdGlsaXR5LmlzTnVsbE9yRW1wdHkodGhpcy5kYXRhU2V0KTtcclxuICAgICAgICAgICAgdmFyIG1vcmVJdGVtc09uU2VydmVyID0gdGhpcy5faXNFbXB0eSA9PT0gZmFsc2UgfHwgKHRoaXMucmF3RGF0YVNldCAhPSBudWxsICYmIHRoaXMucmF3RGF0YVNldC5sZW5ndGggPCB0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vSXRlbXNEaXNwbGF5ZWQgJiYgbW9yZUl0ZW1zT25TZXJ2ZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLCBcImlzRW1wdHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19vYmplY3Qub2JqZWN0VXRpbGl0eS5pc051bGxPckVtcHR5KHRoaXMucmF3RGF0YVNldClcclxuICAgICAgICAgICAgICAgICYmICh0aGlzLl9pc0VtcHR5ICE9IG51bGwgPyB0aGlzLl9pc0VtcHR5IDogdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0VtcHR5ID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUucHJvY2Vzc0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NlZERhdGE7XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnRGaWx0ZXJHcm91cHMpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzQW5kQ291bnQodGhpcy5zb3J0cywgdGhpcy5maWx0ZXJzLCB0aGlzLnBhZ2VyLCB0aGlzLnJhd0RhdGFTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZGF0YVNvdXJjZVByb2Nlc3Nvci5wcm9jZXNzKHRoaXMuc29ydHMsIHRoaXMuZmlsdGVycywgdGhpcy5wYWdlciwgdGhpcy5yYXdEYXRhU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpO1xyXG4gICAgfTtcclxuICAgIC8vdXNlZCB3aGVuIHdlIG5lZWQgdG8gcHJvY2VzcyBkYXRhIGJ1dCB3aXRob3V0IGNsaWVudCBmaWx0ZXJzLlxyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnByb2Nlc3NEYXRhTm9DbGllbnRGaWx0ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwcm9jZXNzZWREYXRhO1xyXG4gICAgICAgIGlmICh0aGlzLmNvdW50RmlsdGVyR3JvdXBzKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLmRhdGFTb3VyY2VQcm9jZXNzb3IucHJvY2Vzc0FuZENvdW50KHRoaXMuc29ydHMsIG51bGwsIHRoaXMucGFnZXIsIHRoaXMucmF3RGF0YVNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9jZXNzZWREYXRhID0gdGhpcy5kYXRhU291cmNlUHJvY2Vzc29yLnByb2Nlc3ModGhpcy5zb3J0cywgbnVsbCwgdGhpcy5wYWdlciwgdGhpcy5yYXdEYXRhU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzZWREYXRhKHByb2Nlc3NlZERhdGEpO1xyXG4gICAgfTtcclxuICAgIERhdGFTb3VyY2VCYXNlLnByb3RvdHlwZS5zZXRQcm9jZXNzZWREYXRhID0gZnVuY3Rpb24gKHByb2Nlc3NlZERhdGEpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gcHJvY2Vzc2VkRGF0YS5jb3VudDtcclxuICAgICAgICB0aGlzLmRhdGFTZXQgPSBwcm9jZXNzZWREYXRhLmRhdGFTZXQ7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJlZERhdGFTZXQgPSBwcm9jZXNzZWREYXRhLmZpbHRlcmVkRGF0YVNldDtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUub25Tb3J0Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nRGF0YVNldCkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkRGF0YVNldCA9IHRoaXMuZGF0YVNvdXJjZVByb2Nlc3Nvci5zb3J0KHRoaXMuZmlsdGVyZWREYXRhU2V0LCB0aGlzLnNvcnRzKTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhU2V0ID0gdGhpcy5kYXRhU291cmNlUHJvY2Vzc29yLnBhZ2UodGhpcy5maWx0ZXJlZERhdGFTZXQsIHRoaXMucGFnZXIpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZShldmVudHMucmVkcmF3aW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLm9uUGFnaW5nQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nRGF0YVNldCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTZXQgPSB0aGlzLmRhdGFTb3VyY2VQcm9jZXNzb3IucGFnZSh0aGlzLmZpbHRlcmVkRGF0YVNldCwgdGhpcy5wYWdlcik7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKGV2ZW50cy5yZWRyYXdpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMubG9hZGluZ0RhdGFTZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZShldmVudHMucmVkcmF3aW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFycmF5LnJlbW92ZSh0aGlzLnJhd0RhdGFTZXQsIGRhdGEpO1xyXG4gICAgICAgIGlmIChpdGVtICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoZXZlbnRzLnJlbW92ZWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZShldmVudHMuY2hhbmdlZCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQmFzZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5yYXdEYXRhU2V0LnB1c2goZGF0YSk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoZXZlbnRzLmFkZGVkKTtcclxuICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZShldmVudHMuY2hhbmdlZCk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAob2xkRGF0YSwgbmV3RGF0YSkge1xyXG4gICAgICAgIHZhciBsb2NhdGlvbk9mT2xkRGF0YSA9IHRoaXMucmF3RGF0YVNldC5pbmRleE9mKG9sZERhdGEpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbk9mT2xkRGF0YSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXkucmVwbGFjZSh0aGlzLnJhd0RhdGFTZXQsIG9sZERhdGEsIG5ld0RhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZShldmVudHMucmVwbGFjZWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmFibGUuZmlyZShldmVudHMuY2hhbmdlZCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0YVNvdXJjZUJhc2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRGF0YVNvdXJjZUJhc2UgPSBEYXRhU291cmNlQmFzZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVNvdXJjZUJhc2Uuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlQmFzZS5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuZXhwb3J0cy5yZWRyYXdpbmcgPSAncmVkcmF3aW5nJztcclxuZXhwb3J0cy5jaGFuZ2VkID0gJ2NoYW5nZWQnO1xyXG5leHBvcnRzLmFkZGVkID0gJ2FkZGVkJztcclxuZXhwb3J0cy5yZW1vdmVkID0gJ3JlbW92ZWQnO1xyXG5leHBvcnRzLnJlcGxhY2VkID0gJ3JlcGxhY2VkJztcclxuZXhwb3J0cy5hbGwgPSBbZXhwb3J0cy5yZWRyYXdpbmcsIGV4cG9ydHMuY2hhbmdlZCwgZXhwb3J0cy5hZGRlZCwgZXhwb3J0cy5yZW1vdmVkLCBleHBvcnRzLnJlcGxhY2VkXTtcclxuZXhwb3J0cy5hc3luYyA9IHtcclxuICAgIHJlbG9hZGVkOiAncmVsb2FkZWQnLFxyXG4gICAgYWxsOiBbXSxcclxufTtcclxuZXhwb3J0cy5hc3luYy5hbGwgPSBfLmNsb25lKGV4cG9ydHMuYWxsKTtcclxuZXhwb3J0cy5hc3luYy5hbGwucHVzaChleHBvcnRzLmFzeW5jLnJlbG9hZGVkKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVNvdXJjZUV2ZW50cy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9kYXRhU291cmNlRXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIHNvcnRlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9zb3J0cy9zb3J0ZXIvc29ydGVyLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5wcm9jZXNzb3JTZXJ2aWNlTmFtZSA9ICdkYXRhU291cmNlUHJvY2Vzc29yJztcclxudmFyIERhdGFTb3VyY2VQcm9jZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0YVNvdXJjZVByb2Nlc3NvcihvYmplY3QsIHNvcnRlcikge1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuc29ydGVyID0gc29ydGVyO1xyXG4gICAgfVxyXG4gICAgRGF0YVNvdXJjZVByb2Nlc3Nvci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzb3J0cywgZmlsdGVycywgcGFnZXIsIGRhdGEpIHtcclxuICAgICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuc29ydChwcm9jZXNzZWREYXRhLCBzb3J0cyk7XHJcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0LmlzTnVsbE9yRW1wdHkoZmlsdGVycykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZERhdGEgPSBfLnJlZHVjZShmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyZWREYXRhLCBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbHRlciB0aGUgZGF0YSBzZXQgdXNpbmcgdGhlIGZpbHRlciBmdW5jdGlvbiBvbiB0aGUgZmlsdGVyXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5maWx0ZXIoZmlsdGVyZWREYXRhLCBmaWx0ZXIuZmlsdGVyLmJpbmQoZmlsdGVyKSk7XHJcbiAgICAgICAgICAgIH0sIHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBjb3VudDogKHByb2Nlc3NlZERhdGEgIT0gbnVsbCA/IHByb2Nlc3NlZERhdGEubGVuZ3RoIDogMCksXHJcbiAgICAgICAgICAgIGZpbHRlcmVkRGF0YVNldDogcHJvY2Vzc2VkRGF0YSxcclxuICAgICAgICAgICAgZGF0YVNldDogcHJvY2Vzc2VkRGF0YSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlc3VsdC5kYXRhU2V0ID0gdGhpcy5wYWdlKHByb2Nlc3NlZERhdGEsIHBhZ2VyKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIERhdGFTb3VyY2VQcm9jZXNzb3IucHJvdG90eXBlLnByb2Nlc3NBbmRDb3VudCA9IGZ1bmN0aW9uIChzb3J0cywgZmlsdGVycywgcGFnZXIsIGRhdGEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBmaWx0ZXJzIHRoYXQgbmVlZCB0byB1cGRhdGVkIG9wdGlvbiBjb3VudHMsIHVzZSB0aGUgbm9ybWFsIHByb2Nlc3NvclxyXG4gICAgICAgIGlmICh0aGlzLm9iamVjdC5pc051bGxPckVtcHR5KGZpbHRlcnMpXHJcbiAgICAgICAgICAgIHx8IF8uc29tZShmaWx0ZXJzLCBmdW5jdGlvbiAoZmlsdGVyKSB7IHJldHVybiBfLmlzRnVuY3Rpb24oZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cyk7IH0pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHNvcnRzLCBmaWx0ZXJzLCBwYWdlciwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9jZXNzZWREYXRhID0gZGF0YTtcclxuICAgICAgICBwcm9jZXNzZWREYXRhID0gdGhpcy5zb3J0KHByb2Nlc3NlZERhdGEsIHNvcnRzKTtcclxuICAgICAgICB2YXIgd3JhcHBlZERhdGEgPSB0aGlzLndyYXBEYXRhKHByb2Nlc3NlZERhdGEpO1xyXG4gICAgICAgIC8vIFJ1biBmaWx0cmF0aW9uIGxvZ2ljIGFuZCBjb21wdXRlIHZpc2libGUgaXRlbXNcclxuICAgICAgICBfLmVhY2goZmlsdGVycywgZnVuY3Rpb24gKGZpbHRlciAvKiBmaWx0ZXJzLklGaWx0ZXJXaXRoQ291bnRzICovKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaCh3cmFwcGVkRGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0uZmlsdGVyRGF0YVtmaWx0ZXIudHlwZV0gPSBmaWx0ZXIuZmlsdGVyKGl0ZW0uZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEdpdmUgZWFjaCBmaWx0ZXIgYSBjaGFuY2UgdG8gdXBkYXRlIG9wdGlvbiBjb3VudHNcclxuICAgICAgICBfLmVhY2goZmlsdGVycywgZnVuY3Rpb24gKGZpbHRlciAvKiBmaWx0ZXJzLklGaWx0ZXJXaXRoQ291bnRzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZmlsdGVyLnVwZGF0ZU9wdGlvbkNvdW50cykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlckZpbHRlcnNBcHBsaWVkID0gXy5maWx0ZXIod3JhcHBlZERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT21pdCB0aGUgdHJ1ZSBvciBmYWxzZSBvZiB0aGUgY3VycmVudCBmaWx0ZXIgYW5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgb25seSBmaWx0ZXIgb3V0IGl0ZW1zIHJlbW92ZWQgYnkgb3RoZXIgZmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJEYXRhID0gXy5vbWl0KGl0ZW0uZmlsdGVyRGF0YSwgZmlsdGVyLnR5cGUpOyAvLypmaWx0ZXJEYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZXZlcnkoXy52YWx1ZXMoZmlsdGVyRGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIudXBkYXRlT3B0aW9uQ291bnRzKF90aGlzLnVud3JhcERhdGEob3RoZXJGaWx0ZXJzQXBwbGllZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRmlsdGVyIGRvd24gdG8gZmluYWwgZGF0YSBzZXQgYnkgcmVtb3ZpbmcgaXRlbXMgdGhhdCBkb24ndCBtYXRjaCBhbGwgZmlsdGVyc1xyXG4gICAgICAgIHdyYXBwZWREYXRhID0gXy5maWx0ZXIod3JhcHBlZERhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfLmV2ZXJ5KF8udmFsdWVzKGl0ZW0uZmlsdGVyRGF0YSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLnVud3JhcERhdGEod3JhcHBlZERhdGEpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIGNvdW50OiBwcm9jZXNzZWREYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgZmlsdGVyZWREYXRhU2V0OiBwcm9jZXNzZWREYXRhLFxyXG4gICAgICAgICAgICBkYXRhU2V0OiBwcm9jZXNzZWREYXRhLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVzdWx0LmRhdGFTZXQgPSB0aGlzLnBhZ2UocHJvY2Vzc2VkRGF0YSwgcGFnZXIpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZVByb2Nlc3Nvci5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChkYXRhLCBzb3J0cykge1xyXG4gICAgICAgIGlmICh0aGlzLm9iamVjdC5pc051bGxPckVtcHR5KHNvcnRzKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVyLnNvcnQoZGF0YSwgc29ydHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlUHJvY2Vzc29yLnByb3RvdHlwZS5wYWdlID0gZnVuY3Rpb24gKGRhdGEsIHBhZ2VyKSB7XHJcbiAgICAgICAgaWYgKHBhZ2VyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhZ2VyLmZpbHRlcihkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgRGF0YVNvdXJjZVByb2Nlc3Nvci5wcm90b3R5cGUud3JhcERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBfLm1hcChkYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YTogaXRlbSxcclxuICAgICAgICAgICAgICAgIGZpbHRlckRhdGE6IHt9LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFTb3VyY2VQcm9jZXNzb3IucHJvdG90eXBlLnVud3JhcERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBfLm1hcChkYXRhLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFTb3VyY2VQcm9jZXNzb3IuJGluamVjdCA9IFtfX29iamVjdC5zZXJ2aWNlTmFtZSwgc29ydGVyX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gRGF0YVNvdXJjZVByb2Nlc3NvcjtcclxufSgpKTtcclxuZXhwb3J0cy5EYXRhU291cmNlUHJvY2Vzc29yID0gRGF0YVNvdXJjZVByb2Nlc3NvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VQcm9jZXNzb3Iuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi8uLi90eXBpbmdzL2xvZGFzaFR5cGVFeHRlbnNpb25zLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMuZGF0YVBhZ2VyJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdkYXRhUGFnZXInO1xyXG5leHBvcnRzLmRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG52YXIgRGF0YVBhZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGFQYWdlcigpIHtcclxuICAgICAgICB0aGlzLnBhZ2VOdW1iZXIgPSAxO1xyXG4gICAgICAgIHRoaXMucGFnZVNpemUgPSBleHBvcnRzLmRlZmF1bHRQYWdlU2l6ZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhUGFnZXIucHJvdG90eXBlLCBcInN0YXJ0SXRlbVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5wYWdlTnVtYmVyIC0gMSkgKiB0aGlzLnBhZ2VTaXplO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRGF0YVBhZ2VyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZGF0YVNldCkge1xyXG4gICAgICAgIHJldHVybiBfKGRhdGFTZXQpXHJcbiAgICAgICAgICAgIC5kcm9wKHRoaXMuc3RhcnRJdGVtKVxyXG4gICAgICAgICAgICAudGFrZSh0aGlzLnBhZ2VTaXplKVxyXG4gICAgICAgICAgICAudmFsdWUoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0YVBhZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLkRhdGFQYWdlciA9IERhdGFQYWdlcjtcclxuZnVuY3Rpb24gZGF0YVBhZ2VyRmFjdG9yeSgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhUGFnZXIoKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRhdGFQYWdlckZhY3RvcnkgPSBkYXRhUGFnZXJGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgZGF0YVBhZ2VyRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFQYWdlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFQYWdlci9kYXRhUGFnZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYnNlcnZhYmxlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9ic2VydmFibGU7XHJcbnZhciBfX2FycmF5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX19zeW5jaHJvbml6ZWRSZXF1ZXN0cyA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5zeW5jaHJvbml6ZWRSZXF1ZXN0cztcclxudmFyIGFzeW5jRGF0YVNvdXJjZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9hc3luY0RhdGFTb3VyY2Uuc2VydmljZScpO1xyXG52YXIgZGF0YVNvdXJjZVByb2Nlc3Nvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9kYXRhU291cmNlUHJvY2Vzc29yLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5kYXRhU291cmNlcy5kYXRhU2VydmljZURhdGFTb3VyY2UnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ2RhdGFTZXJ2aWNlRGF0YVNvdXJjZSc7XHJcbnZhciBEYXRhU2VydmljZURhdGFTb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERhdGFTZXJ2aWNlRGF0YVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERhdGFTZXJ2aWNlRGF0YVNvdXJjZShnZXREYXRhU2V0LCBvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGdldERhdGFTZXQsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KTtcclxuICAgICAgICB0aGlzLmNvdW50RmlsdGVyR3JvdXBzID0gdHJ1ZTtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGdldERhdGFTZXQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIERhdGFTZXJ2aWNlRGF0YVNvdXJjZTtcclxufShhc3luY0RhdGFTb3VyY2Vfc2VydmljZV8xLkFzeW5jRGF0YVNvdXJjZSkpO1xyXG5leHBvcnRzLkRhdGFTZXJ2aWNlRGF0YVNvdXJjZSA9IERhdGFTZXJ2aWNlRGF0YVNvdXJjZTtcclxuZGF0YVNlcnZpY2VEYXRhU291cmNlRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JzZXJ2YWJsZS5mYWN0b3J5TmFtZSwgZGF0YVNvdXJjZVByb2Nlc3Nvcl9zZXJ2aWNlXzEucHJvY2Vzc29yU2VydmljZU5hbWUsIF9fYXJyYXkuc2VydmljZU5hbWUsIF9fc3luY2hyb25pemVkUmVxdWVzdHMuZmFjdG9yeU5hbWVdO1xyXG5mdW5jdGlvbiBkYXRhU2VydmljZURhdGFTb3VyY2VGYWN0b3J5KG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSwgc3luY2hyb25pemVkUmVxdWVzdHMpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChnZXREYXRhU2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YVNlcnZpY2VEYXRhU291cmNlKGdldERhdGFTZXQsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSwgc3luY2hyb25pemVkUmVxdWVzdHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGF0YVNlcnZpY2VEYXRhU291cmNlRmFjdG9yeSA9IGRhdGFTZXJ2aWNlRGF0YVNvdXJjZUZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JzZXJ2YWJsZS5tb2R1bGVOYW1lLCBfX2FycmF5Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgZGF0YVNlcnZpY2VEYXRhU291cmNlRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFTZXJ2aWNlRGF0YVNvdXJjZS5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL2RhdGFTZXJ2aWNlRGF0YVNvdXJjZS9kYXRhU2VydmljZURhdGFTb3VyY2Uuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYnNlcnZhYmxlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9ic2VydmFibGU7XHJcbnZhciBfX2FycmF5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX19zeW5jaHJvbml6ZWRSZXF1ZXN0cyA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5zeW5jaHJvbml6ZWRSZXF1ZXN0cztcclxudmFyIGFzeW5jRGF0YVNvdXJjZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9hc3luY0RhdGFTb3VyY2Uuc2VydmljZScpO1xyXG52YXIgZGF0YVNvdXJjZVByb2Nlc3Nvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9kYXRhU291cmNlUHJvY2Vzc29yLnNlcnZpY2UnKTtcclxudmFyIHNvcnRfMSA9IHJlcXVpcmUoJy4uLy4uL3NvcnRzL3NvcnQnKTtcclxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VFdmVudHMnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5kYXRhU291cmNlcy5zZXJ2ZXJTaWRlRGF0YVNvdXJjZSc7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnc2VydmVyU2lkZURhdGFTb3VyY2UnO1xyXG52YXIgU2VydmVyU2lkZURhdGFTb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNlcnZlclNpZGVEYXRhU291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2VydmVyU2lkZURhdGFTb3VyY2UoZ2V0RGF0YVNldCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGdldERhdGFTZXQsIG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KTtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgIH1cclxuICAgIFNlcnZlclNpZGVEYXRhU291cmNlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVsb2FkKCk7XHJcbiAgICB9O1xyXG4gICAgU2VydmVyU2lkZURhdGFTb3VyY2UucHJvdG90eXBlLmdldFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZmlsdGVyRGljdGlvbmFyeSA9IHRoaXMuYXJyYXkudG9EaWN0aW9uYXJ5KHRoaXMuZmlsdGVycywgZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLnR5cGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsdGVyczogXy5tYXBWYWx1ZXMoZmlsdGVyRGljdGlvbmFyeSwgZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihmaWx0ZXIuc2VyaWFsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHNvcnRzOiBfLm1hcCh0aGlzLnNvcnRzLCBmdW5jdGlvbiAoc29ydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHNvcnQuY29sdW1uLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydF8xLlNvcnREaXJlY3Rpb24uZ2V0RnVsbE5hbWUoc29ydC5kaXJlY3Rpb24pLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHBhZ2luZzoge1xyXG4gICAgICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5wYWdlci5wYWdlTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZXIucGFnZVNpemUsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBTZXJ2ZXJTaWRlRGF0YVNvdXJjZS5wcm90b3R5cGUucmVzb2x2ZVJlbG9hZCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHJlc3VsdDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlc29sdmVSZWxvYWQuY2FsbCh0aGlzLCBkYXRhLmRhdGFTZXQpO1xyXG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc2VkRGF0YSh7XHJcbiAgICAgICAgICAgIGNvdW50OiBkYXRhLmNvdW50LFxyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGFTZXQ6IGRhdGEuZGF0YVNldCxcclxuICAgICAgICAgICAgZGF0YVNldDogZGF0YS5kYXRhU2V0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZS5maXJlKGV2ZW50cy5yZWRyYXdpbmcpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTZXJ2ZXJTaWRlRGF0YVNvdXJjZTtcclxufShhc3luY0RhdGFTb3VyY2Vfc2VydmljZV8xLkFzeW5jRGF0YVNvdXJjZSkpO1xyXG5leHBvcnRzLlNlcnZlclNpZGVEYXRhU291cmNlID0gU2VydmVyU2lkZURhdGFTb3VyY2U7XHJcbnNlcnZlclNpZGVEYXRhU291cmNlRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JzZXJ2YWJsZS5mYWN0b3J5TmFtZSwgZGF0YVNvdXJjZVByb2Nlc3Nvcl9zZXJ2aWNlXzEucHJvY2Vzc29yU2VydmljZU5hbWUsIF9fYXJyYXkuc2VydmljZU5hbWUsIF9fb2JqZWN0LnNlcnZpY2VOYW1lLCBfX3N5bmNocm9uaXplZFJlcXVlc3RzLmZhY3RvcnlOYW1lXTtcclxuZnVuY3Rpb24gc2VydmVyU2lkZURhdGFTb3VyY2VGYWN0b3J5KG9ic2VydmFibGVGYWN0b3J5LCBkYXRhU291cmNlUHJvY2Vzc29yLCBhcnJheSwgb2JqZWN0LCBzeW5jaHJvbml6ZWRSZXF1ZXN0c0ZhY3RvcnkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChnZXREYXRhU2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VydmVyU2lkZURhdGFTb3VyY2UoZ2V0RGF0YVNldCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zZXJ2ZXJTaWRlRGF0YVNvdXJjZUZhY3RvcnkgPSBzZXJ2ZXJTaWRlRGF0YVNvdXJjZUZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZmFjdG9yeShleHBvcnRzLmZhY3RvcnlOYW1lLCBzZXJ2ZXJTaWRlRGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXJTaWRlRGF0YVNvdXJjZS5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RhdGFTb3VyY2VzL3NlcnZlclNpZGVEYXRhU291cmNlL3NlcnZlclNpZGVEYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG52YXIgX19hcnJheSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5hcnJheTtcclxudmFyIGRhdGFTb3VyY2VCYXNlX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VCYXNlLnNlcnZpY2UnKTtcclxudmFyIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vZGF0YVNvdXJjZVByb2Nlc3Nvci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZXMuc2ltcGxlRGF0YVNvdXJjZSc7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnc2ltcGxlRGF0YVNvdXJjZSc7XHJcbnZhciBTaW1wbGVEYXRhU291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTaW1wbGVEYXRhU291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2ltcGxlRGF0YVNvdXJjZShkYXRhLCBvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXkpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXkpO1xyXG4gICAgICAgIHRoaXMuY291bnRGaWx0ZXJHcm91cHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJhd0RhdGFTZXQgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTaW1wbGVEYXRhU291cmNlO1xyXG59KGRhdGFTb3VyY2VCYXNlX3NlcnZpY2VfMS5EYXRhU291cmNlQmFzZSkpO1xyXG5leHBvcnRzLlNpbXBsZURhdGFTb3VyY2UgPSBTaW1wbGVEYXRhU291cmNlO1xyXG5zaW1wbGVEYXRhU291cmNlRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JzZXJ2YWJsZS5mYWN0b3J5TmFtZSwgZGF0YVNvdXJjZVByb2Nlc3Nvcl9zZXJ2aWNlXzEucHJvY2Vzc29yU2VydmljZU5hbWUsIF9fYXJyYXkuc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBzaW1wbGVEYXRhU291cmNlRmFjdG9yeShvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlRGF0YVNvdXJjZShkYXRhLCBvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXkpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2ltcGxlRGF0YVNvdXJjZUZhY3RvcnkgPSBzaW1wbGVEYXRhU291cmNlRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYnNlcnZhYmxlLm1vZHVsZU5hbWUsIF9fYXJyYXkubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShleHBvcnRzLmZhY3RvcnlOYW1lLCBzaW1wbGVEYXRhU291cmNlRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZURhdGFTb3VyY2Uuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9zaW1wbGVEYXRhU291cmNlL3NpbXBsZURhdGFTb3VyY2Uuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYnNlcnZhYmxlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9ic2VydmFibGU7XHJcbnZhciBfX2FycmF5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX19zeW5jaHJvbml6ZWRSZXF1ZXN0cyA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5zeW5jaHJvbml6ZWRSZXF1ZXN0cztcclxudmFyIGFzeW5jRGF0YVNvdXJjZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9hc3luY0RhdGFTb3VyY2Uuc2VydmljZScpO1xyXG52YXIgZGF0YVNvdXJjZVByb2Nlc3Nvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9kYXRhU291cmNlUHJvY2Vzc29yLnNlcnZpY2UnKTtcclxudmFyIHNvcnRfMSA9IHJlcXVpcmUoJy4uLy4uL3NvcnRzL3NvcnQnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5kYXRhU291cmNlcy5zbWFydERhdGFTb3VyY2UnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3NtYXJ0RGF0YVNvdXJjZSc7XHJcbnZhciBTbWFydERhdGFTb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNtYXJ0RGF0YVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNtYXJ0RGF0YVNvdXJjZShnZXREYXRhU2V0LCBvYnNlcnZhYmxlRmFjdG9yeSwgZGF0YVNvdXJjZVByb2Nlc3NvciwgYXJyYXksIG9iamVjdCwgc3luY2hyb25pemVkUmVxdWVzdHNGYWN0b3J5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZ2V0RGF0YVNldCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBzeW5jaHJvbml6ZWRSZXF1ZXN0c0ZhY3RvcnkpO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMudGhyb3R0bGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRocm90dGxlTGltaXQgPSAyMDA7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU21hcnREYXRhU291cmNlLnByb3RvdHlwZSwgXCJmaWx0ZXJzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dXBTdWJzY3JpcHRpb25zKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTbWFydERhdGFTb3VyY2UucHJvdG90eXBlLm9uU29ydENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50aHJvdHRsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUub25Tb3J0Q2hhbmdlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNtYXJ0RGF0YVNvdXJjZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50aHJvdHRsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVmcmVzaC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTbWFydERhdGFTb3VyY2UucHJvdG90eXBlLmdldFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFwcGxpZWRGaWx0ZXJzKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZmlsdGVyczogdGhpcy5hcHBsaWVkRmlsdGVycyxcclxuICAgICAgICAgICAgc29ydHM6IF8ubWFwKHRoaXMuc29ydHMsIGZ1bmN0aW9uIChzb3J0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogc29ydC5jb2x1bW4ubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBzb3J0XzEuU29ydERpcmVjdGlvbi5nZXRGdWxsTmFtZShzb3J0LmRpcmVjdGlvbiksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgcGFnaW5nOiB7XHJcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyOiAxLFxyXG4gICAgICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMudGhyb3R0bGVMaW1pdCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNtYXJ0RGF0YVNvdXJjZS5wcm90b3R5cGUudXBkYXRlQXBwbGllZEZpbHRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZpbHRlckRpY3Rpb25hcnkgPSB0aGlzLmFycmF5LnRvRGljdGlvbmFyeSh0aGlzLmZpbHRlcnMsIGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlci50eXBlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYXBwbGllZEZpbHRlcnMgPSBfLm1hcFZhbHVlcyhmaWx0ZXJEaWN0aW9uYXJ5LCBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24oZmlsdGVyLnNlcmlhbGl6ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIuc2VyaWFsaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hcHBsaWVkRmlsdGVycyA9IF8ub21pdEJ5KHRoaXMuYXBwbGllZEZpbHRlcnMsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT0gbnVsbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hcnREYXRhU291cmNlLnByb3RvdHlwZS5zZXR1cFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfLmVhY2godGhpcy5zdWJzY3JpcHRpb25zLCBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuZmlsdGVycywgZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGZpbHRlci5zdWJzY3JpYmUpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goZmlsdGVyLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IF90aGlzLm9uRmlsdGVyQ2hhbmdlKGZpbHRlcik7IH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFNtYXJ0RGF0YVNvdXJjZS5wcm90b3R5cGUub25GaWx0ZXJDaGFuZ2UgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKF8uaGFzKHRoaXMuYXBwbGllZEZpbHRlcnMsIGZpbHRlci50eXBlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTbWFydERhdGFTb3VyY2UucHJvdG90eXBlLnJlc29sdmVSZWxvYWQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgdGhpcy50aHJvdHRsZWQgPSAoZGF0YS5jb3VudCA+IGRhdGEuZGF0YVNldC5sZW5ndGgpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzb2x2ZVJlbG9hZC5jYWxsKHRoaXMsIGRhdGEuZGF0YVNldCk7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGRhdGEuY291bnQ7XHJcbiAgICAgICAgdGhpcy5pc0VtcHR5ID0gZGF0YS5pc0VtcHR5O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTbWFydERhdGFTb3VyY2U7XHJcbn0oYXN5bmNEYXRhU291cmNlX3NlcnZpY2VfMS5Bc3luY0RhdGFTb3VyY2UpKTtcclxuZXhwb3J0cy5TbWFydERhdGFTb3VyY2UgPSBTbWFydERhdGFTb3VyY2U7XHJcbnNtYXJ0RGF0YVNvdXJjZUZhY3RvcnkuJGluamVjdCA9IFtfX29ic2VydmFibGUuZmFjdG9yeU5hbWUsIGRhdGFTb3VyY2VQcm9jZXNzb3Jfc2VydmljZV8xLnByb2Nlc3NvclNlcnZpY2VOYW1lLCBfX2FycmF5LnNlcnZpY2VOYW1lLCBfX29iamVjdC5zZXJ2aWNlTmFtZSwgX19zeW5jaHJvbml6ZWRSZXF1ZXN0cy5mYWN0b3J5TmFtZV07XHJcbmZ1bmN0aW9uIHNtYXJ0RGF0YVNvdXJjZUZhY3Rvcnkob2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKGdldERhdGFTZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFydERhdGFTb3VyY2UoZ2V0RGF0YVNldCwgb2JzZXJ2YWJsZUZhY3RvcnksIGRhdGFTb3VyY2VQcm9jZXNzb3IsIGFycmF5LCBvYmplY3QsIHN5bmNocm9uaXplZFJlcXVlc3RzRmFjdG9yeSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zbWFydERhdGFTb3VyY2VGYWN0b3J5ID0gc21hcnREYXRhU291cmNlRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIHNtYXJ0RGF0YVNvdXJjZUZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbWFydERhdGFTb3VyY2Uuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9kYXRhU291cmNlcy9zbWFydERhdGFTb3VyY2Uvc21hcnREYXRhU291cmNlLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBjb2x1bW5TZWFyY2hGaWx0ZXIgPSByZXF1aXJlKCcuL2NvbHVtblNlYXJjaEZpbHRlci9jb2x1bW5TZWFyY2hGaWx0ZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmNvbHVtblNlYXJjaEZpbHRlciA9IGNvbHVtblNlYXJjaEZpbHRlcjtcclxudmFyIGRhdGVGaWx0ZXIgPSByZXF1aXJlKCcuL2RhdGVGaWx0ZXIvZGF0ZUZpbHRlci5tb2R1bGUnKTtcclxudmFyIGZpbHRlckdyb3VwID0gcmVxdWlyZSgnLi9maWx0ZXJHcm91cC9maWx0ZXJHcm91cC5tb2R1bGUnKTtcclxuZXhwb3J0cy5maWx0ZXJHcm91cCA9IGZpbHRlckdyb3VwO1xyXG52YXIgc2VsZWN0RmlsdGVyID0gcmVxdWlyZSgnLi9zZWxlY3RGaWx0ZXIvc2VsZWN0RmlsdGVyLm1vZHVsZScpO1xyXG5leHBvcnRzLnNlbGVjdEZpbHRlciA9IHNlbGVjdEZpbHRlcjtcclxudmFyIGNhcmRDb250YWluZXJGaWx0ZXJzID0gcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyRmlsdGVycycpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2NhcmRDb250YWluZXJGaWx0ZXJzJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIGNvbHVtblNlYXJjaEZpbHRlci5tb2R1bGVOYW1lLFxyXG4gICAgZGF0ZUZpbHRlci5tb2R1bGVOYW1lLFxyXG4gICAgZmlsdGVyR3JvdXAubW9kdWxlTmFtZSxcclxuICAgIHNlbGVjdEZpbHRlci5tb2R1bGVOYW1lLFxyXG4gICAgY2FyZENvbnRhaW5lckZpbHRlcnMubW9kdWxlTmFtZVxyXG5dKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVycy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX19zdHJpbmcgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuc3RyaW5nO1xyXG52YXIgX190cmFuc2Zvcm0gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudHJhbnNmb3JtLnRyYW5zZm9ybTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5maWx0ZXJzLmNvbHVtblNlYXJjaEZpbHRlcic7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnY29sdW1uU2VhcmNoRmlsdGVyJztcclxuZXhwb3J0cy5maWx0ZXJOYW1lID0gJ2NvbHVtbi1zZWFyY2gnO1xyXG52YXIgQ29sdW1uU2VhcmNoRmlsdGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbHVtblNlYXJjaEZpbHRlcihvYmplY3QsIHN0cmluZykge1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IGV4cG9ydHMuZmlsdGVyTmFtZTtcclxuICAgIH1cclxuICAgIENvbHVtblNlYXJjaEZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAodGhpcy5jb2x1bW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5vYmplY3QudG9TdHJpbmcoX190cmFuc2Zvcm0uZ2V0VmFsdWUoaXRlbSwgdGhpcy5jb2x1bW4uZ2V0VmFsdWUpKTtcclxuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2hUZXh0O1xyXG4gICAgICAgIGlmICghdGhpcy5jYXNlU2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaCA9IHNlYXJjaC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5jb250YWlucyh2YWx1ZSwgc2VhcmNoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29sdW1uU2VhcmNoRmlsdGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbHVtblNlYXJjaEZpbHRlciA9IENvbHVtblNlYXJjaEZpbHRlcjtcclxuY29sdW1uU2VhcmNoRmlsdGVyRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JqZWN0LnNlcnZpY2VOYW1lLCBfX3N0cmluZy5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIGNvbHVtblNlYXJjaEZpbHRlckZhY3Rvcnkob2JqZWN0LCBzdHJpbmcpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2x1bW5TZWFyY2hGaWx0ZXIob2JqZWN0LCBzdHJpbmcpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY29sdW1uU2VhcmNoRmlsdGVyRmFjdG9yeSA9IGNvbHVtblNlYXJjaEZpbHRlckZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWUsIF9fc3RyaW5nLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgY29sdW1uU2VhcmNoRmlsdGVyRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19kYXRlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmRhdGU7XHJcbnZhciBkYXRlRmlsdGVyX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vZGF0ZUZpbHRlci5zZXJ2aWNlJyk7XHJcbnZhciBkYXRlRmlsdGVyX2NvbXBvbmVudF8xID0gcmVxdWlyZSgnLi9kYXRlRmlsdGVyLmNvbXBvbmVudCcpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuZGF0ZUZpbHRlcic7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZGF0ZUZpbHRlci5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2RhdGVGaWx0ZXIuY29tcG9uZW50JykpO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX2RhdGUubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShkYXRlRmlsdGVyX3NlcnZpY2VfMS5mYWN0b3J5TmFtZSwgZGF0ZUZpbHRlcl9zZXJ2aWNlXzEuZGF0ZUZpbHRlckZhY3RvcnkpXHJcbiAgICAuZGlyZWN0aXZlKGRhdGVGaWx0ZXJfY29tcG9uZW50XzEuZGlyZWN0aXZlTmFtZSwgZGF0ZUZpbHRlcl9jb21wb25lbnRfMS5kYXRlRmlsdGVyKVxyXG4gICAgLmNvbnRyb2xsZXIoZGF0ZUZpbHRlcl9jb21wb25lbnRfMS5jb250cm9sbGVyTmFtZSwgZGF0ZUZpbHRlcl9jb21wb25lbnRfMS5EYXRlRmlsdGVyQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGVGaWx0ZXIubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZGF0ZUZpbHRlci9kYXRlRmlsdGVyLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fZGF0ZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5kYXRlO1xyXG52YXIgX190cmFuc2Zvcm0gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudHJhbnNmb3JtLnRyYW5zZm9ybTtcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdybERhdGVGaWx0ZXJGYWN0b3J5JztcclxudmFyIERhdGVGaWx0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0ZUZpbHRlcihzZXR0aW5ncywgZGF0ZVV0aWxpdHkpIHtcclxuICAgICAgICB0aGlzLmRhdGVVdGlsaXR5ID0gZGF0ZVV0aWxpdHk7XHJcbiAgICAgICAgdGhpcy52YWx1ZVNlbGVjdG9yID0gc2V0dGluZ3MudmFsdWVTZWxlY3RvcjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBzZXR0aW5ncy50eXBlO1xyXG4gICAgICAgIHRoaXMuY2xlYXJCdXR0b24gPSBzZXR0aW5ncy5jbGVhckJ1dHRvbjtcclxuICAgICAgICB0aGlzLmluY2x1ZGVEYXRlUmFuZ2UgPSBzZXR0aW5ncy5pbmNsdWRlRGF0ZVJhbmdlO1xyXG4gICAgICAgIHRoaXMuaW5jbHVkZVRpbWUgPSBzZXR0aW5ncy5pbmNsdWRlVGltZSAhPSBudWxsID8gc2V0dGluZ3MuaW5jbHVkZVRpbWUgOiBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhYmVsID0gc2V0dGluZ3MubGFiZWw7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IFwiPHJsLWRhdGUtZmlsdGVyIGZpbHRlcj1cXFwiZmlsdGVyXFxcIiBzb3VyY2U9XFxcImRhdGFTb3VyY2VcXFwiIGxhYmVsPVxcXCJ7e2ZpbHRlci5sYWJlbH19XFxcIiBpbmNsdWRlLXRpbWU9XFxcImZpbHRlci5pbmNsdWRlVGltZVxcXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQgICAgIGluY2x1ZGUtZGF0ZS1yYW5nZT1cXFwiZmlsdGVyLmluY2x1ZGVEYXRlUmFuZ2VcXFwiIGNsZWFyLWJ1dHRvbj1cXFwiZmlsdGVyLmNsZWFyQnV0dG9uXFxcIj48L3JsLWRhdGUtZmlsdGVyPlwiO1xyXG4gICAgfVxyXG4gICAgRGF0ZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0ZVV0aWxpdHkuaXNEYXRlKHRoaXMuc2VsZWN0ZWREYXRlMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGVSYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgaXRlbURhdGUgPSB0aGlzLmdldFZhbHVlKGl0ZW0pO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlMSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgLy9oYXZlIHRvIHNldCB0aGUgc2VsZWN0ZWREYXRlMSB0byBhIHZhbGlkIERhdGUgb2JqZWN0IGZvciBjb21wYXJpc29ucy5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZTEgPSBtb21lbnQodGhpcy5zZWxlY3RlZERhdGUxKS50b0RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vaW5jcmVhc2UgaXQgYnkgMSBkYXlzLiB0byBpbmxjdWRlIHRoZSBzZWxlY3RlYyBkYXRlIGluIHRoZSByYW5nZS5cclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZTEgPSBtb21lbnQodGhpcy5zZWxlY3RlZERhdGUxKS5hZGQoMSwgJ2RheXMnKS50b0RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlVXRpbGl0eS5kYXRlSW5SYW5nZShpdGVtRGF0ZSwgdGhpcy5zZWxlY3RlZERhdGUyLCB0aGlzLnNlbGVjdGVkRGF0ZTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVVdGlsaXR5LnNhbWVEYXRlVGltZSh0aGlzLmdldFZhbHVlKGl0ZW0pLCB0aGlzLnNlbGVjdGVkRGF0ZTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVV0aWxpdHkuc2FtZURhdGUodGhpcy5nZXRWYWx1ZShpdGVtKSwgdGhpcy5zZWxlY3RlZERhdGUxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlRmlsdGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fdHJhbnNmb3JtLmdldFZhbHVlKGl0ZW0sIHRoaXMudmFsdWVTZWxlY3Rvcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVGaWx0ZXI7XHJcbn0oKSk7XHJcbmRhdGVGaWx0ZXJGYWN0b3J5LiRpbmplY3QgPSBbX19kYXRlLnNlcnZpY2VOYW1lXTtcclxuZnVuY3Rpb24gZGF0ZUZpbHRlckZhY3RvcnkoZGF0ZVV0aWxpdHkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGVGaWx0ZXIoc2V0dGluZ3MsIGRhdGVVdGlsaXR5KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRhdGVGaWx0ZXJGYWN0b3J5ID0gZGF0ZUZpbHRlckZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGVGaWx0ZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2RhdGVGaWx0ZXIvZGF0ZUZpbHRlci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB0aGlzW1wibW9tZW50XCJdOyB9KCkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJtb21lbnRcIlxuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL25vZGUvbm9kZS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fZGF0ZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5kYXRlO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxEYXRlRmlsdGVyJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdybERhdGVGaWx0ZXJDb250cm9sbGVyJztcclxuLy8gT3B0aW9uYWwgaW50ZXJmYWNlIGZvciBib3VuZCBhdHRyaWJ1dGVzXHJcbnZhciBEYXRlT3B0aW9ucztcclxuKGZ1bmN0aW9uIChEYXRlT3B0aW9ucykge1xyXG4gICAgRGF0ZU9wdGlvbnNbRGF0ZU9wdGlvbnNbXCJEYXlcIl0gPSAwXSA9IFwiRGF5XCI7XHJcbiAgICBEYXRlT3B0aW9uc1tEYXRlT3B0aW9uc1tcIldlZWtcIl0gPSAxXSA9IFwiV2Vla1wiO1xyXG4gICAgRGF0ZU9wdGlvbnNbRGF0ZU9wdGlvbnNbXCJNb250aFwiXSA9IDJdID0gXCJNb250aFwiO1xyXG59KShEYXRlT3B0aW9ucyB8fCAoRGF0ZU9wdGlvbnMgPSB7fSkpO1xyXG47XHJcbnZhciBEYXRlRmlsdGVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRlRmlsdGVyQ29udHJvbGxlcigkc2NvcGUsIGRhdGVVdGlsaXR5LCAkZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuZGF0ZVV0aWxpdHkgPSBkYXRlVXRpbGl0eTtcclxuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJkYXlzXCI7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIuaW5jbHVkZVRpbWUgPSB0aGlzLmluY2x1ZGVUaW1lO1xyXG4gICAgICAgIC8vdGhpcyBpcyBhZGRlZCB0byBhZGRyZXNzIGFuIGFndWxhciBxdWlyayBvbiB0aGUgc2VydmljZSBldmVudCBsaXN0IHBhZ2UuXHJcbiAgICAgICAgLy90aGUgaW5wdXQgZmllbGQgd2FzIG5vdCBjbGVhcmluZyBjb3JyZWNsdHkgd2hlbiB0aGUgc2VsZWN0ZWREYXRlMSB2YWx1ZSBpcyBudWxsLlxyXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZCA9IHRoaXMuJGVsZW1lbnQuZmluZCgncmwtZGF0ZS10aW1lIGlucHV0Jyk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIuZGF0ZVJhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xlYXJCdXR0b24gPT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5jbGVhckJ1dHRvbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZUZpbHRlckNvbnRyb2xsZXIucHJvdG90eXBlLCBcInNlbGVjdGVkRGF0ZTFcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIuc2VsZWN0ZWREYXRlMSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuZmlsdGVyLnNlbGVjdGVkRGF0ZTEpLmZvcm1hdCgnTS9EL1lZWVknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vY2xlYXIgaW5wdXQgZmllbGQgb2YgZGF0ZSB2YWx1ZS4gYW5kIHJlc3QgcGFzdCBkYXkvd2VlayBjb3VudFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbCgnJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ291bnQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGVVdGlsaXR5LmlzRGF0ZSh2KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXIuc2VsZWN0ZWREYXRlMSA9IG1vbWVudCh2KS50b0RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vY2xlYXIgaW5wdXQgZmllbGQgb2YgZGF0ZSB2YWx1ZS4gYW5kIHJlc3QgcGFzdCBkYXkvd2VlayBjb3VudFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbCgnJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ291bnQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyLnNlbGVjdGVkRGF0ZTEgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaERhdGFTb3VyY2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlRmlsdGVyQ29udHJvbGxlci5wcm90b3R5cGUsIFwic2VsZWN0ZWREYXRlMlwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5zZWxlY3RlZERhdGUyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlci5zZWxlY3RlZERhdGUyID0gdjtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoRGF0YVNvdXJjZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRGF0ZUZpbHRlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2hEYXRhU291cmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlLiRlbWl0KCdkYXRhU291cmNlLnJlcXVlc3RSZWZyZXNoJyk7IC8vKmV2ZW50P1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlRmlsdGVyQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXJDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmNvdW50Q2hhbmdlKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUZpbHRlckNvbnRyb2xsZXIucHJvdG90eXBlLmRlY3JlYXNlQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCAtPSAxO1xyXG4gICAgICAgIHRoaXMuc2V0RGF0ZVRpbWVOb3dJZk51bGwoKTtcclxuICAgICAgICAvL2RvIG5vdCBhbGxvdyBjb3VudCBiZWxvdyAwXHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPCAwIHx8IHRoaXMuY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY291bnRDaGFuZ2UoKTtcclxuICAgIH07XHJcbiAgICBEYXRlRmlsdGVyQ29udHJvbGxlci5wcm90b3R5cGUuY291bnRDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLmRhdGVSYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIGFkZCBkYXlzIGhhcyB0byBiZSBhIG5lZ2F0aXZlIG51bWJlciB0byBnbyBiYWNrd29yZHMuXHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlMiA9IG1vbWVudCh0aGlzLnNlbGVjdGVkRGF0ZTEpLmFkZCgodGhpcy5jb3VudCAqIC0xKSwgdGhpcy50eXBlKS50b0RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vb25seSBjaGFuZ2UgdGhpcyB2YWx1ZXMgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlci5kYXRlUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyLmRhdGVSYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlRmlsdGVyQ29udHJvbGxlci5wcm90b3R5cGUuaW5jcmVhc2VDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvdW50ICs9IDE7XHJcbiAgICAgICAgdGhpcy5zZXREYXRlVGltZU5vd0lmTnVsbCgpO1xyXG4gICAgICAgIHRoaXMuY291bnRDaGFuZ2UoKTtcclxuICAgIH07XHJcbiAgICBEYXRlRmlsdGVyQ29udHJvbGxlci5wcm90b3R5cGUuc2V0RGF0ZVRpbWVOb3dJZk51bGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWREYXRlMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlMSA9IG1vbWVudChEYXRlLm5vdygpKS5mb3JtYXQoJ00vRC9ZWVlZJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVGaWx0ZXJDb250cm9sbGVyLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RheXMnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICd3ZWVrcyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnZGF5cyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY291bnRDaGFuZ2UoKTtcclxuICAgIH07XHJcbiAgICBEYXRlRmlsdGVyQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCBfX2RhdGUuc2VydmljZU5hbWUsICckZWxlbWVudCddO1xyXG4gICAgcmV0dXJuIERhdGVGaWx0ZXJDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkRhdGVGaWx0ZXJDb250cm9sbGVyID0gRGF0ZUZpbHRlckNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGRhdGVGaWx0ZXIoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZGF0ZUZpbHRlci5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdmaWx0ZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGZpbHRlcjogJz0nLFxyXG4gICAgICAgICAgICBzb3VyY2U6ICc9JyxcclxuICAgICAgICAgICAgbGFiZWw6ICdAJyxcclxuICAgICAgICAgICAgaW5jbHVkZVRpbWU6ICc9JyxcclxuICAgICAgICAgICAgaW5jbHVkZURhdGVSYW5nZTogJz0nLFxyXG4gICAgICAgICAgICBjbGVhckJ1dHRvbjogJz0nXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5kYXRlRmlsdGVyID0gZGF0ZUZpbHRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZUZpbHRlci5jb21wb25lbnQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9kYXRlRmlsdGVyL2RhdGVGaWx0ZXIuY29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJmaWx0ZXItZ3JvdXBcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbnRlbnQtZ3JvdXBcXFwiPlxcclxcblxcdFxcdDxsYWJlbD57ezo6ZmlsdGVyLmxhYmVsfX08L2xhYmVsPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxyXFxuXFx0XFx0XFx0PHJsLWRhdGUtdGltZSBuZy1tb2RlbD1cXFwiZmlsdGVyLnNlbGVjdGVkRGF0ZTFcXFwiIHVzZS10aW1lPVxcXCJmaWx0ZXIuaW5jbHVkZVRpbWVcXFwiIGNsZWFyLWJ1dHRvbj1cXFwiZmlsdGVyLmNsZWFyQnV0dG9uXFxcIiBvbi1jbGVhci1ldmVudD1cXFwiZmlsdGVyLmNsZWFyQ291bnQoKVxcXCJcXHJcXG5cXHRcXHRcXHRjbGFzcz1cXFwicHVsbC1sZWZ0XFxcIj48L3JsLWRhdGUtdGltZT5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IG5nLWlmPVxcXCJmaWx0ZXIuaW5jbHVkZURhdGVSYW5nZVxcXCIgY2xhc3M9XFxcImNvbnRlbnQtZ3JvdXBcXFwiPlxcclxcblxcdFxcdDxsYWJlbD5BZGQgcHJldmlvdXM8L2xhYmVsPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIj5cXHJcXG5cXHRcXHQ8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIj5cXHJcXG5cXHRcXHRcXHQ8YnV0dG9uICBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwiZmlsdGVyLmRlY3JlYXNlQ291bnQoKTtcXFwiPlxcclxcblxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1taW51c1xcXCI+PC9pPlxcclxcblxcdFxcdFxcdDwvYnV0dG9uPlxcclxcblxcdFxcdDwvc3Bhbj5cXHJcXG5cXHRcXHQ8aW5wdXQgdHlwZT1cXFwibnVtYmVyXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiZmlsdGVyLmNvdW50XFxcIiBuZy1jaGFuZ2U9XFxcImZpbHRlci5jb3VudENoYW5nZSgpO1xcXCIgLz5cXHJcXG5cXHRcXHQ8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYnRuXFxcIj5cXHJcXG5cXHRcXHRcXHQ8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsaWNrPVxcXCJmaWx0ZXIudG9nZ2xlKCk7XFxcIj5cXHJcXG5cXHRcXHRcXHR7e2ZpbHRlci50eXBlfX1cXHJcXG5cXHRcXHRcXHQ8L2J1dHRvbj5cXHJcXG5cXHRcXHQ8L3NwYW4+XFxyXFxuXFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxyXFxuXFx0XFx0XFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwiZmlsdGVyLmluY3JlYXNlQ291bnQoKTtcXFwiPlxcclxcblxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1wbHVzXFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0PC9idXR0b24+XFxyXFxuXFx0XFx0PC9zcGFuPlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9kYXRlRmlsdGVyL2RhdGVGaWx0ZXIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIGZpbHRlck9wdGlvbiA9IHJlcXVpcmUoJy4vZmlsdGVyT3B0aW9uL2ZpbHRlck9wdGlvbicpO1xyXG5leHBvcnRzLmZpbHRlck9wdGlvbiA9IGZpbHRlck9wdGlvbjtcclxudmFyIG1vZGVGaWx0ZXJHcm91cCA9IHJlcXVpcmUoJy4vbW9kZUZpbHRlckdyb3VwL21vZGVGaWx0ZXJHcm91cC5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kZUZpbHRlckdyb3VwID0gbW9kZUZpbHRlckdyb3VwO1xyXG52YXIgcmFuZ2VGaWx0ZXJHcm91cCA9IHJlcXVpcmUoJy4vcmFuZ2VGaWx0ZXJHcm91cC9yYW5nZUZpbHRlckdyb3VwLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5yYW5nZUZpbHRlckdyb3VwID0gcmFuZ2VGaWx0ZXJHcm91cDtcclxudmFyIGZpbHRlckdyb3VwX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vZmlsdGVyR3JvdXAuc2VydmljZScpO1xyXG52YXIgZmlsdGVyR3JvdXBfZGlyZWN0aXZlXzEgPSByZXF1aXJlKCcuL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZScpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL2ZpbHRlckdyb3VwLmRpcmVjdGl2ZScpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9maWx0ZXJHcm91cC5zZXJ2aWNlJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuZmlsdGVyR3JvdXAnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtcclxuICAgIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3QubW9kdWxlTmFtZSxcclxuICAgIGZpbHRlck9wdGlvbi5tb2R1bGVOYW1lLFxyXG4gICAgbW9kZUZpbHRlckdyb3VwLm1vZHVsZU5hbWUsXHJcbiAgICByYW5nZUZpbHRlckdyb3VwLm1vZHVsZU5hbWUsXHJcbl0pXHJcbiAgICAuZmFjdG9yeShmaWx0ZXJHcm91cF9zZXJ2aWNlXzEuZmFjdG9yeU5hbWUsIGZpbHRlckdyb3VwX3NlcnZpY2VfMS5maWx0ZXJHcm91cEZhY3RvcnkpXHJcbiAgICAuZGlyZWN0aXZlKGZpbHRlckdyb3VwX2RpcmVjdGl2ZV8xLmRpcmVjdGl2ZU5hbWUsIGZpbHRlckdyb3VwX2RpcmVjdGl2ZV8xLmZpbHRlckdyb3VwKVxyXG4gICAgLmNvbnRyb2xsZXIoZmlsdGVyR3JvdXBfZGlyZWN0aXZlXzEuY29udHJvbGxlck5hbWUsIGZpbHRlckdyb3VwX2RpcmVjdGl2ZV8xLkZpbHRlckdyb3VwQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlckdyb3VwLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZmlsdGVycy5maWx0ZXJHcm91cC5maWx0ZXJPcHRpb24nO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxGaWx0ZXJPcHRpb24nO1xyXG5mdW5jdGlvbiBmaWx0ZXJPcHRpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZmlsdGVyT3B0aW9uLmh0bWwnKSxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBhY3RpdmF0ZTogJyYnLFxyXG4gICAgICAgICAgICBpc0FjdGl2ZTogJz1hY3RpdmUnLFxyXG4gICAgICAgICAgICBvcHRpb246ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmZpbHRlck9wdGlvbiA9IGZpbHRlck9wdGlvbjtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBmaWx0ZXJPcHRpb24pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXJPcHRpb24uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJPcHRpb24vZmlsdGVyT3B0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3cgZmlsdGVyLW9wdGlvblxcXCIgbmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IGlzQWN0aXZlIH1cXFwiIG5nLWNsaWNrPVxcXCJhY3RpdmF0ZSgpXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMVxcXCI+XFxyXFxuXFx0XFx0PGkgY2xhc3M9J2ZhIGZhLWFycm93LXJpZ2h0JyBuZy1zaG93PVxcXCJpc0FjdGl2ZSA9PSB0cnVlXFxcIj48L2k+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29sLXhzLTFcXFwiIG5nLWlmPVxcXCJoYXNJY29uXFxcIiBuZy1iaW5kLWh0bWw9XFxcIm9wdGlvbi5pY29uXFxcIj48L2Rpdj5cXHJcXG5cXHQ8ZGl2IG5nLWNsYXNzPVxcXCJ7ICdjb2wteHMtNic6IGhhc0ljb24sICdjb2wteHMtNyc6ICFoYXNJY29uIH1cXFwiPlxcclxcblxcdFxcdHt7b3B0aW9uLmxhYmVsfX1cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMyB0ZXh0LXJpZ2h0XFxcIiBuZy1zaG93PVxcXCJvcHRpb24uY291bnQgIT0gbnVsbFxcXCI+XFxyXFxuXFx0XFx0KHt7b3B0aW9uLmNvdW50fX0pXFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlck9wdGlvbi9maWx0ZXJPcHRpb24uaHRtbFxuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX190cmFuc2Zvcm0gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudHJhbnNmb3JtLnRyYW5zZm9ybTtcclxudmFyIGZpbHRlckdyb3VwX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2ZpbHRlckdyb3VwLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5maWx0ZXJzLmZpbHRlckdyb3VwLm1vZGVGaWx0ZXJHcm91cCc7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnbW9kZUZpbHRlckdyb3VwJztcclxudmFyIE1vZGVGaWx0ZXJHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTW9kZUZpbHRlckdyb3VwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9kZUZpbHRlckdyb3VwKHNldHRpbmdzLCBvYmplY3QpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzZXR0aW5ncywgb2JqZWN0KTtcclxuICAgICAgICB0aGlzLmdldFZhbHVlID0gc2V0dGluZ3MuZ2V0VmFsdWU7XHJcbiAgICAgICAgc2V0dGluZ3Mub3B0aW9ucyA9IF8ubWFwKHNldHRpbmdzLm9wdGlvbnMsIHRoaXMuYnVpbGRNb2RlT3B0aW9uLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuaW5pdE9wdGlvbnMoKTtcclxuICAgIH1cclxuICAgIE1vZGVGaWx0ZXJHcm91cC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhY3RpdmVPcHRpb24gPSB0aGlzLmFjdGl2ZU9wdGlvbjtcclxuICAgICAgICBpZiAoYWN0aXZlT3B0aW9uLmRpc3BsYXlBbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY3RpdmVPcHRpb24udmFsdWU7XHJcbiAgICB9O1xyXG4gICAgTW9kZUZpbHRlckdyb3VwLnByb3RvdHlwZS5idWlsZE1vZGVPcHRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbW9kZU9wdGlvbiA9IG9wdGlvbjtcclxuICAgICAgICBtb2RlT3B0aW9uLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RlT3B0aW9uLmRpc3BsYXlBbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfX3RyYW5zZm9ybS5nZXRWYWx1ZShpdGVtLCBfdGhpcy5nZXRWYWx1ZSkgPT09IG1vZGVPcHRpb24udmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbW9kZU9wdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9kZUZpbHRlckdyb3VwO1xyXG59KGZpbHRlckdyb3VwX3NlcnZpY2VfMS5GaWx0ZXJHcm91cCkpO1xyXG5leHBvcnRzLk1vZGVGaWx0ZXJHcm91cCA9IE1vZGVGaWx0ZXJHcm91cDtcclxubW9kZUZpbHRlckdyb3VwRmFjdG9yeS4kaW5qZWN0ID0gW19fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuZnVuY3Rpb24gbW9kZUZpbHRlckdyb3VwRmFjdG9yeShvYmplY3QpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVGaWx0ZXJHcm91cChzZXR0aW5ncywgb2JqZWN0KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm1vZGVGaWx0ZXJHcm91cEZhY3RvcnkgPSBtb2RlRmlsdGVyR3JvdXBGYWN0b3J5O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5mYWN0b3J5KGV4cG9ydHMuZmFjdG9yeU5hbWUsIG1vZGVGaWx0ZXJHcm91cEZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlRmlsdGVyR3JvdXAuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2ZpbHRlckdyb3VwL21vZGVGaWx0ZXJHcm91cC9tb2RlRmlsdGVyR3JvdXAuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnZmlsdGVyR3JvdXAnO1xyXG52YXIgRmlsdGVyR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZpbHRlckdyb3VwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRmlsdGVyR3JvdXAoc2V0dGluZ3MsIG9iamVjdCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gJzxybC1maWx0ZXItZ3JvdXAgZmlsdGVyLWdyb3VwPVwiZmlsdGVyXCIgc291cmNlPVwiZGF0YVNvdXJjZVwiPjwvcmwtZmlsdGVyLWdyb3VwPic7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IHNldHRpbmdzLmxhYmVsO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHNldHRpbmdzLnR5cGUgIT0gbnVsbCA/IHNldHRpbmdzLnR5cGUgOiBzZXR0aW5ncy5sYWJlbDtcclxuICAgICAgICB0aGlzLmluaXRPcHRpb25zKCk7XHJcbiAgICB9XHJcbiAgICBGaWx0ZXJHcm91cC5wcm90b3R5cGUuaW5pdE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnNldHRpbmdzLm9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVPcHRpb24gPSB0aGlzLnNldERlZmF1bHRPcHRpb24oKTtcclxuICAgICAgICBfLmVhY2godGhpcy5vcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbi50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnR5cGUgPSBvcHRpb24ubGFiZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0aW9uLnR5cGUgPSBfdGhpcy5vYmplY3QudG9TdHJpbmcob3B0aW9uLnR5cGUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpbHRlckdyb3VwLnByb3RvdHlwZSwgXCJhY3RpdmVPcHRpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlT3B0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlT3B0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgRmlsdGVyR3JvdXAucHJvdG90eXBlLnNldERlZmF1bHRPcHRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb24gPSB0aGlzLm9wdGlvbnNbMF07XHJcbiAgICAgICAgXy5lYWNoKHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uYWN0aXZlICE9IG51bGwgJiYgaXRlbS5hY3RpdmUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb24gPSBpdGVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPcHRpb247XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyR3JvdXAucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT3B0aW9uLmZpbHRlcihpdGVtKTtcclxuICAgIH07XHJcbiAgICBGaWx0ZXJHcm91cC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5zZXJpYWxpemUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuYWN0aXZlT3B0aW9uLnNlcmlhbGl6ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlT3B0aW9uLnNlcmlhbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPcHRpb24udmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyR3JvdXAucHJvdG90eXBlLnNldEFjdGl2ZU9wdGlvbiA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5vcHRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbiA9IHRoaXMub3B0aW9uc1tpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZpbHRlckdyb3VwLnByb3RvdHlwZS5zZXRPcHRpb25Db3VudHMgPSBmdW5jdGlvbiAoY291bnRzKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoXy5oYXMoY291bnRzLCBvcHRpb24udHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5jb3VudCA9IGNvdW50c1tvcHRpb24udHlwZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGaWx0ZXJHcm91cC5wcm90b3R5cGUudXBkYXRlT3B0aW9uQ291bnRzID0gZnVuY3Rpb24gKGZpbHRlcmVkRGF0YVNldCkge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgb3B0aW9uLmNvdW50ID0gXy5maWx0ZXIoZmlsdGVyZWREYXRhU2V0LCBvcHRpb24uZmlsdGVyLmJpbmQob3B0aW9uKSkubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGaWx0ZXJHcm91cDtcclxufSh0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuZmlsdGVycy5TZXJpYWxpemFibGVGaWx0ZXIpKTtcclxuZXhwb3J0cy5GaWx0ZXJHcm91cCA9IEZpbHRlckdyb3VwO1xyXG5maWx0ZXJHcm91cEZhY3RvcnkuJGluamVjdCA9IFtfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIGZpbHRlckdyb3VwRmFjdG9yeShvYmplY3QpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpbHRlckdyb3VwKHNldHRpbmdzLCBvYmplY3QpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZmlsdGVyR3JvdXBGYWN0b3J5ID0gZmlsdGVyR3JvdXBGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXJHcm91cC5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX190cmFuc2Zvcm0gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudHJhbnNmb3JtLnRyYW5zZm9ybTtcclxudmFyIGZpbHRlckdyb3VwX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2ZpbHRlckdyb3VwLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5maWx0ZXJzLmZpbHRlckdyb3VwLnJhbmdlRmlsdGVyR3JvdXAnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3JhbmdlRmlsdGVyR3JvdXAnO1xyXG52YXIgUmFuZ2VGaWx0ZXJHcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmFuZ2VGaWx0ZXJHcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJhbmdlRmlsdGVyR3JvdXAoc2V0dGluZ3MsIG9iamVjdCkge1xyXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzLCBvYmplY3QpO1xyXG4gICAgICAgIHRoaXMuZ2V0VmFsdWUgPSBzZXR0aW5ncy5nZXRWYWx1ZTtcclxuICAgICAgICBzZXR0aW5ncy5vcHRpb25zID0gXy5tYXAoc2V0dGluZ3Mub3B0aW9ucywgdGhpcy5idWlsZFJhbmdlT3B0aW9uLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuaW5pdE9wdGlvbnMoKTtcclxuICAgIH1cclxuICAgIFJhbmdlRmlsdGVyR3JvdXAucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYWN0aXZlT3B0aW9uID0gdGhpcy5hY3RpdmVPcHRpb247XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOdWxsT3B0aW9uKGFjdGl2ZU9wdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhpZ2hJbmNsdXNpdmU6IGFjdGl2ZU9wdGlvbi5oaWdoSW5jbHVzaXZlLFxyXG4gICAgICAgICAgICBoaWdoRXhjbHVzaXZlOiBhY3RpdmVPcHRpb24uaGlnaEV4Y2x1c2l2ZSxcclxuICAgICAgICAgICAgbG93SW5jbHVzaXZlOiBhY3RpdmVPcHRpb24ubG93SW5jbHVzaXZlLFxyXG4gICAgICAgICAgICBsb3dFeGNsdXNpdmU6IGFjdGl2ZU9wdGlvbi5sb3dFeGNsdXNpdmUsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBSYW5nZUZpbHRlckdyb3VwLnByb3RvdHlwZS5idWlsZFJhbmdlT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG1vZGVPcHRpb24gPSBvcHRpb247XHJcbiAgICAgICAgbW9kZU9wdGlvbi5maWx0ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfX3RyYW5zZm9ybS5nZXRWYWx1ZShpdGVtLCBfdGhpcy5nZXRWYWx1ZSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb24uaGlnaEV4Y2x1c2l2ZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZSA8IG9wdGlvbi5oaWdoRXhjbHVzaXZlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLmhpZ2hJbmNsdXNpdmUpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUgPD0gb3B0aW9uLmhpZ2hJbmNsdXNpdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLmxvd0V4Y2x1c2l2ZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdmFsdWUgPiBvcHRpb24ubG93RXhjbHVzaXZlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9uLmxvd0luY2x1c2l2ZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgJiYgdmFsdWUgPj0gb3B0aW9uLmxvd0luY2x1c2l2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG1vZGVPcHRpb247XHJcbiAgICB9O1xyXG4gICAgUmFuZ2VGaWx0ZXJHcm91cC5wcm90b3R5cGUuaXNOdWxsT3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgIHJldHVybiBvcHRpb24uaGlnaEluY2x1c2l2ZSA9PSBudWxsXHJcbiAgICAgICAgICAgICYmIG9wdGlvbi5oaWdoRXhjbHVzaXZlID09IG51bGxcclxuICAgICAgICAgICAgJiYgb3B0aW9uLmxvd0luY2x1c2l2ZSA9PSBudWxsXHJcbiAgICAgICAgICAgICYmIG9wdGlvbi5sb3dFeGNsdXNpdmUgPT0gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmFuZ2VGaWx0ZXJHcm91cDtcclxufShmaWx0ZXJHcm91cF9zZXJ2aWNlXzEuRmlsdGVyR3JvdXApKTtcclxucmFuZ2VGaWx0ZXJHcm91cEZhY3RvcnkuJGluamVjdCA9IFtfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbmZ1bmN0aW9uIHJhbmdlRmlsdGVyR3JvdXBGYWN0b3J5KG9iamVjdCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VGaWx0ZXJHcm91cChzZXR0aW5ncywgb2JqZWN0KTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJhbmdlRmlsdGVyR3JvdXBGYWN0b3J5ID0gcmFuZ2VGaWx0ZXJHcm91cEZhY3Rvcnk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgcmFuZ2VGaWx0ZXJHcm91cEZhY3RvcnkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5nZUZpbHRlckdyb3VwLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9yYW5nZUZpbHRlckdyb3VwL3JhbmdlRmlsdGVyR3JvdXAuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsRmlsdGVyR3JvdXAnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0ZpbHRlckdyb3VwQ29udHJvbGxlcic7XHJcbnZhciBGaWx0ZXJHcm91cENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmlsdGVyR3JvdXBDb250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuaGFzSWNvbiA9IHRoaXMuaWNvbiAhPSBudWxsICYmIHRoaXMuaWNvbiAhPT0gJyc7XHJcbiAgICAgICAgdGhpcy5zaG93Q2hpbGRyZW4gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgRmlsdGVyR3JvdXBDb250cm9sbGVyLnByb3RvdHlwZS50b2dnbGVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNob3dDaGlsZHJlbiA9ICF0aGlzLnNob3dDaGlsZHJlbjtcclxuICAgIH07XHJcbiAgICBGaWx0ZXJHcm91cENvbnRyb2xsZXIucHJvdG90eXBlLnNlbGVjdE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICB0aGlzLmZpbHRlckdyb3VwLmFjdGl2ZU9wdGlvbiA9IG9wdGlvbjtcclxuICAgICAgICB0aGlzLnNob3dDaGlsZHJlbiA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlLiRlbWl0KCdkYXRhU291cmNlLnJlcXVlc3RSZWZyZXNoJyk7IC8vKmV2ZW50P1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBGaWx0ZXJHcm91cENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gRmlsdGVyR3JvdXBDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkZpbHRlckdyb3VwQ29udHJvbGxlciA9IEZpbHRlckdyb3VwQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gZmlsdGVyR3JvdXAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZmlsdGVyR3JvdXAuZGlyZWN0aXZlLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2NvbnRyb2xsZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGljb246ICc9JyxcclxuICAgICAgICAgICAgZmlsdGVyR3JvdXA6ICc9JyxcclxuICAgICAgICAgICAgc291cmNlOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5maWx0ZXJHcm91cCA9IGZpbHRlckdyb3VwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXJHcm91cC5kaXJlY3RpdmUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9maWx0ZXJHcm91cC9maWx0ZXJHcm91cC5kaXJlY3RpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImZpbHRlci1ncm91cFxcXCI+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwicm93IGZpbHRlci1oZWFkZXJcXFwiIG5nLWNsaWNrPVxcXCJjb250cm9sbGVyLnRvZ2dsZUNoaWxkcmVuKClcXFwiPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1zbS0xMlxcXCI+XFxyXFxuXFx0XFx0XFx0PGkgY2xhc3M9XFxcImNvbGxhcHNlLWljb24gZmEgZmEtY2FyZXQtZG93biBmYS0yeFxcXCIgbmctc2hvdz1cXFwiY29udHJvbGxlci5zaG93Q2hpbGRyZW5cXFwiIHRpdGxlPVxcXCJIaWRlIGZpbHRlciBsaXN0XFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0PGkgY2xhc3M9XFxcImNvbGxhcHNlLWljb24gZmEgZmEtY2FyZXQtcmlnaHQgZmEtMnhcXFwiIG5nLWhpZGU9XFxcImNvbnRyb2xsZXIuc2hvd0NoaWxkcmVuXFxcIiB0aXRsZT1cXFwiU2hvdyBmaWx0ZXIgbGlzdFxcXCI+PC9pPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImZpbHRlci1vcHRpb25cXFwiPlxcclxcblxcdFxcdFxcdFxcdDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6aW5saW5lLWJsb2NrXFxcIiBuZy1zaG93PVxcXCJjb250cm9sbGVyLmhhc0ljb25cXFwiIG5nLWJpbmQtaHRtbD1cXFwiY29udHJvbGxlci5pY29uXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8aDQgc3R5bGU9XFxcImRpc3BsYXk6IGlubGluZS1ibG9ja1xcXCI+e3tjb250cm9sbGVyLmZpbHRlckdyb3VwLmxhYmVsfX06IHt7Y29udHJvbGxlci5maWx0ZXJHcm91cC5hY3RpdmVPcHRpb24ubGFiZWx9fTwvaDQ+XFxyXFxuXFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0PC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBuZy1zaG93PVxcXCJjb250cm9sbGVyLnNob3dDaGlsZHJlblxcXCIgbmctcmVwZWF0PVxcXCJmaWx0ZXJPcHRpb24gaW4gY29udHJvbGxlci5maWx0ZXJHcm91cC5vcHRpb25zXFxcIj5cXHJcXG5cXHRcXHQ8cmwtZmlsdGVyLW9wdGlvbiBvcHRpb249XFxcImZpbHRlck9wdGlvblxcXCIgYWN0aXZlPVxcXCJmaWx0ZXJHcm91cC5hY3RpdmVPcHRpb24gPT09IGZpbHRlck9wdGlvblxcXCIgYWN0aXZhdGU9XFxcImNvbnRyb2xsZXIuc2VsZWN0T3B0aW9uKGZpbHRlck9wdGlvbilcXFwiPjwvcmwtZmlsdGVyLW9wdGlvbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvZmlsdGVyR3JvdXAvZmlsdGVyR3JvdXAuZGlyZWN0aXZlLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSA4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBzZWxlY3RGaWx0ZXJfc2VydmljZV8xID0gcmVxdWlyZSgnLi9zZWxlY3RGaWx0ZXIuc2VydmljZScpO1xyXG52YXIgc2VsZWN0RmlsdGVyX2NvbXBvbmVudF8xID0gcmVxdWlyZSgnLi9zZWxlY3RGaWx0ZXIuY29tcG9uZW50Jyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuZmlsdGVycy5zZWxlY3RGaWx0ZXInO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NlbGVjdEZpbHRlci5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3NlbGVjdEZpbHRlci5jb21wb25lbnQnKSk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZmFjdG9yeShzZWxlY3RGaWx0ZXJfc2VydmljZV8xLmZhY3RvcnlOYW1lLCBzZWxlY3RGaWx0ZXJfc2VydmljZV8xLnNlbGVjdEZpbHRlckZhY3RvcnkpXHJcbiAgICAuZGlyZWN0aXZlKHNlbGVjdEZpbHRlcl9jb21wb25lbnRfMS5kaXJlY3RpdmVOYW1lLCBzZWxlY3RGaWx0ZXJfY29tcG9uZW50XzEuc2VsZWN0RmlsdGVyKVxyXG4gICAgLmNvbnRyb2xsZXIoc2VsZWN0RmlsdGVyX2NvbXBvbmVudF8xLmNvbnRyb2xsZXJOYW1lLCBzZWxlY3RGaWx0ZXJfY29tcG9uZW50XzEuU2VsZWN0RmlsdGVyQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdEZpbHRlci5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9zZWxlY3RGaWx0ZXIvc2VsZWN0RmlsdGVyLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBfX3RyYW5zZm9ybSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy50cmFuc2Zvcm0udHJhbnNmb3JtO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ3JsU2VsZWN0RmlsdGVyRmFjdG9yeSc7XHJcbnZhciBTZWxlY3RGaWx0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VsZWN0RmlsdGVyKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3NlbGVjdEZpbHRlcic7XHJcbiAgICAgICAgdGhpcy52YWx1ZVNlbGVjdG9yID0gc2V0dGluZ3MudmFsdWVTZWxlY3RvcjtcclxuICAgICAgICB0aGlzLmNvbXBhcmVyID0gc2V0dGluZ3MuY29tcGFyZXI7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gc2V0dGluZ3Mub3B0aW9ucztcclxuICAgICAgICB0aGlzLmdldE9wdGlvbnMgPSBzZXR0aW5ncy5nZXRPcHRpb25zO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBzZXR0aW5ncy5sYWJlbDtcclxuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lU2VsZWN0b3IgPSBzZXR0aW5ncy5kaXNwbGF5TmFtZVNlbGVjdG9yO1xyXG4gICAgICAgIHRoaXMubnVsbE9wdGlvbiA9IHNldHRpbmdzLm51bGxPcHRpb247XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IFwiPHJsLXNlbGVjdC1maWx0ZXIgZmlsdGVyPVxcXCJmaWx0ZXJcXFwiIHNvdXJjZT1cXFwiZGF0YVNvdXJjZVxcXCIgb3B0aW9ucz1cXFwiZmlsdGVyLm9wdGlvbnNcXFwiIGdldC1vcHRpb25zPVxcXCJmaWx0ZXIuZ2V0T3B0aW9ucygpXFxcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgIGxhYmVsPVxcXCJ7e2ZpbHRlci5sYWJlbH19XFxcIiBzZWxlY3Rvcj1cXFwiZmlsdGVyLmRpc3BsYXlOYW1lU2VsZWN0b3JcXFwiIG51bGwtb3B0aW9uPVxcXCJ7e2ZpbHRlci5udWxsT3B0aW9ufX1cXFwiPjwvcmwtc2VsZWN0LWZpbHRlcj5cIjtcclxuICAgIH1cclxuICAgIFNlbGVjdEZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZXIodGhpcy5nZXRWYWx1ZShpdGVtKSwgdGhpcy5zZWxlY3RlZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9fb2JqZWN0Lm9iamVjdFV0aWxpdHkuYXJlRXF1YWwodGhpcy5nZXRWYWx1ZShpdGVtKSwgdGhpcy5zZWxlY3RlZFZhbHVlKTtcclxuICAgIH07XHJcbiAgICBTZWxlY3RGaWx0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gX190cmFuc2Zvcm0uZ2V0VmFsdWUoaXRlbSwgdGhpcy52YWx1ZVNlbGVjdG9yKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2VsZWN0RmlsdGVyO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBzZWxlY3RGaWx0ZXJGYWN0b3J5KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0RmlsdGVyKHNldHRpbmdzKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNlbGVjdEZpbHRlckZhY3RvcnkgPSBzZWxlY3RGaWx0ZXJGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3RGaWx0ZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL3NlbGVjdEZpbHRlci9zZWxlY3RGaWx0ZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsU2VsZWN0RmlsdGVyJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdTZWxlY3RGaWx0ZXJDb250cm9sbGVyJztcclxudmFyIFNlbGVjdEZpbHRlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VsZWN0RmlsdGVyQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWxlY3RGaWx0ZXJDb250cm9sbGVyLnByb3RvdHlwZSwgXCJzZWxlY3RlZFZhbHVlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyLnNlbGVjdGVkVmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLnNlbGVjdGVkVmFsdWUgPSB2O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2UucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ2RhdGFTb3VyY2UucmVxdWVzdFJlZnJlc2gnKTsgLy8qZXZlbnQ/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFNlbGVjdEZpbHRlckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gU2VsZWN0RmlsdGVyQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5TZWxlY3RGaWx0ZXJDb250cm9sbGVyID0gU2VsZWN0RmlsdGVyQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gc2VsZWN0RmlsdGVyKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3NlbGVjdEZpbHRlci5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdmaWx0ZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGZpbHRlcjogJz0nLFxyXG4gICAgICAgICAgICBvcHRpb25zOiAnPScsXHJcbiAgICAgICAgICAgIGdldE9wdGlvbnM6ICcmJyxcclxuICAgICAgICAgICAgc291cmNlOiAnPScsXHJcbiAgICAgICAgICAgIGxhYmVsOiAnQCcsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnPScsXHJcbiAgICAgICAgICAgIG51bGxPcHRpb246ICdAJ1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2VsZWN0RmlsdGVyID0gc2VsZWN0RmlsdGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3RGaWx0ZXIuY29tcG9uZW50LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2ZpbHRlcnMvc2VsZWN0RmlsdGVyL3NlbGVjdEZpbHRlci5jb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImZpbHRlci1ncm91cFxcXCI+XFxyXFxuXFx0PHJsLXNlbGVjdCBuZy1tb2RlbD1cXFwiZmlsdGVyLnNlbGVjdGVkVmFsdWVcXFwiIG9wdGlvbnM9XFxcImZpbHRlci5vcHRpb25zXFxcIiBsYWJlbD1cXFwie3tmaWx0ZXIubGFiZWx9fVxcXCJcXHJcXG5cXHRcXHRcXHQgICBzZWxlY3Rvcj1cXFwiZmlsdGVyLnNlbGVjdG9yXFxcIiBnZXQtb3B0aW9ucz1cXFwiZmlsdGVyLmdldE9wdGlvbnMoKVxcXCIgbnVsbC1vcHRpb249XFxcInt7ZmlsdGVyLm51bGxPcHRpb259fVxcXCI+PC9ybC1zZWxlY3Q+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL3NlbGVjdEZpbHRlci9zZWxlY3RGaWx0ZXIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL25vZGUvbm9kZS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLmZpbHRlcnMuY2FyZENvbnRhaW5lckZpbHRlcnMnO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxDYXJkQ29udGFpbmVyRmlsdGVycyc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQ2FyZENvbnRhaW5lckZpbHRlcnNDb250cm9sbGVyJztcclxudmFyIENhcmRDb250YWluZXJGaWx0ZXJzQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYXJkQ29udGFpbmVyRmlsdGVyc0NvbnRyb2xsZXIoJHJvb3RTY29wZSkge1xyXG4gICAgICAgIHRoaXMuJHJvb3RTY29wZSA9ICRyb290U2NvcGU7XHJcbiAgICB9XHJcbiAgICBDYXJkQ29udGFpbmVyRmlsdGVyc0NvbnRyb2xsZXIucHJvdG90eXBlLiRvbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlbmRlcmFibGVGaWx0ZXJzID0gXyh0aGlzLmZpbHRlcnMpLmZpbHRlcihmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIudGVtcGxhdGUgIT0gbnVsbDtcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBfdGhpcy4kcm9vdFNjb3BlLiRuZXcoKTtcclxuICAgICAgICAgICAgc2NvcGUuZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgICAgICBzY29wZS5kYXRhU291cmNlID0gX3RoaXMuc291cmNlO1xyXG4gICAgICAgICAgICBmaWx0ZXIudGVtcGxhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZmlsdGVyLnRlbXBsYXRlLFxyXG4gICAgICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgICAgIH0pLnZhbHVlKCk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckZpbHRlcnNDb250cm9sbGVyLiRpbmplY3QgPSBbJyRyb290U2NvcGUnXTtcclxuICAgIHJldHVybiBDYXJkQ29udGFpbmVyRmlsdGVyc0NvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ2FyZENvbnRhaW5lckZpbHRlcnNDb250cm9sbGVyID0gQ2FyZENvbnRhaW5lckZpbHRlcnNDb250cm9sbGVyO1xyXG52YXIgY2FyZENvbnRhaW5lckZpbHRlcnMgPSB7XHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyRmlsdGVycy5odG1sJyksXHJcbiAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgY29udHJvbGxlckFzOiAnY29udHJvbGxlcicsXHJcbiAgICBiaW5kaW5nczoge1xyXG4gICAgICAgIGZpbHRlcnM6ICc8JyxcclxuICAgICAgICBzb3VyY2U6ICc8JyxcclxuICAgIH0sXHJcbn07XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuY29tcG9uZW50KGV4cG9ydHMuY29tcG9uZW50TmFtZSwgY2FyZENvbnRhaW5lckZpbHRlcnMpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBDYXJkQ29udGFpbmVyRmlsdGVyc0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJkQ29udGFpbmVyRmlsdGVycy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9maWx0ZXJzL2NhcmRDb250YWluZXJGaWx0ZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IG5nLXJlcGVhdD1cXFwiZmlsdGVyIGluIGNvbnRyb2xsZXIucmVuZGVyYWJsZUZpbHRlcnNcXFwiPlxcclxcblxcdDxybC10ZW1wbGF0ZS1yZW5kZXJlciB0ZW1wbGF0ZT1cXFwiZmlsdGVyLnRlbXBsYXRlXFxcIj48L3JsLXRlbXBsYXRlLXJlbmRlcmVyPlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZmlsdGVycy9jYXJkQ29udGFpbmVyRmlsdGVycy5odG1sXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIuaXRlbUNvdW50JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsSXRlbUNvdW50JztcclxuZnVuY3Rpb24gaXRlbUNvdW50KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6IHsgY2FyZENvbnRhaW5lcjogJz9eXnJsQ2FyZENvbnRhaW5lcicgfSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9pdGVtQ291bnQuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdpdGVtQ291bnQnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB0cnVlLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLml0ZW1Db3VudCA9IGl0ZW1Db3VudDtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBpdGVtQ291bnQpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtQ291bnQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvaXRlbUNvdW50L2l0ZW1Db3VudC5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHAgbmctc2hvdz1cXFwiIWl0ZW1Db3VudC5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2UubG9hZGluZ0RhdGFTZXRcXFwiPlxcclxcblxcdFNob3dpbmcgPHN0cm9uZz57e2l0ZW1Db3VudC5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2UuZGF0YVNldC5sZW5ndGh9fSBvZiB7e2l0ZW1Db3VudC5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2UuY291bnR9fTwvc3Ryb25nPiB0b3RhbCBpdGVtc1xcclxcbjwvcD5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2l0ZW1Db3VudC9pdGVtQ291bnQuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmNhcmRDb250YWluZXIucGFnZXInO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxQYWdlcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUGFnZXJDb250cm9sbGVyJztcclxuZXhwb3J0cy5kZWZhdWx0VmlzaWJsZVBhZ2VDb3VudCA9IDU7XHJcbnZhciBQYWdlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGFnZXJDb250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy5jYW5Hb0JhY2sgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbkdvRm9yd2FyZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGFzUGFnZUZpbHRlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQYWdlQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbEl0ZW1zID0gX3RoaXMuZGF0YVNvdXJjZS5jb3VudDtcclxuICAgICAgICAgICAgdmFyIG5ld0xhc3RQYWdlID0gTWF0aC5jZWlsKHRvdGFsSXRlbXMgLyBfdGhpcy5wYWdlci5wYWdlU2l6ZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdMYXN0UGFnZSAhPT0gX3RoaXMubGFzdFBhZ2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RQYWdlID0gbmV3TGFzdFBhZ2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50UGFnZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFnaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFBhZ2VyQ29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmNhcmRDb250YWluZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFnZXIgPSB0aGlzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZS5wYWdlcjtcclxuICAgICAgICBpZiAodGhpcy5wYWdlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUGFnZUZpbHRlciA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlUGFnZUNvdW50ID0gdGhpcy5wYWdlQ291bnQgIT0gbnVsbCA/IHRoaXMucGFnZUNvdW50IDogZXhwb3J0cy5kZWZhdWx0VmlzaWJsZVBhZ2VDb3VudDtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UGFnZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuY2FyZENvbnRhaW5lci5kYXRhU291cmNlO1xyXG4gICAgICAgICAgICB0aGlzLiRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGF0YVNvdXJjZS5jb3VudDsgfSwgdGhpcy51cGRhdGVQYWdlQ291bnQpO1xyXG4gICAgICAgICAgICB0aGlzLiRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucGFnZXIucGFnZVNpemU7IH0sIHRoaXMudXBkYXRlUGFnZUNvdW50KTtcclxuICAgICAgICAgICAgdGhpcy4kc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmN1cnJlbnRQYWdlOyB9LCBmdW5jdGlvbiAocGFnZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFnaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wYWdlci5wYWdlTnVtYmVyID0gcGFnZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRhdGFTb3VyY2Uub25QYWdpbmdDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhZ2VyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlUGFnaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcclxuICAgICAgICB0aGlzLmNhbkdvQmFjayA9IHBhZ2UgPiAxO1xyXG4gICAgICAgIHRoaXMuY2FuR29Gb3J3YXJkID0gcGFnZSA8IHRoaXMubGFzdFBhZ2U7XHJcbiAgICAgICAgdmFyIG5vbkN1cnJlbnRWaXNpYmxlUGFnZXMgPSB0aGlzLnZpc2libGVQYWdlQ291bnQgLSAxO1xyXG4gICAgICAgIHZhciBiZWZvcmUgPSBNYXRoLmZsb29yKG5vbkN1cnJlbnRWaXNpYmxlUGFnZXMgLyAyKTtcclxuICAgICAgICB2YXIgYWZ0ZXIgPSBNYXRoLmNlaWwobm9uQ3VycmVudFZpc2libGVQYWdlcyAvIDIpO1xyXG4gICAgICAgIHZhciBzdGFydFBhZ2UgPSBwYWdlIC0gYmVmb3JlO1xyXG4gICAgICAgIHZhciBlbmRQYWdlID0gcGFnZSArIGFmdGVyO1xyXG4gICAgICAgIGlmIChzdGFydFBhZ2UgPCAxKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGFnZSA9IDE7XHJcbiAgICAgICAgICAgIGVuZFBhZ2UgPSBNYXRoLm1pbih0aGlzLnZpc2libGVQYWdlQ291bnQsIHRoaXMubGFzdFBhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbmRQYWdlID4gdGhpcy5sYXN0UGFnZSkge1xyXG4gICAgICAgICAgICBlbmRQYWdlID0gdGhpcy5sYXN0UGFnZTtcclxuICAgICAgICAgICAgc3RhcnRQYWdlID0gTWF0aC5tYXgodGhpcy5sYXN0UGFnZSAtIG5vbkN1cnJlbnRWaXNpYmxlUGFnZXMsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhZ2VzID0gXy5yYW5nZShzdGFydFBhZ2UsIGVuZFBhZ2UgKyAxKTtcclxuICAgIH07XHJcbiAgICBQYWdlckNvbnRyb2xsZXIucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSAxO1xyXG4gICAgfTtcclxuICAgIFBhZ2VyQ29udHJvbGxlci5wcm90b3R5cGUucHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhZ2UtLTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFnZXJDb250cm9sbGVyLnByb3RvdHlwZS5nb3RvID0gZnVuY3Rpb24gKHBhZ2UpIHtcclxuICAgICAgICBpZiAocGFnZSA+PSAxICYmIHBhZ2UgPD0gdGhpcy5sYXN0UGFnZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGFnZXJDb250cm9sbGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlIDwgdGhpcy5sYXN0UGFnZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlKys7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhZ2VyQ29udHJvbGxlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gdGhpcy5sYXN0UGFnZTtcclxuICAgIH07XHJcbiAgICBQYWdlckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gUGFnZXJDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlBhZ2VyQ29udHJvbGxlciA9IFBhZ2VyQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gcGFnZXIoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgcmVxdWlyZTogeyBjYXJkQ29udGFpbmVyOiAnP15ecmxDYXJkQ29udGFpbmVyJyB9LFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3BhZ2VyLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3BhZ2VyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBwYWdlQ291bnQ6ICc9dmlzaWJsZVBhZ2VzJyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnBhZ2VyID0gcGFnZXI7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgcGFnZXIpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBQYWdlckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlci9wYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPG5hdiBuZy1pZj1cXFwicGFnZXIuaGFzUGFnZUZpbHRlclxcXCI+XFxyXFxuXFx0PHVsIGNsYXNzPVxcXCJwYWdpbmF0aW9uXFxcIj5cXHJcXG5cXHRcXHQ8bGkgdGl0bGU9XFxcIkdvIHRvIGZpcnN0IHBhZ2VcXFwiIG5nLWNsaWNrPVxcXCJwYWdlci5maXJzdCgpXFxcIlxcclxcblxcdFxcdFxcdG5nLWNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6ICFwYWdlci5jYW5Hb0JhY2sgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+PGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvdWJsZS1sZWZ0XFxcIj48L2k+PC9hPlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0XFx0PGxpIHRpdGxlPVxcXCJHbyB0byBwcmV2aW91cyBwYWdlXFxcIiBuZy1jbGljaz1cXFwicGFnZXIucHJldmlvdXMoKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1jbGFzcz1cXFwieyAnZGlzYWJsZWQnOiAhcGFnZXIuY2FuR29CYWNrIH1cXFwiPlxcclxcblxcdFxcdFxcdDxhPjxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1sZWZ0XFxcIj48L2k+PC9hPlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0XFx0PGxpIHRpdGxlPVxcXCJHbyB0byBwYWdlIHt7cGFnZXIucGFnZX19XFxcIiBuZy1jbGljaz1cXFwicGFnZXIuZ290byhwYWdlKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1yZXBlYXQ9XFxcInBhZ2UgaW4gcGFnZXIucGFnZXNcXFwiXFxyXFxuXFx0XFx0XFx0bmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IHBhZ2VyLmN1cnJlbnRQYWdlID09IHBhZ2UgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+e3twYWdlfX08L2E+XFxyXFxuXFx0XFx0PC9saT5cXHJcXG5cXHRcXHQ8bGkgdGl0bGU9XFxcIkdvIHRvIG5leHQgcGFnZVxcXCIgbmctY2xpY2s9XFxcInBhZ2VyLm5leHQoKVxcXCJcXHJcXG5cXHRcXHRcXHRuZy1jbGFzcz1cXFwieyAnZGlzYWJsZWQnOiAhcGFnZXIuY2FuR29Gb3J3YXJkIH1cXFwiPlxcclxcblxcdFxcdFxcdDxhPjxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1yaWdodFxcXCI+PC9pPjwvYT5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdFxcdDxsaSB0aXRsZT1cXFwiR28gdG8gbGFzdCBwYWdlXFxcIiBuZy1jbGljaz1cXFwicGFnZXIubGFzdCgpXFxcIlxcclxcblxcdFxcdFxcdG5nLWNsYXNzPVxcXCJ7ICdkaXNhYmxlZCc6ICFwYWdlci5jYW5Hb0ZvcndhcmQgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGE+PGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLWRvdWJsZS1yaWdodFxcXCI+PC9pPjwvYT5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdDwvdWw+XFxyXFxuPC9uYXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlci9wYWdlci5odG1sXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY2FyZENvbnRhaW5lci5wYWdlU2l6ZSc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFBhZ2VTaXplJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdQYWdlU2l6ZUNvbnRyb2xsZXInO1xyXG5leHBvcnRzLmF2YWlsYWJsZVBhZ2VTaXplcyA9IFsxMCwgMjUsIDUwLCAxMDBdO1xyXG5leHBvcnRzLmRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG52YXIgUGFnZVNpemVDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhZ2VTaXplQ29udHJvbGxlcigkc2NvcGUpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgIH1cclxuICAgIFBhZ2VTaXplQ29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmNhcmRDb250YWluZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRQYWdlU2l6ZSA9IGV4cG9ydHMuZGVmYXVsdFBhZ2VTaXplO1xyXG4gICAgICAgIHRoaXMucGFnZVNpemVzID0gZXhwb3J0cy5hdmFpbGFibGVQYWdlU2l6ZXM7XHJcbiAgICAgICAgdGhpcy5oYXNQYWdlRmlsdGVyID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcGFnZXIgPSB0aGlzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZS5wYWdlcjtcclxuICAgICAgICBpZiAocGFnZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BhZ2VGaWx0ZXIgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZWxlY3RlZFBhZ2VTaXplOyB9LCBmdW5jdGlvbiAobmV3UGFnZVNpemUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYWdlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZXIucGFnZVNpemUgPSBuZXdQYWdlU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2Uub25QYWdpbmdDaGFuZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBhZ2VTaXplQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBQYWdlU2l6ZUNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUGFnZVNpemVDb250cm9sbGVyID0gUGFnZVNpemVDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBwYWdlU2l6ZSgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICByZXF1aXJlOiB7IGNhcmRDb250YWluZXI6ICc/Xl5ybENhcmRDb250YWluZXInIH0sXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vcGFnZVNpemUuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY29udHJvbGxlcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHt9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnBhZ2VTaXplID0gcGFnZVNpemU7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgcGFnZVNpemUpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBQYWdlU2l6ZUNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlU2l6ZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlU2l6ZS9wYWdlU2l6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBuZy1zaG93PVxcXCJjb250cm9sbGVyLmhhc1BhZ2VGaWx0ZXJcXFwiPlxcclxcblxcdDxzZWxlY3QgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdGl0bGU9XFxcIkNhcmRzIHBlciBwYWdlXFxcIiBuZy1tb2RlbD1cXFwiY29udHJvbGxlci5zZWxlY3RlZFBhZ2VTaXplXFxcIlxcclxcblxcdFxcdFxcdG5nLW9wdGlvbnM9XFxcInBhZ2VTaXplIGZvciBwYWdlU2l6ZSBpbiBjb250cm9sbGVyLnBhZ2VTaXplc1xcXCI+PC9zZWxlY3Q+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9wYWdlU2l6ZS9wYWdlU2l6ZS5odG1sXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fYm9vbGVhbiA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5ib29sZWFuO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jYXJkQ29udGFpbmVyLnNlbGVjdGlvbkNvbnRyb2wnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTZWxlY3Rpb25Db250cm9sJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlcic7XHJcbnZhciBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlcigkc2NvcGUsIGJvb2wpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLmJvb2wgPSBib29sO1xyXG4gICAgfVxyXG4gICAgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIucHJvdG90eXBlLiRvbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5jYXJkQ29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMgPSB0aGlzLmNhcmRDb250YWluZXIubnVtYmVyU2VsZWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5wYWdpbmdFbmFibGVkID0gdGhpcy5ib29sLnRvQm9vbCh0aGlzLmNhcmRDb250YWluZXIuZGF0YVNvdXJjZS5wYWdlcik7XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5jYXJkQ29udGFpbmVyLmRhdGFTb3VyY2U7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNhcmRDb250YWluZXIubnVtYmVyU2VsZWN0ZWQ7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5zZWxlY3RlZEl0ZW1zID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIucHJvdG90eXBlLnNlbGVjdFBhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuZGF0YVNvdXJjZS5kYXRhU2V0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpdGVtLnZpZXdEYXRhLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRzY29wZS4kZW1pdCgnc2VsZWN0aW9uQ2hhbmdlZCcpOyAvLypldmVudHM/XHJcbiAgICB9O1xyXG4gICAgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIucHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfLmVhY2godGhpcy5kYXRhU291cmNlLmZpbHRlcmVkRGF0YVNldCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ3NlbGVjdGlvbkNoYW5nZWQnKTsgLy8qZXZlbnRzP1xyXG4gICAgfTtcclxuICAgIFNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyLnByb3RvdHlwZS5jbGVhclBhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuZGF0YVNvdXJjZS5kYXRhU2V0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpdGVtLnZpZXdEYXRhLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ3NlbGVjdGlvbkNoYW5nZWQnKTsgLy8qZXZlbnRzP1xyXG4gICAgfTtcclxuICAgIFNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyLnByb3RvdHlwZS5jbGVhckFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfLmVhY2godGhpcy5kYXRhU291cmNlLmZpbHRlcmVkRGF0YVNldCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlLiRlbWl0KCdzZWxlY3Rpb25DaGFuZ2VkJyk7IC8vKmV2ZW50cz9cclxuICAgIH07XHJcbiAgICBTZWxlY3Rpb25Db250cm9sQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCBfX2Jvb2xlYW4uc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlNlbGVjdGlvbkNvbnRyb2xDb250cm9sbGVyID0gU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRyb2woKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgcmVxdWlyZTogeyBjYXJkQ29udGFpbmVyOiAnP15ecmxDYXJkQ29udGFpbmVyJyB9LFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3NlbGVjdGlvbkNvbnRyb2wuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnc2VsZWN0aW9uJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge30sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc2VsZWN0aW9uQ29udHJvbCA9IHNlbGVjdGlvbkNvbnRyb2w7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fYm9vbGVhbi5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBzZWxlY3Rpb25Db250cm9sKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgU2VsZWN0aW9uQ29udHJvbENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3Rpb25Db250cm9sLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL3NlbGVjdGlvbkNvbnRyb2wvc2VsZWN0aW9uQ29udHJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdj5cXHJcXG5cXHQ8ZGl2IHN0eWxlPVxcXCJtYXJnaW4tYm90dG9tOiA1cHhcXFwiPlxcclxcblxcdFxcdDxzcGFuPjxzdHJvbmc+e3tzZWxlY3Rpb24uc2VsZWN0ZWRJdGVtc319PC9zdHJvbmc+IGl0ZW1zIHNlbGVjdGVkPC9zcGFuPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgc3R5bGU9XFxcIm1hcmdpbi1ib3R0b206IDVweFxcXCIgbmctaWY9XFxcInNlbGVjdGlvbi5wYWdpbmdFbmFibGVkXFxcIj5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgbmctY2xpY2s9XFxcInNlbGVjdGlvbi5zZWxlY3RQYWdlKClcXFwiPlNlbGVjdCBwYWdlPC9idXR0b24+XFxyXFxuXFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Rpb24uY2xlYXJQYWdlKClcXFwiPkNsZWFyIHBhZ2U8L2J1dHRvbj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2PlxcclxcblxcdFxcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0aW9uLnNlbGVjdEFsbCgpXFxcIj5TZWxlY3QgYWxsPC9idXR0b24+XFxyXFxuXFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Rpb24uY2xlYXJBbGwoKVxcXCI+Q2xlYXIgYWxsPC9idXR0b24+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9zZWxlY3Rpb25Db250cm9sL3NlbGVjdGlvbkNvbnRyb2wuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBfX2FycmF5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgZGF0YVNvdXJjZXNfbW9kdWxlXzEgPSByZXF1aXJlKCcuL2RhdGFTb3VyY2VzL2RhdGFTb3VyY2VzLm1vZHVsZScpO1xyXG52YXIgc29ydHNfbW9kdWxlXzEgPSByZXF1aXJlKCcuL3NvcnRzL3NvcnRzLm1vZHVsZScpO1xyXG52YXIgYnJlYWtwb2ludF8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludCcpO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxDYXJkQ29udGFpbmVyJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdDYXJkQ29udGFpbmVyQ29udHJvbGxlcic7XHJcbmV4cG9ydHMuZGVmYXVsdE1heENvbHVtblNvcnRzID0gMjtcclxuZXhwb3J0cy5kZWZhdWx0U2VsZWN0aW9uVGl0bGUgPSAnU2VsZWN0IGNhcmQnO1xyXG52YXIgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIoJHNjb3BlLCAkYXR0cnMsICR0cmFuc2NsdWRlLCBvYmplY3QsIGFycmF5LCBkYXRhUGFnZXJGYWN0b3J5LCBwYXJlbnRDaGlsZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xyXG4gICAgICAgIHRoaXMuZGF0YVBhZ2VyRmFjdG9yeSA9IGRhdGFQYWdlckZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZCA9IHBhcmVudENoaWxkO1xyXG4gICAgICAgIHRoaXMubnVtYmVyU2VsZWN0ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuYWRkVmlld0RhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF8uZWFjaChfdGhpcy5kYXRhU291cmNlLnJhd0RhdGFTZXQsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChpdGVtLnZpZXdEYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udmlld0RhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlRGlzYWJsZWRTZWxlY3Rpb25zKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNsZWFyRmlsdGVyZWRTZWxlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbm9uVmlzaWJsZUl0ZW1zID0gXy5kaWZmZXJlbmNlKF90aGlzLmRhdGFTb3VyY2UucmF3RGF0YVNldCwgX3RoaXMuZGF0YVNvdXJjZS5maWx0ZXJlZERhdGFTZXQpO1xyXG4gICAgICAgICAgICBfLmVhY2gobm9uVmlzaWJsZUl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoaXRlbS52aWV3RGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnZpZXdEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGl0ZW0udmlld0RhdGEuc2VsZWN0aW9uVGl0bGUgPSBleHBvcnRzLmRlZmF1bHRTZWxlY3Rpb25UaXRsZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVNlbGVjdGVkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5udW1iZXJTZWxlY3RlZCA9IF8uZmlsdGVyKF90aGlzLmRhdGFTb3VyY2UuZmlsdGVyZWREYXRhU2V0LCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmlld0RhdGEgIT0gbnVsbCAmJiBpdGVtLnZpZXdEYXRhLnNlbGVjdGVkO1xyXG4gICAgICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnVwZGF0ZURpc2FibGVkU2VsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmRpc2FibGluZ1NlbGVjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChfdGhpcy5kYXRhU291cmNlLnJhd0RhdGFTZXQsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc2FibGVkUmVhc29uID0gX3RoaXMuZGlzYWJsZVNlbGVjdGlvbih7IGl0ZW06IGl0ZW0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS52aWV3RGF0YS5kaXNhYmxlZFNlbGVjdGlvbiA9IChkaXNhYmxlZFJlYXNvbiAhPSBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnZpZXdEYXRhLnNlbGVjdGlvblRpdGxlID0gKGl0ZW0udmlld0RhdGEuZGlzYWJsZWRTZWxlY3Rpb24gPyBkaXNhYmxlZFJlYXNvbiA6IGV4cG9ydHMuZGVmYXVsdFNlbGVjdGlvblRpdGxlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5idWlsZGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZGVyLnNldENhcmRDb250YWluZXJQcm9wZXJ0aWVzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1ha2VDYXJkID0gJHRyYW5zY2x1ZGU7XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgdGhpcy5wZXJtYW5lbnRGb290ZXJzID0gXy5pc1VuZGVmaW5lZCh0aGlzLnBlcm1hbmVudEZvb3RlcnMpID8gZmFsc2UgOiB0aGlzLnBlcm1hbmVudEZvb3RlcnM7XHJcbiAgICAgICAgdGhpcy5tYXhDb2xTb3J0cyA9IHRoaXMubWF4Q29sdW1uU29ydHMgIT0gbnVsbCA/IHRoaXMubWF4Q29sdW1uU29ydHMgOiBleHBvcnRzLmRlZmF1bHRNYXhDb2x1bW5Tb3J0cztcclxuICAgICAgICB0aGlzLmRpc2FibGluZ1NlbGVjdGlvbnMgPSBvYmplY3QuaXNOdWxsT3JXaGl0ZXNwYWNlKCRhdHRycy5kaXNhYmxlU2VsZWN0aW9uKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zb3J0RGlyZWN0aW9uID0gc29ydHNfbW9kdWxlXzEuU29ydERpcmVjdGlvbjtcclxuICAgICAgICB0aGlzLnN5bmNGaWx0ZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zZXR1cFBhZ2luZygpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRDb2x1bW5TaXplcygpO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGVDYXJkcykge1xyXG4gICAgICAgICAgICAvLyp1c2UgY2FyZCBjb250YWluZXIgZXZlbnQgc2VydmljZT9cclxuICAgICAgICAgICAgJHNjb3BlLiRvbignc2VsZWN0aW9uQ2hhbmdlZCcsIHRoaXMudXBkYXRlU2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICAkc2NvcGUuJG9uKCd1cGRhdGVEaXNhYmxlZFNlbGVjdGlvbnMnLCB0aGlzLnVwZGF0ZURpc2FibGVkU2VsZWN0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS53YXRjaCh0aGlzLmFkZFZpZXdEYXRhLCAnY2hhbmdlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uud2F0Y2godGhpcy5jbGVhckZpbHRlcmVkU2VsZWN0aW9ucywgJ3JlZHJhd2luZycpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFZpZXdEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ29sdW1uID0ge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmlld0RhdGEuc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmxpcFNvcnQ6IHRydWUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2Uuc29ydHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJHNjb3BlLmNvbnRhaW5lckRhdGEgPSB0aGlzLmNvbnRhaW5lckRhdGE7XHJcbiAgICB9XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuc29ydFNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc29ydCh0aGlzLnNlbGVjdGlvbkNvbHVtbik7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLm9wZW5DYXJkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiZWhhdmlvcnMgPSB0aGlzLnBhcmVudENoaWxkLmdldEFsbENoaWxkQmVoYXZpb3JzKHRoaXMuZGF0YVNvdXJjZS5kYXRhU2V0KTtcclxuICAgICAgICByZXR1cm4gXy5ldmVyeShfLm1hcChiZWhhdmlvcnMsIGZ1bmN0aW9uIChiZWhhdmlvcikgeyByZXR1cm4gYmVoYXZpb3IuY2xvc2UoKTsgfSkpO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgIHZhciBzb3J0TGlzdCA9IHRoaXMuZGF0YVNvdXJjZS5zb3J0cztcclxuICAgICAgICB2YXIgZmlyc3RTb3J0ID0gc29ydExpc3RbMF07XHJcbiAgICAgICAgLy8gSWYgY29sdW1uIGlzIGFscmVhZHkgdGhlIHByaW1hcnkgc29ydCwgY2hhbmdlIHRoZSBkaXJlY3Rpb25cclxuICAgICAgICBpZiAoZmlyc3RTb3J0ICE9IG51bGxcclxuICAgICAgICAgICAgJiYgZmlyc3RTb3J0LmNvbHVtbiA9PT0gY29sdW1uKSB7XHJcbiAgICAgICAgICAgIGZpcnN0U29ydC5kaXJlY3Rpb24gPSBzb3J0c19tb2R1bGVfMS5Tb3J0RGlyZWN0aW9uLnRvZ2dsZShmaXJzdFNvcnQuZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgLy8gQ2xlYXIgc29ydFxyXG4gICAgICAgICAgICBpZiAoZmlyc3RTb3J0LmRpcmVjdGlvbiA9PT0gc29ydHNfbW9kdWxlXzEuU29ydERpcmVjdGlvbi5ub25lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVmlzdWFsU29ydEluZGljYXRvcihmaXJzdFNvcnQpO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RTb3J0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaGFzIHNlY29uZGFyeSBzb3J0cyBkb24ndCBmYWxsIGJhY2sgdG8gYVxyXG4gICAgICAgICAgICAgICAgLy8gIHNlY29uZGFyeSBzb3J0LCBpbnN0ZWFkIGp1c3QgY2xlYXIgYWxsIHNvcnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNlY29uZGFyeVNvcnRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0TGlzdC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydExpc3Quc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRWxzZSBtYWtlIGNvbHVtbiBwcmltYXJ5IGFzY2VuZGluZyBzb3J0XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3Rpbmcgbm9uLXByaW1hcnkgc29ydHMgb24gY29sdW1uXHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXkucmVtb3ZlKHNvcnRMaXN0LCBmdW5jdGlvbiAoc29ydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbiA9PT0gc29ydC5jb2x1bW47XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBCdWlsZCBhc2NlbmRpbmcgc29ydCBmb3IgY29sdW1uXHJcbiAgICAgICAgICAgIHZhciBuZXdTb3J0ID0ge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IHNvcnRzX21vZHVsZV8xLlNvcnREaXJlY3Rpb24uYXNjZW5kaW5nLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzb3J0TGlzdC51bnNoaWZ0KG5ld1NvcnQpO1xyXG4gICAgICAgICAgICBmaXJzdFNvcnQgPSBuZXdTb3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVZpc3VhbENvbHVtblNvcnRpbmcoKTtcclxuICAgICAgICAvLyBJZiBjb2x1bW4gaGFzIHNlY29uZGFyeSBzb3J0cywgd2lwZSB0aGUgc29ydCBvcmRlciBhbmQganVzdCBhcHBseSB0aGUgc2Vjb25kYXJ5IHNvcnRzXHJcbiAgICAgICAgaWYgKGZpcnN0U29ydCAhPSBudWxsICYmIGNvbHVtbi5zZWNvbmRhcnlTb3J0cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNvcnRMaXN0Lmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRhcnlTb3J0cyA9IHRoaXMuYnVpbGRTZWNvbmRhcnlTb3J0cyhmaXJzdFNvcnQuZGlyZWN0aW9uLCBjb2x1bW4uc2Vjb25kYXJ5U29ydHMpO1xyXG4gICAgICAgICAgICBzb3J0TGlzdC5wdXNoKGZpcnN0U29ydCk7XHJcbiAgICAgICAgICAgIHNvcnRMaXN0LnB1c2guYXBwbHkoc29ydExpc3QsIHNlY29uZGFyeVNvcnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vdCB1c2luZyBjb2x1bW4gc2Vjb25kYXJ5IHNvcnRzLCBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXJcclxuICAgICAgICAgICAgLy8gIG9mIHNvcnRzIGFwcGxpZWQgdG8gdGhlIG1heGltdW0gbnVtYmVyIG9mIHNvcnRzXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zb3J0cyA9IF8udGFrZShzb3J0TGlzdCwgdGhpcy5tYXhDb2xTb3J0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5vblNvcnRDaGFuZ2UoKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuc2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkKCk7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJGVtaXQoJ3NlbGVjdGlvbkNoYW5nZWQnKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuc3luY0ZpbHRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9iamVjdC5pc051bGxPckVtcHR5KHRoaXMuZmlsdGVycykpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGF0YVNvdXJjZS5maWx0ZXJzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0gdGhpcy5kYXRhU291cmNlLmZpbHRlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5zZXR1cFBhZ2luZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBJZiBwYWdpbmcgZmxhZyBpcyBzcGVjaWZpZWQsIGNhcmQgY29udGFpbmVyIGNvbnRyb2xzIHBhZ2VyIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKHRoaXMucGFnaW5nICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFnaW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnBhZ2VyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlci5fcGFnZXIgPSB0aGlzLmRhdGFQYWdlckZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5wYWdlciA9IHRoaXMuYnVpbGRlci5fcGFnZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kYXRhU291cmNlLnBhZ2VyKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYWdpbmcgZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgZGF0YVNvdXJjZSBoYXMgYSBwYWdlciwgc2F2ZSBhIHJlZmVyZW5jZSBoZXJlXHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlci5fcGFnZXIgPSB0aGlzLmRhdGFTb3VyY2UucGFnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5idWlsZENvbHVtblNpemVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuY29sdW1ucywgZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZXMgPSBjb2x1bW4uc2l6ZTtcclxuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2l6ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplc1ticmVha3BvaW50XzEueHNdID0gX3RoaXMub2JqZWN0LnZhbHVlT3JEZWZhdWx0KHNpemVzW2JyZWFrcG9pbnRfMS54c10sIDApO1xyXG4gICAgICAgICAgICAgICAgc2l6ZXNbYnJlYWtwb2ludF8xLnNtXSA9IF90aGlzLm9iamVjdC52YWx1ZU9yRGVmYXVsdChzaXplc1ticmVha3BvaW50XzEuc21dLCBzaXplc1ticmVha3BvaW50XzEueHNdKTtcclxuICAgICAgICAgICAgICAgIHNpemVzW2JyZWFrcG9pbnRfMS5tZF0gPSBfdGhpcy5vYmplY3QudmFsdWVPckRlZmF1bHQoc2l6ZXNbYnJlYWtwb2ludF8xLm1kXSwgc2l6ZXNbYnJlYWtwb2ludF8xLnNtXSk7XHJcbiAgICAgICAgICAgICAgICBzaXplc1ticmVha3BvaW50XzEubGddID0gX3RoaXMub2JqZWN0LnZhbHVlT3JEZWZhdWx0KHNpemVzW2JyZWFrcG9pbnRfMS5sZ10sIHNpemVzW2JyZWFrcG9pbnRfMS5tZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sdW1uLnNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeHM6IHNpemVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNtOiBzaXplcyxcclxuICAgICAgICAgICAgICAgICAgICBtZDogc2l6ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGc6IHNpemVzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS5sb29rdXBDb2x1bW4gPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gXy5maW5kKHRoaXMuY29sdW1ucywgZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmxhYmVsID09PSBsYWJlbDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUuYnVpbGRTZWNvbmRhcnlTb3J0cyA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHNlY29uZGFyeVNvcnRzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc29ydExpc3QgPSBzZWNvbmRhcnlTb3J0c1tzb3J0c19tb2R1bGVfMS5Tb3J0RGlyZWN0aW9uLmdldEZ1bGxOYW1lKGRpcmVjdGlvbildO1xyXG4gICAgICAgIHJldHVybiBfLm1hcChzb3J0TGlzdCwgZnVuY3Rpb24gKHNvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogc29ydC5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBjb2x1bW46IF90aGlzLmxvb2t1cENvbHVtbihzb3J0LmNvbHVtbiksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVZpc3VhbENvbHVtblNvcnRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfLmVhY2godGhpcy5kYXRhU291cmNlLnNvcnRzLCBmdW5jdGlvbiAoc29ydCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgLy8gT25seSBmaXJzdCBzb3J0IHNob3VsZCBoYXZlIHZpc2libGUgZGlyZWN0aW9uXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVmlzdWFsU29ydEluZGljYXRvcihzb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVmlzdWFsU29ydEluZGljYXRvcihzb3J0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVWaXN1YWxTb3J0SW5kaWNhdG9yID0gZnVuY3Rpb24gKHNvcnQpIHtcclxuICAgICAgICBzb3J0LmNvbHVtbi5zb3J0RGlyZWN0aW9uID0gc29ydC5kaXJlY3Rpb247XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLmNsZWFyVmlzdWFsU29ydEluZGljYXRvciA9IGZ1bmN0aW9uIChzb3J0KSB7XHJcbiAgICAgICAgc29ydC5jb2x1bW4uc29ydERpcmVjdGlvbiA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRhdHRycycsICckdHJhbnNjbHVkZScsIF9fb2JqZWN0LnNlcnZpY2VOYW1lLCBfX2FycmF5LnNlcnZpY2VOYW1lLCBkYXRhU291cmNlc19tb2R1bGVfMS5kYXRhUGFnZXIuZmFjdG9yeU5hbWUsIF9fcGFyZW50Q2hpbGQuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIENhcmRDb250YWluZXJDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkNhcmRDb250YWluZXJDb250cm9sbGVyID0gQ2FyZENvbnRhaW5lckNvbnRyb2xsZXI7XHJcbmV4cG9ydHMuY2FyZENvbnRhaW5lciA9IHtcclxuICAgIHRyYW5zY2x1ZGU6IHtcclxuICAgICAgICAnY29udGFpbmVySGVhZGVyU2xvdCc6ICc/cmxDb250YWluZXJIZWFkZXInLFxyXG4gICAgICAgICdjb250YWluZXJGb290ZXJTbG90JzogJz9ybENvbnRhaW5lckZvb3RlcicsXHJcbiAgICAgICAgJ2NvbnRlbnRTbG90JzogJz9ybENhcmRDb250ZW50JyxcclxuICAgICAgICAnZm9vdGVyU2xvdCc6ICc/cmxDYXJkRm9vdGVyJyxcclxuICAgIH0sXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYXJkQ29udGFpbmVyLmh0bWwnKSxcclxuICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICBjb250cm9sbGVyQXM6ICdjYXJkQ29udGFpbmVyJyxcclxuICAgIGJpbmRpbmdzOiB7XHJcbiAgICAgICAgYnVpbGRlcjogJz0/JyxcclxuICAgICAgICBjYXJkQ29udHJvbGxlcjogJ0AnLFxyXG4gICAgICAgIGNhcmRDb250cm9sbGVyQXM6ICdAJyxcclxuICAgICAgICBjYXJkQXM6ICdAJyxcclxuICAgIH1cclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyZENvbnRhaW5lci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvY2FyZENvbnRhaW5lci9jYXJkQ29udGFpbmVyLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zIGNvbC14cy0xMlxcXCIgbmctaWY9XFxcImNhcmRDb250YWluZXIucmVuZGVyRmlsdGVyc1xcXCI+XFxyXFxuXFx0XFx0PHJsLWNhcmQtY29udGFpbmVyLWZpbHRlcnMgZmlsdGVycz1cXFwiY2FyZENvbnRhaW5lci5maWx0ZXJzXFxcIiBzb3VyY2U9XFxcImNhcmRDb250YWluZXIuZGF0YVNvdXJjZVxcXCI+PC9ybC1jYXJkLWNvbnRhaW5lci1maWx0ZXJzPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC14cy0xMlxcXCIgbmctY2xhc3M9XFxcInsgJ2NvbC1tZC05JzogY2FyZENvbnRhaW5lci5yZW5kZXJGaWx0ZXJzIH1cXFwiPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGFpbmVyXFxcIj5cXHJcXG5cXHRcXHRcXHQ8ZGl2PlxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGFpbmVyLWhlYWRlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBuZy10cmFuc2NsdWRlPVxcXCJjb250YWluZXJIZWFkZXJTbG90XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8cmwtZGVmYXVsdC1jYXJkLWNvbnRhaW5lci1oZWFkZXI+PC9ybC1kZWZhdWx0LWNhcmQtY29udGFpbmVyLWhlYWRlcj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHRcXHRcXHRcXHQ8cmwtZ2VuZXJpYy1jb250YWluZXIgc2VsZWN0b3I9XFxcImNhcmRDb250YWluZXIuc2VsZWN0YWJsZUNhcmRzXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8dGVtcGxhdGUgd2hlbi1zZWxlY3Rvcj1cXFwiZmFsc2VcXFwiIGRlZmF1bHQ+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZC1jb2x1bW5zLWhlYWRlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBuZy1yZXBlYXQ9XFxcImNvbHVtbiBpbiBjYXJkQ29udGFpbmVyLmNvbHVtbnNcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxybC1jb2x1bW4taGVhZGVyIHNvcnQ9XFxcImNhcmRDb250YWluZXIuc29ydChjb2x1bW4pXFxcIiBzb3J0aW5nPVxcXCJjb2x1bW4uc29ydERpcmVjdGlvblxcXCIgY29sdW1uPVxcXCJjb2x1bW5cXFwiPjwvcmwtY29sdW1uLWhlYWRlcj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PC90ZW1wbGF0ZT5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8dGVtcGxhdGUgd2hlbi1zZWxlY3Rvcj1cXFwidHJ1ZVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2FyZC1jb2x1bW5zLWhlYWRlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwic2VsZWN0LWdyb3VwXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJzZWxlY3QtY29sdW1uXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtY2hlY2tcXFwiIHN0eWxlPVxcXCJtYXJnaW4tbGVmdDogNnB4OyBjdXJzb3I6IHBvaW50ZXJcXFwiIG5nLWNsaWNrPVxcXCJjYXJkQ29udGFpbmVyLnNvcnRTZWxlY3RlZCgpXFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgbmctc2hvdz1cXFwiY2FyZENvbnRhaW5lci5zb3J0Q29sdW1uLnNvcnREaXJlY3Rpb24gPT09IGNhcmRDb250YWluZXIuc29ydERpcmVjdGlvbi5hc2NlbmRpbmdcXFwiIGNsYXNzPVxcXCJmYSBmYS1zb3J0LWFzY1xcXCI+PC9pPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIG5nLXNob3c9XFxcImNhcmRDb250YWluZXIuc29ydENvbHVtbi5zb3J0RGlyZWN0aW9uID09PSBjYXJkQ29udGFpbmVyLnNvcnREaXJlY3Rpb24uZGVzY2VuZGluZ1xcXCIgY2xhc3M9XFxcImZhIGZhLXNvcnQtZGVzY1xcXCI+PC9pPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInNlbGVjdC1jb250ZW50XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXJlcGVhdD1cXFwiY29sdW1uIGluIGNhcmRDb250YWluZXIuY29sdW1uc1xcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PHJsLWNvbHVtbi1oZWFkZXIgc29ydD1cXFwiY2FyZENvbnRhaW5lci5zb3J0KGNvbHVtbilcXFwiIHNvcnRpbmc9XFxcImNvbHVtbi5zb3J0RGlyZWN0aW9uXFxcIiBjb2x1bW49XFxcImNvbHVtblxcXCI+PC9ybC1jb2x1bW4taGVhZGVyPlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L3RlbXBsYXRlPlxcclxcblxcdFxcdFxcdFxcdDwvcmwtZ2VuZXJpYy1jb250YWluZXI+XFxyXFxuXFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBuZy1pZj1cXFwiY2FyZENvbnRhaW5lci5kYXRhU291cmNlLmRhdGFTZXQgfCBpc0VtcHR5OmZhbHNlXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLXJlcGVhdD1cXFwiY2FyZCBpbiBjYXJkQ29udGFpbmVyLmRhdGFTb3VyY2UuZGF0YVNldFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHJsLWNhcmQgY29sdW1ucz1cXFwiY2FyZENvbnRhaW5lci5jb2x1bW5zXFxcIiBpdGVtPVxcXCJjYXJkXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNsaWNrYWJsZT1cXFwiY2FyZENvbnRhaW5lci5jbGlja2FibGVDYXJkc1xcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RhYmxlPVxcXCJjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkc1xcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3Rpb24tY2hhbmdlZD1cXFwiY2FyZENvbnRhaW5lci5zZWxlY3Rpb25DaGFuZ2VkKClcXFwiXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGFpbmVyLWRhdGE9XFxcImNhcmRDb250YWluZXIuY29udGFpbmVyRGF0YVxcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzb3VyY2U9XFxcImNhcmRDb250YWluZXIuZGF0YVNvdXJjZVxcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwZXJtYW5lbnQtZm9vdGVyPVxcXCJjYXJkQ29udGFpbmVyLnBlcm1hbmVudEZvb3RlcnNcXFwiXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FyZC1jb250cm9sbGVyPVxcXCJjYXJkQ29udGFpbmVyLmNhcmRDb250cm9sbGVyXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhcmQtY29udHJvbGxlci1hcz1cXFwiY2FyZENvbnRhaW5lci5jYXJkQ29udHJvbGxlckFzXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhcmQtYXM9XFxcImNhcmRDb250YWluZXIuY2FyZEFzXFxcIlxcclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNhdmUtd2hlbi1pbnZhbGlkPVxcXCJjYXJkQ29udGFpbmVyLnNhdmVXaGVuSW52YWxpZFxcXCI+PC9ybC1jYXJkPlxcclxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDxkaXYgbmctaWY9XFxcImNhcmRDb250YWluZXIuZGF0YVNvdXJjZS5uZWVkc1JlZmluZWRTZWFyY2hcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdFBsZWFzZSByZWZpbmUgeW91ciBzZWFyY2ggcmVzdWx0c1xcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDxkaXYgbmctaWY9XFxcImNhcmRDb250YWluZXIuZGF0YVNvdXJjZS5pc0VtcHR5XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRUaGVyZSBhcmUgbm8gaXRlbXMgdG8gc2hvd1xcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcclxcblxcdFxcdFxcdFxcdDxkaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PHJsLWJ1c3kgbG9hZGluZz1cXFwiY2FyZENvbnRhaW5lci5kYXRhU291cmNlLmxvYWRpbmdEYXRhU2V0XFxcIiBzaXplPVxcXCIyeFxcXCI+PC9ybC1idXN5PlxcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGFpbmVyLWZvb3RlclxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBuZy10cmFuc2NsdWRlPVxcXCJjb250YWluZXJGb290ZXJTbG90XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8cmwtZGVmYXVsdC1jYXJkLWNvbnRhaW5lci1mb290ZXI+PC9ybC1kZWZhdWx0LWNhcmQtY29udGFpbmVyLWZvb3Rlcj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX2dlbmVyaWNTZWFyY2hGaWx0ZXIgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZ2VuZXJpY1NlYXJjaEZpbHRlcjtcclxudmFyIGRhdGFTb3VyY2VzID0gcmVxdWlyZSgnLi9kYXRhU291cmNlcy9kYXRhU291cmNlcy5tb2R1bGUnKTtcclxudmFyIGZpbHRlckdyb3VwID0gcmVxdWlyZSgnLi9maWx0ZXJzL2ZpbHRlckdyb3VwL2ZpbHRlckdyb3VwLm1vZHVsZScpO1xyXG52YXIgc2VsZWN0RmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL3NlbGVjdEZpbHRlci9zZWxlY3RGaWx0ZXIubW9kdWxlJyk7XHJcbnZhciBkYXRlRmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL2RhdGVGaWx0ZXIvZGF0ZUZpbHRlci5tb2R1bGUnKTtcclxudmFyIGNvbHVtblNlYXJjaEZpbHRlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL2ZpbHRlcnMvY29sdW1uU2VhcmNoRmlsdGVyL2NvbHVtblNlYXJjaEZpbHRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZmFjdG9yeU5hbWUgPSAnY2FyZENvbnRhaW5lckJ1aWxkZXInO1xyXG52YXIgQ2FyZENvbnRhaW5lckJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FyZENvbnRhaW5lckJ1aWxkZXIoJGluamVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XHJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gbmV3IERhdGFTb3VyY2VCdWlsZGVyKCRpbmplY3RvciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gbmV3IEZpbHRlckJ1aWxkZXIoJGluamVjdG9yLCB0aGlzKTtcclxuICAgICAgICB0aGlzLl9jb2x1bW5zID0gW107XHJcbiAgICB9XHJcbiAgICBDYXJkQ29udGFpbmVyQnVpbGRlci5wcm90b3R5cGUudXNlU2VhcmNoID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuJGluamVjdG9yLmdldChfX2dlbmVyaWNTZWFyY2hGaWx0ZXIuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgICAgICBmaWx0ZXIgPSBmYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NlYXJjaEZpbHRlciA9IGZpbHRlcjtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoRmlsdGVyO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJCdWlsZGVyLnByb3RvdHlwZS51c2VQYWdpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFnaW5nID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29udGFpbmVyQnVpbGRlci5wcm90b3R5cGUuYWRkQ29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgIHRoaXMuX2NvbHVtbnMucHVzaChjb2x1bW4pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJCdWlsZGVyLnByb3RvdHlwZS51c2VDbGlja2FibGVDYXJkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9jbGlja2FibGVDYXJkcyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckJ1aWxkZXIucHJvdG90eXBlLnVzZVBlcm1hbmVudEZvb3RlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcGVybWFuZW50Rm9vdGVycyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbnRhaW5lckJ1aWxkZXIucHJvdG90eXBlLnVzZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9zZWxlY3RhYmxlQ2FyZHMgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJCdWlsZGVyLnByb3RvdHlwZS5yZW5kZXJGaWx0ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckZpbHRlcnMgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIENhcmRDb250YWluZXJCdWlsZGVyLnByb3RvdHlwZS5zYXZlV2hlbkludmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fc2F2ZVdoZW5JbnZhbGlkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FyZENvbnRhaW5lckJ1aWxkZXIucHJvdG90eXBlLCBcImRpc2FibGVTZWxlY3Rpb25cIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2VsZWN0YWJsZUNhcmRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVzZVNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVTZWxlY3Rpb24gPSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENhcmRDb250YWluZXJCdWlsZGVyLnByb3RvdHlwZS5zZXRDYXJkQ29udGFpbmVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChjYXJkQ29udGFpbmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlYXJjaEZpbHRlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnMucHVzaCh0aGlzLl9zZWFyY2hGaWx0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXJkQ29udGFpbmVyLnNvdXJjZSA9IHRoaXMuX2RhdGFTb3VyY2U7XHJcbiAgICAgICAgY2FyZENvbnRhaW5lci5maWx0ZXJzID0gdGhpcy5fZmlsdGVycztcclxuICAgICAgICBjYXJkQ29udGFpbmVyLnNlYXJjaEZpbHRlciA9IHRoaXMuX3NlYXJjaEZpbHRlcjtcclxuICAgICAgICBjYXJkQ29udGFpbmVyLnBhZ2luZyA9IHRoaXMuX3BhZ2luZztcclxuICAgICAgICBjYXJkQ29udGFpbmVyLmNvbHVtbnMgPSB0aGlzLl9jb2x1bW5zO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIuY29udGFpbmVyRGF0YSA9IHRoaXMuY29udGFpbmVyRGF0YTtcclxuICAgICAgICBjYXJkQ29udGFpbmVyLmNsaWNrYWJsZUNhcmRzID0gdGhpcy5fY2xpY2thYmxlQ2FyZHM7XHJcbiAgICAgICAgY2FyZENvbnRhaW5lci5tYXhDb2x1bW5Tb3J0cyA9IHRoaXMubWF4Q29sdW1uU29ydHM7XHJcbiAgICAgICAgY2FyZENvbnRhaW5lci5wZXJtYW5lbnRGb290ZXJzID0gdGhpcy5fcGVybWFuZW50Rm9vdGVycztcclxuICAgICAgICBjYXJkQ29udGFpbmVyLnNlbGVjdGFibGVDYXJkcyA9IHRoaXMuX3NlbGVjdGFibGVDYXJkcztcclxuICAgICAgICBjYXJkQ29udGFpbmVyLmRpc2FibGVTZWxlY3Rpb24gPSB0aGlzLl9kaXNhYmxlU2VsZWN0aW9uO1xyXG4gICAgICAgIGNhcmRDb250YWluZXIucmVuZGVyRmlsdGVycyA9IHRoaXMuX3JlbmRlckZpbHRlcnM7XHJcbiAgICAgICAgY2FyZENvbnRhaW5lci5zYXZlV2hlbkludmFsaWQgPSB0aGlzLl9zYXZlV2hlbkludmFsaWQ7XHJcbiAgICAgICAgaWYgKGNhcmRDb250YWluZXIuY2FyZENvbnRyb2xsZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjYXJkQ29udGFpbmVyLmNhcmRDb250cm9sbGVyID0gdGhpcy5jYXJkQ29udHJvbGxlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhcmRDb250YWluZXIuY2FyZENvbnRyb2xsZXJBcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNhcmRDb250YWluZXIuY2FyZENvbnRyb2xsZXJBcyA9IHRoaXMuY2FyZENvbnRyb2xsZXJBcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhcmRDb250YWluZXIuY2FyZEFzID09IG51bGwpIHtcclxuICAgICAgICAgICAgY2FyZENvbnRhaW5lci5jYXJkQXMgPSB0aGlzLmNhcmRBcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhcmRDb250YWluZXJCdWlsZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkNhcmRDb250YWluZXJCdWlsZGVyID0gQ2FyZENvbnRhaW5lckJ1aWxkZXI7XHJcbnZhciBEYXRhU291cmNlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhU291cmNlQnVpbGRlcigkaW5qZWN0b3IsIHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMuJGluamVjdG9yID0gJGluamVjdG9yO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGRhdGFTb3VyY2VzLnNpbXBsZURhdGFTb3VyY2UuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgIHBhcmVudC5fZGF0YVNvdXJjZSA9IGZhY3RvcnkuZ2V0SW5zdGFuY2UoW10pO1xyXG4gICAgfVxyXG4gICAgRGF0YVNvdXJjZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkU2ltcGxlRGF0YVNvdXJjZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoZGF0YVNvdXJjZXMuc2ltcGxlRGF0YVNvdXJjZS5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2RhdGFTb3VyY2UgPSBmYWN0b3J5LmdldEluc3RhbmNlKGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZGF0YVNvdXJjZTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQnVpbGRlci5wcm90b3R5cGUuYnVpbGREYXRhU2VydmljZURhdGFTb3VyY2UgPSBmdW5jdGlvbiAoZ2V0RGF0YVNldCkge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGRhdGFTb3VyY2VzLmRhdGFTZXJ2aWNlRGF0YVNvdXJjZS5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2RhdGFTb3VyY2UgPSBmYWN0b3J5LmdldEluc3RhbmNlKGdldERhdGFTZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZGF0YVNvdXJjZTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRDbGllbnRTZXJ2ZXJEYXRhU291cmNlID0gZnVuY3Rpb24gKGdldERhdGFTZXQsIGdldEZpbHRlck1vZGVsLCB2YWxpZGF0ZU1vZGVsKSB7XHJcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5wYXJlbnQuX3NlYXJjaEZpbHRlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXNlU2VhcmNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGRhdGFTb3VyY2VzLmNsaWVudFNlcnZlckRhdGFTb3VyY2UuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9kYXRhU291cmNlID0gZmFjdG9yeS5nZXRJbnN0YW5jZShnZXREYXRhU2V0LCB0aGlzLnBhcmVudC5fc2VhcmNoRmlsdGVyLCBnZXRGaWx0ZXJNb2RlbCwgdmFsaWRhdGVNb2RlbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Ll9kYXRhU291cmNlO1xyXG4gICAgfTtcclxuICAgIERhdGFTb3VyY2VCdWlsZGVyLnByb3RvdHlwZS5idWlsZFNlcnZlclNpZGVEYXRhU291cmNlID0gZnVuY3Rpb24gKGdldERhdGFTZXQpIHtcclxuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuJGluamVjdG9yLmdldChkYXRhU291cmNlcy5zZXJ2ZXJTaWRlRGF0YVNvdXJjZS5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2RhdGFTb3VyY2UgPSBmYWN0b3J5LmdldEluc3RhbmNlKGdldERhdGFTZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZGF0YVNvdXJjZTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRTbWFydERhdGFTb3VyY2UgPSBmdW5jdGlvbiAoZ2V0RGF0YVNldCkge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGRhdGFTb3VyY2VzLnNtYXJ0RGF0YVNvdXJjZS5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2RhdGFTb3VyY2UgPSBmYWN0b3J5LmdldEluc3RhbmNlKGdldERhdGFTZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5fZGF0YVNvdXJjZTtcclxuICAgIH07XHJcbiAgICBEYXRhU291cmNlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRDdXN0b21EYXRhU291cmNlID0gZnVuY3Rpb24gKGRhdGFTb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnBhcmVudC5fZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Ll9kYXRhU291cmNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRhU291cmNlQnVpbGRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5EYXRhU291cmNlQnVpbGRlciA9IERhdGFTb3VyY2VCdWlsZGVyO1xyXG52YXIgRmlsdGVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWx0ZXJCdWlsZGVyKCRpbmplY3RvciwgcGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy4kaW5qZWN0b3IgPSAkaW5qZWN0b3I7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZpbHRlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkRmlsdGVyR3JvdXAgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuJGluamVjdG9yLmdldChmaWx0ZXJHcm91cC5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGZhY3RvcnkuZ2V0SW5zdGFuY2Uoc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTW9kZUZpbHRlckdyb3VwID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoZmlsdGVyR3JvdXAubW9kZUZpbHRlckdyb3VwLmZhY3RvcnlOYW1lKTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZmFjdG9yeS5nZXRJbnN0YW5jZShzZXR0aW5ncyk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyQnVpbGRlci5wcm90b3R5cGUuYnVpbGRSYW5nZUZpbHRlckdyb3VwID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoZmlsdGVyR3JvdXAucmFuZ2VGaWx0ZXJHcm91cC5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGZhY3RvcnkuZ2V0SW5zdGFuY2Uoc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkU2VsZWN0RmlsdGVyID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoc2VsZWN0RmlsdGVyLmZhY3RvcnlOYW1lKTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZmFjdG9yeS5nZXRJbnN0YW5jZShzZXR0aW5ncyk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyQnVpbGRlci5wcm90b3R5cGUuYnVpbGREYXRlRmlsdGVyID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLiRpbmplY3Rvci5nZXQoZGF0ZUZpbHRlci5mYWN0b3J5TmFtZSk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGZhY3RvcnkuZ2V0SW5zdGFuY2Uoc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuICAgIEZpbHRlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkQ29sdW1uU2VhcmNoRmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy4kaW5qZWN0b3IuZ2V0KGNvbHVtblNlYXJjaEZpbHRlcl9zZXJ2aWNlXzEuZmFjdG9yeU5hbWUpO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBmYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZpbHRlcnMucHVzaChmaWx0ZXIpO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9O1xyXG4gICAgRmlsdGVyQnVpbGRlci5wcm90b3R5cGUuYWRkQ3VzdG9tRmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgIHRoaXMucGFyZW50Ll9maWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmlsdGVyQnVpbGRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5GaWx0ZXJCdWlsZGVyID0gRmlsdGVyQnVpbGRlcjtcclxuY2FyZENvbnRhaW5lckJ1aWxkZXJGYWN0b3J5LiRpbmplY3QgPSBbJyRpbmplY3RvciddO1xyXG5mdW5jdGlvbiBjYXJkQ29udGFpbmVyQnVpbGRlckZhY3RvcnkoJGluamVjdG9yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZU1vY2s6IGZhbHNlLFxyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZU1vY2sgPyB0aGlzLm1vY2tCdWlsZGVyIDogbmV3IENhcmRDb250YWluZXJCdWlsZGVyKCRpbmplY3Rvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb2NrQnVpbGRlcjogbmV3IENhcmRDb250YWluZXJCdWlsZGVyKCRpbmplY3RvciksXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY2FyZENvbnRhaW5lckJ1aWxkZXJGYWN0b3J5ID0gY2FyZENvbnRhaW5lckJ1aWxkZXJGYWN0b3J5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJkQ29udGFpbmVyQnVpbGRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2NhcmRDb250YWluZXJCdWlsZGVyLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9ub2RlL25vZGUuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmhlYWRlckNvbXBvbmVudE5hbWUgPSAncmxEZWZhdWx0Q2FyZENvbnRhaW5lckhlYWRlcic7XHJcbmV4cG9ydHMuZm9vdGVyQ29tcG9uZW50TmFtZSA9ICdybERlZmF1bHRDYXJkQ29udGFpbmVyRm9vdGVyJztcclxuZXhwb3J0cy5kZWZhdWx0Q29udGFpbmVySGVhZGVyID0ge1xyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZGVmYXVsdENhcmRDb250YWluZXJIZWFkZXIuaHRtbCcpLFxyXG59O1xyXG5leHBvcnRzLmRlZmF1bHRDb250YWluZXJGb290ZXIgPSB7XHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9kZWZhdWx0Q2FyZENvbnRhaW5lckZvb3Rlci5odG1sJyksXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRDb21wb25lbnRzLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jYXJkQ29udGFpbmVyL2RlZmF1bHRDb21wb25lbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImNvbC14cy0xMiBjb2wtc20tOVxcXCI+XFxyXFxuXFx0XFx0PHJsLWNhcmQtc2VhcmNoPjwvcmwtY2FyZC1zZWFyY2g+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiaGlkZGVuLXhzIGNvbC1zbS0zXFxcIj5cXHJcXG5cXHRcXHQ8cmwtcGFnZS1zaXplPjwvcmwtcGFnZS1zaXplPlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGVmYXVsdENhcmRDb250YWluZXJIZWFkZXIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuXFx0PGRpdiBuZy1pZj1cXFwiIWNhcmRDb250YWluZXIuc2VsZWN0YWJsZUNhcmRzXFxcIiBjbGFzcz1cXFwiY29sLXNtLTZcXFwiPlxcclxcblxcdFxcdDxybC1pdGVtLWNvdW50PjwvcmwtaXRlbS1jb3VudD5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8c3BhbiBuZy1pZj1cXFwiY2FyZENvbnRhaW5lci5zZWxlY3RhYmxlQ2FyZHNcXFwiPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC1zbS0zXFxcIj5cXHJcXG5cXHRcXHRcXHQ8cmwtc2VsZWN0aW9uLWNvbnRyb2w+PC9ybC1zZWxlY3Rpb24tY29udHJvbD5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tM1xcXCI+XFxyXFxuXFx0XFx0XFx0PHJsLWl0ZW0tY291bnQ+PC9ybC1pdGVtLWNvdW50PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvc3Bhbj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wtc20tNlxcXCI+XFxyXFxuXFx0XFx0PHJsLXBhZ2VyIGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj48L3JsLXBhZ2VyPlxcclxcblxcdDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NhcmRDb250YWluZXIvZGVmYXVsdENhcmRDb250YWluZXJGb290ZXIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnJlcXVpcmUoJy4vY2hlY2tib3guY3NzJyk7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgY29tcG9uZW50c0RlZmF1bHRUaGVtZV8xID0gcmVxdWlyZSgnLi4vY29tcG9uZW50c0RlZmF1bHRUaGVtZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5jaGVja2JveCc7XHJcbmV4cG9ydHMuY29tcG9uZW50TmFtZSA9ICdybENoZWNrYm94JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdDaGVja2JveENvbnRyb2xsZXInO1xyXG52YXIgQ2hlY2tib3hDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoZWNrYm94Q29udHJvbGxlcih1c2VEZWZhdWx0VGhlbWUpIHtcclxuICAgICAgICB0aGlzLnVzZURlZmF1bHRUaGVtZSA9IHVzZURlZmF1bHRUaGVtZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGVja2JveENvbnRyb2xsZXIucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZ01vZGVsLiR2aWV3VmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5nTW9kZWwuJHNldFZpZXdWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBDaGVja2JveENvbnRyb2xsZXIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUgJiYgIXRoaXMubmdEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xyXG4gICAgICAgICAgICB0aGlzLm9uVG9nZ2xlKHsgdmFsdWU6IHRoaXMuY2hlY2tlZCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2hlY2tib3hDb250cm9sbGVyLnByb3RvdHlwZS4kb25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5hY3RpdmUgIT0gbnVsbCA/IHRoaXMuYWN0aXZlIDogdHJ1ZTtcclxuICAgIH07XHJcbiAgICBDaGVja2JveENvbnRyb2xsZXIuJGluamVjdCA9IFtjb21wb25lbnRzRGVmYXVsdFRoZW1lXzEuZGVmYXVsdFRoZW1lVmFsdWVOYW1lXTtcclxuICAgIHJldHVybiBDaGVja2JveENvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ2hlY2tib3hDb250cm9sbGVyID0gQ2hlY2tib3hDb250cm9sbGVyO1xyXG5leHBvcnRzLmNoZWNrYm94ID0ge1xyXG4gICAgcmVxdWlyZTogeyBuZ01vZGVsOiAnbmdNb2RlbCcgfSxcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jaGVja2JveC5odG1sJyksXHJcbiAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgY29udHJvbGxlckFzOiAnY2hlY2tib3gnLFxyXG4gICAgYmluZGluZ3M6IHtcclxuICAgICAgICBuZ0Rpc2FibGVkOiAnPD8nLFxyXG4gICAgICAgIGFjdGl2ZTogJzw/JyxcclxuICAgICAgICBvblRvZ2dsZTogJyYnLFxyXG4gICAgfSxcclxufTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5jb21wb25lbnQoZXhwb3J0cy5jb21wb25lbnROYW1lLCBleHBvcnRzLmNoZWNrYm94KVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgQ2hlY2tib3hDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tib3guanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NoZWNrYm94L2NoZWNrYm94LmpzXG4gKiogbW9kdWxlIGlkID0gMTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2NoZWNrYm94LmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jaGVja2JveC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jaGVja2JveC5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnJsLWNoZWNrYm94LmRlZmF1bHQtdGhlbWU6YmVmb3JlIHtcXHJcXG5cXHRmb250LWZhbWlseTogRm9udEF3ZXNvbWU7XFxyXFxuXFx0Y29udGVudDogXFxcIlxcXFxGMDk2XFxcIjsgLypmYS1zcXVhcmUtbyovXFxyXFxuXFx0Zm9udC1zaXplOiAxLjVlbTtcXHJcXG5cXHRwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuXFx0dG9wOiAuMDVlbTtcXHJcXG59XFxyXFxuXFxyXFxuLnJsLWNoZWNrYm94LWNoZWNrZWQuZGVmYXVsdC10aGVtZTpiZWZvcmUge1xcclxcblxcdGZvbnQtZmFtaWx5OiBGb250QXdlc29tZTtcXHJcXG5cXHRjb250ZW50OiBcXFwiXFxcXEYwNDZcXFwiOyAvKmZhLWNoZWNrLXNxdWFyZS1vKi9cXHJcXG5cXHRmb250LXNpemU6IDEuNGVtO1xcclxcbn1cXHJcXG5cXHJcXG4uZGlzYWJsZWQuZGVmYXVsdC10aGVtZTpiZWZvcmUge1xcclxcblxcdGN1cnNvcjogbm90LWFsbG93ZWQ7XFxyXFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9zb3VyY2UvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3BhbiBuZy1jbGljaz1cXFwiY2hlY2tib3gudG9nZ2xlKClcXFwiIG5nLXRyYW5zY2x1ZGVcXHJcXG5cXHQgIG5nLWNsYXNzPVxcXCJ7ICdybC1jaGVja2JveCc6ICFjaGVja2JveC5jaGVja2VkXFxyXFxuXFx0ICAsICdybC1jaGVja2JveC1jaGVja2VkJzogY2hlY2tib3guY2hlY2tlZFxcclxcblxcdCAgLCAnZGlzYWJsZWQnOiBjaGVja2JveC5uZ0Rpc2FibGVkXFxyXFxuXFx0ICAsICdkZWZhdWx0LXRoZW1lJzogY2hlY2tib3gudXNlRGVmYXVsdFRoZW1lIH1cXFwiPjwvc3Bhbj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5odG1sXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX190cmFuc2Zvcm0gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudHJhbnNmb3JtLnRyYW5zZm9ybTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuY29tbWFMaXN0JztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsQ29tbWFMaXN0JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdDb21tYUxpc3RDb250cm9sbGVyJztcclxudmFyIENvbW1hTGlzdENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tbWFMaXN0Q29udHJvbGxlcihvYmplY3QpIHtcclxuICAgICAgICB0aGlzLnJlbWFpbmluZ0l0ZW1zID0gMDtcclxuICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmdldEZpcnN0SXRlbXModGhpcy5pbkxpc3QpO1xyXG4gICAgfVxyXG4gICAgQ29tbWFMaXN0Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0Rmlyc3RJdGVtcyA9IGZ1bmN0aW9uIChsaXN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsaXN0ID0gXy5tYXAobGlzdCwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX3RyYW5zZm9ybS5nZXRWYWx1ZShpdGVtLCBfdGhpcy50cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgICAgIHZhciBuZXdMaXN0O1xyXG4gICAgICAgIGlmICh0aGlzLm1heCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5ld0xpc3QgPSBfLnRha2UobGlzdCwgdGhpcy5tYXgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbWFpbmluZ0l0ZW1zID0gbGlzdC5sZW5ndGggLSB0aGlzLm1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0xpc3QgPSBfLmNsb25lKGxpc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3TGlzdDtcclxuICAgIH07XHJcbiAgICBDb21tYUxpc3RDb250cm9sbGVyLiRpbmplY3QgPSBbX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIENvbW1hTGlzdENvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ29tbWFMaXN0Q29udHJvbGxlciA9IENvbW1hTGlzdENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIGNvbW1hTGlzdCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8c3Bhbj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBuZy1yZXBlYXQ9XFxcIml0ZW0gaW4gY29tbWFMaXN0Lmxpc3QgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8c3Bhbj57e2l0ZW19fTwvc3Bhbj48c3BhbiBuZy1oaWRlPVxcXCIkbGFzdFxcXCI+LCA8L3NwYW4+XFxuXFx0XFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIG5nLXNob3c9XFxcImNvbW1hTGlzdC5yZW1haW5pbmdJdGVtcyA+IDBcXFwiPi4uLiB7e2NvbW1hTGlzdC5yZW1haW5pbmdJdGVtc319IG1vcmUgaXRlbXM8L3NwYW4+XFxuXFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY29tbWFMaXN0JyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBpbkxpc3Q6ICc8bGlzdCcsXHJcbiAgICAgICAgICAgIG1heDogJzw/JyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiAnPD8nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGNvbW1hTGlzdClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIENvbW1hTGlzdENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tYUxpc3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2NvbW1hTGlzdC9jb21tYUxpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9ib290c3RyYXBEYXRlVGltZVBpY2tlci5kLnRzJyAvPlxyXG5yZXF1aXJlKCcuLi8uLi8uLi9saWJyYXJpZXMvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL2luZGV4Jyk7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19kYXRlVGltZUZvcm1hdFN0cmluZ3MgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZGF0ZTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fZ3VpZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5ndWlkO1xyXG52YXIgcmVxdWlyZWRfMSA9IHJlcXVpcmUoJy4uLy4uL2JlaGF2aW9ycy9yZXF1aXJlZC9yZXF1aXJlZCcpO1xyXG52YXIgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2NvbXBvbmVudFZhbGlkYXRvci9jb21wb25lbnRWYWxpZGF0b3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5kYXRlVGltZSc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybERhdGVUaW1lJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdEYXRlVGltZUNvbnRyb2xsZXInO1xyXG52YXIgRGF0ZVRpbWVDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGVUaW1lQ29udHJvbGxlcigkc2NvcGUsICRhdHRycywgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKF9fb2JqZWN0Lm9iamVjdFV0aWxpdHkuaXNOdWxsT3JFbXB0eSgkYXR0cnMubmFtZSkpIHtcclxuICAgICAgICAgICAgJGF0dHJzLiRzZXQoJ25hbWUnLCAnZGF0ZS10aW1lLScgKyBfX2d1aWQuZ3VpZC5yYW5kb20oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1bnJlZ2lzdGVyID0gJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5uZ01vZGVsOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHZhbGlkYXRvcnMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF90aGlzLnZhbGlkYXRvcikpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChfdGhpcy52YWxpZGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZXF1aXJlZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdybFJlcXVpcmVkJyxcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gIV9fb2JqZWN0Lm9iamVjdFV0aWxpdHkuaXNOdWxsT3JFbXB0eShfdGhpcy5uZ01vZGVsLiR2aWV3VmFsdWUpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogX3RoaXMucmVxdWlyZWQubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfLnNvbWUodmFsaWRhdG9ycykpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRhdGVUaW1lVmFsaWRhdG9yID0gY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeS5nZXRJbnN0YW5jZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmdNb2RlbDogX3RoaXMubmdNb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGU6ICRzY29wZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW5yZWdpc3RlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRGF0ZVRpbWVDb250cm9sbGVyLnByb3RvdHlwZS5vbkNsZWFyQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5uZ01vZGVsLiRzZXRWaWV3VmFsdWUoJycpO1xyXG4gICAgICAgIHRoaXMub25DbGVhckV2ZW50KCk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVRpbWVDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckYXR0cnMnLCBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLmZhY3RvcnlOYW1lXTtcclxuICAgIHJldHVybiBEYXRlVGltZUNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRGF0ZVRpbWVDb250cm9sbGVyID0gRGF0ZVRpbWVDb250cm9sbGVyO1xyXG5kYXRlVGltZS4kaW5qZWN0ID0gW3R5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5tb21lbnQuc2VydmljZU5hbWUsIF9fZGF0ZVRpbWVGb3JtYXRTdHJpbmdzLmRhdGVUaW1lRm9ybWF0U2VydmljZU5hbWUsIF9fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuZnVuY3Rpb24gZGF0ZVRpbWUobW9tZW50LCBkYXRlVGltZUZvcm1hdFN0cmluZ3MsIG9iamVjdCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2RhdGVUaW1lLmh0bWwnKSxcclxuICAgICAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAnPycgKyByZXF1aXJlZF8xLmRpcmVjdGl2ZU5hbWVdLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnZGF0ZVRpbWUnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIG1pbnV0ZVN0ZXBwaW5nOiAnPScsXHJcbiAgICAgICAgICAgIHVzZURhdGU6ICc9JyxcclxuICAgICAgICAgICAgdXNlVGltZTogJz0nLFxyXG4gICAgICAgICAgICBtaW46ICc9JyxcclxuICAgICAgICAgICAgbWF4OiAnPScsXHJcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJz0nLFxyXG4gICAgICAgICAgICBjbGVhckJ1dHRvbjogJz0nLFxyXG4gICAgICAgICAgICBvbkNsZWFyRXZlbnQ6ICcmJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcnMpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGVUaW1lID0gc2NvcGUuZGF0ZVRpbWU7XHJcbiAgICAgICAgICAgIHZhciBuZ01vZGVsID0gY29udHJvbGxlcnNbMF07XHJcbiAgICAgICAgICAgIGRhdGVUaW1lLnJlcXVpcmVkID0gY29udHJvbGxlcnNbMV07XHJcbiAgICAgICAgICAgIGRhdGVUaW1lLm5nTW9kZWwgPSBuZ01vZGVsO1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgIHZhciBoYXNEYXRlID0gXy5pc1VuZGVmaW5lZChkYXRlVGltZS51c2VEYXRlKSA/IHRydWUgOiBkYXRlVGltZS51c2VEYXRlO1xyXG4gICAgICAgICAgICB2YXIgaGFzVGltZSA9IF8uaXNVbmRlZmluZWQoZGF0ZVRpbWUudXNlVGltZSkgPyB0cnVlIDogZGF0ZVRpbWUudXNlVGltZTtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0gZWxlbWVudC5kYXRldGltZXBpY2tlci5kZWZhdWx0cztcclxuICAgICAgICAgICAgdmFyIG1pbiA9IGRhdGVUaW1lLm1pbiAhPSBudWxsID8gZGF0ZVRpbWUubWluIDogZGVmYXVsdHMubWluRGF0ZTtcclxuICAgICAgICAgICAgdmFyIG1heCA9IGRhdGVUaW1lLm1heCAhPSBudWxsID8gZGF0ZVRpbWUubWF4IDogZGVmYXVsdHMubWF4RGF0ZTtcclxuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nTW9kZWwuJHZpZXdWYWx1ZTsgfSwgZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlVGltZS52YWxpZEZvcm1hdCA9IG9iamVjdC5pc051bGxPckVtcHR5KG5ld1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIDogbW9tZW50KG5ld1ZhbHVlKS5pc1ZhbGlkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlbGVtZW50LmZpbmQoJy5zaG93LWRhdGUtcGlja2VyJykuZGF0ZXRpbWVwaWNrZXIoe1xyXG4gICAgICAgICAgICAgICAgc3RlcHBpbmc6IGRhdGVUaW1lLm1pbnV0ZVN0ZXBwaW5nIHx8IDEsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRhdGVUaW1lLmZvcm1hdCB8fCBkZWZhdWx0Rm9ybWF0KGhhc0RhdGUsIGhhc1RpbWUpLFxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYm90dG9tJyxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRIZWlnaHQ6IDIsXHJcbiAgICAgICAgICAgICAgICBwaWNrRGF0ZTogaGFzRGF0ZSxcclxuICAgICAgICAgICAgICAgIHBpY2tUaW1lOiBoYXNUaW1lLFxyXG4gICAgICAgICAgICAgICAgbWluRGF0ZTogbWluLFxyXG4gICAgICAgICAgICAgICAgbWF4RGF0ZTogbWF4LFxyXG4gICAgICAgICAgICB9KS5vbignY2hhbmdlLmRwJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gJCh0aGlzKS5maW5kKCdpbnB1dCcpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdEZvcm1hdChoYXNEYXRlLCBoYXNUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGF0ZSAmJiBoYXNUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVUaW1lRm9ybWF0U3RyaW5ncy5kYXRlVGltZUZvcm1hdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc0RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZVRpbWVGb3JtYXRTdHJpbmdzLmRhdGVGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVUaW1lRm9ybWF0U3RyaW5ncy50aW1lRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IHRvIGRlZmF1bHQgZm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm1vbWVudC5tb2R1bGVOYW1lLCB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZGF0ZS5tb2R1bGVOYW1lLCBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLm1vZHVsZU5hbWUsIF9fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGRhdGVUaW1lKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgRGF0ZVRpbWVDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZVRpbWUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2RhdGVUaW1lL2RhdGVUaW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5jc3MnKTtcclxucmVxdWlyZSgnLi9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXInKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcclxcbiAqIERhdGV0aW1lcGlja2VyIGZvciBCb290c3RyYXAgdjNcXHJcXG4vLyEgdmVyc2lvbiA6IDMuMS4zXFxyXFxuICogaHR0cHM6Ly9naXRodWIuY29tL0VvbmFzZGFuL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9cXHJcXG4gKi9cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBsZWZ0OiAwO1xcclxcbiAgd2lkdGg6IDI1MHB4O1xcclxcbiAgcGFkZGluZzogNHB4O1xcclxcbiAgbWFyZ2luLXRvcDogMXB4O1xcclxcbiAgei1pbmRleDogOTk5OTkgIWltcG9ydGFudDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQudGltZXBpY2tlci1zYnMge1xcclxcbiAgd2lkdGg6IDYwMHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC5ib3R0b206YmVmb3JlIHtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgYm9yZGVyLWxlZnQ6IDdweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG4gIGJvcmRlci1yaWdodDogN3B4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcbiAgYm9yZGVyLWJvdHRvbTogN3B4IHNvbGlkICNjY2M7XFxyXFxuICBib3JkZXItYm90dG9tLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMik7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IC03cHg7XFxyXFxuICBsZWZ0OiA3cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0LmJvdHRvbTphZnRlciB7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIGJvcmRlci1sZWZ0OiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBib3JkZXItcmlnaHQ6IDZweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG4gIGJvcmRlci1ib3R0b206IDZweCBzb2xpZCB3aGl0ZTtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogLTZweDtcXHJcXG4gIGxlZnQ6IDhweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQudG9wOmJlZm9yZSB7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIGJvcmRlci1sZWZ0OiA3cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBib3JkZXItcmlnaHQ6IDdweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG4gIGJvcmRlci10b3A6IDdweCBzb2xpZCAjY2NjO1xcclxcbiAgYm9yZGVyLXRvcC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYm90dG9tOiAtN3B4O1xcclxcbiAgbGVmdDogNnB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC50b3A6YWZ0ZXIge1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICBib3JkZXItbGVmdDogNnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcbiAgYm9yZGVyLXJpZ2h0OiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBib3JkZXItdG9wOiA2cHggc29saWQgd2hpdGU7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBib3R0b206IC02cHg7XFxyXFxuICBsZWZ0OiA3cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IC5kb3cge1xcclxcbiAgd2lkdGg6IDE0LjI4NTclO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC5wdWxsLXJpZ2h0OmJlZm9yZSB7XFxyXFxuICBsZWZ0OiBhdXRvO1xcclxcbiAgcmlnaHQ6IDZweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQucHVsbC1yaWdodDphZnRlciB7XFxyXFxuICBsZWZ0OiBhdXRvO1xcclxcbiAgcmlnaHQ6IDdweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgPiB1bCB7XFxyXFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IGFbZGF0YS1hY3Rpb25dIHtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IGFbZGF0YS1hY3Rpb25dOmFjdGl2ZSB7XFxyXFxuICBib3gtc2hhZG93OiBub25lO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCAudGltZXBpY2tlciB7XFxyXFxuICBtYXJnaW46IDAgNHB4IDRweCA0cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IC50aW1lcGlja2VyLWhvdXIsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgLnRpbWVwaWNrZXItbWludXRlLFxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IC50aW1lcGlja2VyLXNlY29uZCB7XFxyXFxuICB3aWR0aDogNTRweDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgZm9udC1zaXplOiAxLjJlbTtcXHJcXG4gIG1hcmdpbi10b3A6IDRweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgYnV0dG9uW2RhdGEtYWN0aW9uXSB7XFxyXFxuICBwYWRkaW5nOiA2cHg7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRhYmxlW2RhdGEtaG91ci1mb3JtYXQ9XFxcIjEyXFxcIl0gLnNlcGFyYXRvciB7XFxyXFxuICB3aWR0aDogNHB4O1xcclxcbiAgcGFkZGluZzogMDtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgLmRhdGVwaWNrZXIgPiBkaXYge1xcclxcbiAgZGlzcGxheTogbm9uZTtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgLnBpY2tlci1zd2l0Y2gge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0YWJsZSB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGgge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZCB7XFxyXFxuICBoZWlnaHQ6IDI1cHg7XFxyXFxuICBsaW5lLWhlaWdodDogMjVweDtcXHJcXG4gIHdpZHRoOiA1NHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5jdyB7XFxyXFxuICBmb250LXNpemU6IDEwcHg7XFxyXFxuICBoZWlnaHQ6IDIwcHg7XFxyXFxuICBsaW5lLWhlaWdodDogMjBweDtcXHJcXG4gIGNvbG9yOiAjNzc3Nzc3O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5kYXkge1xcclxcbiAgaGVpZ2h0OiAyMHB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxyXFxuICB3aWR0aDogMjBweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQuZGF5OmhvdmVyLFxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLmhvdXI6aG92ZXIsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQubWludXRlOmhvdmVyLFxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLnNlY29uZDpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZWVlZWVlO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5vbGQsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQubmV3IHtcXHJcXG4gIGNvbG9yOiAjNzc3Nzc3O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC50b2RheSB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLnRvZGF5OmJlZm9yZSB7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIGJvcmRlci1sZWZ0OiA3cHggc29saWQgdHJhbnNwYXJlbnQ7XFxyXFxuICBib3JkZXItYm90dG9tOiA3cHggc29saWQgIzQyOGJjYTtcXHJcXG4gIGJvcmRlci10b3AtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4yKTtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGJvdHRvbTogNHB4O1xcclxcbiAgcmlnaHQ6IDRweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQuYWN0aXZlLFxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkLmFjdGl2ZTpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDI4YmNhO1xcclxcbiAgY29sb3I6ICNmZmZmZmY7XFxyXFxuICB0ZXh0LXNoYWRvdzogMCAtMXB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQuYWN0aXZlLnRvZGF5OmJlZm9yZSB7XFxyXFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZmZmO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5kaXNhYmxlZCxcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZC5kaXNhYmxlZDpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiBub25lO1xcclxcbiAgY29sb3I6ICM3Nzc3Nzc7XFxyXFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZCBzcGFuIHtcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIHdpZHRoOiA1NHB4O1xcclxcbiAgaGVpZ2h0OiAyNXB4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XFxyXFxuICBtYXJnaW46IDBweCAxLjVweDtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQgc3Bhbjpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZWVlZWVlO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0ZCBzcGFuLmFjdGl2ZSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDI4YmNhO1xcclxcbiAgY29sb3I6ICNmZmZmZmY7XFxyXFxuICB0ZXh0LXNoYWRvdzogMCAtMXB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQgc3Bhbi5vbGQge1xcclxcbiAgY29sb3I6ICM3Nzc3Nzc7XFxyXFxufVxcclxcbi5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0IHRkIHNwYW4uZGlzYWJsZWQsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGQgc3Bhbi5kaXNhYmxlZDpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiBub25lO1xcclxcbiAgY29sb3I6ICM3Nzc3Nzc7XFxyXFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aCB7XFxyXFxuICBoZWlnaHQ6IDIwcHg7XFxyXFxuICBsaW5lLWhlaWdodDogMjBweDtcXHJcXG4gIHdpZHRoOiAyMHB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aC5waWNrZXItc3dpdGNoIHtcXHJcXG4gIHdpZHRoOiAxNDVweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGgubmV4dCxcXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aC5wcmV2IHtcXHJcXG4gIGZvbnQtc2l6ZTogMjFweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGguZGlzYWJsZWQsXFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGguZGlzYWJsZWQ6aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZDogbm9uZTtcXHJcXG4gIGNvbG9yOiAjNzc3Nzc3O1xcclxcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGgge1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aDpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZWVlZWVlO1xcclxcbn1cXHJcXG4uaW5wdXQtZ3JvdXAuZGF0ZSAuaW5wdXQtZ3JvdXAtYWRkb24gc3BhbiB7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIHdpZHRoOiAxNnB4O1xcclxcbiAgaGVpZ2h0OiAxNnB4O1xcclxcbn1cXHJcXG4uYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldC5sZWZ0LW9yaWVudGVkOmJlZm9yZSB7XFxyXFxuICBsZWZ0OiBhdXRvO1xcclxcbiAgcmlnaHQ6IDZweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQubGVmdC1vcmllbnRlZDphZnRlciB7XFxyXFxuICBsZWZ0OiBhdXRvO1xcclxcbiAgcmlnaHQ6IDdweDtcXHJcXG59XFxyXFxuLmJvb3RzdHJhcC1kYXRldGltZXBpY2tlci13aWRnZXQgdWwubGlzdC11bnN0eWxlZCBsaSBkaXYudGltZXBpY2tlciBkaXYudGltZXBpY2tlci1waWNrZXIgdGFibGUudGFibGUtY29uZGVuc2VkIHRib2R5ID4gdHIgPiB0ZCB7XFxyXFxuICBwYWRkaW5nOiAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcXHJcXG4gIC5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXItd2lkZ2V0LnRpbWVwaWNrZXItc2JzIHtcXHJcXG4gICAgd2lkdGg6IDI4M3B4O1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vbGlicmFyaWVzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG4vLyEgdmVyc2lvbiA6IDMuMS4zXHJcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIuanNcclxuaHR0cHM6Ly9naXRodWIuY29tL0VvbmFzZGFuL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlclxyXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcblxyXG5Db3B5cmlnaHQgKGMpIDIwMTQgSm9uYXRoYW4gUGV0ZXJzb25cclxuXHJcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuVEhFIFNPRlRXQVJFLlxyXG4qL1xyXG47IChmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0XHQvLyBBTUQgaXMgdXNlZCAtIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcblx0XHRkZWZpbmUoWydqcXVlcnknLCAnbW9tZW50J10sIGZhY3RvcnkpO1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0XHRmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpLCByZXF1aXJlKCdtb21lbnQnKSk7XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0Ly8gTmVpdGhlciBBTUQgb3IgQ29tbW9uSlMgdXNlZC4gVXNlIGdsb2JhbCB2YXJpYWJsZXMuXHJcblx0XHRpZiAoIWpRdWVyeSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXF1aXJlcyBqUXVlcnkgdG8gYmUgbG9hZGVkIGZpcnN0Jyk7XHJcblx0XHR9XHJcblx0XHRpZiAoIW1vbWVudCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXF1aXJlcyBtb21lbnQuanMgdG8gYmUgbG9hZGVkIGZpcnN0Jyk7XHJcblx0XHR9XHJcblx0XHRmYWN0b3J5KHJvb3QualF1ZXJ5LCBtb21lbnQpO1xyXG5cdH1cclxufSh0aGlzLCBmdW5jdGlvbiAoJCwgbW9tZW50KSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdGlmICh0eXBlb2YgbW9tZW50ID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdtb21lbnRqcyBpcyByZXF1aXJlZCcpO1xyXG5cdH1cclxuXHJcblx0dmFyIGRwZ0lkID0gMCxcclxuXHJcbiAgICBEYXRlVGltZVBpY2tlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICBcdHZhciBkZWZhdWx0cyA9ICQuZm4uZGF0ZXRpbWVwaWNrZXIuZGVmYXVsdHMsXHJcblxyXG4gICAgICAgICAgICBpY29ucyA9IHtcclxuICAgICAgICAgICAgXHR0aW1lOiAnZmEgZmEtY2xvY2stbycsXHJcbiAgICAgICAgICAgIFx0ZGF0ZTogJ2ZhIGZhLWNhbGVuZGFyJyxcclxuICAgICAgICAgICAgXHR1cDogJ2ZhIGZhLWNoZXZyb24tdXAnLFxyXG4gICAgICAgICAgICBcdGRvd246ICdmYSBmYS1jaGV2cm9uLWRvd24nXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwaWNrZXIgPSB0aGlzLFxyXG4gICAgICAgICAgICBlcnJvcmVkID0gZmFsc2UsXHJcbiAgICAgICAgICAgIGREYXRlLFxyXG5cclxuICAgICAgICBpbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0dmFyIGljb24gPSBmYWxzZSwgbG9jYWxlRGF0YSwgckludGVydmFsO1xyXG4gICAgICAgIFx0cGlja2VyLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG4gICAgICAgIFx0cGlja2VyLm9wdGlvbnMuaWNvbnMgPSAkLmV4dGVuZCh7fSwgaWNvbnMsIHBpY2tlci5vcHRpb25zLmljb25zKTtcclxuXHJcbiAgICAgICAgXHRwaWNrZXIuZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgIFx0ZGF0YVRvT3B0aW9ucygpO1xyXG5cclxuICAgICAgICBcdGlmICghKHBpY2tlci5vcHRpb25zLnBpY2tUaW1lIHx8IHBpY2tlci5vcHRpb25zLnBpY2tEYXRlKSkge1xyXG4gICAgICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgY2hvb3NlIGF0IGxlYXN0IG9uZSBwaWNrZXInKTtcclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRwaWNrZXIuaWQgPSBkcGdJZCsrO1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHRwaWNrZXIuZGF0ZSA9IG1vbWVudCgpO1xyXG4gICAgICAgIFx0cGlja2VyLnVuc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgXHRwaWNrZXIuaXNJbnB1dCA9IHBpY2tlci5lbGVtZW50LmlzKCdpbnB1dCcpO1xyXG4gICAgICAgIFx0cGlja2VyLmNvbXBvbmVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBcdGlmIChwaWNrZXIuZWxlbWVudC5oYXNDbGFzcygnaW5wdXQtZ3JvdXAnKSkge1xyXG4gICAgICAgIFx0XHRpZiAocGlja2VyLmVsZW1lbnQuZmluZCgnLmRhdGVwaWNrZXJidXR0b24nKS5zaXplKCkgPT09IDApIHsvL2luIGNhc2UgdGhlcmUgaXMgbW9yZSB0aGVuIG9uZSAnaW5wdXQtZ3JvdXAtYWRkb24nIElzc3VlICM0OFxyXG4gICAgICAgIFx0XHRcdHBpY2tlci5jb21wb25lbnQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCdbY2xhc3NePVwiaW5wdXQtZ3JvdXAtXCJdJyk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0ZWxzZSB7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmNvbXBvbmVudCA9IHBpY2tlci5lbGVtZW50LmZpbmQoJy5kYXRlcGlja2VyYnV0dG9uJyk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci5mb3JtYXQgPSBwaWNrZXIub3B0aW9ucy5mb3JtYXQ7XHJcblxyXG4gICAgICAgIFx0bG9jYWxlRGF0YSA9IG1vbWVudCgpLmxvY2FsZURhdGEoKTtcclxuXHJcbiAgICAgICAgXHRpZiAoIXBpY2tlci5mb3JtYXQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmZvcm1hdCA9IChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSA/IGxvY2FsZURhdGEubG9uZ0RhdGVGb3JtYXQoJ0wnKSA6ICcnKTtcclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5vcHRpb25zLnBpY2tEYXRlICYmIHBpY2tlci5vcHRpb25zLnBpY2tUaW1lKSB7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmZvcm1hdCArPSAnICc7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0cGlja2VyLmZvcm1hdCArPSAocGlja2VyLm9wdGlvbnMucGlja1RpbWUgPyBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KCdMVCcpIDogJycpO1xyXG4gICAgICAgIFx0XHRpZiAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcykge1xyXG4gICAgICAgIFx0XHRcdGlmIChsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KCdMVCcpLmluZGV4T2YoJyBBJykgIT09IC0xKSB7XHJcbiAgICAgICAgXHRcdFx0XHRwaWNrZXIuZm9ybWF0ID0gcGlja2VyLmZvcm1hdC5zcGxpdCgnIEEnKVswXSArICc6c3MgQSc7XHJcbiAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdFx0cGlja2VyLmZvcm1hdCArPSAnOnNzJztcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci51c2UyNGhvdXJzID0gKHBpY2tlci5mb3JtYXQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhJykgPCAwICYmIHBpY2tlci5mb3JtYXQuaW5kZXhPZignaCcpIDwgMCk7XHJcblxyXG4gICAgICAgIFx0aWYgKHBpY2tlci5jb21wb25lbnQpIHtcclxuICAgICAgICBcdFx0aWNvbiA9IHBpY2tlci5jb21wb25lbnQuZmluZCgnc3BhbicpO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xyXG4gICAgICAgIFx0XHRpZiAoaWNvbikge1xyXG4gICAgICAgIFx0XHRcdGljb24uYWRkQ2xhc3MocGlja2VyLm9wdGlvbnMuaWNvbnMudGltZSk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5waWNrRGF0ZSkge1xyXG4gICAgICAgIFx0XHRpZiAoaWNvbikge1xyXG4gICAgICAgIFx0XHRcdGljb24ucmVtb3ZlQ2xhc3MocGlja2VyLm9wdGlvbnMuaWNvbnMudGltZSk7XHJcbiAgICAgICAgXHRcdFx0aWNvbi5hZGRDbGFzcyhwaWNrZXIub3B0aW9ucy5pY29ucy5kYXRlKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdHBpY2tlci5vcHRpb25zLndpZGdldFBhcmVudCA9XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGlja2VyLm9wdGlvbnMud2lkZ2V0UGFyZW50ID09PSAnc3RyaW5nJyAmJiBwaWNrZXIub3B0aW9ucy53aWRnZXRQYXJlbnQgfHxcclxuICAgICAgICAgICAgICAgIHBpY2tlci5lbGVtZW50LnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgXHRyZXR1cm4gJ3Njcm9sbCcgPT09ICQodGhpcykuY3NzKCdvdmVyZmxvdy15Jyk7XHJcbiAgICAgICAgICAgICAgICB9KS5nZXQoMCkgfHxcclxuICAgICAgICAgICAgICAgICdib2R5JztcclxuXHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0ID0gJChnZXRUZW1wbGF0ZSgpKS5hcHBlbmRUbyhwaWNrZXIub3B0aW9ucy53aWRnZXRQYXJlbnQpO1xyXG5cclxuICAgICAgICBcdHBpY2tlci5taW5WaWV3TW9kZSA9IHBpY2tlci5vcHRpb25zLm1pblZpZXdNb2RlIHx8IDA7XHJcbiAgICAgICAgXHRpZiAodHlwZW9mIHBpY2tlci5taW5WaWV3TW9kZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBcdFx0c3dpdGNoIChwaWNrZXIubWluVmlld01vZGUpIHtcclxuICAgICAgICBcdFx0XHRjYXNlICdtb250aHMnOlxyXG4gICAgICAgIFx0XHRcdFx0cGlja2VyLm1pblZpZXdNb2RlID0gMTtcclxuICAgICAgICBcdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgIFx0XHRcdGNhc2UgJ3llYXJzJzpcclxuICAgICAgICBcdFx0XHRcdHBpY2tlci5taW5WaWV3TW9kZSA9IDI7XHJcbiAgICAgICAgXHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRkZWZhdWx0OlxyXG4gICAgICAgIFx0XHRcdFx0cGlja2VyLm1pblZpZXdNb2RlID0gMDtcclxuICAgICAgICBcdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRwaWNrZXIudmlld01vZGUgPSBwaWNrZXIub3B0aW9ucy52aWV3TW9kZSB8fCAwO1xyXG4gICAgICAgIFx0aWYgKHR5cGVvZiBwaWNrZXIudmlld01vZGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgXHRcdHN3aXRjaCAocGlja2VyLnZpZXdNb2RlKSB7XHJcbiAgICAgICAgXHRcdFx0Y2FzZSAnbW9udGhzJzpcclxuICAgICAgICBcdFx0XHRcdHBpY2tlci52aWV3TW9kZSA9IDE7XHJcbiAgICAgICAgXHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRjYXNlICd5ZWFycyc6XHJcbiAgICAgICAgXHRcdFx0XHRwaWNrZXIudmlld01vZGUgPSAyO1xyXG4gICAgICAgIFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0ZGVmYXVsdDpcclxuICAgICAgICBcdFx0XHRcdHBpY2tlci52aWV3TW9kZSA9IDA7XHJcbiAgICAgICAgXHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdHBpY2tlci52aWV3TW9kZSA9IE1hdGgubWF4KHBpY2tlci52aWV3TW9kZSwgcGlja2VyLm1pblZpZXdNb2RlKTtcclxuXHJcbiAgICAgICAgXHRwaWNrZXIub3B0aW9ucy5kaXNhYmxlZERhdGVzID0gaW5kZXhHaXZlbkRhdGVzKHBpY2tlci5vcHRpb25zLmRpc2FibGVkRGF0ZXMpO1xyXG4gICAgICAgIFx0cGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzID0gaW5kZXhHaXZlbkRhdGVzKHBpY2tlci5vcHRpb25zLmVuYWJsZWREYXRlcyk7XHJcblxyXG4gICAgICAgIFx0cGlja2VyLnN0YXJ0Vmlld01vZGUgPSBwaWNrZXIudmlld01vZGU7XHJcbiAgICAgICAgXHRwaWNrZXIuc2V0TWluRGF0ZShwaWNrZXIub3B0aW9ucy5taW5EYXRlKTtcclxuICAgICAgICBcdHBpY2tlci5zZXRNYXhEYXRlKHBpY2tlci5vcHRpb25zLm1heERhdGUpO1xyXG4gICAgICAgIFx0ZmlsbERvdygpO1xyXG4gICAgICAgIFx0ZmlsbE1vbnRocygpO1xyXG4gICAgICAgIFx0ZmlsbEhvdXJzKCk7XHJcbiAgICAgICAgXHRmaWxsTWludXRlcygpO1xyXG4gICAgICAgIFx0ZmlsbFNlY29uZHMoKTtcclxuICAgICAgICBcdHVwZGF0ZSgpO1xyXG4gICAgICAgIFx0c2hvd01vZGUoKTtcclxuICAgICAgICBcdGlmICghZ2V0UGlja2VySW5wdXQoKS5wcm9wKCdkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgXHRcdGF0dGFjaERhdGVQaWNrZXJFdmVudHMoKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5kZWZhdWx0RGF0ZSAhPT0gJycgJiYgZ2V0UGlja2VySW5wdXQoKS52YWwoKSA9PT0gJycpIHtcclxuICAgICAgICBcdFx0cGlja2VyLnNldFZhbHVlKHBpY2tlci5vcHRpb25zLmRlZmF1bHREYXRlKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZyAhPT0gMSkge1xyXG4gICAgICAgIFx0XHRySW50ZXJ2YWwgPSBwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZztcclxuICAgICAgICBcdFx0cGlja2VyLmRhdGUubWludXRlcygoTWF0aC5yb3VuZChwaWNrZXIuZGF0ZS5taW51dGVzKCkgLyBySW50ZXJ2YWwpICogckludGVydmFsKSAlIDYwKS5zZWNvbmRzKDApO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFBpY2tlcklucHV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0dmFyIGlucHV0O1xyXG5cclxuICAgICAgICBcdGlmIChwaWNrZXIuaXNJbnB1dCkge1xyXG4gICAgICAgIFx0XHRyZXR1cm4gcGlja2VyLmVsZW1lbnQ7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpbnB1dCA9IHBpY2tlci5lbGVtZW50LmZpbmQoJy5kYXRlcGlja2VyaW5wdXQnKTtcclxuICAgICAgICBcdGlmIChpbnB1dC5zaXplKCkgPT09IDApIHtcclxuICAgICAgICBcdFx0aW5wdXQgPSBwaWNrZXIuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0ZWxzZSBpZiAoIWlucHV0LmlzKCdpbnB1dCcpKSB7XHJcbiAgICAgICAgXHRcdHRocm93IG5ldyBFcnJvcignQ1NTIGNsYXNzIFwiZGF0ZXBpY2tlcmlucHV0XCIgY2Fubm90IGJlIGFwcGxpZWQgdG8gbm9uIGlucHV0IGVsZW1lbnQnKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHJldHVybiBpbnB1dDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkYXRhVG9PcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0dmFyIGVEYXRhO1xyXG4gICAgICAgIFx0aWYgKHBpY2tlci5lbGVtZW50LmlzKCdpbnB1dCcpKSB7XHJcbiAgICAgICAgXHRcdGVEYXRhID0gcGlja2VyLmVsZW1lbnQuZGF0YSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0ZWxzZSB7XHJcbiAgICAgICAgXHRcdGVEYXRhID0gcGlja2VyLmVsZW1lbnQuZmluZCgnaW5wdXQnKS5kYXRhKCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZURhdGEuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLmZvcm1hdCA9IGVEYXRhLmRhdGVGb3JtYXQ7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZURhdGEuZGF0ZVBpY2tkYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMucGlja0RhdGUgPSBlRGF0YS5kYXRlUGlja2RhdGU7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZURhdGEuZGF0ZVBpY2t0aW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMucGlja1RpbWUgPSBlRGF0YS5kYXRlUGlja3RpbWU7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZURhdGEuZGF0ZVVzZW1pbnV0ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy51c2VNaW51dGVzID0gZURhdGEuZGF0ZVVzZW1pbnV0ZXM7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZURhdGEuZGF0ZVVzZXNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy51c2VTZWNvbmRzID0gZURhdGEuZGF0ZVVzZXNlY29uZHM7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZURhdGEuZGF0ZVVzZWN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy51c2VDdXJyZW50ID0gZURhdGEuZGF0ZVVzZWN1cnJlbnQ7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoZURhdGEuY2FsZW5kYXJXZWVrcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLmNhbGVuZGFyV2Vla3MgPSBlRGF0YS5jYWxlbmRhcldlZWtzO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVNaW51dGVzdGVwcGluZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLm1pbnV0ZVN0ZXBwaW5nID0gZURhdGEuZGF0ZU1pbnV0ZXN0ZXBwaW5nO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVNaW5kYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMubWluRGF0ZSA9IGVEYXRhLmRhdGVNaW5kYXRlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVNYXhkYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMubWF4RGF0ZSA9IGVEYXRhLmRhdGVNYXhkYXRlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVTaG93dG9kYXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5zaG93VG9kYXkgPSBlRGF0YS5kYXRlU2hvd3RvZGF5O1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVDb2xsYXBzZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLmNvbGxhcHNlID0gZURhdGEuZGF0ZUNvbGxhcHNlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVMYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLmxhbmd1YWdlID0gZURhdGEuZGF0ZUxhbmd1YWdlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVEZWZhdWx0ZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLmRlZmF1bHREYXRlID0gZURhdGEuZGF0ZURlZmF1bHRkYXRlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVEaXNhYmxlZGRhdGVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlcyA9IGVEYXRhLmRhdGVEaXNhYmxlZGRhdGVzO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVFbmFibGVkZGF0ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5lbmFibGVkRGF0ZXMgPSBlRGF0YS5kYXRlRW5hYmxlZGRhdGVzO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVJY29ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5vcHRpb25zLmljb25zID0gZURhdGEuZGF0ZUljb25zO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVVc2VzdHJpY3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QgPSBlRGF0YS5kYXRlVXNlc3RyaWN0O1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVEaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5kaXJlY3Rpb24gPSBlRGF0YS5kYXRlRGlyZWN0aW9uO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVTaWRlYnlzaWRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLm9wdGlvbnMuc2lkZUJ5U2lkZSA9IGVEYXRhLmRhdGVTaWRlYnlzaWRlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGVEYXRhLmRhdGVEYXlzb2Z3ZWVrZGlzYWJsZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIub3B0aW9ucy5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBlRGF0YS5kYXRlRGF5c29md2Vla2Rpc2FibGVkO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBsYWNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0dmFyIHBvc2l0aW9uID0gJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBpY2tlci5jb21wb25lbnQgPyBwaWNrZXIuY29tcG9uZW50Lm9mZnNldCgpIDogcGlja2VyLmVsZW1lbnQub2Zmc2V0KCksXHJcbiAgICAgICAgICAgICAgICAkd2luZG93ID0gJCh3aW5kb3cpLFxyXG4gICAgICAgICAgICAgICAgcGxhY2VQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgXHRwaWNrZXIud2lkdGggPSBwaWNrZXIuY29tcG9uZW50ID8gcGlja2VyLmNvbXBvbmVudC5vdXRlcldpZHRoKCkgOiBwaWNrZXIuZWxlbWVudC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgXHRvZmZzZXQudG9wID0gb2Zmc2V0LnRvcCArIHBpY2tlci5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XHJcblxyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3VwJykge1xyXG4gICAgICAgIFx0XHRwbGFjZVBvc2l0aW9uID0gJ3RvcCc7XHJcbiAgICAgICAgXHR9IGVsc2UgaWYgKHBpY2tlci5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgICBcdFx0cGxhY2VQb3NpdGlvbiA9ICdib3R0b20nO1xyXG4gICAgICAgIFx0fSBlbHNlIGlmIChwaWNrZXIub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdhdXRvJykge1xyXG4gICAgICAgIFx0XHRpZiAob2Zmc2V0LnRvcCArIHBpY2tlci53aWRnZXQuaGVpZ2h0KCkgPiAkd2luZG93LmhlaWdodCgpICsgJHdpbmRvdy5zY3JvbGxUb3AoKSAmJiBwaWNrZXIud2lkZ2V0LmhlaWdodCgpICsgcGlja2VyLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSA8IG9mZnNldC50b3ApIHtcclxuICAgICAgICBcdFx0XHRwbGFjZVBvc2l0aW9uID0gJ3RvcCc7XHJcbiAgICAgICAgXHRcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdFx0cGxhY2VQb3NpdGlvbiA9ICdib3R0b20nO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAocGxhY2VQb3NpdGlvbiA9PT0gJ3RvcCcpIHtcclxuICAgICAgICBcdFx0b2Zmc2V0LmJvdHRvbSA9ICR3aW5kb3cuaGVpZ2h0KCkgLSBvZmZzZXQudG9wICsgcGlja2VyLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSArIDM7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuYWRkQ2xhc3MoJ3RvcCcpLnJlbW92ZUNsYXNzKCdib3R0b20nKTtcclxuICAgICAgICBcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdG9mZnNldC50b3AgKz0gMTtcclxuICAgICAgICBcdFx0b2Zmc2V0LnRvcCArPSBwaWNrZXIub3B0aW9ucy5lbGVtZW50SGVpZ2h0O1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmFkZENsYXNzKCdib3R0b20nKS5yZW1vdmVDbGFzcygndG9wJyk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC53aWR0aChwaWNrZXIub3B0aW9ucy53aWR0aCk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLm9yaWVudGF0aW9uID09PSAnbGVmdCcpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5hZGRDbGFzcygnbGVmdC1vcmllbnRlZCcpO1xyXG4gICAgICAgIFx0XHRvZmZzZXQubGVmdCA9IG9mZnNldC5sZWZ0IC0gcGlja2VyLndpZGdldC53aWR0aCgpICsgMjA7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0aWYgKGlzSW5GaXhlZCgpKSB7XHJcbiAgICAgICAgXHRcdHBvc2l0aW9uID0gJ2ZpeGVkJztcclxuICAgICAgICBcdFx0b2Zmc2V0LnRvcCAtPSAkd2luZG93LnNjcm9sbFRvcCgpO1xyXG4gICAgICAgIFx0XHRvZmZzZXQubGVmdCAtPSAkd2luZG93LnNjcm9sbExlZnQoKTtcclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRpZiAoJHdpbmRvdy53aWR0aCgpIDwgb2Zmc2V0LmxlZnQgKyBwaWNrZXIud2lkZ2V0Lm91dGVyV2lkdGgoKSkge1xyXG4gICAgICAgIFx0XHRvZmZzZXQucmlnaHQgPSAkd2luZG93LndpZHRoKCkgLSBvZmZzZXQubGVmdCAtIHBpY2tlci53aWR0aDtcclxuICAgICAgICBcdFx0b2Zmc2V0LmxlZnQgPSAnYXV0byc7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuYWRkQ2xhc3MoJ3B1bGwtcmlnaHQnKTtcclxuICAgICAgICBcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdG9mZnNldC5yaWdodCA9ICdhdXRvJztcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5yZW1vdmVDbGFzcygncHVsbC1yaWdodCcpO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGlmIChwbGFjZVBvc2l0aW9uID09PSAndG9wJykge1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmNzcyh7XHJcbiAgICAgICAgXHRcdFx0cG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICAgIFx0XHRcdGJvdHRvbTogb2Zmc2V0LmJvdHRvbSxcclxuICAgICAgICBcdFx0XHR0b3A6ICdhdXRvJyxcclxuICAgICAgICBcdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCxcclxuICAgICAgICBcdFx0XHRyaWdodDogb2Zmc2V0LnJpZ2h0XHJcbiAgICAgICAgXHRcdH0pO1xyXG4gICAgICAgIFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5jc3Moe1xyXG4gICAgICAgIFx0XHRcdHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICBcdFx0XHR0b3A6IG9mZnNldC50b3AsXHJcbiAgICAgICAgXHRcdFx0Ym90dG9tOiAnYXV0bycsXHJcbiAgICAgICAgXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQsXHJcbiAgICAgICAgXHRcdFx0cmlnaHQ6IG9mZnNldC5yaWdodFxyXG4gICAgICAgIFx0XHR9KTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBub3RpZnlDaGFuZ2UgPSBmdW5jdGlvbiAob2xkRGF0ZSwgZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgXHRpZiAobW9tZW50KHBpY2tlci5kYXRlKS5pc1NhbWUobW9tZW50KG9sZERhdGUpKSAmJiAhZXJyb3JlZCkge1xyXG4gICAgICAgIFx0XHRyZXR1cm47XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRlcnJvcmVkID0gZmFsc2U7XHJcbiAgICAgICAgXHRwaWNrZXIuZWxlbWVudC50cmlnZ2VyKHtcclxuICAgICAgICBcdFx0dHlwZTogJ2RwLmNoYW5nZScsXHJcbiAgICAgICAgXHRcdGRhdGU6IG1vbWVudChwaWNrZXIuZGF0ZSksXHJcbiAgICAgICAgXHRcdG9sZERhdGU6IG1vbWVudChvbGREYXRlKVxyXG4gICAgICAgIFx0fSk7XHJcblxyXG4gICAgICAgIFx0aWYgKGV2ZW50VHlwZSAhPT0gJ2NoYW5nZScpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmVsZW1lbnQuY2hhbmdlKCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIFx0ZXJyb3JlZCA9IHRydWU7XHJcbiAgICAgICAgXHRwaWNrZXIuZWxlbWVudC50cmlnZ2VyKHtcclxuICAgICAgICBcdFx0dHlwZTogJ2RwLmVycm9yJyxcclxuICAgICAgICBcdFx0ZGF0ZTogbW9tZW50KGRhdGUsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdClcclxuICAgICAgICBcdH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdEYXRlKSB7XHJcbiAgICAgICAgXHRtb21lbnQubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgICAgICBcdHZhciBkYXRlU3RyID0gbmV3RGF0ZTtcclxuICAgICAgICBcdGlmICghZGF0ZVN0cikge1xyXG4gICAgICAgIFx0XHRkYXRlU3RyID0gZ2V0UGlja2VySW5wdXQoKS52YWwoKTtcclxuICAgICAgICBcdFx0aWYgKGRhdGVTdHIpIHtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuZGF0ZSA9IG1vbWVudChkYXRlU3RyLCBwaWNrZXIuZm9ybWF0LCBwaWNrZXIub3B0aW9ucy51c2VTdHJpY3QpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdGlmICghcGlja2VyLmRhdGUpIHtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuZGF0ZSA9IG1vbWVudCgpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRwaWNrZXIudmlld0RhdGUgPSBtb21lbnQocGlja2VyLmRhdGUpLnN0YXJ0T2YoJ21vbnRoJyk7XHJcbiAgICAgICAgXHRmaWxsRGF0ZSgpO1xyXG4gICAgICAgIFx0ZmlsbFRpbWUoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaWxsRG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHR2YXIgaHRtbCA9ICQoJzx0cj4nKSwgd2Vla2RheXNNaW4gPSBtb21lbnQud2Vla2RheXNNaW4oKSwgaTtcclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5jYWxlbmRhcldlZWtzID09PSB0cnVlKSB7XHJcbiAgICAgICAgXHRcdGh0bWwuYXBwZW5kKCc8dGggY2xhc3M9XCJjd1wiPiM8L3RoPicpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKG1vbWVudCgpLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cgPT09IDApIHsgLy8gc3RhcnRzIG9uIFN1bmRheVxyXG4gICAgICAgIFx0XHRmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgXHRcdFx0aHRtbC5hcHBlbmQoJzx0aCBjbGFzcz1cImRvd1wiPicgKyB3ZWVrZGF5c01pbltpXSArICc8L3RoPicpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRmb3IgKGkgPSAxOyBpIDwgODsgaSsrKSB7XHJcbiAgICAgICAgXHRcdFx0aWYgKGkgPT09IDcpIHtcclxuICAgICAgICBcdFx0XHRcdGh0bWwuYXBwZW5kKCc8dGggY2xhc3M9XCJkb3dcIj4nICsgd2Vla2RheXNNaW5bMF0gKyAnPC90aD4nKTtcclxuICAgICAgICBcdFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdFx0aHRtbC5hcHBlbmQoJzx0aCBjbGFzcz1cImRvd1wiPicgKyB3ZWVrZGF5c01pbltpXSArICc8L3RoPicpO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoZWFkJykuYXBwZW5kKGh0bWwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpbGxNb250aHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRtb21lbnQubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgICAgICBcdHZhciBodG1sID0gJycsIGksIG1vbnRoc1Nob3J0ID0gbW9tZW50Lm1vbnRoc1Nob3J0KCk7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgIFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cIm1vbnRoXCI+JyArIG1vbnRoc1Nob3J0W2ldICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGQnKS5hcHBlbmQoaHRtbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlsbERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRpZiAoIXBpY2tlci5vcHRpb25zLnBpY2tEYXRlKSB7XHJcbiAgICAgICAgXHRcdHJldHVybjtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdG1vbWVudC5sb2NhbGUocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xyXG4gICAgICAgIFx0dmFyIHllYXIgPSBwaWNrZXIudmlld0RhdGUueWVhcigpLFxyXG4gICAgICAgICAgICAgICAgbW9udGggPSBwaWNrZXIudmlld0RhdGUubW9udGgoKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0WWVhciA9IHBpY2tlci5vcHRpb25zLm1pbkRhdGUueWVhcigpLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRNb250aCA9IHBpY2tlci5vcHRpb25zLm1pbkRhdGUubW9udGgoKSxcclxuICAgICAgICAgICAgICAgIGVuZFllYXIgPSBwaWNrZXIub3B0aW9ucy5tYXhEYXRlLnllYXIoKSxcclxuICAgICAgICAgICAgICAgIGVuZE1vbnRoID0gcGlja2VyLm9wdGlvbnMubWF4RGF0ZS5tb250aCgpLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2TW9udGgsIG5leHRNb250aCwgaHRtbCA9IFtdLCByb3csIGNsc05hbWUsIGksIGRheXMsIHllYXJDb250LCBjdXJyZW50WWVhciwgbW9udGhzID0gbW9tZW50Lm1vbnRocygpO1xyXG5cclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cycpLmZpbmQoJy5kaXNhYmxlZCcpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMnKS5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKCcuZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGg6ZXEoMSknKS50ZXh0KFxyXG4gICAgICAgICAgICAgICAgbW9udGhzW21vbnRoXSArICcgJyArIHllYXIpO1xyXG5cclxuICAgICAgICBcdHByZXZNb250aCA9IG1vbWVudChwaWNrZXIudmlld0RhdGUsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCkuc3VidHJhY3QoMSwgJ21vbnRocycpO1xyXG4gICAgICAgIFx0ZGF5cyA9IHByZXZNb250aC5kYXlzSW5Nb250aCgpO1xyXG4gICAgICAgIFx0cHJldk1vbnRoLmRhdGUoZGF5cykuc3RhcnRPZignd2VlaycpO1xyXG4gICAgICAgIFx0aWYgKCh5ZWFyID09PSBzdGFydFllYXIgJiYgbW9udGggPD0gc3RhcnRNb250aCkgfHwgeWVhciA8IHN0YXJ0WWVhcikge1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGg6ZXEoMCknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmICgoeWVhciA9PT0gZW5kWWVhciAmJiBtb250aCA+PSBlbmRNb250aCkgfHwgeWVhciA+IGVuZFllYXIpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRoOmVxKDIpJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0bmV4dE1vbnRoID0gbW9tZW50KHByZXZNb250aCkuYWRkKDQyLCAnZCcpO1xyXG4gICAgICAgIFx0d2hpbGUgKHByZXZNb250aC5pc0JlZm9yZShuZXh0TW9udGgpKSB7XHJcbiAgICAgICAgXHRcdGlmIChwcmV2TW9udGgud2Vla2RheSgpID09PSBtb21lbnQoKS5zdGFydE9mKCd3ZWVrJykud2Vla2RheSgpKSB7XHJcbiAgICAgICAgXHRcdFx0cm93ID0gJCgnPHRyPicpO1xyXG4gICAgICAgIFx0XHRcdGh0bWwucHVzaChyb3cpO1xyXG4gICAgICAgIFx0XHRcdGlmIChwaWNrZXIub3B0aW9ucy5jYWxlbmRhcldlZWtzID09PSB0cnVlKSB7XHJcbiAgICAgICAgXHRcdFx0XHRyb3cuYXBwZW5kKCc8dGQgY2xhc3M9XCJjd1wiPicgKyBwcmV2TW9udGgud2VlaygpICsgJzwvdGQ+Jyk7XHJcbiAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdGNsc05hbWUgPSAnJztcclxuICAgICAgICBcdFx0aWYgKHByZXZNb250aC55ZWFyKCkgPCB5ZWFyIHx8IChwcmV2TW9udGgueWVhcigpID09PSB5ZWFyICYmIHByZXZNb250aC5tb250aCgpIDwgbW9udGgpKSB7XHJcbiAgICAgICAgXHRcdFx0Y2xzTmFtZSArPSAnIG9sZCc7XHJcbiAgICAgICAgXHRcdH0gZWxzZSBpZiAocHJldk1vbnRoLnllYXIoKSA+IHllYXIgfHwgKHByZXZNb250aC55ZWFyKCkgPT09IHllYXIgJiYgcHJldk1vbnRoLm1vbnRoKCkgPiBtb250aCkpIHtcclxuICAgICAgICBcdFx0XHRjbHNOYW1lICs9ICcgbmV3JztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRpZiAocHJldk1vbnRoLmlzU2FtZShtb21lbnQoeyB5OiBwaWNrZXIuZGF0ZS55ZWFyKCksIE06IHBpY2tlci5kYXRlLm1vbnRoKCksIGQ6IHBpY2tlci5kYXRlLmRhdGUoKSB9KSkpIHtcclxuICAgICAgICBcdFx0XHRjbHNOYW1lICs9ICcgYWN0aXZlJztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRpZiAoaXNJbkRpc2FibGVEYXRlcyhwcmV2TW9udGgsICdkYXknKSB8fCAhaXNJbkVuYWJsZURhdGVzKHByZXZNb250aCkpIHtcclxuICAgICAgICBcdFx0XHRjbHNOYW1lICs9ICcgZGlzYWJsZWQnO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdGlmIChwaWNrZXIub3B0aW9ucy5zaG93VG9kYXkgPT09IHRydWUpIHtcclxuICAgICAgICBcdFx0XHRpZiAocHJldk1vbnRoLmlzU2FtZShtb21lbnQoKSwgJ2RheScpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRjbHNOYW1lICs9ICcgdG9kYXknO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRpZiAocGlja2VyLm9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkKSB7XHJcbiAgICAgICAgXHRcdFx0Zm9yIChpID0gMDsgaSA8IHBpY2tlci5vcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIFx0XHRcdFx0aWYgKHByZXZNb250aC5kYXkoKSA9PT0gcGlja2VyLm9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkW2ldKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdGNsc05hbWUgKz0gJyBkaXNhYmxlZCc7XHJcbiAgICAgICAgXHRcdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgIFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRyb3cuYXBwZW5kKCc8dGQgY2xhc3M9XCJkYXknICsgY2xzTmFtZSArICdcIj4nICsgcHJldk1vbnRoLmRhdGUoKSArICc8L3RkPicpO1xyXG5cclxuICAgICAgICBcdFx0Y3VycmVudERhdGUgPSBwcmV2TW9udGguZGF0ZSgpO1xyXG4gICAgICAgIFx0XHRwcmV2TW9udGguYWRkKDEsICdkJyk7XHJcblxyXG4gICAgICAgIFx0XHRpZiAoY3VycmVudERhdGUgPT09IHByZXZNb250aC5kYXRlKCkpIHtcclxuICAgICAgICBcdFx0XHRwcmV2TW9udGguYWRkKDEsICdkJyk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0Ym9keScpLmVtcHR5KCkuYXBwZW5kKGh0bWwpO1xyXG4gICAgICAgIFx0Y3VycmVudFllYXIgPSBwaWNrZXIuZGF0ZS55ZWFyKCk7XHJcbiAgICAgICAgXHRtb250aHMgPSBwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLW1vbnRocycpLmZpbmQoJ3RoOmVxKDEpJykudGV4dCh5ZWFyKS5lbmQoKS5maW5kKCdzcGFuJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgIFx0aWYgKGN1cnJlbnRZZWFyID09PSB5ZWFyKSB7XHJcbiAgICAgICAgXHRcdG1vbnRocy5lcShwaWNrZXIuZGF0ZS5tb250aCgpKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAoeWVhciAtIDEgPCBzdGFydFllYXIpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGg6ZXEoMCknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmICh5ZWFyICsgMSA+IGVuZFllYXIpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGg6ZXEoMiknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgXHRcdGlmICgoeWVhciA9PT0gc3RhcnRZZWFyICYmIHN0YXJ0TW9udGggPiBpKSB8fCAoeWVhciA8IHN0YXJ0WWVhcikpIHtcclxuICAgICAgICBcdFx0XHQkKG1vbnRoc1tpXSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHRcdH0gZWxzZSBpZiAoKHllYXIgPT09IGVuZFllYXIgJiYgZW5kTW9udGggPCBpKSB8fCAoeWVhciA+IGVuZFllYXIpKSB7XHJcbiAgICAgICAgXHRcdFx0JChtb250aHNbaV0pLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0aHRtbCA9ICcnO1xyXG4gICAgICAgIFx0eWVhciA9IHBhcnNlSW50KHllYXIgLyAxMCwgMTApICogMTA7XHJcbiAgICAgICAgXHR5ZWFyQ29udCA9IHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKS5maW5kKFxyXG4gICAgICAgICAgICAgICAgJ3RoOmVxKDEpJykudGV4dCh5ZWFyICsgJy0nICsgKHllYXIgKyA5KSkucGFyZW50cygndGFibGUnKS5maW5kKCd0ZCcpO1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci15ZWFycycpLmZpbmQoJ3RoJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHRpZiAoc3RhcnRZZWFyID4geWVhcikge1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy5kYXRlcGlja2VyLXllYXJzJykuZmluZCgndGg6ZXEoMCknKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChlbmRZZWFyIDwgeWVhciArIDkpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcuZGF0ZXBpY2tlci15ZWFycycpLmZpbmQoJ3RoOmVxKDIpJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHR5ZWFyIC09IDE7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAtMTsgaSA8IDExOyBpKyspIHtcclxuICAgICAgICBcdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCJ5ZWFyJyArIChpID09PSAtMSB8fCBpID09PSAxMCA/ICcgb2xkJyA6ICcnKSArIChjdXJyZW50WWVhciA9PT0geWVhciA/ICcgYWN0aXZlJyA6ICcnKSArICgoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhcikgPyAnIGRpc2FibGVkJyA6ICcnKSArICdcIj4nICsgeWVhciArICc8L3NwYW4+JztcclxuICAgICAgICBcdFx0eWVhciArPSAxO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0eWVhckNvbnQuaHRtbChodG1sKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaWxsSG91cnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRtb21lbnQubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgICAgICBcdHZhciB0YWJsZSA9IHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItaG91cnMgdGFibGUnKSwgaHRtbCA9ICcnLCBjdXJyZW50LCBpLCBqO1xyXG4gICAgICAgIFx0dGFibGUucGFyZW50KCkuaGlkZSgpO1xyXG4gICAgICAgIFx0aWYgKHBpY2tlci51c2UyNGhvdXJzKSB7XHJcbiAgICAgICAgXHRcdGN1cnJlbnQgPSAwO1xyXG4gICAgICAgIFx0XHRmb3IgKGkgPSAwOyBpIDwgNjsgaSArPSAxKSB7XHJcbiAgICAgICAgXHRcdFx0aHRtbCArPSAnPHRyPic7XHJcbiAgICAgICAgXHRcdFx0Zm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xyXG4gICAgICAgIFx0XHRcdFx0aHRtbCArPSAnPHRkIGNsYXNzPVwiaG91clwiPicgKyBwYWRMZWZ0KGN1cnJlbnQudG9TdHJpbmcoKSkgKyAnPC90ZD4nO1xyXG4gICAgICAgIFx0XHRcdFx0Y3VycmVudCsrO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRodG1sICs9ICc8L3RyPic7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGVsc2Uge1xyXG4gICAgICAgIFx0XHRjdXJyZW50ID0gMTtcclxuICAgICAgICBcdFx0Zm9yIChpID0gMDsgaSA8IDM7IGkgKz0gMSkge1xyXG4gICAgICAgIFx0XHRcdGh0bWwgKz0gJzx0cj4nO1xyXG4gICAgICAgIFx0XHRcdGZvciAoaiA9IDA7IGogPCA0OyBqICs9IDEpIHtcclxuICAgICAgICBcdFx0XHRcdGh0bWwgKz0gJzx0ZCBjbGFzcz1cImhvdXJcIj4nICsgcGFkTGVmdChjdXJyZW50LnRvU3RyaW5nKCkpICsgJzwvdGQ+JztcclxuICAgICAgICBcdFx0XHRcdGN1cnJlbnQrKztcclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0aHRtbCArPSAnPC90cj4nO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHR0YWJsZS5odG1sKGh0bWwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpbGxNaW51dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0dmFyIHRhYmxlID0gcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1taW51dGVzIHRhYmxlJyksIGh0bWwgPSAnJywgY3VycmVudCA9IDAsIGksIGosIHN0ZXAgPSBwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZztcclxuICAgICAgICBcdHRhYmxlLnBhcmVudCgpLmhpZGUoKTtcclxuICAgICAgICBcdGlmIChzdGVwID09PSAxKSB7XHJcbiAgICAgICAgXHRcdHN0ZXAgPSA1O1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0Zm9yIChpID0gMDsgaSA8IE1hdGguY2VpbCg2MCAvIHN0ZXAgLyA0KSA7IGkrKykge1xyXG4gICAgICAgIFx0XHRodG1sICs9ICc8dHI+JztcclxuICAgICAgICBcdFx0Zm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xyXG4gICAgICAgIFx0XHRcdGlmIChjdXJyZW50IDwgNjApIHtcclxuICAgICAgICBcdFx0XHRcdGh0bWwgKz0gJzx0ZCBjbGFzcz1cIm1pbnV0ZVwiPicgKyBwYWRMZWZ0KGN1cnJlbnQudG9TdHJpbmcoKSkgKyAnPC90ZD4nO1xyXG4gICAgICAgIFx0XHRcdFx0Y3VycmVudCArPSBzdGVwO1xyXG4gICAgICAgIFx0XHRcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdFx0XHRodG1sICs9ICc8dGQ+PC90ZD4nO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRodG1sICs9ICc8L3RyPic7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHR0YWJsZS5odG1sKGh0bWwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpbGxTZWNvbmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0dmFyIHRhYmxlID0gcGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1zZWNvbmRzIHRhYmxlJyksIGh0bWwgPSAnJywgY3VycmVudCA9IDAsIGksIGo7XHJcbiAgICAgICAgXHR0YWJsZS5wYXJlbnQoKS5oaWRlKCk7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgXHRcdGh0bWwgKz0gJzx0cj4nO1xyXG4gICAgICAgIFx0XHRmb3IgKGogPSAwOyBqIDwgNDsgaiArPSAxKSB7XHJcbiAgICAgICAgXHRcdFx0aHRtbCArPSAnPHRkIGNsYXNzPVwic2Vjb25kXCI+JyArIHBhZExlZnQoY3VycmVudC50b1N0cmluZygpKSArICc8L3RkPic7XHJcbiAgICAgICAgXHRcdFx0Y3VycmVudCArPSA1O1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdGh0bWwgKz0gJzwvdHI+JztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHRhYmxlLmh0bWwoaHRtbCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlsbFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRpZiAoIXBpY2tlci5kYXRlKSB7XHJcbiAgICAgICAgXHRcdHJldHVybjtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHZhciB0aW1lQ29tcG9uZW50cyA9IHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgc3BhbltkYXRhLXRpbWUtY29tcG9uZW50XScpLFxyXG4gICAgICAgICAgICAgICAgaG91ciA9IHBpY2tlci5kYXRlLmhvdXJzKCksXHJcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSBwaWNrZXIuZGF0ZS5mb3JtYXQoJ0EnKTtcclxuICAgICAgICBcdGlmICghcGlja2VyLnVzZTI0aG91cnMpIHtcclxuICAgICAgICBcdFx0aWYgKGhvdXIgPT09IDApIHtcclxuICAgICAgICBcdFx0XHRob3VyID0gMTI7XHJcbiAgICAgICAgXHRcdH0gZWxzZSBpZiAoaG91ciAhPT0gMTIpIHtcclxuICAgICAgICBcdFx0XHRob3VyID0gaG91ciAlIDEyO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgW2RhdGEtYWN0aW9uPXRvZ2dsZVBlcmlvZF0nKS50ZXh0KHBlcmlvZCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHR0aW1lQ29tcG9uZW50cy5maWx0ZXIoJ1tkYXRhLXRpbWUtY29tcG9uZW50PWhvdXJzXScpLnRleHQocGFkTGVmdChob3VyKSk7XHJcbiAgICAgICAgXHR0aW1lQ29tcG9uZW50cy5maWx0ZXIoJ1tkYXRhLXRpbWUtY29tcG9uZW50PW1pbnV0ZXNdJykudGV4dChwYWRMZWZ0KHBpY2tlci5kYXRlLm1pbnV0ZXMoKSkpO1xyXG4gICAgICAgIFx0dGltZUNvbXBvbmVudHMuZmlsdGVyKCdbZGF0YS10aW1lLWNvbXBvbmVudD1zZWNvbmRzXScpLnRleHQocGFkTGVmdChwaWNrZXIuZGF0ZS5zZWNvbmQoKSkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsaWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgXHRlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgXHRwaWNrZXIudW5zZXQgPSBmYWxzZTtcclxuICAgICAgICBcdHZhciB0YXJnZXQgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCdzcGFuLCB0ZCwgdGgnKSwgbW9udGgsIHllYXIsIHN0ZXAsIGRheSwgb2xkRGF0ZSA9IG1vbWVudChwaWNrZXIuZGF0ZSk7XHJcbiAgICAgICAgXHRpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIFx0XHRpZiAoIXRhcmdldC5pcygnLmRpc2FibGVkJykpIHtcclxuICAgICAgICBcdFx0XHRzd2l0Y2ggKHRhcmdldFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRjYXNlICd0aCc6XHJcbiAgICAgICAgXHRcdFx0XHRcdHN3aXRjaCAodGFyZ2V0WzBdLmNsYXNzTmFtZSkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdGNhc2UgJ3BpY2tlci1zd2l0Y2gnOlxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0c2hvd01vZGUoMSk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRcdFx0XHRjYXNlICdwcmV2JzpcclxuICAgICAgICBcdFx0XHRcdFx0XHRjYXNlICduZXh0JzpcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdHN0ZXAgPSBkcEdsb2JhbC5tb2Rlc1twaWNrZXIudmlld01vZGVdLm5hdlN0ZXA7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0WzBdLmNsYXNzTmFtZSA9PT0gJ3ByZXYnKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRcdHN0ZXAgPSBzdGVwICogLTE7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRwaWNrZXIudmlld0RhdGUuYWRkKHN0ZXAsIGRwR2xvYmFsLm1vZGVzW3BpY2tlci52aWV3TW9kZV0ubmF2Rm5jKTtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdGZpbGxEYXRlKCk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRcdGNhc2UgJ3NwYW4nOlxyXG4gICAgICAgIFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcubW9udGgnKSkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdG1vbnRoID0gdGFyZ2V0LnBhcmVudCgpLmZpbmQoJ3NwYW4nKS5pbmRleCh0YXJnZXQpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdHBpY2tlci52aWV3RGF0ZS5tb250aChtb250aCk7XHJcbiAgICAgICAgXHRcdFx0XHRcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0eWVhciA9IHBhcnNlSW50KHRhcmdldC50ZXh0KCksIDEwKSB8fCAwO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdHBpY2tlci52aWV3RGF0ZS55ZWFyKHllYXIpO1xyXG4gICAgICAgIFx0XHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0XHRcdGlmIChwaWNrZXIudmlld01vZGUgPT09IHBpY2tlci5taW5WaWV3TW9kZSkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdHBpY2tlci5kYXRlID0gbW9tZW50KHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdHk6IHBpY2tlci52aWV3RGF0ZS55ZWFyKCksXHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRNOiBwaWNrZXIudmlld0RhdGUubW9udGgoKSxcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdGQ6IHBpY2tlci52aWV3RGF0ZS5kYXRlKCksXHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRoOiBwaWNrZXIuZGF0ZS5ob3VycygpLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0bTogcGlja2VyLmRhdGUubWludXRlcygpLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0czogcGlja2VyLmRhdGUuc2Vjb25kcygpXHJcbiAgICAgICAgXHRcdFx0XHRcdFx0fSk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0c2V0KCk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0bm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XHJcbiAgICAgICAgXHRcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRcdFx0c2hvd01vZGUoLTEpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRmaWxsRGF0ZSgpO1xyXG4gICAgICAgIFx0XHRcdFx0XHRicmVhaztcclxuICAgICAgICBcdFx0XHRcdGNhc2UgJ3RkJzpcclxuICAgICAgICBcdFx0XHRcdFx0aWYgKHRhcmdldC5pcygnLmRheScpKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0ZGF5ID0gcGFyc2VJbnQodGFyZ2V0LnRleHQoKSwgMTApIHx8IDE7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0bW9udGggPSBwaWNrZXIudmlld0RhdGUubW9udGgoKTtcclxuICAgICAgICBcdFx0XHRcdFx0XHR5ZWFyID0gcGlja2VyLnZpZXdEYXRlLnllYXIoKTtcclxuICAgICAgICBcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcub2xkJykpIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdGlmIChtb250aCA9PT0gMCkge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0XHRtb250aCA9IDExO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0XHR5ZWFyIC09IDE7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0XHRtb250aCAtPSAxO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0LmlzKCcubmV3JykpIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdGlmIChtb250aCA9PT0gMTEpIHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdFx0bW9udGggPSAwO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0XHR5ZWFyICs9IDE7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0XHRtb250aCArPSAxO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRcdFx0XHRwaWNrZXIuZGF0ZSA9IG1vbWVudCh7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHR5OiB5ZWFyLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0TTogbW9udGgsXHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRkOiBkYXksXHJcbiAgICAgICAgXHRcdFx0XHRcdFx0XHRoOiBwaWNrZXIuZGF0ZS5ob3VycygpLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0bTogcGlja2VyLmRhdGUubWludXRlcygpLFxyXG4gICAgICAgIFx0XHRcdFx0XHRcdFx0czogcGlja2VyLmRhdGUuc2Vjb25kcygpXHJcbiAgICAgICAgXHRcdFx0XHRcdFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0cGlja2VyLnZpZXdEYXRlID0gbW9tZW50KHtcclxuICAgICAgICBcdFx0XHRcdFx0XHRcdHk6IHllYXIsIE06IG1vbnRoLCBkOiBNYXRoLm1pbigyOCwgZGF5KVxyXG4gICAgICAgIFx0XHRcdFx0XHRcdH0pO1xyXG4gICAgICAgIFx0XHRcdFx0XHRcdGZpbGxEYXRlKCk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0c2V0KCk7XHJcbiAgICAgICAgXHRcdFx0XHRcdFx0bm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XHJcbiAgICAgICAgXHRcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHRcdFx0YnJlYWs7XHJcbiAgICAgICAgXHRcdFx0fVxyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWN0aW9ucyA9IHtcclxuICAgICAgICBcdGluY3JlbWVudEhvdXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdGNoZWNrRGF0ZSgnYWRkJywgJ2hvdXJzJywgMSk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdGluY3JlbWVudE1pbnV0ZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdFx0Y2hlY2tEYXRlKCdhZGQnLCAnbWludXRlcycsIHBpY2tlci5vcHRpb25zLm1pbnV0ZVN0ZXBwaW5nKTtcclxuICAgICAgICBcdH0sXHJcblxyXG4gICAgICAgIFx0aW5jcmVtZW50U2Vjb25kczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHRjaGVja0RhdGUoJ2FkZCcsICdzZWNvbmRzJywgMSk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdGRlY3JlbWVudEhvdXJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdGNoZWNrRGF0ZSgnc3VidHJhY3QnLCAnaG91cnMnLCAxKTtcclxuICAgICAgICBcdH0sXHJcblxyXG4gICAgICAgIFx0ZGVjcmVtZW50TWludXRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHRjaGVja0RhdGUoJ3N1YnRyYWN0JywgJ21pbnV0ZXMnLCBwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZyk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdGRlY3JlbWVudFNlY29uZHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdFx0Y2hlY2tEYXRlKCdzdWJ0cmFjdCcsICdzZWNvbmRzJywgMSk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdHRvZ2dsZVBlcmlvZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0XHR2YXIgaG91ciA9IHBpY2tlci5kYXRlLmhvdXJzKCk7XHJcbiAgICAgICAgXHRcdGlmIChob3VyID49IDEyKSB7XHJcbiAgICAgICAgXHRcdFx0aG91ciAtPSAxMjtcclxuICAgICAgICBcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRob3VyICs9IDEyO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHBpY2tlci5kYXRlLmhvdXJzKGhvdXIpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRzaG93UGlja2VyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgPiBkaXY6bm90KC50aW1lcGlja2VyLXBpY2tlciknKS5oaWRlKCk7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItcGlja2VyJykuc2hvdygpO1xyXG4gICAgICAgIFx0fSxcclxuXHJcbiAgICAgICAgXHRzaG93SG91cnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5maW5kKCcudGltZXBpY2tlciAudGltZXBpY2tlci1waWNrZXInKS5oaWRlKCk7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItaG91cnMnKS5zaG93KCk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdHNob3dNaW51dGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItcGlja2VyJykuaGlkZSgpO1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLW1pbnV0ZXMnKS5zaG93KCk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdHNob3dTZWNvbmRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQuZmluZCgnLnRpbWVwaWNrZXIgLnRpbWVwaWNrZXItcGlja2VyJykuaGlkZSgpO1xyXG4gICAgICAgIFx0XHRwaWNrZXIud2lkZ2V0LmZpbmQoJy50aW1lcGlja2VyIC50aW1lcGlja2VyLXNlY29uZHMnKS5zaG93KCk7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdHNlbGVjdEhvdXI6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRcdHZhciBob3VyID0gcGFyc2VJbnQoJChlLnRhcmdldCkudGV4dCgpLCAxMCk7XHJcbiAgICAgICAgXHRcdGlmICghcGlja2VyLnVzZTI0aG91cnMpIHtcclxuICAgICAgICBcdFx0XHRpZiAocGlja2VyLmRhdGUuaG91cnMoKSA+PSAxMikge1xyXG4gICAgICAgIFx0XHRcdFx0aWYgKGhvdXIgIT09IDEyKSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdGhvdXIgKz0gMTI7XHJcbiAgICAgICAgXHRcdFx0XHR9XHJcbiAgICAgICAgXHRcdFx0fSBlbHNlIHtcclxuICAgICAgICBcdFx0XHRcdGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgIFx0XHRcdFx0XHRob3VyID0gMDtcclxuICAgICAgICBcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0cGlja2VyLmRhdGUuaG91cnMoaG91cik7XHJcbiAgICAgICAgXHRcdGFjdGlvbnMuc2hvd1BpY2tlci5jYWxsKHBpY2tlcik7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdHNlbGVjdE1pbnV0ZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmRhdGUubWludXRlcyhwYXJzZUludCgkKGUudGFyZ2V0KS50ZXh0KCksIDEwKSk7XHJcbiAgICAgICAgXHRcdGFjdGlvbnMuc2hvd1BpY2tlci5jYWxsKHBpY2tlcik7XHJcbiAgICAgICAgXHR9LFxyXG5cclxuICAgICAgICBcdHNlbGVjdFNlY29uZDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmRhdGUuc2Vjb25kcyhwYXJzZUludCgkKGUudGFyZ2V0KS50ZXh0KCksIDEwKSk7XHJcbiAgICAgICAgXHRcdGFjdGlvbnMuc2hvd1BpY2tlci5jYWxsKHBpY2tlcik7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZG9BY3Rpb24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIFx0dmFyIG9sZERhdGUgPSBtb21lbnQocGlja2VyLmRhdGUpLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2FjdGlvbicpLFxyXG4gICAgICAgICAgICAgICAgcnYgPSBhY3Rpb25zW2FjdGlvbl0uYXBwbHkocGlja2VyLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIFx0c3RvcEV2ZW50KGUpO1xyXG4gICAgICAgIFx0aWYgKCFwaWNrZXIuZGF0ZSkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIuZGF0ZSA9IG1vbWVudCh7IHk6IDE5NzAgfSk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRzZXQoKTtcclxuICAgICAgICBcdGZpbGxUaW1lKCk7XHJcbiAgICAgICAgXHRub3RpZnlDaGFuZ2Uob2xkRGF0ZSwgZS50eXBlKTtcclxuICAgICAgICBcdHJldHVybiBydjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdG9wRXZlbnQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBcdGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBrZXlkb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7IC8vIGFsbG93IGVzY2FwZSB0byBoaWRlIHBpY2tlclxyXG4gICAgICAgIFx0XHRwaWNrZXIuaGlkZSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgXHRtb21lbnQubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgICAgICBcdHZhciBpbnB1dCA9ICQoZS50YXJnZXQpLCBvbGREYXRlID0gbW9tZW50KHBpY2tlci5kYXRlKSwgbmV3RGF0ZSA9IG1vbWVudChpbnB1dC52YWwoKSwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KTtcclxuICAgICAgICBcdGlmIChuZXdEYXRlLmlzVmFsaWQoKSAmJiAhaXNJbkRpc2FibGVEYXRlcyhuZXdEYXRlKSAmJiBpc0luRW5hYmxlRGF0ZXMobmV3RGF0ZSkpIHtcclxuICAgICAgICBcdFx0dXBkYXRlKCk7XHJcbiAgICAgICAgXHRcdHBpY2tlci5zZXRWYWx1ZShuZXdEYXRlKTtcclxuICAgICAgICBcdFx0bm90aWZ5Q2hhbmdlKG9sZERhdGUsIGUudHlwZSk7XHJcbiAgICAgICAgXHRcdHNldCgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0ZWxzZSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci52aWV3RGF0ZSA9IG9sZERhdGU7XHJcbiAgICAgICAgXHRcdHBpY2tlci51bnNldCA9IHRydWU7XHJcbiAgICAgICAgXHRcdG5vdGlmeUNoYW5nZShvbGREYXRlLCBlLnR5cGUpO1xyXG4gICAgICAgIFx0XHRub3RpZnlFcnJvcihuZXdEYXRlKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaG93TW9kZSA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgICAgICBcdGlmIChkaXIpIHtcclxuICAgICAgICBcdFx0cGlja2VyLnZpZXdNb2RlID0gTWF0aC5tYXgocGlja2VyLm1pblZpZXdNb2RlLCBNYXRoLm1pbigyLCBwaWNrZXIudmlld01vZGUgKyBkaXIpKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci53aWRnZXQuZmluZCgnLmRhdGVwaWNrZXIgPiBkaXYnKS5oaWRlKCkuZmlsdGVyKCcuZGF0ZXBpY2tlci0nICsgZHBHbG9iYWwubW9kZXNbcGlja2VyLnZpZXdNb2RlXS5jbHNOYW1lKS5zaG93KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXR0YWNoRGF0ZVBpY2tlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBcdHZhciAkdGhpcywgJHBhcmVudCwgZXhwYW5kZWQsIGNsb3NlZCwgY29sbGFwc2VEYXRhO1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5vbignY2xpY2snLCAnLmRhdGVwaWNrZXIgKicsICQucHJveHkoY2xpY2ssIHRoaXMpKTsgLy8gdGhpcyBoYW5kbGVzIGRhdGUgcGlja2VyIGNsaWNrc1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5vbignY2xpY2snLCAnW2RhdGEtYWN0aW9uXScsICQucHJveHkoZG9BY3Rpb24sIHRoaXMpKTsgLy8gdGhpcyBoYW5kbGVzIHRpbWUgcGlja2VyIGNsaWNrc1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5vbignbW91c2Vkb3duJywgJC5wcm94eShzdG9wRXZlbnQsIHRoaXMpKTtcclxuICAgICAgICBcdHBpY2tlci5lbGVtZW50Lm9uKCdrZXlkb3duJywgJC5wcm94eShrZXlkb3duLCB0aGlzKSk7XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMucGlja0RhdGUgJiYgcGlja2VyLm9wdGlvbnMucGlja1RpbWUpIHtcclxuICAgICAgICBcdFx0cGlja2VyLndpZGdldC5vbignY2xpY2sudG9nZ2xlUGlja2VyJywgJy5hY2NvcmRpb24tdG9nZ2xlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIFx0XHRcdCR0aGlzID0gJCh0aGlzKTtcclxuICAgICAgICBcdFx0XHQkcGFyZW50ID0gJHRoaXMuY2xvc2VzdCgndWwnKTtcclxuICAgICAgICBcdFx0XHRleHBhbmRlZCA9ICRwYXJlbnQuZmluZCgnLmluJyk7XHJcbiAgICAgICAgXHRcdFx0Y2xvc2VkID0gJHBhcmVudC5maW5kKCcuY29sbGFwc2U6bm90KC5pbiknKTtcclxuXHJcbiAgICAgICAgXHRcdFx0aWYgKGV4cGFuZGVkICYmIGV4cGFuZGVkLmxlbmd0aCkge1xyXG4gICAgICAgIFx0XHRcdFx0Y29sbGFwc2VEYXRhID0gZXhwYW5kZWQuZGF0YSgnY29sbGFwc2UnKTtcclxuICAgICAgICBcdFx0XHRcdGlmIChjb2xsYXBzZURhdGEgJiYgY29sbGFwc2VEYXRhLnRyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICBcdFx0XHRcdFx0cmV0dXJuO1xyXG4gICAgICAgIFx0XHRcdFx0fVxyXG4gICAgICAgIFx0XHRcdFx0ZXhwYW5kZWQuY29sbGFwc2UoJ2hpZGUnKTtcclxuICAgICAgICBcdFx0XHRcdGNsb3NlZC5jb2xsYXBzZSgnc2hvdycpO1xyXG4gICAgICAgIFx0XHRcdFx0JHRoaXMuZmluZCgnc3BhbicpLnRvZ2dsZUNsYXNzKHBpY2tlci5vcHRpb25zLmljb25zLnRpbWUgKyAnICcgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kYXRlKTtcclxuICAgICAgICBcdFx0XHRcdGlmIChwaWNrZXIuY29tcG9uZW50KSB7XHJcbiAgICAgICAgXHRcdFx0XHRcdHBpY2tlci5jb21wb25lbnQuZmluZCgnc3BhbicpLnRvZ2dsZUNsYXNzKHBpY2tlci5vcHRpb25zLmljb25zLnRpbWUgKyAnICcgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kYXRlKTtcclxuICAgICAgICBcdFx0XHRcdH1cclxuICAgICAgICBcdFx0XHR9XHJcbiAgICAgICAgXHRcdH0pO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKHBpY2tlci5pc0lucHV0KSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5lbGVtZW50Lm9uKHtcclxuICAgICAgICBcdFx0XHQnY2xpY2snOiAkLnByb3h5KHBpY2tlci5zaG93LCB0aGlzKSxcclxuICAgICAgICBcdFx0XHQnZm9jdXMnOiAkLnByb3h5KHBpY2tlci5zaG93LCB0aGlzKSxcclxuICAgICAgICBcdFx0XHQnY2hhbmdlJzogJC5wcm94eShjaGFuZ2UsIHRoaXMpLFxyXG4gICAgICAgIFx0XHRcdCdibHVyJzogJC5wcm94eShwaWNrZXIuaGlkZSwgdGhpcylcclxuICAgICAgICBcdFx0fSk7XHJcbiAgICAgICAgXHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRwaWNrZXIuZWxlbWVudC5vbih7XHJcbiAgICAgICAgXHRcdFx0J2NoYW5nZSc6ICQucHJveHkoY2hhbmdlLCB0aGlzKVxyXG4gICAgICAgIFx0XHR9LCAnaW5wdXQnKTtcclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5jb21wb25lbnQpIHtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuY29tcG9uZW50Lm9uKCdjbGljaycsICQucHJveHkocGlja2VyLnNob3csIHRoaXMpKTtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuY29tcG9uZW50Lm9uKCdtb3VzZWRvd24nLCAkLnByb3h5KHN0b3BFdmVudCwgdGhpcykpO1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdHBpY2tlci5lbGVtZW50Lm9uKCdjbGljaycsICQucHJveHkocGlja2VyLnNob3csIHRoaXMpKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5vbignY2xpY2sudG9nZ2xlUGlja2VyJywgJyN0b2RheS1idXR0b24nLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIFx0XHRpZiAocGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmcgIT09IDEpIHtcclxuICAgICAgICBcdFx0XHR2YXIgbURhdGUgPSBtb21lbnQoKSxcclxuXHRcdFx0XHRcdFx0ckludGVydmFsID0gcGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmc7XHJcbiAgICAgICAgXHRcdFx0bURhdGUubWludXRlcygoTWF0aC5yb3VuZChtRGF0ZS5taW51dGVzKCkgLyBySW50ZXJ2YWwpICogckludGVydmFsKSAlIDYwKS5zZWNvbmRzKDApO1xyXG4gICAgICAgIFx0XHRcdHBpY2tlci5zZXRWYWx1ZShtRGF0ZS5mb3JtYXQocGlja2VyLmZvcm1hdCkpO1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdHBpY2tlci5zZXRWYWx1ZShtb21lbnQoKS5mb3JtYXQocGlja2VyLmZvcm1hdCkpO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdG5vdGlmeUNoYW5nZSgnJywgZS50eXBlKTtcclxuICAgICAgICBcdFx0c2V0KCk7XHJcbiAgICAgICAgXHR9KTtcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQub24oJ2NsaWNrLnRvZ2dsZVBpY2tlcicsICcjY2xlYXItYnV0dG9uJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdFx0cGlja2VyLnNldFZhbHVlKG51bGwpO1xyXG4gICAgICAgIFx0XHRub3RpZnlDaGFuZ2UoJycsIGUudHlwZSk7XHJcbiAgICAgICAgXHR9KTtcclxuICAgICAgICBcdHBpY2tlci53aWRnZXQub24oJ2NsaWNrLnRvZ2dsZVBpY2tlcicsICcjY2xvc2UtYnV0dG9uJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmhpZGUoKTtcclxuICAgICAgICBcdH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGF0dGFjaERhdGVQaWNrZXJHbG9iYWxFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHQkKHdpbmRvdykub24oXHJcbiAgICAgICAgICAgICAgICAncmVzaXplLmRhdGV0aW1lcGlja2VyJyArIHBpY2tlci5pZCwgJC5wcm94eShwbGFjZSwgdGhpcykpO1xyXG4gICAgICAgIFx0aWYgKCFwaWNrZXIuaXNJbnB1dCkge1xyXG4gICAgICAgIFx0XHQkKGRvY3VtZW50KS5vbihcclxuICAgICAgICAgICAgICAgICAgICAnbW91c2Vkb3duLmRhdGV0aW1lcGlja2VyJyArIHBpY2tlci5pZCwgJC5wcm94eShwaWNrZXIuaGlkZSwgdGhpcykpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRldGFjaERhdGVQaWNrZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0Lm9mZignY2xpY2snLCAnLmRhdGVwaWNrZXIgKicsIHBpY2tlci5jbGljayk7XHJcbiAgICAgICAgXHRwaWNrZXIud2lkZ2V0Lm9mZignY2xpY2snLCAnW2RhdGEtYWN0aW9uXScpO1xyXG4gICAgICAgIFx0cGlja2VyLndpZGdldC5vZmYoJ21vdXNlZG93bicsIHBpY2tlci5zdG9wRXZlbnQpO1xyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLnBpY2tEYXRlICYmIHBpY2tlci5vcHRpb25zLnBpY2tUaW1lKSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci53aWRnZXQub2ZmKCdjbGljay50b2dnbGVQaWNrZXInKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChwaWNrZXIuaXNJbnB1dCkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIuZWxlbWVudC5vZmYoe1xyXG4gICAgICAgIFx0XHRcdCdmb2N1cyc6IHBpY2tlci5zaG93LFxyXG4gICAgICAgIFx0XHRcdCdjaGFuZ2UnOiBjaGFuZ2UsXHJcbiAgICAgICAgXHRcdFx0J2NsaWNrJzogcGlja2VyLnNob3csXHJcbiAgICAgICAgXHRcdFx0J2JsdXInOiBwaWNrZXIuaGlkZVxyXG4gICAgICAgIFx0XHR9KTtcclxuICAgICAgICBcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdHBpY2tlci5lbGVtZW50Lm9mZih7XHJcbiAgICAgICAgXHRcdFx0J2NoYW5nZSc6IGNoYW5nZVxyXG4gICAgICAgIFx0XHR9LCAnaW5wdXQnKTtcclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5jb21wb25lbnQpIHtcclxuICAgICAgICBcdFx0XHRwaWNrZXIuY29tcG9uZW50Lm9mZignY2xpY2snLCBwaWNrZXIuc2hvdyk7XHJcbiAgICAgICAgXHRcdFx0cGlja2VyLmNvbXBvbmVudC5vZmYoJ21vdXNlZG93bicsIHBpY2tlci5zdG9wRXZlbnQpO1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdHBpY2tlci5lbGVtZW50Lm9mZignY2xpY2snLCBwaWNrZXIuc2hvdyk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZXRhY2hEYXRlUGlja2VyR2xvYmFsRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0JCh3aW5kb3cpLm9mZigncmVzaXplLmRhdGV0aW1lcGlja2VyJyArIHBpY2tlci5pZCk7XHJcbiAgICAgICAgXHRpZiAoIXBpY2tlci5pc0lucHV0KSB7XHJcbiAgICAgICAgXHRcdCQoZG9jdW1lbnQpLm9mZignbW91c2Vkb3duLmRhdGV0aW1lcGlja2VyJyArIHBpY2tlci5pZCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNJbkZpeGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFx0aWYgKHBpY2tlci5lbGVtZW50KSB7XHJcbiAgICAgICAgXHRcdHZhciBwYXJlbnRzID0gcGlja2VyLmVsZW1lbnQucGFyZW50cygpLCBpbkZpeGVkID0gZmFsc2UsIGk7XHJcbiAgICAgICAgXHRcdGZvciAoaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgXHRcdFx0aWYgKCQocGFyZW50c1tpXSkuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XHJcbiAgICAgICAgXHRcdFx0XHRpbkZpeGVkID0gdHJ1ZTtcclxuICAgICAgICBcdFx0XHRcdGJyZWFrO1xyXG4gICAgICAgIFx0XHRcdH1cclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRyZXR1cm4gaW5GaXhlZDtcclxuICAgICAgICBcdH0gZWxzZSB7XHJcbiAgICAgICAgXHRcdHJldHVybiBmYWxzZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHRtb21lbnQubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgICAgICBcdHZhciBmb3JtYXR0ZWQgPSAnJztcclxuICAgICAgICBcdGlmICghcGlja2VyLnVuc2V0KSB7XHJcbiAgICAgICAgXHRcdGZvcm1hdHRlZCA9IG1vbWVudChwaWNrZXIuZGF0ZSkuZm9ybWF0KHBpY2tlci5mb3JtYXQpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0Z2V0UGlja2VySW5wdXQoKS52YWwoZm9ybWF0dGVkKTtcclxuICAgICAgICBcdHBpY2tlci5lbGVtZW50LmRhdGEoJ2RhdGUnLCBmb3JtYXR0ZWQpO1xyXG4gICAgICAgIFx0aWYgKCFwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xyXG4gICAgICAgIFx0XHRwaWNrZXIuaGlkZSgpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNoZWNrRGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHVuaXQsIGFtb3VudCkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHR2YXIgbmV3RGF0ZTtcclxuICAgICAgICBcdGlmIChkaXJlY3Rpb24gPT09ICdhZGQnKSB7XHJcbiAgICAgICAgXHRcdG5ld0RhdGUgPSBtb21lbnQocGlja2VyLmRhdGUpO1xyXG4gICAgICAgIFx0XHRpZiAobmV3RGF0ZS5ob3VycygpID09PSAyMykge1xyXG4gICAgICAgIFx0XHRcdG5ld0RhdGUuYWRkKGFtb3VudCwgdW5pdCk7XHJcbiAgICAgICAgXHRcdH1cclxuICAgICAgICBcdFx0bmV3RGF0ZS5hZGQoYW1vdW50LCB1bml0KTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGVsc2Uge1xyXG4gICAgICAgIFx0XHRuZXdEYXRlID0gbW9tZW50KHBpY2tlci5kYXRlKS5zdWJ0cmFjdChhbW91bnQsIHVuaXQpO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGlzSW5EaXNhYmxlRGF0ZXMobW9tZW50KG5ld0RhdGUuc3VidHJhY3QoYW1vdW50LCB1bml0KSkpIHx8IGlzSW5EaXNhYmxlRGF0ZXMobmV3RGF0ZSkpIHtcclxuICAgICAgICBcdFx0bm90aWZ5RXJyb3IobmV3RGF0ZS5mb3JtYXQocGlja2VyLmZvcm1hdCkpO1xyXG4gICAgICAgIFx0XHRyZXR1cm47XHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0aWYgKGRpcmVjdGlvbiA9PT0gJ2FkZCcpIHtcclxuICAgICAgICBcdFx0cGlja2VyLmRhdGUuYWRkKGFtb3VudCwgdW5pdCk7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRlbHNlIHtcclxuICAgICAgICBcdFx0cGlja2VyLmRhdGUuc3VidHJhY3QoYW1vdW50LCB1bml0KTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHBpY2tlci51bnNldCA9IGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzSW5EaXNhYmxlRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZSwgdGltZVVuaXQpIHtcclxuICAgICAgICBcdG1vbWVudC5sb2NhbGUocGlja2VyLm9wdGlvbnMubGFuZ3VhZ2UpO1xyXG4gICAgICAgIFx0dmFyIG1heERhdGUgPSBtb21lbnQocGlja2VyLm9wdGlvbnMubWF4RGF0ZSwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KSxcclxuICAgICAgICAgICAgICAgIG1pbkRhdGUgPSBtb21lbnQocGlja2VyLm9wdGlvbnMubWluRGF0ZSwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KTtcclxuXHJcbiAgICAgICAgXHRpZiAodGltZVVuaXQpIHtcclxuICAgICAgICBcdFx0bWF4RGF0ZSA9IG1heERhdGUuZW5kT2YodGltZVVuaXQpO1xyXG4gICAgICAgIFx0XHRtaW5EYXRlID0gbWluRGF0ZS5zdGFydE9mKHRpbWVVbml0KTtcclxuICAgICAgICBcdH1cclxuXHJcbiAgICAgICAgXHRpZiAoZGF0ZS5pc0FmdGVyKG1heERhdGUpIHx8IGRhdGUuaXNCZWZvcmUobWluRGF0ZSkpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIHRydWU7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMuZGlzYWJsZWREYXRlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cmV0dXJuIHBpY2tlci5vcHRpb25zLmRpc2FibGVkRGF0ZXNbZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKV0gPT09IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0luRW5hYmxlRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICAgICAgXHRpZiAocGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzID09PSBmYWxzZSkge1xyXG4gICAgICAgIFx0XHRyZXR1cm4gdHJ1ZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHJldHVybiBwaWNrZXIub3B0aW9ucy5lbmFibGVkRGF0ZXNbZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKV0gPT09IHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaW5kZXhHaXZlbkRhdGVzID0gZnVuY3Rpb24gKGdpdmVuRGF0ZXNBcnJheSkge1xyXG4gICAgICAgIFx0Ly8gU3RvcmUgZ2l2ZW4gZW5hYmxlZERhdGVzIGFuZCBkaXNhYmxlZERhdGVzIGFzIGtleXMuXHJcbiAgICAgICAgXHQvLyBUaGlzIHdheSB3ZSBjYW4gY2hlY2sgdGhlaXIgZXhpc3RlbmNlIGluIE8oMSkgdGltZSBpbnN0ZWFkIG9mIGxvb3BpbmcgdGhyb3VnaCB3aG9sZSBhcnJheS5cclxuICAgICAgICBcdC8vIChmb3IgZXhhbXBsZTogcGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzWycyMDE0LTAyLTI3J10gPT09IHRydWUpXHJcbiAgICAgICAgXHR2YXIgZ2l2ZW5EYXRlc0luZGV4ZWQgPSB7fSwgZ2l2ZW5EYXRlc0NvdW50ID0gMCwgaTtcclxuICAgICAgICBcdGZvciAoaSA9IDA7IGkgPCBnaXZlbkRhdGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBcdFx0aWYgKG1vbWVudC5pc01vbWVudChnaXZlbkRhdGVzQXJyYXlbaV0pIHx8IGdpdmVuRGF0ZXNBcnJheVtpXSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICBcdFx0XHRkRGF0ZSA9IG1vbWVudChnaXZlbkRhdGVzQXJyYXlbaV0pO1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdGREYXRlID0gbW9tZW50KGdpdmVuRGF0ZXNBcnJheVtpXSwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRpZiAoZERhdGUuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgXHRcdFx0Z2l2ZW5EYXRlc0luZGV4ZWRbZERhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyldID0gdHJ1ZTtcclxuICAgICAgICBcdFx0XHRnaXZlbkRhdGVzQ291bnQrKztcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0aWYgKGdpdmVuRGF0ZXNDb3VudCA+IDApIHtcclxuICAgICAgICBcdFx0cmV0dXJuIGdpdmVuRGF0ZXNJbmRleGVkO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgXHRzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoKTtcclxuICAgICAgICBcdGlmIChzdHJpbmcubGVuZ3RoID49IDIpIHtcclxuICAgICAgICBcdFx0cmV0dXJuIHN0cmluZztcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHJldHVybiAnMCcgKyBzdHJpbmc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgXHR2YXJcclxuICAgICAgICAgICAgICAgIGhlYWRUZW1wbGF0ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dGhlYWQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJwcmV2XCI+JmxzYXF1bzs8L3RoPjx0aCBjb2xzcGFuPVwiJyArIChwaWNrZXIub3B0aW9ucy5jYWxlbmRhcldlZWtzID8gJzYnIDogJzUnKSArICdcIiBjbGFzcz1cInBpY2tlci1zd2l0Y2hcIj48L3RoPjx0aCBjbGFzcz1cIm5leHRcIj4mcnNhcXVvOzwvdGg+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyxcclxuICAgICAgICAgICAgICAgIGNvbnRUZW1wbGF0ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dGJvZHk+PHRyPjx0ZCBjb2xzcGFuPVwiJyArIChwaWNrZXIub3B0aW9ucy5jYWxlbmRhcldlZWtzID8gJzgnIDogJzcnKSArICdcIj48L3RkPjwvdHI+PC90Ym9keT4nLFxyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItZGF5c1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nICsgaGVhZFRlbXBsYXRlICsgJzx0Ym9keT48L3Rib2R5PjwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItbW9udGhzXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicgKyBoZWFkVGVtcGxhdGUgKyBjb250VGVtcGxhdGUgKyAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci15ZWFyc1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nICsgaGVhZFRlbXBsYXRlICsgY29udFRlbXBsYXRlICsgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyxcclxuICAgICAgICAgICAgICAgIHJldCA9ICcnO1xyXG4gICAgICAgIFx0aWYgKHBpY2tlci5vcHRpb25zLnBpY2tEYXRlICYmIHBpY2tlci5vcHRpb25zLnBpY2tUaW1lKSB7XHJcbiAgICAgICAgXHRcdHJldCA9ICc8ZGl2IGNsYXNzPVwiYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCcgKyAocGlja2VyLm9wdGlvbnMuc2lkZUJ5U2lkZSA/ICcgdGltZXBpY2tlci1zYnMnIDogJycpICsgKHBpY2tlci51c2UyNGhvdXJzID8gJyB1c2V0d2VudHlmb3VyJyA6ICcnKSArICcgZHJvcGRvd24tbWVudVwiIHN0eWxlPVwiei1pbmRleDo5OTk5ICFpbXBvcnRhbnQ7XCI+JztcclxuICAgICAgICBcdFx0aWYgKHBpY2tlci5vcHRpb25zLnNpZGVCeVNpZGUpIHtcclxuICAgICAgICBcdFx0XHRyZXQgKz0gJzxkaXYgY2xhc3M9XCJyb3dcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImNvbC1zbS02IGRhdGVwaWNrZXJcIj4nICsgdGVtcGxhdGUgKyAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjb2wtc20tNiB0aW1lcGlja2VyXCI+JyArIHRwR2xvYmFsLmdldFRlbXBsYXRlKCkgKyAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHRcdHJldCArPSAnPHVsIGNsYXNzPVwibGlzdC11bnN0eWxlZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGxpJyArIChwaWNrZXIub3B0aW9ucy5jb2xsYXBzZSA/ICcgY2xhc3M9XCJjb2xsYXBzZSBpblwiJyA6ICcnKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXJcIj4nICsgdGVtcGxhdGUgKyAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2xpPicgK1xyXG5cdFx0XHRcdFx0XHQnPGxpPicgK1xyXG5cdFx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJidG4tZ3JvdXBcIiBzdHlsZT1cImZsb2F0OmxlZnQ7IG1hcmdpbi1sZWZ0OjRweFwiPicgK1xyXG5cdFx0XHRcdFx0XHQnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4taW5mb1wiXCIgaWQ9XCJ0b2RheS1idXR0b25cIj4gTm93IDwvYnV0dG9uPicgK1xyXG5cdFx0XHRcdFx0XHQnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tZGFuZ2VyXCIgaWQ9XCJjbGVhci1idXR0b25cIj4gQ2xlYXIgPC9idXR0b24+JyArXHJcblx0XHRcdFx0XHRcdCc8L3NwYW4+JyArXHJcblx0XHRcdFx0XHRcdCc8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zdWNjZXNzXCIgaWQ9XCJjbG9zZS1idXR0b25cIiBzdHlsZT1cImZsb2F0OnJpZ2h0OyBtYXJnaW4tcmlnaHQ6NHB4O1wiPkRvbmU8L2J1dHRvbj4nICtcclxuXHRcdFx0XHRcdFx0JzxkaXYgc3R5bGU9XCJjbGVhcjpib3RoOyBwYWRkaW5nLWJvdHRvbTo1cHg7XCI+PC9kaXY+JyArXHJcblx0XHRcdFx0XHRcdCc8L2xpPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGxpJyArIChwaWNrZXIub3B0aW9ucy5jb2xsYXBzZSA/ICcgY2xhc3M9XCJjb2xsYXBzZVwiJyA6ICcnKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXJcIj4nICsgdHBHbG9iYWwuZ2V0VGVtcGxhdGUoKSArICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvbGk+JyArXHJcbiAgICAgICAgICAgICAgICAgICAnPC91bD4nO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdHJldCArPSAnPC9kaXY+JztcclxuICAgICAgICBcdFx0cmV0dXJuIHJldDtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGlmIChwaWNrZXIub3B0aW9ucy5waWNrVGltZSkge1xyXG4gICAgICAgIFx0XHRyZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCBkcm9wZG93bi1tZW51XCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidGltZXBpY2tlclwiPicgKyB0cEdsb2JhbC5nZXRUZW1wbGF0ZSgpICsgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgIFx0fVxyXG4gICAgICAgIFx0cmV0dXJuIChcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLXdpZGdldCBkcm9wZG93bi1tZW51XCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyXCI+JyArIHRlbXBsYXRlICsgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PidcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkcEdsb2JhbCA9IHtcclxuICAgICAgICBcdG1vZGVzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcdGNsc05hbWU6ICdkYXlzJyxcclxuICAgICAgICAgICAgICAgIFx0bmF2Rm5jOiAnbW9udGgnLFxyXG4gICAgICAgICAgICAgICAgXHRuYXZTdGVwOiAxXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXHRjbHNOYW1lOiAnbW9udGhzJyxcclxuICAgICAgICAgICAgICAgIFx0bmF2Rm5jOiAneWVhcicsXHJcbiAgICAgICAgICAgICAgICBcdG5hdlN0ZXA6IDFcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcdGNsc05hbWU6ICd5ZWFycycsXHJcbiAgICAgICAgICAgICAgICBcdG5hdkZuYzogJ3llYXInLFxyXG4gICAgICAgICAgICAgICAgXHRuYXZTdGVwOiAxMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIFx0XVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRwR2xvYmFsID0ge1xyXG4gICAgICAgIFx0aG91clRlbXBsYXRlOiAnPHNwYW4gZGF0YS1hY3Rpb249XCJzaG93SG91cnNcIiAgIGRhdGEtdGltZS1jb21wb25lbnQ9XCJob3Vyc1wiICAgY2xhc3M9XCJ0aW1lcGlja2VyLWhvdXJcIj48L3NwYW4+JyxcclxuICAgICAgICBcdG1pbnV0ZVRlbXBsYXRlOiAnPHNwYW4gZGF0YS1hY3Rpb249XCJzaG93TWludXRlc1wiIGRhdGEtdGltZS1jb21wb25lbnQ9XCJtaW51dGVzXCIgY2xhc3M9XCJ0aW1lcGlja2VyLW1pbnV0ZVwiPjwvc3Bhbj4nLFxyXG4gICAgICAgIFx0c2Vjb25kVGVtcGxhdGU6ICc8c3BhbiBkYXRhLWFjdGlvbj1cInNob3dTZWNvbmRzXCIgIGRhdGEtdGltZS1jb21wb25lbnQ9XCJzZWNvbmRzXCIgY2xhc3M9XCJ0aW1lcGlja2VyLXNlY29uZFwiPjwvc3Bhbj4nXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBcdHRwR2xvYmFsLmdldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXHRcdHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItcGlja2VyXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZD48YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCIgZGF0YS1hY3Rpb249XCJpbmNyZW1lbnRIb3Vyc1wiPjxzcGFuIGNsYXNzPVwiJyArIHBpY2tlci5vcHRpb25zLmljb25zLnVwICsgJ1wiPjwvc3Bhbj48L2E+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgKHBpY2tlci5vcHRpb25zLnVzZU1pbnV0ZXMgPyAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiIGRhdGEtYWN0aW9uPVwiaW5jcmVtZW50TWludXRlc1wiPjxzcGFuIGNsYXNzPVwiJyArIHBpY2tlci5vcHRpb25zLmljb25zLnVwICsgJ1wiPjwvc3Bhbj48L2E+JyA6ICcnKSArICc8L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBpY2tlci5vcHRpb25zLnVzZVNlY29uZHMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPjx0ZD48YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuXCIgZGF0YS1hY3Rpb249XCJpbmNyZW1lbnRTZWNvbmRzXCI+PHNwYW4gY2xhc3M9XCInICsgcGlja2VyLm9wdGlvbnMuaWNvbnMudXAgKyAnXCI+PC9zcGFuPjwvYT48L3RkPicgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBpY2tlci51c2UyNGhvdXJzID8gJycgOiAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nKSArICc8dGQ+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkPicgKyB0cEdsb2JhbC5ob3VyVGVtcGxhdGUgKyAnPC90ZD4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+OjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkPicgKyAocGlja2VyLm9wdGlvbnMudXNlTWludXRlcyA/IHRwR2xvYmFsLm1pbnV0ZVRlbXBsYXRlIDogJzxzcGFuIGNsYXNzPVwidGltZXBpY2tlci1taW51dGVcIj4wMDwvc3Bhbj4nKSArICc8L3RkPiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwaWNrZXIub3B0aW9ucy51c2VTZWNvbmRzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+OjwvdGQ+PHRkPicgKyB0cEdsb2JhbC5zZWNvbmRUZW1wbGF0ZSArICc8L3RkPicgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBpY2tlci51c2UyNGhvdXJzID8gJycgOiAnPHRkIGNsYXNzPVwic2VwYXJhdG9yXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQ+PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiBkYXRhLWFjdGlvbj1cInRvZ2dsZVBlcmlvZFwiPjwvYnV0dG9uPjwvdGQ+JykgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQ+PGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiIGRhdGEtYWN0aW9uPVwiZGVjcmVtZW50SG91cnNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kb3duICsgJ1wiPjwvc3Bhbj48L2E+PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJzZXBhcmF0b3JcIj48L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZD4nICsgKHBpY2tlci5vcHRpb25zLnVzZU1pbnV0ZXMgPyAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0blwiIGRhdGEtYWN0aW9uPVwiZGVjcmVtZW50TWludXRlc1wiPjxzcGFuIGNsYXNzPVwiJyArIHBpY2tlci5vcHRpb25zLmljb25zLmRvd24gKyAnXCI+PC9zcGFuPjwvYT4nIDogJycpICsgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+PHRkPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG5cIiBkYXRhLWFjdGlvbj1cImRlY3JlbWVudFNlY29uZHNcIj48c3BhbiBjbGFzcz1cIicgKyBwaWNrZXIub3B0aW9ucy5pY29ucy5kb3duICsgJ1wiPjwvc3Bhbj48L2E+PC90ZD4nIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwaWNrZXIudXNlMjRob3VycyA/ICcnIDogJzx0ZCBjbGFzcz1cInNlcGFyYXRvclwiPjwvdGQ+JykgKyAnPHRkPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLWhvdXJzXCIgZGF0YS1hY3Rpb249XCJzZWxlY3RIb3VyXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPjwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRpbWVwaWNrZXItbWludXRlc1wiIGRhdGEtYWN0aW9uPVwic2VsZWN0TWludXRlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPjwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAocGlja2VyLm9wdGlvbnMudXNlU2Vjb25kcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0aW1lcGlja2VyLXNlY29uZHNcIiBkYXRhLWFjdGlvbj1cInNlbGVjdFNlY29uZFwiPjx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPjwvdGFibGU+PC9kaXY+JyA6ICcnKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0cGlja2VyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBcdFx0ZGV0YWNoRGF0ZVBpY2tlckV2ZW50cygpO1xyXG4gICAgXHRcdGRldGFjaERhdGVQaWNrZXJHbG9iYWxFdmVudHMoKTtcclxuICAgIFx0XHRwaWNrZXIud2lkZ2V0LnJlbW92ZSgpO1xyXG4gICAgXHRcdHBpY2tlci5lbGVtZW50LnJlbW92ZURhdGEoJ0RhdGVUaW1lUGlja2VyJyk7XHJcbiAgICBcdFx0aWYgKHBpY2tlci5jb21wb25lbnQpIHtcclxuICAgIFx0XHRcdHBpY2tlci5jb21wb25lbnQucmVtb3ZlRGF0YSgnRGF0ZVRpbWVQaWNrZXInKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuc2hvdyA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICBcdFx0aWYgKGdldFBpY2tlcklucHV0KCkucHJvcCgnZGlzYWJsZWQnKSkge1xyXG4gICAgXHRcdFx0cmV0dXJuO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRpZiAocGlja2VyLm9wdGlvbnMudXNlQ3VycmVudCkge1xyXG4gICAgXHRcdFx0aWYgKGdldFBpY2tlcklucHV0KCkudmFsKCkgPT09ICcnKSB7XHJcbiAgICBcdFx0XHRcdGlmIChwaWNrZXIub3B0aW9ucy5maWxsRW1wdHkpIHtcclxuICAgIFx0XHRcdFx0XHRpZiAocGlja2VyLm9wdGlvbnMubWludXRlU3RlcHBpbmcgIT09IDEpIHtcclxuICAgIFx0XHRcdFx0XHRcdHZhciBtRGF0ZSA9IG1vbWVudCgpLFxyXG5cdFx0XHRcdCAgICAgICAgICAgICAgICBySW50ZXJ2YWwgPSBwaWNrZXIub3B0aW9ucy5taW51dGVTdGVwcGluZztcclxuICAgIFx0XHRcdFx0XHRcdG1EYXRlLm1pbnV0ZXMoKE1hdGgucm91bmQobURhdGUubWludXRlcygpIC8gckludGVydmFsKSAqIHJJbnRlcnZhbCkgJSA2MCkuc2Vjb25kcygwKTtcclxuICAgIFx0XHRcdFx0XHRcdHBpY2tlci5zZXRWYWx1ZShtRGF0ZS5mb3JtYXQocGlja2VyLmZvcm1hdCkpO1xyXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XHJcbiAgICBcdFx0XHRcdFx0XHRwaWNrZXIuc2V0VmFsdWUobW9tZW50KCkuZm9ybWF0KHBpY2tlci5mb3JtYXQpKTtcclxuICAgIFx0XHRcdFx0XHR9XHJcbiAgICBcdFx0XHRcdFx0bm90aWZ5Q2hhbmdlKCcnLCBlLnR5cGUpO1xyXG4gICAgXHRcdFx0XHR9XHJcbiAgICBcdFx0XHR9IGVsc2VcclxuICAgIFx0XHRcdFx0cGlja2VyLnNldFZhbHVlKGdldFBpY2tlcklucHV0KCkudmFsKCkpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHQvLyBpZiB0aGlzIGlzIGEgY2xpY2sgZXZlbnQgb24gdGhlIGlucHV0IGZpZWxkIGFuZCBwaWNrZXIgaXMgYWxyZWFkeSBvcGVuIGRvbid0IGhpZGUgaXRcclxuICAgIFx0XHRpZiAoZSAmJiBlLnR5cGUgPT09ICdjbGljaycgJiYgcGlja2VyLmlzSW5wdXQgJiYgcGlja2VyLndpZGdldC5oYXNDbGFzcygncGlja2VyLW9wZW4nKSkge1xyXG4gICAgXHRcdFx0cmV0dXJuO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRpZiAocGlja2VyLndpZGdldC5oYXNDbGFzcygncGlja2VyLW9wZW4nKSkge1xyXG4gICAgXHRcdFx0cGlja2VyLndpZGdldC5oaWRlKCk7XHJcbiAgICBcdFx0XHRwaWNrZXIud2lkZ2V0LnJlbW92ZUNsYXNzKCdwaWNrZXItb3BlbicpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRlbHNlIHtcclxuICAgIFx0XHRcdHBpY2tlci53aWRnZXQuc2hvdygpO1xyXG4gICAgXHRcdFx0cGlja2VyLndpZGdldC5hZGRDbGFzcygncGlja2VyLW9wZW4nKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0cGlja2VyLmhlaWdodCA9IHBpY2tlci5jb21wb25lbnQgPyBwaWNrZXIuY29tcG9uZW50Lm91dGVySGVpZ2h0KCkgOiBwaWNrZXIuZWxlbWVudC5vdXRlckhlaWdodCgpO1xyXG4gICAgXHRcdHBsYWNlKCk7XHJcbiAgICBcdFx0cGlja2VyLmVsZW1lbnQudHJpZ2dlcih7XHJcbiAgICBcdFx0XHR0eXBlOiAnZHAuc2hvdycsXHJcbiAgICBcdFx0XHRkYXRlOiBtb21lbnQocGlja2VyLmRhdGUpXHJcbiAgICBcdFx0fSk7XHJcbiAgICBcdFx0YXR0YWNoRGF0ZVBpY2tlckdsb2JhbEV2ZW50cygpO1xyXG4gICAgXHRcdGlmIChlKSB7XHJcbiAgICBcdFx0XHRzdG9wRXZlbnQoZSk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0cGlja2VyLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBcdFx0dmFyIGlucHV0ID0gZ2V0UGlja2VySW5wdXQoKTtcclxuICAgIFx0XHRpZiAoaW5wdXQucHJvcCgnZGlzYWJsZWQnKSkge1xyXG4gICAgXHRcdFx0cmV0dXJuO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRpbnB1dC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xyXG4gICAgXHRcdGRldGFjaERhdGVQaWNrZXJFdmVudHMoKTtcclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBcdFx0dmFyIGlucHV0ID0gZ2V0UGlja2VySW5wdXQoKTtcclxuICAgIFx0XHRpZiAoIWlucHV0LnByb3AoJ2Rpc2FibGVkJykpIHtcclxuICAgIFx0XHRcdHJldHVybjtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aW5wdXQucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XHJcbiAgICBcdFx0YXR0YWNoRGF0ZVBpY2tlckV2ZW50cygpO1xyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0cGlja2VyLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBcdFx0Ly8gSWdub3JlIGV2ZW50IGlmIGluIHRoZSBtaWRkbGUgb2YgYSBwaWNrZXIgdHJhbnNpdGlvblxyXG4gICAgXHRcdHZhciBjb2xsYXBzZSA9IHBpY2tlci53aWRnZXQuZmluZCgnLmNvbGxhcHNlJyksIGksIGNvbGxhcHNlRGF0YTtcclxuICAgIFx0XHRmb3IgKGkgPSAwOyBpIDwgY29sbGFwc2UubGVuZ3RoOyBpKyspIHtcclxuICAgIFx0XHRcdGNvbGxhcHNlRGF0YSA9IGNvbGxhcHNlLmVxKGkpLmRhdGEoJ2NvbGxhcHNlJyk7XHJcbiAgICBcdFx0XHRpZiAoY29sbGFwc2VEYXRhICYmIGNvbGxhcHNlRGF0YS50cmFuc2l0aW9uaW5nKSB7XHJcbiAgICBcdFx0XHRcdHJldHVybjtcclxuICAgIFx0XHRcdH1cclxuICAgIFx0XHR9XHJcbiAgICBcdFx0cGlja2VyLndpZGdldC5oaWRlKCk7XHJcbiAgICBcdFx0cGlja2VyLndpZGdldC5yZW1vdmVDbGFzcygncGlja2VyLW9wZW4nKTtcclxuICAgIFx0XHRwaWNrZXIudmlld01vZGUgPSBwaWNrZXIuc3RhcnRWaWV3TW9kZTtcclxuICAgIFx0XHRzaG93TW9kZSgpO1xyXG4gICAgXHRcdHBpY2tlci5lbGVtZW50LnRyaWdnZXIoe1xyXG4gICAgXHRcdFx0dHlwZTogJ2RwLmhpZGUnLFxyXG4gICAgXHRcdFx0ZGF0ZTogbW9tZW50KHBpY2tlci5kYXRlKVxyXG4gICAgXHRcdH0pO1xyXG4gICAgXHRcdGRldGFjaERhdGVQaWNrZXJHbG9iYWxFdmVudHMoKTtcclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChuZXdEYXRlKSB7XHJcbiAgICBcdFx0bW9tZW50LmxvY2FsZShwaWNrZXIub3B0aW9ucy5sYW5ndWFnZSk7XHJcbiAgICBcdFx0aWYgKCFuZXdEYXRlKSB7XHJcbiAgICBcdFx0XHRwaWNrZXIudW5zZXQgPSB0cnVlO1xyXG4gICAgXHRcdFx0c2V0KCk7XHJcbiAgICBcdFx0fSBlbHNlIHtcclxuICAgIFx0XHRcdHBpY2tlci51bnNldCA9IGZhbHNlO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRpZiAoIW1vbWVudC5pc01vbWVudChuZXdEYXRlKSkge1xyXG4gICAgXHRcdFx0bmV3RGF0ZSA9IChuZXdEYXRlIGluc3RhbmNlb2YgRGF0ZSkgPyBtb21lbnQobmV3RGF0ZSkgOiBtb21lbnQobmV3RGF0ZSwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KTtcclxuICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgXHRcdFx0bmV3RGF0ZSA9IG5ld0RhdGUubG9jYWxlKHBpY2tlci5vcHRpb25zLmxhbmd1YWdlKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aWYgKG5ld0RhdGUuaXNWYWxpZCgpKSB7XHJcbiAgICBcdFx0XHRwaWNrZXIuZGF0ZSA9IG5ld0RhdGU7XHJcbiAgICBcdFx0XHRzZXQoKTtcclxuICAgIFx0XHRcdHBpY2tlci52aWV3RGF0ZSA9IG1vbWVudCh7IHk6IHBpY2tlci5kYXRlLnllYXIoKSwgTTogcGlja2VyLmRhdGUubW9udGgoKSB9KTtcclxuICAgIFx0XHRcdGZpbGxEYXRlKCk7XHJcbiAgICBcdFx0XHRmaWxsVGltZSgpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRlbHNlIHtcclxuICAgIFx0XHRcdG5vdGlmeUVycm9yKG5ld0RhdGUpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXHRcdGlmIChwaWNrZXIudW5zZXQpIHtcclxuICAgIFx0XHRcdHJldHVybiBudWxsO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRyZXR1cm4gbW9tZW50KHBpY2tlci5kYXRlKTtcclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5zZXREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgIFx0XHR2YXIgb2xkRGF0ZSA9IG1vbWVudChwaWNrZXIuZGF0ZSk7XHJcbiAgICBcdFx0aWYgKCFkYXRlKSB7XHJcbiAgICBcdFx0XHRwaWNrZXIuc2V0VmFsdWUobnVsbCk7XHJcbiAgICBcdFx0fSBlbHNlIHtcclxuICAgIFx0XHRcdHBpY2tlci5zZXRWYWx1ZShkYXRlKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0bm90aWZ5Q2hhbmdlKG9sZERhdGUsICdmdW5jdGlvbicpO1xyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0cGlja2VyLnNldERpc2FibGVkRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZXMpIHtcclxuICAgIFx0XHRwaWNrZXIub3B0aW9ucy5kaXNhYmxlZERhdGVzID0gaW5kZXhHaXZlbkRhdGVzKGRhdGVzKTtcclxuICAgIFx0XHRpZiAocGlja2VyLnZpZXdEYXRlKSB7XHJcbiAgICBcdFx0XHR1cGRhdGUoKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuc2V0RW5hYmxlZERhdGVzID0gZnVuY3Rpb24gKGRhdGVzKSB7XHJcbiAgICBcdFx0cGlja2VyLm9wdGlvbnMuZW5hYmxlZERhdGVzID0gaW5kZXhHaXZlbkRhdGVzKGRhdGVzKTtcclxuICAgIFx0XHRpZiAocGlja2VyLnZpZXdEYXRlKSB7XHJcbiAgICBcdFx0XHR1cGRhdGUoKTtcclxuICAgIFx0XHR9XHJcbiAgICBcdH07XHJcblxyXG4gICAgXHRwaWNrZXIuc2V0TWF4RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICBcdFx0aWYgKGRhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgXHRcdFx0cmV0dXJuO1xyXG4gICAgXHRcdH1cclxuICAgIFx0XHRpZiAobW9tZW50LmlzTW9tZW50KGRhdGUpIHx8IGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICBcdFx0XHRwaWNrZXIub3B0aW9ucy5tYXhEYXRlID0gbW9tZW50KGRhdGUpO1xyXG4gICAgXHRcdH0gZWxzZSB7XHJcbiAgICBcdFx0XHRwaWNrZXIub3B0aW9ucy5tYXhEYXRlID0gbW9tZW50KGRhdGUsIHBpY2tlci5mb3JtYXQsIHBpY2tlci5vcHRpb25zLnVzZVN0cmljdCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGlmIChwaWNrZXIudmlld0RhdGUpIHtcclxuICAgIFx0XHRcdHVwZGF0ZSgpO1xyXG4gICAgXHRcdH1cclxuICAgIFx0fTtcclxuXHJcbiAgICBcdHBpY2tlci5zZXRNaW5EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgIFx0XHRpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBcdFx0XHRyZXR1cm47XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdGlmIChtb21lbnQuaXNNb21lbnQoZGF0ZSkgfHwgZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgIFx0XHRcdHBpY2tlci5vcHRpb25zLm1pbkRhdGUgPSBtb21lbnQoZGF0ZSk7XHJcbiAgICBcdFx0fSBlbHNlIHtcclxuICAgIFx0XHRcdHBpY2tlci5vcHRpb25zLm1pbkRhdGUgPSBtb21lbnQoZGF0ZSwgcGlja2VyLmZvcm1hdCwgcGlja2VyLm9wdGlvbnMudXNlU3RyaWN0KTtcclxuICAgIFx0XHR9XHJcbiAgICBcdFx0aWYgKHBpY2tlci52aWV3RGF0ZSkge1xyXG4gICAgXHRcdFx0dXBkYXRlKCk7XHJcbiAgICBcdFx0fVxyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0aW5pdCgpO1xyXG4gICAgfTtcclxuXHJcblx0JC5mbi5kYXRldGltZXBpY2tlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCdEYXRlVGltZVBpY2tlcicpO1xyXG5cdFx0XHRpZiAoIWRhdGEpIHtcclxuXHRcdFx0XHQkdGhpcy5kYXRhKCdEYXRlVGltZVBpY2tlcicsIG5ldyBEYXRlVGltZVBpY2tlcih0aGlzLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdCQuZm4uZGF0ZXRpbWVwaWNrZXIuZGVmYXVsdHMgPSB7XHJcblx0XHRmb3JtYXQ6IGZhbHNlLFxyXG5cdFx0cGlja0RhdGU6IHRydWUsXHJcblx0XHRwaWNrVGltZTogdHJ1ZSxcclxuXHRcdHVzZU1pbnV0ZXM6IHRydWUsXHJcblx0XHR1c2VTZWNvbmRzOiBmYWxzZSxcclxuXHRcdHVzZUN1cnJlbnQ6IHRydWUsXHJcblx0XHRjYWxlbmRhcldlZWtzOiBmYWxzZSxcclxuXHRcdG1pbnV0ZVN0ZXBwaW5nOiAxLFxyXG5cdFx0bWluRGF0ZTogbW9tZW50KHsgeTogMTkwMCB9KSxcclxuXHRcdG1heERhdGU6IG1vbWVudCgpLmFkZCgxMDAsICd5JyksXHJcblx0XHRzaG93VG9kYXk6IHRydWUsXHJcblx0XHRjb2xsYXBzZTogZmFsc2UsXHJcblx0XHRsYW5ndWFnZTogbW9tZW50LmxvY2FsZSgpLFxyXG5cdFx0ZGVmYXVsdERhdGU6ICcnLFxyXG5cdFx0ZGlzYWJsZWREYXRlczogZmFsc2UsXHJcblx0XHRlbmFibGVkRGF0ZXM6IGZhbHNlLFxyXG5cdFx0aWNvbnM6IHt9LFxyXG5cdFx0dXNlU3RyaWN0OiBmYWxzZSxcclxuXHRcdGRpcmVjdGlvbjogJ2F1dG8nLFxyXG5cdFx0c2lkZUJ5U2lkZTogZmFsc2UsXHJcblx0XHRkYXlzT2ZXZWVrRGlzYWJsZWQ6IFtdLFxyXG5cdFx0d2lkZ2V0UGFyZW50OiBmYWxzZSxcclxuXHRcdGZpbGxFbXB0eTogZmFsc2VcclxuXHR9O1xyXG59KSk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWJyYXJpZXMvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fdmFsaWRhdGlvbiA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy52YWxpZGF0aW9uO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMuY29tcG9uZW50VmFsaWRhdG9yJztcclxuZXhwb3J0cy5mYWN0b3J5TmFtZSA9ICdjb21wb25lbnRWYWxpZGF0b3InO1xyXG52YXIgQ29tcG9uZW50VmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudFZhbGlkYXRvcih2YWxpZGF0aW9uU2VydmljZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSBvcHRpb25zLiRzY29wZTtcclxuICAgICAgICB0aGlzLm5nTW9kZWwgPSBvcHRpb25zLm5nTW9kZWw7XHJcbiAgICAgICAgdGhpcy5mb3JtID0gb3B0aW9ucy5mb3JtO1xyXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gdmFsaWRhdGlvblNlcnZpY2UuYnVpbGRDdXN0b21WYWxpZGF0b3IoZnVuY3Rpb24gKGVycm9yLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgIF90aGlzLmVycm9yVHlwZSA9IG5hbWUgfHwgJ2N1c3RvbVZhbGlkYXRpb24nO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF8uZWFjaChvcHRpb25zLnZhbGlkYXRvcnMsIGZ1bmN0aW9uIChjdXN0b21WYWxpZGF0b3IpIHtcclxuICAgICAgICAgICAgX3RoaXMudmFsaWRhdG9yLnJlZ2lzdGVyVmFsaWRhdGlvbkhhbmRsZXIoY3VzdG9tVmFsaWRhdG9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNldFZhbGlkYXRvcigpO1xyXG4gICAgfVxyXG4gICAgQ29tcG9uZW50VmFsaWRhdG9yLnByb3RvdHlwZS5zZXRWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy4kc2NvcGUuJHdhdGNoKHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlLmJpbmQodGhpcy52YWxpZGF0b3IpLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5lcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF90aGlzLm5nTW9kZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5uZ01vZGVsLiRzZXRWYWxpZGl0eShfdGhpcy5lcnJvclR5cGUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLm5nTW9kZWwucmxFcnJvck1lc3NhZ2UgPSBfdGhpcy5lcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChfdGhpcy5mb3JtKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZm9ybS4kc2V0VmFsaWRpdHkoX3RoaXMuZXJyb3JUeXBlLCB2YWx1ZSwgJ2dyb3VwJyk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mb3JtLnJsRXJyb3JNZXNzYWdlID0gX3RoaXMuZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKF90aGlzLnNldFZhbGlkaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VmFsaWRpdHkodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudFZhbGlkYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5Db21wb25lbnRWYWxpZGF0b3IgPSBDb21wb25lbnRWYWxpZGF0b3I7XHJcbmNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkuJGluamVjdCA9IFtfX3ZhbGlkYXRpb24uc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5KHZhbGlkYXRpb25TZXJ2aWNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudFZhbGlkYXRvcih2YWxpZGF0aW9uU2VydmljZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5ID0gY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX192YWxpZGF0aW9uLm1vZHVsZU5hbWVdKVxyXG4gICAgLmZhY3RvcnkoZXhwb3J0cy5mYWN0b3J5TmFtZSwgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBvbmVudFZhbGlkYXRvci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvY29tcG9uZW50VmFsaWRhdG9yL2NvbXBvbmVudFZhbGlkYXRvci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7ICdoYXMtd2FybmluZyc6ICFkYXRlVGltZS52YWxpZEZvcm1hdCwgJ2Vycm9yJzogZGF0ZVRpbWUubmdNb2RlbC4kaW52YWxpZCB9XFxcIj5cXHJcXG5cXHQ8c3BhbiBjbGFzcz1cXFwic2hvdy1kYXRlLXBpY2tlclxcXCI+XFxyXFxuXFx0XFx0PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCJkYXRlVGltZS5uZ01vZGVsLiR2aWV3VmFsdWVcXFwiIC8+XFxyXFxuXFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCI+XFxyXFxuXFx0XFx0XFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlKClcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jYWxlbmRhclxcXCI+PC9pPjwvYnV0dG9uPlxcclxcblxcdFxcdDwvc3Bhbj5cXHJcXG5cXHQ8L3NwYW4+XFxyXFxuXFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWJ0blxcXCIgbmctaWY9XFxcImRhdGVUaW1lLmNsZWFyQnV0dG9uXFxcIj5cXHJcXG5cXHRcXHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBwdWxsLWxlZnRcXFwiICBuZy1kaXNhYmxlZD1cXFwiZGF0ZVRpbWUubmdNb2RlbC4kdmlld1ZhbHVlIHwgaXNFbXB0eVxcXCIgbmctY2xpY2s9XFxcImRhdGVUaW1lLm9uQ2xlYXJDbGljaygpXFxcIiA+XFxyXFxuXFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzXFxcIj48L2k+XFxyXFxuXFx0XFx0PC9idXR0b24+XFxyXFxuXFx0PC9zcGFuPlxcclxcblxcdDxzcGFuIGNsYXNzPVxcXCJlcnJvci1zdHJpbmdcXFwiIG5nLWhpZGU9XFxcImRhdGVUaW1lLmRhdGVUaW1lVmFsaWRhdG9yLmVycm9yIHwgaXNFbXB0eVxcXCI+e3tkYXRlVGltZS5kYXRlVGltZVZhbGlkYXRvci5lcnJvcn19PC9zcGFuPlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2RhdGVUaW1lL2RhdGVUaW1lLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9ib290c3RyYXBEYXRlVGltZVBpY2tlci5kLnRzJyAvPlxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5kYXRlVGltZVN0YXRpYyc7XHJcbmV4cG9ydHMuY29tcG9uZW50TmFtZSA9ICdybERhdGVUaW1lU3RhdGljJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdEYXRlVGltZVN0YXRpY0NvbnRyb2xsZXInO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19kYXRlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmRhdGU7XHJcbnZhciBEYXRlVGltZVN0YXRpY0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0ZVRpbWVTdGF0aWNDb250cm9sbGVyKGRhdGVVdGlsaXR5KSB7XHJcbiAgICAgICAgdGhpcy5kYXRlVXRpbGl0eSA9IGRhdGVVdGlsaXR5O1xyXG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gJyc7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVZhbHVlICE9IG51bGwgJiYgdGhpcy5kYXRlVXRpbGl0eS5pc0RhdGUodGhpcy5kYXRlVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gbW9tZW50KHRoaXMuZGF0ZVZhbHVlKS5mb3JtYXQoJ01NL0REL1lZWVknKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVRpbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVRpbWVab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5kaXNwbGF5VmFsdWUgKyBtb21lbnQodGhpcy5kYXRlVmFsdWUpLmZvcm1hdCgnIGg6bW0gYScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRGF0ZVRpbWVTdGF0aWNDb250cm9sbGVyLiRpbmplY3QgPSBbX19kYXRlLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBEYXRlVGltZVN0YXRpY0NvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRGF0ZVRpbWVTdGF0aWNDb250cm9sbGVyID0gRGF0ZVRpbWVTdGF0aWNDb250cm9sbGVyO1xyXG52YXIgZGF0ZVRpbWVTdGF0aWNDb21wb25lbnQgPSB7XHJcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9kYXRlVGltZVN0YXRpYy5odG1sJyksXHJcbiAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgY29udHJvbGxlckFzOiAndmlldycsXHJcbiAgICBiaW5kaW5nczoge1xyXG4gICAgICAgIGRhdGVWYWx1ZTogJzwnLFxyXG4gICAgICAgIGluY2x1ZGVUaW1lOiAnPD8nLFxyXG4gICAgICAgIGRpc3BsYXlUaW1lWm9uZTogJzw/JyxcclxuICAgIH0sXHJcbn07XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuY29tcG9uZW50KGV4cG9ydHMuY29tcG9uZW50TmFtZSwgZGF0ZVRpbWVTdGF0aWNDb21wb25lbnQpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBEYXRlVGltZVN0YXRpY0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlVGltZVN0YXRpYy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvZGF0ZVRpbWVTdGF0aWMvZGF0ZVRpbWVTdGF0aWMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3BhbiBjbGFzcz1cXFwicmwtZGF0ZS10aW1lLXN0YXRpY1xcXCI+e3t2aWV3LmRpc3BsYXlWYWx1ZX19Jm5ic3A7PHNwYW4gbmctaWY9XFxcInZpZXcuZGlzcGxheVRpbWVab25lXFxcIiBjbGFzcz1cXFwidGltZS16b25lXFxcIj5FU1Q8L3NwYW4+PC9zcGFuPlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2RhdGVUaW1lU3RhdGljL2RhdGVUaW1lU3RhdGljLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3Mvbm9kZS9ub2RlLmQudHMnIC8+XHJcbi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgZGlhbG9nX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2RpYWxvZy9kaWFsb2cuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5kaWFsb2cnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxEaWFsb2cnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0RpYWxvZ0NvbnRyb2xsZXInO1xyXG52YXIgRGlhbG9nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEaWFsb2dDb250cm9sbGVyKCRzY29wZSwgZGlhbG9nU2VydmljZSkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuZGlhbG9nU2VydmljZSA9IGRpYWxvZ1NlcnZpY2U7XHJcbiAgICB9XHJcbiAgICBEaWFsb2dDb250cm9sbGVyLnByb3RvdHlwZS4kb25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVuYmluZCA9IHRoaXMuJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5mb3JtOyB9LCBmdW5jdGlvbiAoZm9ybSkge1xyXG4gICAgICAgICAgICBpZiAoZm9ybSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kaWFsb2dTZXJ2aWNlLnNldEZvcm0oZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB1bmJpbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERpYWxvZ0NvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgZGlhbG9nX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gRGlhbG9nQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5EaWFsb2dDb250cm9sbGVyID0gRGlhbG9nQ29udHJvbGxlcjtcclxuZGlhbG9nLiRpbmplY3QgPSBbJyRjb21waWxlJ107XHJcbmZ1bmN0aW9uIGRpYWxvZygkY29tcGlsZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRyYW5zY2x1ZGU6IHtcclxuICAgICAgICAgICAgaGVhZGVyU2xvdDogJz9ybERpYWxvZ0hlYWRlcicsXHJcbiAgICAgICAgICAgIGNvbnRlbnRTbG90OiAnP3JsRGlhbG9nQ29udGVudCcsXHJcbiAgICAgICAgICAgIGZvb3RlclNsb3Q6ICc/cmxEaWFsb2dGb290ZXInLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZGlhbG9nLmh0bWwnKSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2RpYWxvZycsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgYXV0b3NhdmU6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXIsIHRyYW5zY2x1ZGUpIHtcclxuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSA9IHNjb3BlLiRwYXJlbnQuJGNsb3NlO1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLmRpc21pc3MgPSBzY29wZS4kcGFyZW50LiRkaXNtaXNzO1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLnNhdmVBbmRDbG9zZSA9IHNjb3BlLiRwYXJlbnQuJHNhdmVBbmRDbG9zZTtcclxuICAgICAgICAgICAgdmFyIGZvb3RlckFyZWEgPSBlbGVtZW50LmZpbmQoJy5mb290ZXItdGVtcGxhdGUnKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zY2x1ZGUuaXNTbG90RmlsbGVkKCdmb290ZXJTbG90JykpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zY2x1ZGUoZnVuY3Rpb24gKGZvb3Rlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuaGFzRm9vdGVyID0gKGZvb3Rlci5sZW5ndGggPiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5oYXNGb290ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyQXJlYS5hcHBlbmQoZm9vdGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBudWxsLCAnZm9vdGVyU2xvdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xsZXIuYXV0b3NhdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb290ZXIgPSAkY29tcGlsZShyZXF1aXJlKCcuL2F1dG9zYXZlRGlhbG9nRm9vdGVyLmh0bWwnKSkoc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5oYXNGb290ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9vdGVyQXJlYS5hcHBlbmQoZm9vdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW2RpYWxvZ19zZXJ2aWNlXzEubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgZGlhbG9nKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgRGlhbG9nQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpYWxvZy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvZGlhbG9nL2RpYWxvZy5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcHJvbWlzZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG52YXIgX19ub3RpZmljYXRpb24gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMubm90aWZpY2F0aW9uO1xyXG52YXIgYm9vdHN0cmFwTW9kYWxEaWFsb2cgPSByZXF1aXJlKCcuL2Jvb3RzdHJhcE1vZGFsRGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nLm1vZHVsZScpO1xyXG5leHBvcnRzLmJvb3RzdHJhcE1vZGFsRGlhbG9nID0gYm9vdHN0cmFwTW9kYWxEaWFsb2c7XHJcbnZhciBhdXRvc2F2ZV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi9hdXRvc2F2ZS9hdXRvc2F2ZS5zZXJ2aWNlJyk7XHJcbnZhciBmb3JtX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uL2Zvcm0vZm9ybS5zZXJ2aWNlJyk7XHJcbnZhciBkaWFsb2dfMSA9IHJlcXVpcmUoJy4uLy4uL2NvbXBvbmVudHMvZGlhbG9nL2RpYWxvZycpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSBkaWFsb2dfMS5kaXJlY3RpdmVOYW1lO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gZGlhbG9nXzEuY29udHJvbGxlck5hbWU7XHJcbmV4cG9ydHMuRGlhbG9nQ29udHJvbGxlciA9IGRpYWxvZ18xLkRpYWxvZ0NvbnRyb2xsZXI7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcy5kaWFsb2cnO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ2RpYWxvZyc7XHJcbnZhciBEaWFsb2dTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERpYWxvZ1NlcnZpY2UoZGlhbG9nLCAkcm9vdFNjb3BlLCBhdXRvc2F2ZUZhY3RvcnksIHByb21pc2UsIG5vdGlmaWNhdGlvbiwgZm9ybVNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZGlhbG9nID0gZGlhbG9nO1xyXG4gICAgICAgIHRoaXMuJHJvb3RTY29wZSA9ICRyb290U2NvcGU7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZUZhY3RvcnkgPSBhdXRvc2F2ZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcclxuICAgICAgICB0aGlzLmZvcm1TZXJ2aWNlID0gZm9ybVNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5hdXRvc2F2ZUNsb3NlSGFuZGxlciA9IGZ1bmN0aW9uIChleHBsaWNpdCkge1xyXG4gICAgICAgICAgICBpZiAoZXhwbGljaXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hdXRvc2F2ZS5hdXRvc2F2ZShfdGhpcy5kYXRhKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgRGlhbG9nU2VydmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBjbG9zZUhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkaWFsb2dJbnN0YW5jZSA9IHRoaXMuZGlhbG9nLm9wZW4ob3B0aW9ucywgY2xvc2VIYW5kbGVyKTtcclxuICAgICAgICBkaWFsb2dJbnN0YW5jZS52YWxpZGF0ZUFuZE5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbGlkID0gX3RoaXMuZm9ybS4kdmFsaWQ7XHJcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmaWNhdGlvbi53YXJuaW5nKF90aGlzLmZvcm1TZXJ2aWNlLmdldEFnZ3JlZ2F0ZUVycm9yKF90aGlzLmZvcm0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZGlhbG9nSW5zdGFuY2U7XHJcbiAgICB9O1xyXG4gICAgRGlhbG9nU2VydmljZS5wcm90b3R5cGUucHJvbXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zLm9rQnV0dG9uID0gb3B0aW9ucy5va0J1dHRvbiB8fCAnT2snO1xyXG4gICAgICAgIG9wdGlvbnMuY2FuY2VsQnV0dG9uID0gb3B0aW9ucy5jYW5jZWxCdXR0b24gfHwgJ0NhbmNlbCc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nLnByb21wdChvcHRpb25zLCByZXF1aXJlKCcuL3Byb21wdERpYWxvZy5odG1sJykpO1xyXG4gICAgfTtcclxuICAgIERpYWxvZ1NlcnZpY2UucHJvdG90eXBlLm9wZW5Gb3JtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBkaWFsb2dJbnN0YW5jZSA9IHtcclxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICAgICAgZGlzbWlzczogZnVuY3Rpb24gKCkgeyB9LFxyXG4gICAgICAgICAgICBzYXZlOiBmdW5jdGlvbiAoKSB7IH0sXHJcbiAgICAgICAgICAgIHNhdmVBbmRDbG9zZTogZnVuY3Rpb24gKCkgeyB9LFxyXG4gICAgICAgICAgICB2YWxpZGF0ZUFuZE5vdGlmeTogZnVuY3Rpb24gKCkgeyB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wcm9taXNlLnJlc29sdmVQcm9taXNlcyhvcHRpb25zLnJlc29sdmUpLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzY29wZSA9IG9wdGlvbnMuc2NvcGU7XHJcbiAgICAgICAgICAgIGlmIChzY29wZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZSA9IF90aGlzLiRyb290U2NvcGUuJG5ldygpO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zY29wZSA9IHNjb3BlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50cmlnZ2VycyA9ICdub25lJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5hdXRvc2F2ZSA9IF90aGlzLmF1dG9zYXZlRmFjdG9yeS5nZXRJbnN0YW5jZSh7XHJcbiAgICAgICAgICAgICAgICBzYXZlOiBvcHRpb25zLnNhdmUsXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2Vyczogb3B0aW9ucy50cmlnZ2VycyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGEgPSBfLmV4dGVuZChvcHRpb25zLmRhdGEsIHJlc29sdmVEYXRhKTtcclxuICAgICAgICAgICAgc2NvcGUuZGlhbG9nID0gX3RoaXMuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gX3RoaXMub3BlbihvcHRpb25zLCBfdGhpcy5hdXRvc2F2ZUNsb3NlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIGRpYWxvZ0luc3RhbmNlLmNsb3NlID0gaW5zdGFuY2UuY2xvc2U7XHJcbiAgICAgICAgICAgIGRpYWxvZ0luc3RhbmNlLmRpc21pc3MgPSBpbnN0YW5jZS5kaXNtaXNzO1xyXG4gICAgICAgICAgICBzY29wZS4kc2F2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmF1dG9zYXZlLnZhbGlkYXRlQW5kU2F2ZShfdGhpcy5kYXRhKTsgfTtcclxuICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICBzY29wZS4kc2F2ZUFuZENsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBzY29wZS4kc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uaXNCb29sZWFuKHByb21pc2UpICYmIHByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucHJvbWlzZS5pc1Byb21pc2UocHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRpYWxvZ0luc3RhbmNlLnNhdmUgPSBzY29wZS4kc2F2ZTtcclxuICAgICAgICAgICAgZGlhbG9nSW5zdGFuY2Uuc2F2ZUFuZENsb3NlID0gc2NvcGUuJHNhdmVBbmRDbG9zZTtcclxuICAgICAgICAgICAgZGlhbG9nSW5zdGFuY2UudmFsaWRhdGVBbmROb3RpZnkgPSBpbnN0YW5jZS52YWxpZGF0ZUFuZE5vdGlmeTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGlhbG9nSW5zdGFuY2U7XHJcbiAgICB9O1xyXG4gICAgRGlhbG9nU2VydmljZS5wcm90b3R5cGUuc2V0Rm9ybSA9IGZ1bmN0aW9uIChmb3JtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b3NhdmUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9zYXZlLmNvbnRlbnRGb3JtID0gZm9ybTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mb3JtID0gZm9ybTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGlhbG9nU2VydmljZTtcclxufSgpKTtcclxuZXhwb3J0cy5EaWFsb2dTZXJ2aWNlID0gRGlhbG9nU2VydmljZTtcclxuZnVuY3Rpb24gZGlhbG9nU2VydmljZVByb3ZpZGVyKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciBwcm92aWRlciA9IHtcclxuICAgICAgICBzZXRJbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24gKGRpYWxvZ0ltcGxlbWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRpYWxvZ0ltcGxlbWVudGF0aW9uID0gZGlhbG9nSW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkZ2V0OiBmdW5jdGlvbiAoYm9vdHN0cmFwTW9kYWxEaWFsb2csICRyb290U2NvcGUsIGF1dG9zYXZlRmFjdG9yeSwgcHJvbWlzZSwgbm90aWZpY2F0aW9uLCBmb3JtU2VydmljZSkge1xyXG4gICAgICAgICAgICB2YXIgZGlhbG9nSW1wbGVtZW50YXRpb24gPSBfdGhpcy5kaWFsb2dJbXBsZW1lbnRhdGlvbiAhPSBudWxsXHJcbiAgICAgICAgICAgICAgICA/IF90aGlzLmRpYWxvZ0ltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgICAgICAgICA6IGJvb3RzdHJhcE1vZGFsRGlhbG9nO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWxvZ1NlcnZpY2UoZGlhbG9nSW1wbGVtZW50YXRpb24sICRyb290U2NvcGUsIGF1dG9zYXZlRmFjdG9yeSwgcHJvbWlzZSwgbm90aWZpY2F0aW9uLCBmb3JtU2VydmljZSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBwcm92aWRlci4kZ2V0LiRpbmplY3QgPSBbYm9vdHN0cmFwTW9kYWxEaWFsb2cuc2VydmljZU5hbWUsICckcm9vdFNjb3BlJywgYXV0b3NhdmVfc2VydmljZV8xLmZhY3RvcnlOYW1lLCBfX3Byb21pc2Uuc2VydmljZU5hbWUsIF9fbm90aWZpY2F0aW9uLnNlcnZpY2VOYW1lLCBmb3JtX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gcHJvdmlkZXI7XHJcbn1cclxuZXhwb3J0cy5kaWFsb2dTZXJ2aWNlUHJvdmlkZXIgPSBkaWFsb2dTZXJ2aWNlUHJvdmlkZXI7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW2Jvb3RzdHJhcE1vZGFsRGlhbG9nLm1vZHVsZU5hbWUsIGF1dG9zYXZlX3NlcnZpY2VfMS5tb2R1bGVOYW1lLCBfX25vdGlmaWNhdGlvbi5tb2R1bGVOYW1lLCBmb3JtX3NlcnZpY2VfMS5tb2R1bGVOYW1lXSlcclxuICAgIC5wcm92aWRlcihleHBvcnRzLnNlcnZpY2VOYW1lLCBkaWFsb2dTZXJ2aWNlUHJvdmlkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWFsb2cuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9kaWFsb2cuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3Byb21pc2UgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucHJvbWlzZTtcclxudmFyIGJvb3RzdHJhcE1vZGFsRGlhbG9nX2NvbnRyb2xsZXJfMSA9IHJlcXVpcmUoJy4vYm9vdHN0cmFwTW9kYWxEaWFsb2cuY29udHJvbGxlcicpO1xyXG52YXIgYm9vdHN0cmFwTW9kYWxEaWFsb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9ib290c3RyYXBNb2RhbERpYWxvZy5zZXJ2aWNlJyk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYm9vdHN0cmFwTW9kYWxEaWFsb2cuY29udHJvbGxlcicpKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9ib290c3RyYXBNb2RhbERpYWxvZy5zZXJ2aWNlJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMuZGlhbG9nLmJvb3RzdHJhcE1vZGFsRGlhbG9nJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19wcm9taXNlLm1vZHVsZU5hbWVdKVxyXG4gICAgLmNvbnRyb2xsZXIoYm9vdHN0cmFwTW9kYWxEaWFsb2dfY29udHJvbGxlcl8xLmNvbnRyb2xsZXJOYW1lLCBib290c3RyYXBNb2RhbERpYWxvZ19jb250cm9sbGVyXzEuQm9vdHN0cmFwTW9kYWxEaWFsb2dDb250cm9sbGVyKVxyXG4gICAgLnNlcnZpY2UoYm9vdHN0cmFwTW9kYWxEaWFsb2dfc2VydmljZV8xLnNlcnZpY2VOYW1lLCBib290c3RyYXBNb2RhbERpYWxvZ19zZXJ2aWNlXzEuQm9vdHN0cmFwTW9kYWxEaWFsb2dTZXJ2aWNlKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwTW9kYWxEaWFsb2cubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYm9vdHN0cmFwTW9kYWxEaWFsb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9ib290c3RyYXBNb2RhbERpYWxvZy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnQm9vdHN0cmFwTW9kYWxEaWFsb2dDb250cm9sbGVyJztcclxudmFyIEJvb3RzdHJhcE1vZGFsRGlhbG9nQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCb290c3RyYXBNb2RhbERpYWxvZ0NvbnRyb2xsZXIoJHNjb3BlLCAkY29udHJvbGxlciwgYmFzZURpYWxvZykge1xyXG4gICAgICAgIHZhciBjb250cm9sbGVyO1xyXG4gICAgICAgIGlmICgkc2NvcGUubW9kYWxDb250cm9sbGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FscyA9ICRzY29wZS5yZXNvbHZlRGF0YSB8fCB7fTtcclxuICAgICAgICAgICAgJHNjb3BlLnJlc29sdmVEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgbG9jYWxzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICAgICAgY29udHJvbGxlciA9ICRjb250cm9sbGVyKCRzY29wZS5tb2RhbENvbnRyb2xsZXIsIGxvY2Fscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICRzY29wZS4kb24oJ21vZGFsLmNsb3NpbmcnLCBiYXNlRGlhbG9nLm1vZGFsQ2xvc2luZyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XHJcbiAgICB9XHJcbiAgICBCb290c3RyYXBNb2RhbERpYWxvZ0NvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRjb250cm9sbGVyJywgYm9vdHN0cmFwTW9kYWxEaWFsb2dfc2VydmljZV8xLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBCb290c3RyYXBNb2RhbERpYWxvZ0NvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQm9vdHN0cmFwTW9kYWxEaWFsb2dDb250cm9sbGVyID0gQm9vdHN0cmFwTW9kYWxEaWFsb2dDb250cm9sbGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXBNb2RhbERpYWxvZy5jb250cm9sbGVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvZGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nL2Jvb3RzdHJhcE1vZGFsRGlhbG9nLmNvbnRyb2xsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcHJvbWlzZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wcm9taXNlO1xyXG52YXIgYm9vdHN0cmFwTW9kYWxEaWFsb2dfY29udHJvbGxlcl8xID0gcmVxdWlyZSgnLi9ib290c3RyYXBNb2RhbERpYWxvZy5jb250cm9sbGVyJyk7XHJcbmV4cG9ydHMuc2VydmljZU5hbWUgPSAndWlCb290c3RyYXBNb2RlbERpYWxvZyc7XHJcbnZhciBCb290c3RyYXBNb2RhbERpYWxvZ1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQm9vdHN0cmFwTW9kYWxEaWFsb2dTZXJ2aWNlKCRtb2RhbCwgJHJvb3RTY29wZSwgcHJvbWlzZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kbW9kYWwgPSAkbW9kYWw7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlID0gJHJvb3RTY29wZTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMubW9kYWxDbG9zaW5nID0gZnVuY3Rpb24gKGV2ZW50LCByZWFzb24sIGV4cGxpY2l0bHlDbG9zZWQpIHtcclxuICAgICAgICAgICAgdmFyIGNhbkNsb3NlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihfdGhpcy5jbG9zZUhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5DbG9zZSA9IF90aGlzLmNsb3NlSGFuZGxlcihleHBsaWNpdGx5Q2xvc2VkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIEJvb3RzdHJhcE1vZGFsRGlhbG9nU2VydmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBjbG9zZUhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlhbG9nSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7IH0sXHJcbiAgICAgICAgICAgIGRpc21pc3M6IGZ1bmN0aW9uICgpIHsgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvbWlzZS5yZXNvbHZlUHJvbWlzZXMob3B0aW9ucy5yZXNvbHZlKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNsb3NlSGFuZGxlciA9IGNsb3NlSGFuZGxlcjtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IF90aGlzLmNvbmZpZ3VyZU1vZGFsU2V0dGluZ3Mob3B0aW9ucywgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIHZhciBtb2RhbEluc3RhbmNlID0gX3RoaXMuJG1vZGFsLm9wZW4ob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGRpYWxvZ0luc3RhbmNlLmNsb3NlID0gbW9kYWxJbnN0YW5jZS5jbG9zZTtcclxuICAgICAgICAgICAgZGlhbG9nSW5zdGFuY2UuZGlzbWlzcyA9IG1vZGFsSW5zdGFuY2UuZGlzbWlzcztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGlhbG9nSW5zdGFuY2U7XHJcbiAgICB9O1xyXG4gICAgQm9vdHN0cmFwTW9kYWxEaWFsb2dTZXJ2aWNlLnByb3RvdHlwZS5wcm9tcHQgPSBmdW5jdGlvbiAob3B0aW9ucywgdGVtcGxhdGUpIHtcclxuICAgICAgICB2YXIgYWNjZXB0SGFuZGxlciA9IG9wdGlvbnMuYWNjZXB0SGFuZGxlcjtcclxuICAgICAgICB2YXIgY2FuY2VsSGFuZGxlciA9IG9wdGlvbnMuY2FuY2VsSGFuZGxlcjtcclxuICAgICAgICBvcHRpb25zLmFjY2VwdEhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIG9wdGlvbnMuY2FuY2VsSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgdmFyIG1vZGFsU2NvcGUgPSB0aGlzLiRyb290U2NvcGUuJG5ldygpO1xyXG4gICAgICAgIG1vZGFsU2NvcGUucHJvbXB0ID0gb3B0aW9ucztcclxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgICAgIHNjb3BlOiBtb2RhbFNjb3BlLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IGJvb3RzdHJhcE1vZGFsRGlhbG9nX2NvbnRyb2xsZXJfMS5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBtb2RhbEluc3RhbmNlID0gdGhpcy4kbW9kYWwub3BlbihzZXR0aW5ncyk7XHJcbiAgICAgICAgdmFyIGFjY2VwdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYWNjZXB0SGFuZGxlcigpO1xyXG4gICAgICAgICAgICBtb2RhbEluc3RhbmNlLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjYW5jZWxIYW5kbGVyKCk7XHJcbiAgICAgICAgICAgIG1vZGFsSW5zdGFuY2UuY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIG1vZGFsU2NvcGUuJGFjY2VwdCA9IGFjY2VwdDtcclxuICAgICAgICBtb2RhbFNjb3BlLiRjYW5jZWwgPSBjYW5jZWw7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHQsXHJcbiAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsLFxyXG4gICAgICAgICAgICBjbG9zZTogbW9kYWxJbnN0YW5jZS5jbG9zZSxcclxuICAgICAgICAgICAgZGlzbWlzczogbW9kYWxJbnN0YW5jZS5kaXNtaXNzLFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgQm9vdHN0cmFwTW9kYWxEaWFsb2dTZXJ2aWNlLnByb3RvdHlwZS5jb25maWd1cmVNb2RhbFNldHRpbmdzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlc29sdmVEYXRhKSB7XHJcbiAgICAgICAgdmFyIG1vZGFsU2NvcGUgPSBvcHRpb25zLnNjb3BlO1xyXG4gICAgICAgIGlmIChtb2RhbFNjb3BlID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW9kYWxTY29wZSA9IHRoaXMuJHJvb3RTY29wZS4kbmV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnJlc29sdmVUb0RpYWxvZykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaWFsb2dBcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlW29wdGlvbnMuZGlhbG9nQXNdID0gcmVzb2x2ZURhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlID0gXy5leHRlbmQobW9kYWxTY29wZSwgcmVzb2x2ZURhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb2RhbFNjb3BlLnJlc29sdmVEYXRhID0gcmVzb2x2ZURhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGFsU2NvcGUubW9kYWxDb250cm9sbGVyID0gb3B0aW9ucy5jb250cm9sbGVyO1xyXG4gICAgICAgIG9wdGlvbnMucmVzb2x2ZSA9IG51bGw7XHJcbiAgICAgICAgb3B0aW9ucy5jb250cm9sbGVyID0gYm9vdHN0cmFwTW9kYWxEaWFsb2dfY29udHJvbGxlcl8xLmNvbnRyb2xsZXJOYW1lO1xyXG4gICAgICAgIG9wdGlvbnMuc2NvcGUgPSBtb2RhbFNjb3BlO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfTtcclxuICAgIEJvb3RzdHJhcE1vZGFsRGlhbG9nU2VydmljZS4kaW5qZWN0ID0gWyckdWliTW9kYWwnLCAnJHJvb3RTY29wZScsIF9fcHJvbWlzZS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gQm9vdHN0cmFwTW9kYWxEaWFsb2dTZXJ2aWNlO1xyXG59KCkpO1xyXG5leHBvcnRzLkJvb3RzdHJhcE1vZGFsRGlhbG9nU2VydmljZSA9IEJvb3RzdHJhcE1vZGFsRGlhbG9nU2VydmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwTW9kYWxEaWFsb2cuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RpYWxvZy9ib290c3RyYXBNb2RhbERpYWxvZy9ib290c3RyYXBNb2RhbERpYWxvZy5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keVxcXCI+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTJcXFwiPlxcclxcblxcdFxcdFxcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGRhdGEtZGlzbWlzcz1cXFwibW9kYWxcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBuZy1jbGljaz1cXFwiJGRpc21pc3MoKVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImZhLXN0YWNrXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiY2xvc2UtYmcgZmEgZmEtY2lyY2xlIGZhLXN0YWNrLTJ4XFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImNsb3NlLWljb24gZmEgZmEtY2xvc2UgZmEtc3RhY2stMXhcXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHRcXHQ8L3NwYW4+XFxyXFxuXFx0XFx0XFx0PC9idXR0b24+XFxyXFxuXFx0XFx0PC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFxyXFxuXFx0e3twcm9tcHQubWVzc2FnZX19XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjxkaXYgY2xhc3M9XFxcIm1vZGFsLWZvb3RlclxcXCI+XFxyXFxuXFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kYW5nZXJcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctY2xpY2s9XFxcIiRjYW5jZWwoKVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzXFxcIj48L2k+IHt7cHJvbXB0LmNhbmNlbEJ1dHRvbn19PC9idXR0b24+XFxyXFxuXFx0PGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIG5nLWNsaWNrPVxcXCIkYWNjZXB0KClcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGVja1xcXCI+PC9pPiB7e3Byb21wdC5va0J1dHRvbn19PC9idXR0b24+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9kaWFsb2cvcHJvbXB0RGlhbG9nLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8cmwtZm9ybSBzYXZlPVxcXCJkaWFsb2cuc2F2ZUFuZENsb3NlKClcXFwiIHNhdmluZz1cXFwiZGlhbG9nLnNhdmluZ1xcXCIgZm9ybT1cXFwiZGlhbG9nLmZvcm1cXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcIm1vZGFsLWhlYWRlclxcXCI+XFxyXFxuXFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIG5nLWNsaWNrPVxcXCJkaWFsb2cuY2xvc2UoKVxcXCI+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImZhLXN0YWNrXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiY2xvc2UtYmcgZmEgZmEtY2lyY2xlIGZhLXN0YWNrLTJ4XFxcIj48L2k+XFxyXFxuXFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImNsb3NlLWljb24gZmEgZmEtY2xvc2UgZmEtc3RhY2stMXhcXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHQ8L3NwYW4+XFxyXFxuXFx0XFx0PC9idXR0b24+XFxyXFxuXFx0XFx0PGRpdiBuZy10cmFuc2NsdWRlPVxcXCJoZWFkZXJTbG90XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeCBcXFwiPjwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHlcXFwiPlxcclxcblxcdFxcdDxkaXYgbmctdHJhbnNjbHVkZT1cXFwiY29udGVudFNsb3RcXFwiPjwvZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJtb2RhbC1mb290ZXJcXFwiIG5nLXNob3c9XFxcImRpYWxvZy5oYXNGb290ZXJcXFwiPlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImZvb3Rlci10ZW1wbGF0ZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcbjwvcmwtZm9ybT5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9kaWFsb2cvZGlhbG9nLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8cmwtYnV0dG9uIHR5cGU9XFxcImRhbmdlclxcXCIgYWN0aW9uPVxcXCJkaWFsb2cuY2xvc2UoKVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzXFxcIj48L2k+IENhbmNlbDwvcmwtYnV0dG9uPlxcclxcbjxybC1idXR0b24tYXN5bmMgdHlwZT1cXFwic3VjY2Vzc1xcXCIgYWN0aW9uPVxcXCJkaWFsb2cuc2F2ZUFuZENsb3NlKClcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGVja1xcXCI+PC9pPiBTYXZlPC9ybC1idXR0b24tc3VibWl0PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2RpYWxvZy9hdXRvc2F2ZURpYWxvZ0Zvb3Rlci5odG1sXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL25vZGUvbm9kZS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wYXJlbnRDaGlsZCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5wYXJlbnRDaGlsZEJlaGF2aW9yO1xyXG52YXIgYXV0b3NhdmVfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvYXV0b3NhdmUvYXV0b3NhdmUuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5mb3JtJztcclxuZXhwb3J0cy5jb21wb25lbnROYW1lID0gJ3JsRm9ybSc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAncmxGb3JtQ29udHJvbGxlcic7XHJcbnZhciBGb3JtQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGb3JtQ29udHJvbGxlcigkZWxlbWVudCwgJHNjb3BlLCAkdGltZW91dCwgJHEsIGF1dG9zYXZlRmFjdG9yeSwgcGFyZW50Q2hpbGQpIHtcclxuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xyXG4gICAgICAgIHRoaXMuJHEgPSAkcTtcclxuICAgICAgICB0aGlzLmF1dG9zYXZlRmFjdG9yeSA9IGF1dG9zYXZlRmFjdG9yeTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkID0gcGFyZW50Q2hpbGQ7XHJcbiAgICB9XHJcbiAgICBGb3JtQ29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5mb3JtID0gX3RoaXMuJHNjb3BlLnJsRm9ybTtcclxuICAgICAgICAgICAgX3RoaXMuYXV0b3NhdmUgPSBfdGhpcy5hdXRvc2F2ZUZhY3RvcnkuZ2V0SW5zdGFuY2Uoe1xyXG4gICAgICAgICAgICAgICAgc2F2ZTogX3RoaXMuc2F2ZUZvcm0uYmluZChfdGhpcyksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50Rm9ybTogX3RoaXMuJHNjb3BlLnJsRm9ybSxcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJzOiAnbm9uZScsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfdGhpcy5wYXJlbnRDaGlsZC5yZWdpc3RlckNoaWxkQmVoYXZpb3IoX3RoaXMuY2hpbGRMaW5rLCB7XHJcbiAgICAgICAgICAgICAgICBzYXZlOiBfdGhpcy5hdXRvc2F2ZS52YWxpZGF0ZUFuZFNhdmUuYmluZChfdGhpcy5hdXRvc2F2ZSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEZvcm1Db250cm9sbGVyLnByb3RvdHlwZS5zYXZlRm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc2F2aW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy4kcS53aGVuKHRoaXMuc2F2ZSgpKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2F2aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkgeyBfdGhpcy5zYXZpbmcgPSBmYWxzZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRm9ybUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJGVsZW1lbnQnLCAnJHNjb3BlJywgJyR0aW1lb3V0JywgJyRxJywgYXV0b3NhdmVfc2VydmljZV8xLmZhY3RvcnlOYW1lLCBfX3BhcmVudENoaWxkLnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBGb3JtQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Gb3JtQ29udHJvbGxlciA9IEZvcm1Db250cm9sbGVyO1xyXG52YXIgZm9ybSA9IHtcclxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXHJcbiAgICB0ZW1wbGF0ZTogXCI8Zm9ybSBuZy10cmFuc2NsdWRlIG5hbWU9XFxcInJsRm9ybVxcXCIgbmctc3VibWl0PVxcXCJjb250cm9sbGVyLmF1dG9zYXZlLnZhbGlkYXRlQW5kU2F2ZSgpXFxcIj48L2Zvcm0+XCIsXHJcbiAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgY29udHJvbGxlckFzOiAnY29udHJvbGxlcicsXHJcbiAgICBiaW5kaW5nczoge1xyXG4gICAgICAgIHNhdmluZzogJz0/JyxcclxuICAgICAgICBzYXZlOiAnJicsXHJcbiAgICAgICAgZm9ybTogJz0/JyxcclxuICAgICAgICBjaGlsZExpbms6ICc9PycsXHJcbiAgICB9LFxyXG59O1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFthdXRvc2F2ZV9zZXJ2aWNlXzEubW9kdWxlTmFtZV0pXHJcbiAgICAuY29tcG9uZW50KGV4cG9ydHMuY29tcG9uZW50TmFtZSwgZm9ybSlcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIEZvcm1Db250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvZm9ybS9mb3JtLmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIganF1ZXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZScpO1xyXG52YXIgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5nZW5lcmljQ29udGFpbmVyJztcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsR2VuZXJpY0NvbnRhaW5lcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXInO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIoJHNjb3BlLCBvYmplY3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0b3I7IH0sIGZ1bmN0aW9uIChuZXdUeXBlLCBvbGRUeXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vYmplY3QuYXJlRXF1YWwobmV3VHlwZSwgb2xkVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBfdGhpcy5yZXNvbHZlVGVtcGxhdGUobmV3VHlwZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnN3YXBUZW1wbGF0ZXModGVtcGxhdGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgR2VuZXJpY0NvbnRhaW5lckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5yZXNvbHZlVGVtcGxhdGUodGhpcy5zZWxlY3Rvcik7XHJcbiAgICAgICAgdGhpcy5zd2FwVGVtcGxhdGVzKHRlbXBsYXRlKTtcclxuICAgIH07XHJcbiAgICBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVzb2x2ZVRlbXBsYXRlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAoXy5oYXModGhpcy50ZW1wbGF0ZXMsIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlc1t0eXBlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdlbmVyaWNDb250YWluZXJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsIF9fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5HZW5lcmljQ29udGFpbmVyQ29udHJvbGxlciA9IEdlbmVyaWNDb250YWluZXJDb250cm9sbGVyO1xyXG5nZW5lcmljQ29udGFpbmVyLiRpbmplY3QgPSBbXHJcbiAgICAnJGNvbXBpbGUnLFxyXG4gICAgJyRpbnRlcnBvbGF0ZScsXHJcbiAgICBqcXVlcnlfc2VydmljZV8xLnNlcnZpY2VOYW1lLFxyXG4gICAgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xLnNlcnZpY2VOYW1lLFxyXG4gICAgX19vYmplY3Quc2VydmljZU5hbWUsXHJcbl07XHJcbmZ1bmN0aW9uIGdlbmVyaWNDb250YWluZXIoJGNvbXBpbGUsICRpbnRlcnBvbGF0ZSwganF1ZXJ5LCB0ZW1wbGF0ZUxvYWRlciwgb2JqZWN0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6ICc8ZGl2IGlkPVwiY29udGFpbmVyXCI+PC9kaXY+JyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnZ2VuZXJpY0NvbnRhaW5lcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICc9JyxcclxuICAgICAgICAgICAgY29uZmlndXJlZFRlbXBsYXRlczogJz10ZW1wbGF0ZXMnLFxyXG4gICAgICAgICAgICBkZWZhdWx0VGVtcGxhdGU6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cmlidXRlcywgY29udHJvbGxlciwgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICBpbml0RGVmYXVsdHMoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBlbGVtZW50LmZpbmQoJyNjb250YWluZXInKTtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlUmVzdWx0ID0gdGVtcGxhdGVMb2FkZXIubG9hZFRlbXBsYXRlcyh0cmFuc2NsdWRlKTtcclxuICAgICAgICAgICAgY29udHJvbGxlci50ZW1wbGF0ZXMgPSBfLmV4dGVuZChjb250cm9sbGVyLnRlbXBsYXRlcywgdGVtcGxhdGVSZXN1bHQudGVtcGxhdGVzKTtcclxuICAgICAgICAgICAgY29udHJvbGxlci5kZWZhdWx0ID0gdGVtcGxhdGVSZXN1bHQuZGVmYXVsdDtcclxuICAgICAgICAgICAgdmFyIHRlbXBsYXRlU2NvcGUgPSB0ZW1wbGF0ZVJlc3VsdC50cmFuc2NsdXNpb25TY29wZTtcclxuICAgICAgICAgICAgaWYgKCFjb250cm9sbGVyLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZGVmYXVsdCA9ICc8ZGl2PjwvZGl2Pic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udHJvbGxlci5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXREZWZhdWx0cyhjb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmRlZmF1bHQgPSBjb250cm9sbGVyLmRlZmF1bHRUZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudGVtcGxhdGVzID0gY29udHJvbGxlci5jb25maWd1cmVkVGVtcGxhdGVzID8gY29udHJvbGxlci5jb25maWd1cmVkVGVtcGxhdGVzIDoge307XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnN3YXBUZW1wbGF0ZXMgPSBzd2FwVGVtcGxhdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN3YXBUZW1wbGF0ZXModGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gYW5ndWxhci5lbGVtZW50KHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIGpxdWVyeS5yZXBsYWNlQ29udGVudChjb250YWluZXIsIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgJGNvbXBpbGUoY29udGVudCkodGVtcGxhdGVTY29wZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW2pxdWVyeV9zZXJ2aWNlXzEubW9kdWxlTmFtZSwgX19vYmplY3QubW9kdWxlTmFtZSwgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xLm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIGdlbmVyaWNDb250YWluZXIpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBHZW5lcmljQ29udGFpbmVyQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyaWNDb250YWluZXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL2dlbmVyaWNDb250YWluZXIvZ2VuZXJpY0NvbnRhaW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzXCIgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnV0aWxpdGllcy5zZXJ2aWNlcy5qcXVlcnknO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ2pxdWVyeVV0aWxpdHknO1xyXG52YXIgSlF1ZXJ5VXRpbGl0eSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBKUXVlcnlVdGlsaXR5KCkge1xyXG4gICAgfVxyXG4gICAgSlF1ZXJ5VXRpbGl0eS5wcm90b3R5cGUucmVwbGFjZUNvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudEFyZWEsIG5ld0NvbnRlbnQpIHtcclxuICAgICAgICBjb250ZW50QXJlYS5lbXB0eSgpO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50QXJlYS5hcHBlbmQobmV3Q29udGVudCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEpRdWVyeVV0aWxpdHk7XHJcbn0oKSk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBKUXVlcnlVdGlsaXR5KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anF1ZXJ5LnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9qcXVlcnkvanF1ZXJ5LnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudXRpbGl0aWVzLnNlcnZpY2VzLnRlbXBsYXRlTG9hZGVyJztcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICd0ZW1wbGF0ZUxvYWRlcic7XHJcbnZhciBUZW1wbGF0ZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZUxvYWRlcigkaW50ZXJwb2xhdGUsIHRlbXBsYXRlU2VsZWN0b3JWYWx1ZSwgb2JqZWN0VXRpbGl0eSkge1xyXG4gICAgICAgIHRoaXMuJGludGVycG9sYXRlID0gJGludGVycG9sYXRlO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVTZWxlY3RvclZhbHVlID0gdGVtcGxhdGVTZWxlY3RvclZhbHVlO1xyXG4gICAgICAgIHRoaXMub2JqZWN0VXRpbGl0eSA9IG9iamVjdFV0aWxpdHk7XHJcbiAgICB9XHJcbiAgICBUZW1wbGF0ZUxvYWRlci5wcm90b3R5cGUubG9hZFRlbXBsYXRlcyA9IGZ1bmN0aW9uICh0cmFuc2NsdWRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZXM6IHt9LFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxyXG4gICAgICAgICAgICB0cmFuc2NsdXNpb25TY29wZTogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIExvYWQgdGVtcGxhdGVzIGZyb20gdGhlIERPTVxyXG4gICAgICAgIHRyYW5zY2x1ZGUoZnVuY3Rpb24gKGNsb25lLCB0cmFuc2NsdXNpb25TY29wZSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVzID0gY2xvbmUuZmlsdGVyKF90aGlzLnRlbXBsYXRlU2VsZWN0b3JWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlcy5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlSHRtbCA9IHRlbXBsYXRlRWxlbWVudC5odG1sKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlckF0dHJpYnV0ZSA9IHRlbXBsYXRlRWxlbWVudC5hdHRyKCd3aGVuLXNlbGVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9iamVjdFV0aWxpdHkuaXNOdWxsT3JXaGl0ZXNwYWNlKHRyaWdnZXJBdHRyaWJ1dGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWdnZXIgPSBfdGhpcy4kaW50ZXJwb2xhdGUodHJpZ2dlckF0dHJpYnV0ZSkodHJhbnNjbHVzaW9uU2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC50ZW1wbGF0ZXNbdHJpZ2dlcl0gPSB0ZW1wbGF0ZUh0bWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNEZWZhdWx0ID0gdGVtcGxhdGVFbGVtZW50LmF0dHIoJ2RlZmF1bHQnKTtcclxuICAgICAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChpc0RlZmF1bHQpICYmIGlzRGVmYXVsdC50b0xvd2VyQ2FzZSgpICE9PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRlZmF1bHQgPSB0ZW1wbGF0ZUh0bWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXN1bHQudHJhbnNjbHVzaW9uU2NvcGUgPSB0cmFuc2NsdXNpb25TY29wZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFRlbXBsYXRlTG9hZGVyLiRpbmplY3QgPSBbJyRpbnRlcnBvbGF0ZScsICd0ZW1wbGF0ZVNlbGVjdG9yVmFsdWUnLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gVGVtcGxhdGVMb2FkZXI7XHJcbn0oKSk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fb2JqZWN0Lm1vZHVsZU5hbWVdKVxyXG4gICAgLnZhbHVlKCd0ZW1wbGF0ZVNlbGVjdG9yVmFsdWUnLCAndGVtcGxhdGUnKVxyXG4gICAgLnNlcnZpY2UoZXhwb3J0cy5zZXJ2aWNlTmFtZSwgVGVtcGxhdGVMb2FkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZUxvYWRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMubGF6eUxvYWQnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxMYXp5TG9hZCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnTGF6eUxvYWRDb250cm9sbGVyJztcclxudmFyIExhenlMb2FkQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMYXp5TG9hZENvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgdW5iaW5kID0gJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zaG93OyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHVuYmluZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBMYXp5TG9hZENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gTGF6eUxvYWRDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkxhenlMb2FkQ29udHJvbGxlciA9IExhenlMb2FkQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gbGF6eUxvYWQoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8ZGl2IG5nLWlmPVxcXCJsYXp5TG9hZC5pbml0XFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IG5nLXNob3c9XFxcImxhenlMb2FkLnNob3dcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcIixcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ2xhenlMb2FkJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBzaG93OiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBsYXp5TG9hZClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIExhenlMb2FkQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhenlMb2FkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9sYXp5TG9hZC9sYXp5TG9hZC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19wcm9taXNlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnByb21pc2U7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmxvbmdDbGlja0J1dHRvbic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybExvbmdDbGlja0J1dHRvbic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlcic7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIoJHNjb3BlLCAkaW50ZXJ2YWwsICR0aW1lb3V0LCBvYmplY3RVdGlsaXR5LCBwcm9taXNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRpbnRlcnZhbCA9ICRpbnRlcnZhbDtcclxuICAgICAgICB0aGlzLiR0aW1lb3V0ID0gJHRpbWVvdXQ7XHJcbiAgICAgICAgdGhpcy5vYmplY3RVdGlsaXR5ID0gb2JqZWN0VXRpbGl0eTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAyNTtcclxuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMTUwMDtcclxuICAgICAgICB0aGlzLmJ1dHRvblRleHQgPSB0aGlzLnRleHQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy50eXBlICE9IG51bGwgPyB0aGlzLnR5cGUgOiAnZGVmYXVsdCc7XHJcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5zaXplICE9IG51bGwgPyAnYnRuLScgKyB0aGlzLnNpemUgOiBudWxsO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYnV0dG9uVGV4dDsgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy53aWR0aCA9ICQoJyNhY3Rpb25CdXR0b24nKS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci5wcm90b3R5cGUuc3RhcnRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUgfHwgdGhpcy5idXN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3Rpb25Qcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uSW50ZXJ2YWwgPSB0aGlzLiRpbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmFjdGlvblByb2dyZXNzICs9IF90aGlzLmludGVydmFsO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aW9uUHJvZ3Jlc3MgPj0gX3RoaXMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmJ1dHRvblRleHQgPSBfdGhpcy50ZXh0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdGhpcy5pbnRlcnZhbCk7XHJcbiAgICB9O1xyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci5wcm90b3R5cGUuc3RvcEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uUHJvZ3Jlc3MgPCB0aGlzLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhcm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLiRpbnRlcnZhbC5jYW5jZWwodGhpcy5hY3Rpb25JbnRlcnZhbCk7XHJcbiAgICAgICAgdGhpcy5hY3Rpb25Qcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9iamVjdFV0aWxpdHkuaXNOdWxsT3JFbXB0eSh0aGlzLm9uU2hvcnRDbGlja1RleHQpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRleHQgPSB0aGlzLm9uU2hvcnRDbGlja1RleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExvbmdDbGlja0J1dHRvbkNvbnRyb2xsZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuYnVzeSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1c3kgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hY3Rpb24oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvbWlzZS5pc1Byb21pc2UocmVzdWx0KSAmJiBfLmlzRnVuY3Rpb24ocmVzdWx0LmZpbmFsbHkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZmluYWxseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnVzeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCAnJGludGVydmFsJywgJyR0aW1lb3V0JywgX19vYmplY3Quc2VydmljZU5hbWUsIF9fcHJvbWlzZS5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Mb25nQ2xpY2tCdXR0b25Db250cm9sbGVyID0gTG9uZ0NsaWNrQnV0dG9uQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gbG9uZ0NsaWNrQnV0dG9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2xvbmdDbGlja0J1dHRvbi5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdidXR0b24nLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJyYnLFxyXG4gICAgICAgICAgICB0ZXh0OiAnQCcsXHJcbiAgICAgICAgICAgIG9uU2hvcnRDbGlja1RleHQ6ICdAJyxcclxuICAgICAgICAgICAgaWNvbjogJ0AnLFxyXG4gICAgICAgICAgICBidXN5OiAnPT8nLFxyXG4gICAgICAgICAgICByaWdodEFsaWduZWQ6ICc9PycsXHJcbiAgICAgICAgICAgIHR5cGU6ICdAJyxcclxuICAgICAgICAgICAgbmdEaXNhYmxlZDogJz0/JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBsb25nQ2xpY2tCdXR0b24pXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBMb25nQ2xpY2tCdXR0b25Db250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9uZ0NsaWNrQnV0dG9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9sb25nQ2xpY2tCdXR0b24vbG9uZ0NsaWNrQnV0dG9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibG9uZy1jbGljay1idXR0b25cXFwiPlxcclxcblxcdDxidXR0b24gaWQ9XFxcImFjdGlvbkJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4te3tidXR0b24udHlwZX19IHt7YnV0dG9uLnNpemV9fVxcXCIgbmctbW91c2Vkb3duPVxcXCJidXR0b24uc3RhcnRBY3Rpb24oKVxcXCIgbmctbW91c2VsZWF2ZT1cXFwiYnV0dG9uLnN0b3BBY3Rpb24oKVxcXCIgbmctbW91c2V1cD1cXFwiYnV0dG9uLnN0b3BBY3Rpb24oKVxcXCIgbmctZGlzYWJsZWQ9XFxcImJ1dHRvbi5idXN5IHx8IGJ1dHRvbi5uZ0Rpc2FibGVkXFxcIj5cXHJcXG5cXHRcXHQ8cmwtYnVzeSBsb2FkaW5nPVxcXCJidXR0b24uYnVzeVxcXCIgbmctaWY9XFxcImJ1dHRvbi5yaWdodEFsaWduZWRcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHRcXHQ8aSBuZy1zaG93PVxcXCJidXR0b24uaWNvbiAhPSBudWxsXFxcIiBjbGFzcz1cXFwiZmEgZmEte3tidXR0b24uaWNvbn19XFxcIj48L2k+IHt7YnV0dG9uLmJ1dHRvblRleHR9fVxcclxcblxcdFxcdDxybC1idXN5IGxvYWRpbmc9XFxcImJ1dHRvbi5idXN5XFxcIiBuZy1pZj1cXFwiIWJ1dHRvbi5yaWdodEFsaWduZWRcXFwiPjwvcmwtYnVzeT5cXHJcXG5cXHQ8L2J1dHRvbj5cXHJcXG5cXHQ8cmwtcmF0aW5nLWJhciBuZy1pZj1cXFwiYnV0dG9uLmFjdGl2ZVxcXCIgd2lkdGg9XFxcImJ1dHRvbi53aWR0aFxcXCIgaGVpZ2h0PVxcXCI1XFxcIiBtaW49XFxcIjBcXFwiIG1heD1cXFwiYnV0dG9uLmR1cmF0aW9uXFxcIlxcclxcblxcdFxcdFxcdFxcdHZhbHVlPVxcXCJidXR0b24uYWN0aW9uUHJvZ3Jlc3NcXFwiIGJhY2tncm91bmQ9XFxcInRyYW5zcGFyZW50XFxcIj48L3JsLXJhdGluZy1iYXI+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbG9uZ0NsaWNrQnV0dG9uL2xvbmdDbGlja0J1dHRvbi5odG1sXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIGpxdWVyeV9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9qcXVlcnkvanF1ZXJ5LnNlcnZpY2UnKTtcclxudmFyIG1lc3NhZ2VMb2dfc2VydmljZV8xID0gcmVxdWlyZSgnLi9tZXNzYWdlTG9nLnNlcnZpY2UnKTtcclxudmFyIG1lc3NhZ2VMb2dfZGlyZWN0aXZlXzEgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cuZGlyZWN0aXZlJyk7XHJcbnZhciBlZGl0YWJsZU1lc3NhZ2VMb2dfMSA9IHJlcXVpcmUoJy4vZWRpdGFibGVNZXNzYWdlTG9nJyk7XHJcbnZhciBjb21wb25lbnRTZXJ2aWNlcyA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL3NlcnZpY2VzLm1vZHVsZScpO1xyXG52YXIgX19kaWFsb2cgPSBjb21wb25lbnRTZXJ2aWNlcy5kaWFsb2c7XHJcbnZhciB0ZW1wbGF0ZUxvYWRlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy90ZW1wbGF0ZUxvYWRlci90ZW1wbGF0ZUxvYWRlci5zZXJ2aWNlJyk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vbWVzc2FnZUxvZy5zZXJ2aWNlJykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL21lc3NhZ2VMb2cuZGlyZWN0aXZlJykpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5tZXNzYWdlTG9nJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZSwganF1ZXJ5X3NlcnZpY2VfMS5tb2R1bGVOYW1lLCB0ZW1wbGF0ZUxvYWRlcl9zZXJ2aWNlXzEubW9kdWxlTmFtZSwgX19kaWFsb2cubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShtZXNzYWdlTG9nX3NlcnZpY2VfMS5mYWN0b3J5TmFtZSwgbWVzc2FnZUxvZ19zZXJ2aWNlXzEubWVzc2FnZUxvZ0ZhY3RvcnkpXHJcbiAgICAuZGlyZWN0aXZlKG1lc3NhZ2VMb2dfZGlyZWN0aXZlXzEuZGlyZWN0aXZlTmFtZSwgbWVzc2FnZUxvZ19kaXJlY3RpdmVfMS5tZXNzYWdlTG9nKVxyXG4gICAgLmNvbnRyb2xsZXIobWVzc2FnZUxvZ19kaXJlY3RpdmVfMS5jb250cm9sbGVyTmFtZSwgbWVzc2FnZUxvZ19kaXJlY3RpdmVfMS5NZXNzYWdlTG9nQ29udHJvbGxlcilcclxuICAgIC5kaXJlY3RpdmUoZWRpdGFibGVNZXNzYWdlTG9nXzEuZGlyZWN0aXZlTmFtZSwgZWRpdGFibGVNZXNzYWdlTG9nXzEuZWRpdGFibGVNZXNzYWdlTG9nKVxyXG4gICAgLmNvbnRyb2xsZXIoZWRpdGFibGVNZXNzYWdlTG9nXzEuY29udHJvbGxlck5hbWUsIGVkaXRhYmxlTWVzc2FnZUxvZ18xLkVkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNzYWdlTG9nLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmZhY3RvcnlOYW1lID0gJ21lc3NhZ2VMb2cnO1xyXG5leHBvcnRzLmRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xyXG52YXIgTWVzc2FnZUxvZyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZXNzYWdlTG9nKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5faGFzRm9yd2FyZE1lc3NhZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFzQmFja3dhcmRNZXNzYWdlcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3BhZ2VTaXplID0gZXhwb3J0cy5kZWZhdWx0UGFnZVNpemU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUxvZy5wcm90b3R5cGUsIFwicGFnZVNpemVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFnZVNpemU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VTaXplID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlTG9nLnByb3RvdHlwZSwgXCJoYXNGb3J3YXJkTWVzc2FnZXNcIiwge1xyXG4gICAgICAgIC8qIHRzbGludDplbmFibGUgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZvcndhcmRNZXNzYWdlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlTG9nLnByb3RvdHlwZSwgXCJoYXNCYWNrd2FyZE1lc3NhZ2VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0JhY2t3YXJkTWVzc2FnZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZUxvZy5wcm90b3R5cGUsIFwiZGF0YVNlcnZpY2VcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNlcnZpY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTZXJ2aWNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVNZXNzYWdlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRQYWdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qIHRzbGludDplbmFibGUgKi9cclxuICAgIE1lc3NhZ2VMb2cucHJvdG90eXBlLmFkZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2Uuc2F2ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmdldFRvcFBhZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS51cGRhdGVNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLnVwZGF0ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmdldFRvcFBhZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5kZWxldGVNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTZXJ2aWNlLmRlbGV0ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5nZXROZXh0UGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzRm9yd2FyZE1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlICs9IHRoaXMucGFnZVNpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS5nZXRQcmV2aW91c1BhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0JhY2t3YXJkTWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydGluZ01lc3NhZ2UgLT0gdGhpcy5wYWdlU2l6ZTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGFydGluZ01lc3NhZ2UgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDdXJyZW50UGFnZSgpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2cucHJvdG90eXBlLmdldFRvcFBhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDdXJyZW50UGFnZSgpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2cucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ3VycmVudFBhZ2UoKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nLnByb3RvdHlwZS51cGRhdGVDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGFTZXJ2aWNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVzeSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZ2V0TWVzc2FnZXModGhpcy5jdXJyZW50U3RhcnRpbmdNZXNzYWdlLCB0aGlzLnBhZ2VTaXplKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgX3RoaXMudmlzaWJsZU1lc3NhZ2VzID0gcmVzdWx0Lm1lc3NhZ2VzO1xyXG4gICAgICAgICAgICBfdGhpcy5faGFzRm9yd2FyZE1lc3NhZ2VzID0gcmVzdWx0Lmhhc01vcmVNZXNzYWdlcztcclxuICAgICAgICAgICAgX3RoaXMuX2hhc0JhY2t3YXJkTWVzc2FnZXMgPSAoX3RoaXMuY3VycmVudFN0YXJ0aW5nTWVzc2FnZSA+IDApO1xyXG4gICAgICAgICAgICBfdGhpcy5idXN5ID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1lc3NhZ2VMb2c7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTWVzc2FnZUxvZyA9IE1lc3NhZ2VMb2c7XHJcbmZ1bmN0aW9uIG1lc3NhZ2VMb2dGYWN0b3J5KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VMb2coKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLm1lc3NhZ2VMb2dGYWN0b3J5ID0gbWVzc2FnZUxvZ0ZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VMb2cuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nLnNlcnZpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIganF1ZXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2pxdWVyeS9qcXVlcnkuc2VydmljZScpO1xyXG52YXIgbWVzc2FnZUxvZ19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cuc2VydmljZScpO1xyXG52YXIgY29tcG9uZW50U2VydmljZXMgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9zZXJ2aWNlcy5tb2R1bGUnKTtcclxudmFyIF9fZGlhbG9nID0gY29tcG9uZW50U2VydmljZXMuZGlhbG9nO1xyXG52YXIgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvdGVtcGxhdGVMb2FkZXIvdGVtcGxhdGVMb2FkZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxNZXNzYWdlTG9nJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdNZXNzYWdlTG9nQ29udHJvbGxlcic7XHJcbihmdW5jdGlvbiAoRGVsZXRlUGVybWlzc2lvbnMpIHtcclxuICAgIERlbGV0ZVBlcm1pc3Npb25zW0RlbGV0ZVBlcm1pc3Npb25zW1wiZGVsZXRlTWluZVwiXSA9IDBdID0gXCJkZWxldGVNaW5lXCI7XHJcbiAgICBEZWxldGVQZXJtaXNzaW9uc1tEZWxldGVQZXJtaXNzaW9uc1tcImRlbGV0ZUFsbFwiXSA9IDFdID0gXCJkZWxldGVBbGxcIjtcclxuICAgIERlbGV0ZVBlcm1pc3Npb25zW0RlbGV0ZVBlcm1pc3Npb25zW1wiZGVsZXRlTm9uZVwiXSA9IDJdID0gXCJkZWxldGVOb25lXCI7XHJcbn0pKGV4cG9ydHMuRGVsZXRlUGVybWlzc2lvbnMgfHwgKGV4cG9ydHMuRGVsZXRlUGVybWlzc2lvbnMgPSB7fSkpO1xyXG52YXIgRGVsZXRlUGVybWlzc2lvbnMgPSBleHBvcnRzLkRlbGV0ZVBlcm1pc3Npb25zO1xyXG4oZnVuY3Rpb24gKEVkaXRQZXJtaXNzaW9ucykge1xyXG4gICAgRWRpdFBlcm1pc3Npb25zW0VkaXRQZXJtaXNzaW9uc1tcImVkaXRNaW5lXCJdID0gMF0gPSBcImVkaXRNaW5lXCI7XHJcbiAgICBFZGl0UGVybWlzc2lvbnNbRWRpdFBlcm1pc3Npb25zW1wiZWRpdEFsbFwiXSA9IDFdID0gXCJlZGl0QWxsXCI7XHJcbiAgICBFZGl0UGVybWlzc2lvbnNbRWRpdFBlcm1pc3Npb25zW1wiZWRpdE5vbmVcIl0gPSAyXSA9IFwiZWRpdE5vbmVcIjtcclxufSkoZXhwb3J0cy5FZGl0UGVybWlzc2lvbnMgfHwgKGV4cG9ydHMuRWRpdFBlcm1pc3Npb25zID0ge30pKTtcclxudmFyIEVkaXRQZXJtaXNzaW9ucyA9IGV4cG9ydHMuRWRpdFBlcm1pc3Npb25zO1xyXG52YXIgTWVzc2FnZUxvZ0NvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWVzc2FnZUxvZ0NvbnRyb2xsZXIoZGlhbG9nLCAkc2NvcGUsIG1lc3NhZ2VMb2dGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRpYWxvZyA9IGRpYWxvZztcclxuICAgICAgICB0aGlzLm1lc3NhZ2VMb2cgPSB0aGlzLm1lc3NhZ2VMb2dCaW5kaW5nIHx8IG1lc3NhZ2VMb2dGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLnZpc2libGVNZXNzYWdlczsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm1lc3NhZ2VzID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLmhhc0ZvcndhcmRNZXNzYWdlczsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhc05leHRQYWdlID0gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXNzYWdlTG9nLmhhc0JhY2t3YXJkTWVzc2FnZXM7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5oYXNQcmV2aW91c1BhZ2UgPSB2YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1lc3NhZ2VMb2cuYnVzeTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdJbml0aWFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VydmljZTsgfSwgZnVuY3Rpb24gKHNlcnZpY2UpIHtcclxuICAgICAgICAgICAgX3RoaXMubWVzc2FnZUxvZy5kYXRhU2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmdJbml0aWFsID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VMb2cucGFnZVNpemUgPSB0aGlzLnBhZ2VTaXplICE9IG51bGwgPyB0aGlzLnBhZ2VTaXplIDogODtcclxuICAgIH1cclxuICAgIE1lc3NhZ2VMb2dDb250cm9sbGVyLnByb3RvdHlwZS5nZXRFbnRyeVNlbGVjdG9yID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcodGhpcy5zZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5W3RoaXMuc2VsZWN0b3JdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChfLmlzRnVuY3Rpb24odGhpcy5zZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IoZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0T2xkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUxvZy5nZXROZXh0UGFnZSgpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2dDb250cm9sbGVyLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUxvZy5nZXRUb3BQYWdlKCk7XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZ0NvbnRyb2xsZXIucHJvdG90eXBlLmNhbkRlbGV0ZUVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKGVudHJ5LmlzU3lzdGVtTm90ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5jYW5EZWxldGUpIHtcclxuICAgICAgICAgICAgY2FzZSBEZWxldGVQZXJtaXNzaW9ucy5kZWxldGVBbGw6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgY2FzZSBEZWxldGVQZXJtaXNzaW9ucy5kZWxldGVNaW5lOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnRVc2VyID09IG51bGwgfHwgdGhpcy5jdXJyZW50VXNlci5pZCA9PT0gZW50cnkuY3JlYXRlZEJ5LmlkKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZ0NvbnRyb2xsZXIucHJvdG90eXBlLmNhbkVkaXRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmIChlbnRyeS5pc1N5c3RlbU5vdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHRoaXMuY2FuRWRpdCkge1xyXG4gICAgICAgICAgICBjYXNlIEVkaXRQZXJtaXNzaW9ucy5lZGl0QWxsOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGNhc2UgRWRpdFBlcm1pc3Npb25zLmVkaXRNaW5lOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmN1cnJlbnRVc2VyID09IG51bGwgfHwgdGhpcy5jdXJyZW50VXNlci5pZCA9PT0gZW50cnkuY3JlYXRlZEJ5LmlkKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWVzc2FnZUxvZ0NvbnRyb2xsZXIucHJvdG90eXBlLmVkaXRNZXNzYWdlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgdmFyIGVkaXRlZEVudHJ5ID0gXy5jbG9uZShlbnRyeSk7XHJcbiAgICAgICAgdGhpcy5kaWFsb2cub3BlbkZvcm0oe1xyXG4gICAgICAgICAgICBzYXZlOiB0aGlzLnVwZGF0ZU5vdGUuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgZW50cnk6IGVkaXRlZEVudHJ5LFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFbnRyeTogZW50cnksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL21lc3NhZ2VMb2dFZGl0RGlhbG9nLmh0bWwnKSxcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlTG9nQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlTm90ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUxvZy51cGRhdGVNZXNzYWdlKGRhdGEuZW50cnkpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2dDb250cm9sbGVyLnByb3RvdHlwZS5zYXZlTm90ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUxvZy5hZGRNZXNzYWdlKGRhdGEuZW50cnkpO1xyXG4gICAgfTtcclxuICAgIE1lc3NhZ2VMb2dDb250cm9sbGVyLiRpbmplY3QgPSBbX19kaWFsb2cuc2VydmljZU5hbWUsICckc2NvcGUnLCBtZXNzYWdlTG9nX3NlcnZpY2VfMS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gTWVzc2FnZUxvZ0NvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTWVzc2FnZUxvZ0NvbnRyb2xsZXIgPSBNZXNzYWdlTG9nQ29udHJvbGxlcjtcclxubWVzc2FnZUxvZy4kaW5qZWN0ID0gW1xyXG4gICAgJyRpbnRlcnBvbGF0ZScsXHJcbiAgICBqcXVlcnlfc2VydmljZV8xLnNlcnZpY2VOYW1lLFxyXG4gICAgdGVtcGxhdGVMb2FkZXJfc2VydmljZV8xLnNlcnZpY2VOYW1lLFxyXG4gICAgX19vYmplY3Quc2VydmljZU5hbWUsXHJcbl07XHJcbmZ1bmN0aW9uIG1lc3NhZ2VMb2coJGludGVycG9sYXRlLCBqcXVlcnksIHRlbXBsYXRlTG9hZGVyLCBvYmplY3QpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9tZXNzYWdlTG9nLmh0bWwnKSxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnbG9nJyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBtZXNzYWdlRGF0YTogXCI9XCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHNlcnZpY2U6ICc9JyxcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICc9JyxcclxuICAgICAgICAgICAgcGFnZVNpemU6ICc9JyxcclxuICAgICAgICAgICAgbWVzc2FnZUxvZ0JpbmRpbmc6ICc9bWVzc2FnZUxvZycsXHJcbiAgICAgICAgICAgIG1lc3NhZ2VBczogXCJAXCIsXHJcbiAgICAgICAgICAgIGN1cnJlbnRVc2VyOiAnPT8nLFxyXG4gICAgICAgICAgICBjYW5EZWxldGU6ICc9PycsXHJcbiAgICAgICAgICAgIGNhbkVkaXQ6ICc9PycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJpYnV0ZXMsIGNvbnRyb2xsZXIsIHRyYW5zY2x1ZGUpIHtcclxuICAgICAgICAgICAgY29udHJvbGxlci50ZW1wbGF0ZXMgPSB0ZW1wbGF0ZUxvYWRlci5sb2FkVGVtcGxhdGVzKHRyYW5zY2x1ZGUpLnRlbXBsYXRlcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMubWVzc2FnZUxvZyA9IG1lc3NhZ2VMb2c7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VMb2cuZGlyZWN0aXZlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9tZXNzYWdlTG9nL21lc3NhZ2VMb2cuZGlyZWN0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMTMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgYXV0b3NhdmUgPSByZXF1aXJlKCcuL2F1dG9zYXZlL2F1dG9zYXZlLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5hdXRvc2F2ZSA9IGF1dG9zYXZlO1xyXG52YXIgYXV0b3NhdmVBY3Rpb24gPSByZXF1aXJlKCcuL2F1dG9zYXZlQWN0aW9uL2F1dG9zYXZlQWN0aW9uLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5hdXRvc2F2ZUFjdGlvbiA9IGF1dG9zYXZlQWN0aW9uO1xyXG52YXIgYnJlYWtwb2ludHMgPSByZXF1aXJlKCcuL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLm1vZHVsZScpO1xyXG5leHBvcnRzLmJyZWFrcG9pbnRzID0gYnJlYWtwb2ludHM7XHJcbnZhciBjb21wb25lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL2NvbXBvbmVudFZhbGlkYXRvci9jb21wb25lbnRWYWxpZGF0b3Iuc2VydmljZScpO1xyXG5leHBvcnRzLmNvbXBvbmVudFZhbGlkYXRvciA9IGNvbXBvbmVudFZhbGlkYXRvcjtcclxudmFyIGNvbnRlbnRQcm92aWRlciA9IHJlcXVpcmUoJy4vY29udGVudFByb3ZpZGVyL2NvbnRlbnRQcm92aWRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuY29udGVudFByb3ZpZGVyID0gY29udGVudFByb3ZpZGVyO1xyXG52YXIgZGlhbG9nID0gcmVxdWlyZSgnLi9kaWFsb2cvZGlhbG9nLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5kaWFsb2cgPSBkaWFsb2c7XHJcbnZhciBkb2N1bWVudFdyYXBwZXIgPSByZXF1aXJlKCcuL2RvY3VtZW50V3JhcHBlci9kb2N1bWVudFdyYXBwZXIuc2VydmljZScpO1xyXG5leHBvcnRzLmRvY3VtZW50V3JhcHBlciA9IGRvY3VtZW50V3JhcHBlcjtcclxudmFyIGZvcm0gPSByZXF1aXJlKCcuL2Zvcm0vZm9ybS5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMuZm9ybSA9IGZvcm07XHJcbnZhciBqcXVlcnkgPSByZXF1aXJlKCcuL2pxdWVyeS9qcXVlcnkuc2VydmljZScpO1xyXG5leHBvcnRzLmpxdWVyeSA9IGpxdWVyeTtcclxudmFyIHRlbXBsYXRlTG9hZGVyID0gcmVxdWlyZSgnLi90ZW1wbGF0ZUxvYWRlci90ZW1wbGF0ZUxvYWRlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMudGVtcGxhdGVMb2FkZXIgPSB0ZW1wbGF0ZUxvYWRlcjtcclxudmFyIHdpbmRvd1dyYXBwZXIgPSByZXF1aXJlKCcuL3dpbmRvd1dyYXBwZXIvd2luZG93V3JhcHBlci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMud2luZG93V3JhcHBlciA9IHdpbmRvd1dyYXBwZXI7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5zZXJ2aWNlcyc7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW1xyXG4gICAgYXV0b3NhdmUubW9kdWxlTmFtZSxcclxuICAgIGF1dG9zYXZlQWN0aW9uLm1vZHVsZU5hbWUsXHJcbiAgICBicmVha3BvaW50cy5tb2R1bGVOYW1lLFxyXG4gICAgY29tcG9uZW50VmFsaWRhdG9yLm1vZHVsZU5hbWUsXHJcbiAgICBjb250ZW50UHJvdmlkZXIubW9kdWxlTmFtZSxcclxuICAgIGRpYWxvZy5tb2R1bGVOYW1lLFxyXG4gICAgZG9jdW1lbnRXcmFwcGVyLm1vZHVsZU5hbWUsXHJcbiAgICBmb3JtLm1vZHVsZU5hbWUsXHJcbiAgICBqcXVlcnkubW9kdWxlTmFtZSxcclxuICAgIHRlbXBsYXRlTG9hZGVyLm1vZHVsZU5hbWUsXHJcbiAgICB3aW5kb3dXcmFwcGVyLm1vZHVsZU5hbWUsXHJcbl0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlcy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy9zZXJ2aWNlcy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgd2luZG93V3JhcHBlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi93aW5kb3dXcmFwcGVyL3dpbmRvd1dyYXBwZXIuc2VydmljZScpO1xyXG52YXIgdmlzaWJsZUJyZWFrcG9pbnRfc2VydmljZV8xID0gcmVxdWlyZSgnLi92aXNpYmxlQnJlYWtwb2ludC5zZXJ2aWNlJyk7XHJcbnZhciBicmVha3BvaW50c19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL2JyZWFrcG9pbnRzLnNlcnZpY2UnKTtcclxuX19leHBvcnQocmVxdWlyZSgnLi9icmVha3BvaW50JykpO1xyXG5fX2V4cG9ydChyZXF1aXJlKCcuL3Zpc2libGVCcmVha3BvaW50LnNlcnZpY2UnKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoJy4vYnJlYWtwb2ludHMuc2VydmljZScpKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLnNlcnZpY2VzLmJyZWFrcG9pbnRzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZS5tb2R1bGVOYW1lLFxyXG4gICAgd2luZG93V3JhcHBlcl9zZXJ2aWNlXzEubW9kdWxlTmFtZSxcclxuXSlcclxuICAgIC5jb25zdGFudCgncmVzaXplRGVib3VuY2VNaWxsaXNlY29uZHMnLCA1MDApXHJcbiAgICAuc2VydmljZSh2aXNpYmxlQnJlYWtwb2ludF9zZXJ2aWNlXzEudmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlTmFtZSwgdmlzaWJsZUJyZWFrcG9pbnRfc2VydmljZV8xLlZpc2libGVCcmVha3BvaW50U2VydmljZSlcclxuICAgIC5zZXJ2aWNlKGJyZWFrcG9pbnRzX3NlcnZpY2VfMS5icmVha3BvaW50U2VydmljZU5hbWUsIGJyZWFrcG9pbnRzX3NlcnZpY2VfMS5CcmVha3BvaW50U2VydmljZSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyZWFrcG9pbnRzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLnNlcnZpY2VzLndpbmRvd1dyYXBwZXInO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ3dpbmRvd1dyYXBwZXInO1xyXG52YXIgV2luZG93U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBXaW5kb3dTZXJ2aWNlKCkge1xyXG4gICAgICAgIHRoaXMud2luZG93Q29udHJvbCA9ICQod2luZG93KTtcclxuICAgIH1cclxuICAgIFdpbmRvd1NlcnZpY2UucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMud2luZG93Q29udHJvbC5yZXNpemUoY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIFdpbmRvd1NlcnZpY2UucHJvdG90eXBlLnNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dDb250cm9sLnNjcm9sbFRvcCgpO1xyXG4gICAgfTtcclxuICAgIFdpbmRvd1NlcnZpY2UucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy53aW5kb3dDb250cm9sLnNjcm9sbChoYW5kbGVyKTtcclxuICAgIH07XHJcbiAgICBXaW5kb3dTZXJ2aWNlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93Q29udHJvbC5oZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gV2luZG93U2VydmljZTtcclxufSgpKTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5zZXJ2aWNlKGV4cG9ydHMuc2VydmljZU5hbWUsIFdpbmRvd1NlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dXcmFwcGVyLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9zZXJ2aWNlcy93aW5kb3dXcmFwcGVyL3dpbmRvd1dyYXBwZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG4vKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBhbHNvIHJlcXVpcmVzIHRoZSBmb2xsb3dpbmcgZWxlbWVudHMgdG8gYmUgaW5zZXJ0ZWQgb24gdGhlIHBhZ2U6XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS14cyB2aXNpYmxlLXhzXCI+PC9kaXY+XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS1zbSB2aXNpYmxlLXNtXCI+PC9kaXY+XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS1tZCB2aXNpYmxlLW1kXCI+PC9kaXY+XHJcbiAqICAgPGRpdiBjbGFzcz1cImRldmljZS1sZyB2aXNpYmxlLWxnXCI+PC9kaXY+XHJcbiAqIFRoZXkgaGF2ZSBiZWVuIGluc2VydGVkIGludG8gaW5kZXguaHRtbCBmb3IgeW91ciBjb252ZW5pZW5jZS5cclxuICovXHJcbmV4cG9ydHMudmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlTmFtZSA9ICd2aXNpYmxlQnJlYWtwb2ludCc7XHJcbnZhciBWaXNpYmxlQnJlYWtwb2ludFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlKCkge1xyXG4gICAgfVxyXG4gICAgVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoYnJlYWtwb2ludCkge1xyXG4gICAgICAgIC8vIGpxdWVyeSBnZXRzIHRoZSBicmVha3BvaW50IHRyaWdnZXIgZGlyZWN0aXZlcyBsaXN0ZWQgYWJvdmUgb24gbGluZSAzXHJcbiAgICAgICAgcmV0dXJuICQoJy5kZXZpY2UtJyArIGJyZWFrcG9pbnQpLmlzKCc6dmlzaWJsZScpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaXNpYmxlQnJlYWtwb2ludFNlcnZpY2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlID0gVmlzaWJsZUJyZWFrcG9pbnRTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXNpYmxlQnJlYWtwb2ludC5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvdmlzaWJsZUJyZWFrcG9pbnQuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgd2luZG93V3JhcHBlcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi93aW5kb3dXcmFwcGVyL3dpbmRvd1dyYXBwZXIuc2VydmljZScpO1xyXG52YXIgdmlzaWJsZUJyZWFrcG9pbnRfc2VydmljZV8xID0gcmVxdWlyZSgnLi92aXNpYmxlQnJlYWtwb2ludC5zZXJ2aWNlJyk7XHJcbnZhciBicmVha3BvaW50XzEgPSByZXF1aXJlKCcuL2JyZWFrcG9pbnQnKTtcclxuZXhwb3J0cy5icmVha3BvaW50U2VydmljZU5hbWUgPSAnYnJlYWtwb2ludHMnO1xyXG52YXIgX19vYnNlcnZhYmxlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9ic2VydmFibGU7XHJcbnZhciBCcmVha3BvaW50U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCcmVha3BvaW50U2VydmljZSgkcm9vdFNjb3BlLCB2aXNpYmxlQnJlYWtwb2ludHMsIHJlc2l6ZURlYm91bmNlTWlsbGlzZWNvbmRzLCB3aW5kb3dTZXJ2aWNlLCBvYnNlcnZhYmxlRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kcm9vdFNjb3BlID0gJHJvb3RTY29wZTtcclxuICAgICAgICB0aGlzLnZpc2libGVCcmVha3BvaW50cyA9IHZpc2libGVCcmVha3BvaW50cztcclxuICAgICAgICB0aGlzLnVwZGF0ZUJyZWFrcG9pbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdCcmVha1BvaW50ID0gX3RoaXMuZ2V0QnJlYWtwb2ludCgpO1xyXG4gICAgICAgICAgICBpZiAobmV3QnJlYWtQb2ludCAhPT0gX3RoaXMuY3VycmVudEJyZWFrcG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLiRyb290U2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50QnJlYWtwb2ludCA9IG5ld0JyZWFrUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2JzZXJ2YWJsZS5maXJlKCd3aW5kb3cuYnJlYWtwb2ludENoYW5nZWQnLCBfdGhpcy5jdXJyZW50QnJlYWtwb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnJlYWtwb2ludCA9IHRoaXMuZ2V0QnJlYWtwb2ludCgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGVGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIGVmZmljaWVudFJlc2l6ZSA9IF8uZGVib3VuY2UodGhpcy51cGRhdGVCcmVha3BvaW50LCByZXNpemVEZWJvdW5jZU1pbGxpc2Vjb25kcywge1xyXG4gICAgICAgICAgICBsZWFkaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICB0cmFpbGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgbWF4V2FpdDogcmVzaXplRGVib3VuY2VNaWxsaXNlY29uZHMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd2luZG93U2VydmljZS5yZXNpemUoZWZmaWNpZW50UmVzaXplKTtcclxuICAgIH1cclxuICAgIEJyZWFrcG9pbnRTZXJ2aWNlLnByb3RvdHlwZS5nZXRCcmVha3BvaW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZpc2libGVCcmVha3BvaW50cy5pc1Zpc2libGUoYnJlYWtwb2ludF8xLmxnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnJlYWtwb2ludF8xLmxnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnZpc2libGVCcmVha3BvaW50cy5pc1Zpc2libGUoYnJlYWtwb2ludF8xLm1kKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnJlYWtwb2ludF8xLm1kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnZpc2libGVCcmVha3BvaW50cy5pc1Zpc2libGUoYnJlYWtwb2ludF8xLnNtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYnJlYWtwb2ludF8xLnNtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJyZWFrcG9pbnRfMS54cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnJlYWtwb2ludFNlcnZpY2UucHJvdG90eXBlLmlzQnJlYWtwb2ludCA9IGZ1bmN0aW9uIChicmVha3BvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEJyZWFrcG9pbnQgPT09IGJyZWFrcG9pbnQ7XHJcbiAgICB9O1xyXG4gICAgQnJlYWtwb2ludFNlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmFibGUucmVnaXN0ZXIoYWN0aW9uLCAnd2luZG93LmJyZWFrcG9pbnRDaGFuZ2VkJyk7XHJcbiAgICB9O1xyXG4gICAgQnJlYWtwb2ludFNlcnZpY2UuJGluamVjdCA9IFsnJHJvb3RTY29wZScsIHZpc2libGVCcmVha3BvaW50X3NlcnZpY2VfMS52aXNpYmxlQnJlYWtwb2ludFNlcnZpY2VOYW1lLCAncmVzaXplRGVib3VuY2VNaWxsaXNlY29uZHMnLCB3aW5kb3dXcmFwcGVyX3NlcnZpY2VfMS5zZXJ2aWNlTmFtZSwgX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lXTtcclxuICAgIHJldHVybiBCcmVha3BvaW50U2VydmljZTtcclxufSgpKTtcclxuZXhwb3J0cy5CcmVha3BvaW50U2VydmljZSA9IEJyZWFrcG9pbnRTZXJ2aWNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmVha3BvaW50cy5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzXCIgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgbmcgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29ic2VydmFibGUgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JzZXJ2YWJsZTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnV0aWxpdGllcy5zZXJ2aWNlcy5jb250ZW50UHJvdmlkZXInO1xyXG5leHBvcnRzLnNlcnZpY2VOYW1lID0gJ2NvbnRlbnRQcm92aWRlckZhY3RvcnknO1xyXG52YXIgQ29udGVudFByb3ZpZGVyU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb250ZW50UHJvdmlkZXJTZXJ2aWNlKG9ic2VydmFibGVGYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnNldFRyYW5zY2x1ZGVDb250ZW50ID0gZnVuY3Rpb24gKHRyYW5zY2x1ZGVGdW5jdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHRyYW5zY2x1ZGVGdW5jdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zY2x1ZGVGdW5jdGlvbihmdW5jdGlvbiAoY2xvbmUsIHRyYW5zY2x1ZGVTY29wZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldENvbnRlbnQoY2xvbmUsIHRyYW5zY2x1ZGVTY29wZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldENvbnRlbnQobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGVGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICBDb250ZW50UHJvdmlkZXJTZXJ2aWNlLnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQsIHNjb3BlKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcclxuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlLmZpcmUoJ2NvbnRlbnRDaGFuZ2VkJyk7XHJcbiAgICB9O1xyXG4gICAgQ29udGVudFByb3ZpZGVyU2VydmljZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoYWN0aW9uLCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbih0aGlzLmdldENvbnRlbnQoc2VsZWN0b3IpLCB0aGlzLnNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2YWJsZS5yZWdpc3RlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbihfdGhpcy5nZXRDb250ZW50KHNlbGVjdG9yKSwgX3RoaXMuc2NvcGUpO1xyXG4gICAgICAgIH0sICdjb250ZW50Q2hhbmdlZCcpO1xyXG4gICAgfTtcclxuICAgIENvbnRlbnRQcm92aWRlclNlcnZpY2UucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcihzZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbnRlbnRQcm92aWRlclNlcnZpY2U7XHJcbn0oKSk7XHJcbmNvbnRlbnRQcm92aWRlclNlcnZpY2VGYWN0b3J5LiRpbmplY3QgPSBbX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lXTtcclxuZnVuY3Rpb24gY29udGVudFByb3ZpZGVyU2VydmljZUZhY3Rvcnkob2JzZXJ2YWJsZUZhY3RvcnkpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250ZW50UHJvdmlkZXJTZXJ2aWNlKG9ic2VydmFibGVGYWN0b3J5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbm5nLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZV0pXHJcbiAgICAuZmFjdG9yeShleHBvcnRzLnNlcnZpY2VOYW1lLCBjb250ZW50UHJvdmlkZXJTZXJ2aWNlRmFjdG9yeSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRlbnRQcm92aWRlci5zZXJ2aWNlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2Uvc2VydmljZXMvY29udGVudFByb3ZpZGVyL2NvbnRlbnRQcm92aWRlci5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuc2VydmljZXMuZG9jdW1lbnRXcmFwcGVyJztcclxuZXhwb3J0cy5zZXJ2aWNlTmFtZSA9ICdkb2N1bWVudFdyYXBwZXInO1xyXG52YXIgRG9jdW1lbnRTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERvY3VtZW50U2VydmljZSgpIHtcclxuICAgICAgICB0aGlzLmRvY3VtZW50Q29udHJvbCA9ICQoZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgRG9jdW1lbnRTZXJ2aWNlLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDb250cm9sLmhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEb2N1bWVudFNlcnZpY2U7XHJcbn0oKSk7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuc2VydmljZShleHBvcnRzLnNlcnZpY2VOYW1lLCBEb2N1bWVudFNlcnZpY2UpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudFdyYXBwZXIuc2VydmljZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3NlcnZpY2VzL2RvY3VtZW50V3JhcHBlci9kb2N1bWVudFdyYXBwZXIuc2VydmljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxybC1kaWFsb2cgYXV0b3NhdmU9XFxcInRydWVcXFwiPlxcclxcblxcdDxybC1kaWFsb2ctY29udGVudD5cXHJcXG5cXHRcXHQ8bmctZm9ybSBuYW1lPVxcXCJub3RlRm9ybVxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PHJsLXRleHRib3ggbmctbW9kZWw9XFxcImRpYWxvZy5lbnRyeS5tZXNzYWdlXFxcIiBsYWJlbD1cXFwiTWVzc2FnZTpcXFwiIG1heGxlbmd0aD1cXFwiMjUwXFxcIj48L3JsLXRleHRib3g+XFxyXFxuXFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0PC9uZy1mb3JtPlxcclxcblxcdDwvcmwtZGlhbG9nLWNvbnRlbnQ+XFxyXFxuPC9ybC1kaWFsb2c+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvbWVzc2FnZUxvZy9tZXNzYWdlTG9nRWRpdERpYWxvZy5odG1sXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdj5cXHJcXG5cXHQ8cmwtYnVzeSBsb2FkaW5nPVxcXCJsb2cubG9hZGluZ0luaXRpYWxcXFwiIHNpemU9XFxcIjJ4XFxcIj48L3JsLWJ1c3k+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwiY29udGVudC1ncm91cFxcXCIgbmctcmVwZWF0PVxcXCJlbnRyeSBpbiBsb2cubWVzc2FnZXNcXFwiIHJsLWFsaWFzPVxcXCJlbnRyeSBhcyB7e2xvZy5tZXNzYWdlQXN9fVxcXCIgbmctY2xhc3M9XFxcInsgJ3N5c3RlbS1ub3RlJzogZW50cnkuaXNTeXN0ZW1Ob3RlIH1cXFwiPlxcclxcblxcdFxcdDxybC1nZW5lcmljLWNvbnRhaW5lciBzZWxlY3Rvcj1cXFwibG9nLmdldEVudHJ5U2VsZWN0b3IoZW50cnkpXFxcIiB0ZW1wbGF0ZXM9XFxcImxvZy50ZW1wbGF0ZXNcXFwiPlxcclxcblxcdFxcdFxcdDx0ZW1wbGF0ZSBkZWZhdWx0PlxcclxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcIm1lc3NhZ2UtYm9keVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwibWVzc2FnZS1jb250ZW50XFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IG5nLWJpbmQtaHRtbD1cXFwiZW50cnkubWVzc2FnZVxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcIm1lc3NhZ2UtYnV0dG9uXFxcIiBuZy1pZj1cXFwibG9nLmNhbkRlbGV0ZUVudHJ5KGVudHJ5KVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHJsLWJ1dHRvbi1hc3luYyB0eXBlPVxcXCJtZXNzYWdlLWRlbGV0ZSBmbGF0XFxcIiBhY3Rpb249XFxcImxvZy5tZXNzYWdlTG9nLmRlbGV0ZU1lc3NhZ2UoZW50cnkpXFxcIiBzaXplPVxcXCJ4c1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPjwvcmwtYnV0dG9uLWFzeW5jPlxcclxcblxcdFxcdFxcdFxcdFxcdDwvc3Bhbj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwibWVzc2FnZS1idXR0b25cXFwiIG5nLWlmPVxcXCJsb2cuY2FuRWRpdEVudHJ5KGVudHJ5KVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0PHJsLWJ1dHRvbi1hc3luYyB0eXBlPVxcXCJtZXNzYWdlLWRlbGV0ZS1idXR0b24gZmxhdFxcXCIgYWN0aW9uPVxcXCJsb2cuZWRpdE1lc3NhZ2UoZW50cnkpXFxcIiBzaXplPVxcXCJ4c1xcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWVkaXRcXFwiPjwvaT48L3JsLWJ1dHRvbi1hc3luYz5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8L3NwYW4+XFxyXFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwibWVzc2FnZS1ieWxpbmVcXFwiPlxcclxcblxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImJ5bGluZVxcXCI+e3tlbnRyeS5jcmVhdGVkQnkubmFtZX19PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiYnlsaW5lXFxcIj57e2VudHJ5LmNyZWF0ZWREYXRlIHwgZGF0ZTonc2hvcnQnfX0gVVRDIDxzcGFuICBuZy1pZj1cXFwiZW50cnkuZWRpdGVkXFxcIiBjbGFzcz1cXFwiZWRpdGVkLW5vdGVcXFwiIHVpYi10b29sdGlwPVxcXCJMYXN0IGVkaXRlZCBieToge3tlbnRyeS5sYXN0VXBkYXRlZEJ5Lm5hbWV9fSB7e2VudHJ5Lmxhc3RVcGRhdGVkRGF0ZSB8IGRhdGU6J3Nob3J0JyB9fSBVVENcXFwiPihlZGl0ZWQpPC9zcGFuPjwvZGl2PlxcclxcblxcdFxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDwvdGVtcGxhdGU+XFxyXFxuXFx0XFx0PC9ybC1nZW5lcmljLWNvbnRhaW5lcj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb250ZW50LWdyb3VwXFxcIiBuZy1pZj1cXFwiKGxvZy5tZXNzYWdlcyB8IGlzRW1wdHkpICYmICFsb2cubG9hZGluZ0luaXRpYWxcXFwiPk5vIGV4aXN0aW5nIG1lc3NhZ2VzPC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTJcXFwiPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHQ8cmwtYnV0dG9uLWFzeW5jIGFjdGlvbj1cXFwibG9nLmdldFRvcCgpXFxcIiBuZy1kaXNhYmxlZD1cXFwibG9nLmxvYWRpbmdcXFwiIGJ1dHRvbi1yaWdodC1hbGlnbmVkPVxcXCJ0cnVlXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHQ8c3BhbiBuZy1zaG93PVxcXCJsb2cuaGFzUHJldmlvdXNQYWdlXFxcIj5Ub3AgPGkgY2xhc3M9XFxcImZhIGZhLWNhcmV0LXVwXFxcIj48L2k+PC9zcGFuPlxcclxcblxcdFxcdFxcdFxcdFxcdDxzcGFuIG5nLWhpZGU9XFxcImxvZy5oYXNQcmV2aW91c1BhZ2VcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZWZyZXNoXFxcIj48L2k+IFJlZnJlc2g8L3NwYW4+XFxyXFxuXFx0XFx0XFx0XFx0PC9ybC1idXR0b24tYXN5bmM+XFxyXFxuXFx0XFx0XFx0XFx0PHJsLWJ1dHRvbi1hc3luYyBuZy1kaXNhYmxlZD1cXFwibG9nLmhhc05leHRQYWdlID09IGZhbHNlIHx8IGxvZy5sb2FkaW5nXFxcIiBhY3Rpb249XFxcImxvZy5nZXRPbGRlcigpXFxcIj5cXHJcXG5cXHRcXHRcXHRcXHRcXHRPbGRlciA8aSBjbGFzcz1cXFwiZmEgZmEtY2FyZXQtcmlnaHRcXFwiPjwvaT5cXHJcXG5cXHRcXHRcXHRcXHQ8L3JsLWJ1dHRvbi1hc3luYz5cXHJcXG5cXHRcXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9tZXNzYWdlTG9nL21lc3NhZ2VMb2cuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgbWVzc2FnZUxvZ19zZXJ2aWNlXzEgPSByZXF1aXJlKCcuL21lc3NhZ2VMb2cuc2VydmljZScpO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxFZGl0YWJsZU1lc3NhZ2VMb2cnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ0VkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXInO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG47XHJcbnZhciBFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVkaXRhYmxlTWVzc2FnZUxvZ0NvbnRyb2xsZXIoJHNjb3BlLCBtZXNzYWdlTG9nRmFjdG9yeSwgb2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VMb2dTZXJ2aWNlID0gbWVzc2FnZUxvZ0ZhY3RvcnkuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1lc3NhZ2VMb2dTZXJ2aWNlLmJ1c3k7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5idXN5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zYXZpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5idXN5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9iamVjdC5pc051bGxPcldoaXRlc3BhY2UodGhpcy5uZXdNZXNzYWdlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zYXZpbmdNZXNzYWdlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubmV3TWVzc2FnZTtcclxuICAgICAgICB0aGlzLm5ld01lc3NhZ2UgPSAnJztcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlTG9nU2VydmljZS5hZGRNZXNzYWdlKHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcclxuICAgIH07XHJcbiAgICBFZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsIG1lc3NhZ2VMb2dfc2VydmljZV8xLmZhY3RvcnlOYW1lLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5FZGl0YWJsZU1lc3NhZ2VMb2dDb250cm9sbGVyID0gRWRpdGFibGVNZXNzYWdlTG9nQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gZWRpdGFibGVNZXNzYWdlTG9nKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxmb3JtIG5nLXN1Ym1pdD1cXFwibG9nLmFkZCgpXFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCJsb2cubmV3TWVzc2FnZVxcXCIgcGxhY2Vob2xkZXI9XFxcIkVudGVyIGxvZyBtZXNzYWdlXFxcIiAvPlxcblxcdFxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1ncm91cC1idG5cXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxidXR0b24gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgdHlwZT1cXFwic3VibWl0XFxcIiBuZy1kaXNhYmxlZD1cXFwibG9nLmJ1c3lcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxybC1idXN5IGxvYWRpbmc9XFxcImxvZy5zYXZpbmdNZXNzYWdlXFxcIj48L3JsLWJ1c3k+IEFkZFxcblxcdFxcdFxcdFxcdFxcdFxcdDwvYnV0dG9uPlxcblxcdFxcdFxcdFxcdFxcdDwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJtZXNzYWdlLWxvZ1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHJsLW1lc3NhZ2UtbG9nIHNlcnZpY2U9XFxcImxvZy5zZXJ2aWNlXFxcIiBwYWdlLXNpemU9XFxcImxvZy5wYWdlU2l6ZVxcXCIgbWVzc2FnZS1sb2c9XFxcImxvZy5tZXNzYWdlTG9nU2VydmljZVxcXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50LXVzZXI9XFxcImxvZy5jdXJyZW50VXNlclxcXCIgY2FuLWRlbGV0ZT1cXFwibG9nLmNhbkRlbGV0ZVxcXCI+PC9ybC1tZXNzYWdlLWxvZz5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Zvcm0+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdsb2cnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHNlcnZpY2U6ICc9JyxcclxuICAgICAgICAgICAgcGFnZVNpemU6ICc9JyxcclxuICAgICAgICAgICAgY3VycmVudFVzZXI6ICc9PycsXHJcbiAgICAgICAgICAgIGNhbkRlbGV0ZTogJz0/JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmVkaXRhYmxlTWVzc2FnZUxvZyA9IGVkaXRhYmxlTWVzc2FnZUxvZztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWRpdGFibGVNZXNzYWdlTG9nLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9tZXNzYWdlTG9nL2VkaXRhYmxlTWVzc2FnZUxvZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5tdWx0aVN0ZXBJbmRpY2F0b3InO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxNdWx0aVN0ZXBJbmRpY2F0b3InO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ011bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXInO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyKCRzdGF0ZSwgJHEsIG9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuJHN0YXRlID0gJHN0YXRlO1xyXG4gICAgICAgIHRoaXMuJHEgPSAkcTtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyZVN0ZXBzKCk7XHJcbiAgICB9XHJcbiAgICBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICBpZiAoIXRoaXMuYW55TG9hZGluZygpKSB7XHJcbiAgICAgICAgICAgIHN0ZXAubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuJHEud2hlbihzdGVwLm9uQ2xpY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLmFueUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uc29tZSh0aGlzLnN0ZXBzLCBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RlcC5sb2FkaW5nO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbmZpZ3VyZVN0ZXBzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgXy5lYWNoKHRoaXMuc3RlcHMsIGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAuaGFzQ291bnQgPSBfLmlzRnVuY3Rpb24oc3RlcC5jb3VudCk7XHJcbiAgICAgICAgICAgIHN0ZXAuZ2V0Q29tcGxldGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0SXNDb21wbGV0ZWQoc3RlcCk7IH07XHJcbiAgICAgICAgICAgIHN0ZXAuZ2V0VmFsaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nZXRJc1ZhbGlkKHN0ZXApOyB9O1xyXG4gICAgICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihzdGVwLm9uQ2xpY2spKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub2JqZWN0LmlzTnVsbE9yV2hpdGVzcGFjZShzdGVwLnN0YXRlTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwLmluYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXAub25DbGljayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlZGlyZWN0VG9TdGF0ZShzdGVwKTsgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuJHN0YXRlLmluY2x1ZGVzKHN0ZXAuc3RhdGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwLmlzQ3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci5wcm90b3R5cGUucmVkaXJlY3RUb1N0YXRlID0gZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRzdGF0ZS5nbyhzdGVwLnN0YXRlTmFtZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ3VycmVudFN0YXRlKCk7XHJcbiAgICAgICAgICAgIHN0ZXAuaXNDdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyLnByb3RvdHlwZS5jbGVhckN1cnJlbnRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfLmVhY2godGhpcy5zdGVwcywgZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICAgICAgc3RlcC5pc0N1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyLnByb3RvdHlwZS5nZXRJc0NvbXBsZXRlZCA9IGZ1bmN0aW9uIChzdGVwKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uaXNGdW5jdGlvbihzdGVwLmlzQ29tcGxldGVkKVxyXG4gICAgICAgICAgICA/IHN0ZXAuaXNDb21wbGV0ZWQoKVxyXG4gICAgICAgICAgICA6IHN0ZXAuaXNDb21wbGV0ZWQ7XHJcbiAgICB9O1xyXG4gICAgTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlci5wcm90b3R5cGUuc2V0SXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoc3RlcCwgaXNDb21wbGV0ZWQpIHtcclxuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihzdGVwLmlzQ29tcGxldGVkKSkge1xyXG4gICAgICAgICAgICBzdGVwLmlzQ29tcGxldGVkID0gaXNDb21wbGV0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIucHJvdG90eXBlLmdldElzVmFsaWQgPSBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oc3RlcC5pc1ZhbGlkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RlcC5pc1ZhbGlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKHN0ZXAuaXNWYWxpZCAhPSBudWxsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RlcC5pc1ZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHN0YXRlJywgJyRxJywgX19vYmplY3Quc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTXVsdGlTdGVwSW5kaWNhdG9yQ29udHJvbGxlciA9IE11bHRpU3RlcEluZGljYXRvckNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIG11bHRpU3RlcEluZGljYXRvcigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9tdWx0aVN0ZXBJbmRpY2F0b3IuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnYnJlYWRjcnVtYicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc3RlcHM6ICc9JyxcclxuICAgICAgICAgICAgbnVtYmVyZWQ6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUoZXhwb3J0cy5kaXJlY3RpdmVOYW1lLCBtdWx0aVN0ZXBJbmRpY2F0b3IpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBNdWx0aVN0ZXBJbmRpY2F0b3JDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlTdGVwSW5kaWNhdG9yLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9tdWx0aVN0ZXBJbmRpY2F0b3IvbXVsdGlTdGVwSW5kaWNhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwibXVsdGktc3RlcCBjaGVja2VkXFxcIiBuZy1jbGFzcz1cXFwieyAnbnVtYmVyZWQnOiBicmVhZGNydW1iLm51bWJlcmVkIH1cXFwiPlxcclxcblxcdDxvbD5cXHJcXG5cXHRcXHQ8bGkgbmctcmVwZWF0PVxcXCJzdGVwIGluIGJyZWFkY3J1bWIuc3RlcHNcXFwiIG5nLWNsaWNrPVxcXCJicmVhZGNydW1iLm9uQ2xpY2soc3RlcClcXFwiXFxyXFxuXFx0XFx0XFx0bmctY2xhc3M9XFxcInsgJ2NvbXBsZXRlZCc6IHN0ZXAuZ2V0Q29tcGxldGVkKCksICdjdXJyZW50Jzogc3RlcC5pc0N1cnJlbnQsICdhY3RpdmUnOiAhc3RlcC5pbmFjdGl2ZSAmJiAhYnJlYWRjcnVtYi5hbnlMb2FkaW5nKCkgfVxcXCI+XFxyXFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwid3JhcFxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PHAgY2xhc3M9XFxcImJhZGdlXFxcIiBuZy1zaG93PVxcXCJzdGVwLmhhc0NvdW50XFxcIj57e3N0ZXAuY291bnQoKX19PC9wPlxcclxcblxcdFxcdFxcdFxcdDxwIGNsYXNzPVxcXCJlcnJvclxcXCIgbmctaWY9XFxcIiFzdGVwLmdldFZhbGlkKClcXFwiPjwvcD5cXHJcXG5cXHRcXHRcXHRcXHQ8cCBjbGFzcz1cXFwidGl0bGVcXFwiPnt7c3RlcC50aXRsZX19IDxybC1idXN5IGxvYWRpbmc9XFxcInN0ZXAubG9hZGluZ1xcXCI+PC9ybC1idXN5PjwvcD5cXHJcXG5cXHRcXHRcXHRcXHQ8cCBjbGFzcz1cXFwic3VidGl0bGVcXFwiPnt7c3RlcC5zdWJ0aXRsZX19PC9wPlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvbGk+XFxyXFxuXFx0PC9vbD5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9tdWx0aVN0ZXBJbmRpY2F0b3IvbXVsdGlTdGVwSW5kaWNhdG9yLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciByYWRpb0dyb3VwXzEgPSByZXF1aXJlKCcuL3JhZGlvR3JvdXAnKTtcclxuZXhwb3J0cy5yYWRpb0dyb3VwRGlyZWN0aXZlTmFtZSA9IHJhZGlvR3JvdXBfMS5kaXJlY3RpdmVOYW1lO1xyXG5leHBvcnRzLnJhZGlvR3JvdXAgPSByYWRpb0dyb3VwXzEucmFkaW9Hcm91cDtcclxuZXhwb3J0cy5yYWRpb0dyb3VwQ29udHJvbGxlck5hbWUgPSByYWRpb0dyb3VwXzEuY29udHJvbGxlck5hbWU7XHJcbmV4cG9ydHMuUmFkaW9Hcm91cENvbnRyb2xsZXIgPSByYWRpb0dyb3VwXzEuUmFkaW9Hcm91cENvbnRyb2xsZXI7XHJcbnZhciByYWRpb18xID0gcmVxdWlyZSgnLi9yYWRpbycpO1xyXG5leHBvcnRzLnJhZGlvRGlyZWN0aXZlTmFtZSA9IHJhZGlvXzEuZGlyZWN0aXZlTmFtZTtcclxuZXhwb3J0cy5yYWRpbyA9IHJhZGlvXzEucmFkaW87XHJcbmV4cG9ydHMucmFkaW9Db250cm9sbGVyTmFtZSA9IHJhZGlvXzEuY29udHJvbGxlck5hbWU7XHJcbmV4cG9ydHMuUmFkaW9Db250cm9sbGVyID0gcmFkaW9fMS5SYWRpb0NvbnRyb2xsZXI7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybDIxLmNvbXBvbmVudHMucmFkaW8nO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29iamVjdC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUocmFkaW9Hcm91cF8xLmRpcmVjdGl2ZU5hbWUsIHJhZGlvR3JvdXBfMS5yYWRpb0dyb3VwKVxyXG4gICAgLmNvbnRyb2xsZXIocmFkaW9Hcm91cF8xLmNvbnRyb2xsZXJOYW1lLCByYWRpb0dyb3VwXzEuUmFkaW9Hcm91cENvbnRyb2xsZXIpXHJcbiAgICAuZGlyZWN0aXZlKHJhZGlvXzEuZGlyZWN0aXZlTmFtZSwgcmFkaW9fMS5yYWRpbylcclxuICAgIC5jb250cm9sbGVyKHJhZGlvXzEuY29udHJvbGxlck5hbWUsIHJhZGlvXzEuUmFkaW9Db250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFkaW8ubW9kdWxlLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYWRpby9yYWRpby5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JqZWN0ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxuZXhwb3J0cy5kaXJlY3RpdmVOYW1lID0gJ3JsUmFkaW9Hcm91cCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmFkaW9Hcm91cENvbnRyb2xsZXInO1xyXG52YXIgUmFkaW9Hcm91cCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSYWRpb0dyb3VwKCRzY29wZSwgbmdNb2RlbCwgbmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nTW9kZWwuJHZpZXdWYWx1ZTsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0aW9uOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSYWRpb0dyb3VwO1xyXG59KCkpO1xyXG5leHBvcnRzLlJhZGlvR3JvdXAgPSBSYWRpb0dyb3VwO1xyXG52YXIgUmFkaW9Hcm91cENvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmFkaW9Hcm91cENvbnRyb2xsZXIoJHNjb3BlLCAkYXR0cnMsICRlbGVtZW50LCBvYmplY3QpIHtcclxuICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICBpZiAoIW9iamVjdC5pc051bGxPcldoaXRlc3BhY2UoJGF0dHJzLnJsUmFkaW9Hcm91cCkpIHtcclxuICAgICAgICAgICAgbmFtZSA9ICRhdHRycy5ybFJhZGlvR3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvYmplY3QuaXNOdWxsT3JXaGl0ZXNwYWNlKCRhdHRycy5uYW1lKSkge1xyXG4gICAgICAgICAgICBuYW1lID0gJGF0dHJzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuYW1lID0gJ1JhZGlvR3JvdXAnICsgdGhpcy5nZXROZXh0SWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5nTW9kZWwgPSAkZWxlbWVudC5jb250cm9sbGVyKCduZ01vZGVsJyk7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBSYWRpb0dyb3VwKCRzY29wZSwgbmdNb2RlbCwgbmFtZSk7XHJcbiAgICB9XHJcbiAgICBSYWRpb0dyb3VwQ29udHJvbGxlci5wcm90b3R5cGUucmVnaXN0ZXJCdXR0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXA7XHJcbiAgICB9O1xyXG4gICAgUmFkaW9Hcm91cENvbnRyb2xsZXIucHJvdG90eXBlLmdldE5leHRJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbmV4dElkID0gUmFkaW9Hcm91cENvbnRyb2xsZXIubmV4dElkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgUmFkaW9Hcm91cENvbnRyb2xsZXIubmV4dElkKys7XHJcbiAgICAgICAgcmV0dXJuIG5leHRJZDtcclxuICAgIH07XHJcbiAgICBSYWRpb0dyb3VwQ29udHJvbGxlci5uZXh0SWQgPSAxO1xyXG4gICAgUmFkaW9Hcm91cENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRhdHRycycsICckZWxlbWVudCcsIF9fb2JqZWN0LnNlcnZpY2VOYW1lXTtcclxuICAgIHJldHVybiBSYWRpb0dyb3VwQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5SYWRpb0dyb3VwQ29udHJvbGxlciA9IFJhZGlvR3JvdXBDb250cm9sbGVyO1xyXG5mdW5jdGlvbiByYWRpb0dyb3VwKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0FFJyxcclxuICAgICAgICByZXF1aXJlOiAnbmdNb2RlbCcsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5yYWRpb0dyb3VwID0gcmFkaW9Hcm91cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFkaW9Hcm91cC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmFkaW8vcmFkaW9Hcm91cC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgcmFkaW9Hcm91cF8xID0gcmVxdWlyZSgnLi9yYWRpb0dyb3VwJyk7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFJhZGlvJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdSYWRpb0NvbnRyb2xsZXInO1xyXG52YXIgUmFkaW9Db250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbGxlcigkc2NvcGUsICRlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHJhZGlvR3JvdXBDb250cm9sbGVyID0gJGVsZW1lbnQuY29udHJvbGxlcigncmxSYWRpb0dyb3VwJyk7XHJcbiAgICAgICAgaWYgKHJhZGlvR3JvdXBDb250cm9sbGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwID0gcmFkaW9Hcm91cENvbnRyb2xsZXIucmVnaXN0ZXJCdXR0b24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBuZ01vZGVsID0gJGVsZW1lbnQuY29udHJvbGxlcignbmdNb2RlbCcpO1xyXG4gICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAgPSBuZXcgcmFkaW9Hcm91cF8xLlJhZGlvR3JvdXAoJHNjb3BlLCBuZ01vZGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBSYWRpb0NvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRlbGVtZW50J107XHJcbiAgICByZXR1cm4gUmFkaW9Db250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlJhZGlvQ29udHJvbGxlciA9IFJhZGlvQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gcmFkaW8oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgcmVxdWlyZTogWyc/Xl5ybFJhZGlvR3JvdXAnLCAnP25nTW9kZWwnXSxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxsYWJlbD5cXG5cXHRcXHRcXHRcXHQ8aW5wdXQgaWQ9XFxcInJhZGlvXFxcIiB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwie3tyYWRpby5yYWRpb0dyb3VwLm5hbWV9fVxcXCIgbmctbW9kZWw9XFxcInJhZGlvLnJhZGlvR3JvdXAuc2VsZWN0aW9uXFxcIiBuZy12YWx1ZT1cXFwicmFkaW8udmFsdWVcXFwiIC8+XFxuXFx0XFx0XFx0XFx0PHNwYW4gbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cXHRcXHRcXHQ8L2xhYmVsPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAncmFkaW8nLFxyXG4gICAgICAgIHNjb3BlOiB0cnVlLFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgdmFsdWU6ICc9JyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJhZGlvID0gcmFkaW87XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhZGlvLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yYWRpby9yYWRpby5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIHJhdGluZ0JhckJhY2tncm91bmRzX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4vcmF0aW5nQmFyQmFja2dyb3VuZHMuc2VydmljZScpO1xyXG52YXIgcmF0aW5nQmFyQ2xhc3Nfc2VydmljZV8xID0gcmVxdWlyZSgnLi9yYXRpbmdCYXJDbGFzcy5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnJhdGluZ0Jhcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFJhdGluZ0Jhcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmF0aW5nQmFyQ29udHJvbGxlcic7XHJcbnZhciBSYXRpbmdCYXJDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhdGluZ0JhckNvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB2YXIgcmF0aW5nQmFyQmFja2dyb3VuZHMgPSBuZXcgcmF0aW5nQmFyQmFja2dyb3VuZHNfc2VydmljZV8xLlJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMucmF0aW5nQmFyQ2xhc3MgPSBuZXcgcmF0aW5nQmFyQ2xhc3Nfc2VydmljZV8xLlJhdGluZ0JhckNsYXNzU2VydmljZTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDbGFzcyA9IHJhdGluZ0JhckJhY2tncm91bmRzLmdldEJhY2tncm91bmQodGhpcy5iYWNrZ3JvdW5kKTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnZhbHVlOyB9LCBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlVmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudG90YWxXaWR0aDsgfSwgZnVuY3Rpb24gKG5ld1dpZHRoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAyLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy5oZWlnaHQgKyAyLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGVWYWx1ZShfdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBSYXRpbmdCYXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgIHZhciBjb25maWRlbmNlU2NvcmUgPSAobmV3VmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XHJcbiAgICAgICAgdGhpcy5iYXJDbGFzcyA9IHRoaXMucmF0aW5nQmFyQ2xhc3MuZ2V0Q2xhc3MoY29uZmlkZW5jZVNjb3JlKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5yb3VuZChjb25maWRlbmNlU2NvcmUgKiB0aGlzLnRvdGFsV2lkdGgpO1xyXG4gICAgfTtcclxuICAgIFJhdGluZ0JhckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJ107XHJcbiAgICByZXR1cm4gUmF0aW5nQmFyQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5SYXRpbmdCYXJDb250cm9sbGVyID0gUmF0aW5nQmFyQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gcmF0aW5nQmFyKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInJhdGluZy1iYXJcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcInt7cmF0aW5nQmFyLmJhY2tncm91bmRDbGFzc319XFxcIiBuZy1jbGFzcz1cXFwieyBlbXB0eTogcmF0aW5nQmFyLnZhbHVlID09IG1pbiB9XFxcIiBuZy1zdHlsZT1cXFwicmF0aW5nQmFyLmRpbWVuc2lvbnNcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxkaXYgbmctY2xhc3M9XFxcInJhdGluZ0Jhci5iYXJDbGFzc1xcXCIgbmctc3R5bGU9XFxcInsgd2lkdGg6IHJhdGluZ0Jhci53aWR0aCwgaGVpZ2h0OiByYXRpbmdCYXIuaGVpZ2h0IH1cXFwiPjwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAncmF0aW5nQmFyJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICB0b3RhbFdpZHRoOiAnPXdpZHRoJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnPScsXHJcbiAgICAgICAgICAgIHZhbHVlOiAnPScsXHJcbiAgICAgICAgICAgIG1pbjogJz0nLFxyXG4gICAgICAgICAgICBtYXg6ICc9JyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZDogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmF0aW5nQmFyID0gcmF0aW5nQmFyO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHJhdGluZ0JhcilcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFJhdGluZ0JhckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRpbmdCYXIuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JhdGluZ0Jhci9yYXRpbmdCYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIFJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlKCkge1xyXG4gICAgICAgIHRoaXMuc3RhbmRhcmQgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdzdGFuZGFyZCcsXHJcbiAgICAgICAgICAgIGNsYXNzOiAnYmFja2dyb3VuZCcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRhcmsgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdkYXJrJyxcclxuICAgICAgICAgICAgY2xhc3M6ICdiYWNrZ3JvdW5kLWRhcmsnLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgY2xhc3M6ICdiYWNrZ3JvdW5kLXRyYW5zcGFyZW50JyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgUmF0aW5nQmFyQmFja2dyb3VuZFNlcnZpY2UucHJvdG90eXBlLmdldEJhY2tncm91bmQgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlID09PSB0aGlzLmRhcmsudHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXJrLmNsYXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSB0aGlzLnRyYW5zcGFyZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwYXJlbnQuY2xhc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFuZGFyZC5jbGFzcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlO1xyXG59KCkpO1xyXG5leHBvcnRzLlJhdGluZ0JhckJhY2tncm91bmRTZXJ2aWNlID0gUmF0aW5nQmFyQmFja2dyb3VuZFNlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhdGluZ0JhckJhY2tncm91bmRzLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JhdGluZ0Jhci9yYXRpbmdCYXJCYWNrZ3JvdW5kcy5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBSYXRpbmdCYXJDbGFzc1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlKCkge1xyXG4gICAgfVxyXG4gICAgUmF0aW5nQmFyQ2xhc3NTZXJ2aWNlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChjb25maWRlbmNlKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZGVuY2UgPj0gMC44KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndmVyeS1oaWdoJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlkZW5jZSA+PSAwLjYpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdoaWdoJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlkZW5jZSA+PSAwLjQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtZWRpdW0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25maWRlbmNlID49IDAuMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xvdyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3ZlcnktbG93JztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJhdGluZ0JhckNsYXNzU2VydmljZTtcclxufSgpKTtcclxuZXhwb3J0cy5SYXRpbmdCYXJDbGFzc1NlcnZpY2UgPSBSYXRpbmdCYXJDbGFzc1NlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhdGluZ0JhckNsYXNzLnNlcnZpY2UuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JhdGluZ0Jhci9yYXRpbmdCYXJDbGFzcy5zZXJ2aWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxucmVxdWlyZSgnbmctd2lnL2Rpc3QvY3NzL25nLXdpZy5jc3MnKTtcclxucmVxdWlyZSgnbmctd2lnL2Rpc3Qvbmctd2lnJyk7XHJcbnJlcXVpcmUoJy4vZWRpdG9yQnV0dG9ucy5jc3MnKTtcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBpbnB1dF8xID0gcmVxdWlyZSgnLi4vaW5wdXQvaW5wdXQnKTtcclxudmFyIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UnKTtcclxudmFyIHJpY2hUZXh0RWRpdG9yX2NvbmZpZ18xID0gcmVxdWlyZSgnLi9yaWNoVGV4dEVkaXRvci5jb25maWcnKTtcclxudmFyIGhlYWRlckJ1dHRvbl8xID0gcmVxdWlyZSgnLi9oZWFkZXJCdXR0b24nKTtcclxudmFyIHBhcmFncmFwaEJ1dHRvbl8xID0gcmVxdWlyZSgnLi9wYXJhZ3JhcGhCdXR0b24nKTtcclxudmFyIGV4dGVybmFsUHJvdmlkZXJOYW1lID0gcmljaFRleHRFZGl0b3JfY29uZmlnXzEucHJvdmlkZXJOYW1lICsgJ1Byb3ZpZGVyJztcclxuZXhwb3J0cy5wcm92aWRlck5hbWUgPSBleHRlcm5hbFByb3ZpZGVyTmFtZTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMucmljaFRleHRFZGl0b3InO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxSaWNoVGV4dEVkaXRvcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnUmljaFRleHRFZGl0b3JDb250cm9sbGVyJztcclxudmFyIFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUmljaFRleHRFZGl0b3JDb250cm9sbGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmljaFRleHRFZGl0b3JDb250cm9sbGVyKCRzY29wZSwgJGF0dHJzLCBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5LCBvYmplY3QsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJHNjb3BlLCAkYXR0cnMsIGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRUeXBlID0gJ3JpY2gtdGV4dC1lZGl0b3InO1xyXG4gICAgICAgIHRoaXMudG9vbGJhciA9ICdoMSwgcGFyYWdyYXBoLCBib2xkLCBpdGFsaWMsIHVuZGVybGluZSwgbGlzdDEsIGxpc3QyLCBpbmRlbnQsIG91dGRlbnQnO1xyXG4gICAgICAgIGlmICghb2JqZWN0LmlzTnVsbE9yRW1wdHkodGhpcy5jdXN0b21CdXR0b25zKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2xiYXIgKz0gJywgJyArIHRoaXMuY3VzdG9tQnV0dG9ucztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBSaWNoVGV4dEVkaXRvckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRhdHRycycsIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEuZmFjdG9yeU5hbWUsIF9fb2JqZWN0LnNlcnZpY2VOYW1lLCByaWNoVGV4dEVkaXRvcl9jb25maWdfMS5wcm92aWRlck5hbWVdO1xyXG4gICAgcmV0dXJuIFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlcjtcclxufShpbnB1dF8xLklucHV0Q29udHJvbGxlcikpO1xyXG5leHBvcnRzLlJpY2hUZXh0RWRpdG9yQ29udHJvbGxlciA9IFJpY2hUZXh0RWRpdG9yQ29udHJvbGxlcjtcclxudmFyIHJpY2hUZXh0RWRpdG9yID0gXy5jbG9uZShpbnB1dF8xLmlucHV0KTtcclxucmljaFRleHRFZGl0b3IudGVtcGxhdGUgPSByZXF1aXJlKCcuL3JpY2hUZXh0RWRpdG9yLmh0bWwnKTtcclxucmljaFRleHRFZGl0b3IuY29udHJvbGxlciA9IGV4cG9ydHMuY29udHJvbGxlck5hbWU7XHJcbnJpY2hUZXh0RWRpdG9yLmNvbnRyb2xsZXJBcyA9ICdlZGl0b3InO1xyXG52YXIgcmljaFRleHRFZGl0b3JCaW5kaW5ncyA9IHJpY2hUZXh0RWRpdG9yLmJpbmRpbmdzO1xyXG5yaWNoVGV4dEVkaXRvckJpbmRpbmdzLmN1c3RvbUJ1dHRvbnMgPSAnPD8nO1xyXG5yaWNoVGV4dEVkaXRvckJpbmRpbmdzLm5nRGlzYWJsZWQgPSAnPD8nO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFsnbmdXaWcnLCBfX29iamVjdC5tb2R1bGVOYW1lLCBpbnB1dF8xLm1vZHVsZU5hbWVdKVxyXG4gICAgLmNvbXBvbmVudChleHBvcnRzLmNvbXBvbmVudE5hbWUsIHJpY2hUZXh0RWRpdG9yKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgUmljaFRleHRFZGl0b3JDb250cm9sbGVyKVxyXG4gICAgLmRpcmVjdGl2ZShoZWFkZXJCdXR0b25fMS5oZWFkZXJCdXR0b25EaXJlY3RpdmVOYW1lLCBoZWFkZXJCdXR0b25fMS5oZWFkZXJCdXR0b24pXHJcbiAgICAuZGlyZWN0aXZlKHBhcmFncmFwaEJ1dHRvbl8xLnBhcmFncmFwaEJ1dHRvbkRpcmVjdGl2ZU5hbWUsIHBhcmFncmFwaEJ1dHRvbl8xLnBhcmFncmFwaEJ1dHRvbilcclxuICAgIC5wcm92aWRlcihyaWNoVGV4dEVkaXRvcl9jb25maWdfMS5wcm92aWRlck5hbWUsIHJpY2hUZXh0RWRpdG9yX2NvbmZpZ18xLnJpY2hUZXh0RWRpdG9yUHJvdmlkZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaWNoVGV4dEVkaXRvci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvcmljaFRleHRFZGl0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9uZy13aWcuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9uZy13aWcuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9uZy13aWcuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9uZy13aWcvZGlzdC9jc3Mvbmctd2lnLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNC4wL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyk7XCIsIFwiXCJdKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiAtLS0tLS0tLSBORy1XSUcgLS0tLS0tLS0gKi9cXG4vKipcXG4gKlxcbiAqICBSRVNFVCBCT1ggTU9ERUxcXG4gKlxcbiAqL1xcbi5uZy13aWcsXFxuW2NsYXNzXj1cXFwibnctXFxcIl0ge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLW8tYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC1tcy1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuXFxuLyoqXFxuICogICBtYWluIHdyYXBwZXIgZm9yIHRoZSBlZGl0b3JcXG4gKlxcbiAqICAubmctd2lnXFxuICpcXG4gKi9cXG4ubmctd2lnIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuXFxuLyoqXFxuICogIHN0eWxpbmcgZm9yIHRvb2xiYXIgYW5kIGl0cyBpdGVtc1xcbiAqXFxuICogIC5udy10b29sYmFyXFxuICogICAgJl9faXRlbVxcbiAqXFxuICovXFxuLm53LXRvb2xiYXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW46IDAgIWltcG9ydGFudDtcXG4gIHBhZGRpbmc6IDAgIWltcG9ydGFudDtcXG4gIGxpc3Qtc3R5bGU6IG5vbmUgIWltcG9ydGFudDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiAjNkI3Mjc3O1xcblxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoOTBkZWcsICNmZmZmZmYgMCUsICNmOWY5ZjkgMTAwJSk7XFxuICBiYWNrZ3JvdW5kOiAgICAtbW96LWxpbmVhci1ncmFkaWVudCg5MGRlZywgI2ZmZmZmZiAwJSwgI2Y5ZjlmOSAxMDAlKTtcXG4gIGJhY2tncm91bmQ6ICAgICAgICAgbGluZWFyLWdyYWRpZW50KDE4MGRlZywgI2ZmZmZmZiAwJSwgI2Y5ZjlmOSAxMDAlKTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNDQ0NDQ0M7XFxuICBib3JkZXItcmFkaXVzOiAzcHggM3B4IDAgMDtcXG59XFxuXFxuLm53LXRvb2xiYXJfX2l0ZW0ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gIG1hcmdpbjogMDtcXG5cXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNERURFREU7XFxufVxcblxcbi5udy10b29sYmFyIGxhYmVsIHtcXG4gIGxpbmUtaGVpZ2h0OiAzMHB4O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgcGFkZGluZzogMCA2cHggMCAzcHg7XFxufVxcblxcbi5udy10b29sYmFyIGlucHV0W3R5cGU9Y2hlY2tib3hdIHtcXG4gIHZlcnRpY2FsLWFsaWduOiAtM3B4O1xcbiAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xcbn1cXG5cXG4vKipcXG4gKiAgc3R5bGluZyBmb3IgdGhlIGVkaXRvciBwYXJ0OiBzb3VyY2UgY29kZSAob3JpZ2luYWwgdGV4dGFyZWEpIGFuZCByZXN1bHRpbmcgZGl2XFxuICpcXG4gKiAgLm53LWVkaXRvclxcbiAqICAgICZfX3NyY1xcbiAqICAgICZfX3Jlc1xcbiAqXFxuICovXFxuLm53LWVkaXRvciB7XFxuICBkaXNwbGF5OiB0YWJsZTtcXG4gIC8qIERlZmF1bHQgd2hlbiBoZWlnaHQgaXMgbm90IHNldCAqL1xcbiAgaGVpZ2h0OiAzMDBweDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBjdXJzb3I6IHRleHQ7XFxuICB3aWR0aDoxMDAlO1xcbn1cXG5cXG4ubnctZWRpdG9yLWNvbnRhaW5lciB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDQ0NDO1xcbiAgYm9yZGVyLXRvcDogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDAgMCAzcHggM3B4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4ubnctZWRpdG9yX19yZXMge1xcbiAgbWluLWhlaWdodDogMTAwJTtcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbiAgZGlzcGxheTogdGFibGUtY2VsbDtcXG59XFxuXFxuLm53LWVkaXRvcl9fc3JjLFxcbi5udy1lZGl0b3JfX3JlcyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4ubnctZWRpdG9yX19zcmMtY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG59XFxuXFxuLm53LWVkaXRvcl9fc3JjIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHJlc2l6ZTogbm9uZTtcXG4gIHBhZGRpbmc6IDAgOHB4O1xcbn1cXG5cXG4ubnctZWRpdG9yLS1maXhlZCAubnctZWRpdG9yIHtcXG4gIGRpc3BsYXk6YmxvY2s7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbn1cXG5cXG4ubnctZWRpdG9yLS1maXhlZCAubnctZWRpdG9yX19yZXMge1xcbiAgcGFkZGluZzogMXB4IDhweDtcXG4gIGRpc3BsYXk6YmxvY2s7XFxufVxcblxcbi5udy1pbnZpc2libGUge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG5cXG4ubnctZWRpdG9yLS1maXhlZCAubnctaW52aXNpYmxlIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi5udy1lZGl0b3IubnctZGlzYWJsZWQge1xcblxcdGN1cnNvcjogZGVmYXVsdDtcXG59XFxuXFxuLyoqXFxuICogIHN0eWxpbmcgZm9yIHRvb2xiYXIgYnV0dG9uLCBoYXMgdHdvIG1vZGlmaWVyczogYWN0aXZlIGFuZCB0eXBlIG9mIGljb24gZm9yIGJhY2tncm91bmRcXG4gKlxcbiAqICAubnctYnV0dG9uXFxuICogICAgJi0tYWN0aXZlXFxuICogICAgJi0te2J1dHRvbiB0eXBlfVxcbiAqXFxuICovXFxuLm53LWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAtbW96LWFwcGVhcmFuY2U6ICAgIG5vbmU7XFxuICBhcHBlYXJhbmNlOiAgICAgICAgIG5vbmU7XFxuXFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAzMHB4O1xcbiAgaGVpZ2h0OiAzMHB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG9wYWNpdHk6IDAuNTtcXG5cXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxuXFxuICBmb250LXNpemU6IDA7XFxuXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5udy1idXR0b246YmVmb3JlIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGZvbnQtZmFtaWx5OiBGb250QXdlc29tZTtcXG59XFxuXFxuLm53LWJ1dHRvbi5ib2xkOmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXEYwMzInO1xcbn1cXG5cXG4ubnctYnV0dG9uLml0YWxpYzpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFxGMDMzJztcXG59XFxuXFxuLm53LWJ1dHRvbi5saXN0LXVsOmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXEYwQ0EnO1xcbn1cXG5cXG4ubnctYnV0dG9uLmxpc3Qtb2w6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICdcXFxcRjBDQic7XFxufVxcblxcbi5udy1idXR0b24ubGluazpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFxGMEMxJztcXG59XFxuXFxuLm53LWJ1dHRvbi5mb250LWNvbG9yOmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXEYwMzEnO1xcbn1cXG5cXG4ubnctYnV0dG9uLm53LWJ1dHRvbi0tc291cmNlOmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXEYwNDAnO1xcbn1cXG5cXG4ubnctYnV0dG9uOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcblxcbi5udy1idXR0b246aG92ZXIsXFxuLm53LWJ1dHRvbi5udy1idXR0b24tLWFjdGl2ZSB7XFxuICBvcGFjaXR5OiAxXFxufVxcblxcbi5udy1idXR0b24tLWFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRUVFRUVFO1xcbn1cXG5cXG4ubnctYnV0dG9uOmRpc2FibGVkIHtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuLm53LWJ1dHRvbjpkaXNhYmxlZDpob3ZlciB7XFxuICBvcGFjaXR5OiAwLjU7XFxufVxcblxcbi8qKlxcbiAqICBzdHlsaW5nICYgZm9ybWF0dGluZyBvZiBjb250ZW50IGluc2lkZSBjb250ZW50ZWRpdGFibGUgZGl2XFxuICpcXG4gKiAgLm53LWNvbnRlbnRcXG4gKlxcbiAqL1xcbi5udy1jb250ZW50IHtcXG4gIHBhZGRpbmc6IDEycHg7XFxuICBtYXJnaW46IDA7XFxuXFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbn1cXG5cXG4ubnctc2VsZWN0IHtcXG4gIGhlaWdodDogMzBweDtcXG4gIHBhZGRpbmc6IDZweDtcXG4gIGNvbG9yOiAjNTU1O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gIGJvcmRlcjogMDtcXG59XFxuXFxuLm53LXNlbGVjdDpkaXNhYmxlZCB7XFxuXFx0b3BhY2l0eTogMC41O1xcbn1cXG5cXG4ubnctc2VsZWN0OmZvY3VzIHsgb3V0bGluZTogbm9uZTsgfVxcblxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L25nLXdpZy9kaXN0L2Nzcy9uZy13aWcuY3NzXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIHZlcnNpb246IDIuMy40XG4gKi9cbmFuZ3VsYXIubW9kdWxlKCduZ1dpZycsIFsnbmd3aWctYXBwLXRlbXBsYXRlcyddKTtcblxuYW5ndWxhci5tb2R1bGUoJ25nV2lnJylcbiAgLmRpcmVjdGl2ZSgnbmdXaWcnLCBbXCIkd2luZG93XCIsIFwiJGRvY3VtZW50XCIsIFwibmdXaWdUb29sYmFyXCIsIGZ1bmN0aW9uICgkd2luZG93LCAkZG9jdW1lbnQsIG5nV2lnVG9vbGJhcikge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGNvbnRlbnQ6ICc9bmdXaWcnLFxuICAgICAgICBvblBhc3RlOiAnPSdcbiAgICAgIH0sXG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiAnbmctd2lnL3ZpZXdzL25nLXdpZy5odG1sJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgc2NvcGUuZm9ybUVsZW1lbnROYW1lID0gYXR0cnMubmFtZTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyKCduYW1lJyk7XG5cbiAgICAgICAgc2NvcGUuaXNSZXF1aXJlZCA9ICEhYXR0cnMucmVxdWlyZWQ7XG4gICAgICAgIHNjb3BlLmlzU291cmNlTW9kZUFsbG93ZWQgPSBPYmplY3Qua2V5cyhhdHRycykuaW5kZXhPZignc291cmNlTW9kZUFsbG93ZWQnKSAhPT0gLTEgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHNjb3BlLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgICAgIHNjb3BlLnRvb2xiYXJCdXR0b25zID0gbmdXaWdUb29sYmFyLmdldFRvb2xiYXJCdXR0b25zKGF0dHJzLmJ1dHRvbnMgJiYgc3RyaW5nMmFycmF5KGF0dHJzLmJ1dHRvbnMpKTtcblxuICAgICAgICBmdW5jdGlvbiBzdHJpbmcyYXJyYXkoa2V5c1N0cmluZyl7XG4gICAgICAgICAgcmV0dXJuIGtleXNTdHJpbmcuc3BsaXQoJywnKS5tYXAoRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsIFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS50b2dnbGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY29wZS5lZGl0TW9kZSA9ICFzY29wZS5lZGl0TW9kZTtcblxuICAgICAgICAgIGlmICgkd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcykge1xuICAgICAgICAgICAgJHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCwgb3B0aW9ucykge1xuICAgICAgICAgIGlmKHNjb3BlLmVkaXRNb2RlICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGNvbW1hbmQgPT09ICdjcmVhdGVsaW5rJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb21wdCgnUGxlYXNlIGVudGVyIHRoZSBVUkwnLCAnaHR0cDovLycpO1xuICAgICAgICAgICAgaWYoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzY29wZS4kYnJvYWRjYXN0KCdleGVjQ29tbWFuZCcsIHtjb21tYW5kOiBjb21tYW5kLCBvcHRpb25zOiBvcHRpb25zfSk7XG4gICAgICAgIH07XG5cdFx0XG5cdFx0aWYgKGF0dHJzLm5nRGlzYWJsZWQgIT0gbnVsbCB8fCBhdHRycy5kaXNhYmxlZCAhPSBudWxsKSB7XG5cdFx0XHRzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiAhIWF0dHJzLmRpc2FibGVkOyB9LCBmdW5jdGlvbihpc0Rpc2FibGVkKSB7XG5cdFx0XHRcdHNjb3BlLmlzRGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuXHRcdFx0XHRzY29wZS4kYnJvYWRjYXN0KCdudy1kaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuXHRcdFx0fSk7XHRcblx0XHR9XG4gICAgICB9XG4gICAgfVxuICB9XVxuKTtcblxuXG5hbmd1bGFyLm1vZHVsZSgnbmdXaWcnKVxuICAuZGlyZWN0aXZlKCduZ1dpZ0VkaXRhYmxlJywgW1wiJGRvY3VtZW50XCIsIGZ1bmN0aW9uICgkZG9jdW1lbnQpIHtcbiAgICBmdW5jdGlvbiBpbml0KHNjb3BlLCAkZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDb250cm9sbGVyKSB7XG5cbiAgICAgICRlbGVtZW50LmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScsIHRydWUpO1xuXG4gICAgICAvL21vZGVsIC0tPiB2aWV3XG4gICAgICBuZ01vZGVsQ29udHJvbGxlci4kcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkZWxlbWVudC5odG1sKG5nTW9kZWxDb250cm9sbGVyLiR2aWV3VmFsdWUgfHwgJycpO1xuICAgICAgfTtcblxuICAgICAgLy92aWV3IC0tPiBtb2RlbFxuICAgICAgZnVuY3Rpb24gdmlld1RvTW9kZWwoKSB7XG4gICAgICAgIG5nTW9kZWxDb250cm9sbGVyLiRzZXRWaWV3VmFsdWUoJGVsZW1lbnQuaHRtbCgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2ZW50c1RvQmluZCA9IFtcbiAgICAgICAgJ2JsdXInLFxuICAgICAgICAna2V5dXAnLFxuICAgICAgICAnY2hhbmdlJyxcbiAgICAgICAgJ2ZvY3VzJyxcbiAgICAgICAgJ2NsaWNrJ1xuICAgICAgXTtcblxuICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzY29wZS5vblBhc3RlKSkge1xuICAgICAgICAkZWxlbWVudC5vbigncGFzdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgc2NvcGUub25QYXN0ZShlLCAkZWxlbWVudC5odG1sKCkpLnRoZW4oZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAkZWxlbWVudC5odG1sKHZhbCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZXZlbnRzVG9CaW5kLnB1c2goJ3Bhc3RlJyk7XG4gICAgICB9XG5cbiAgICAgICRlbGVtZW50LmJpbmQoZXZlbnRzVG9CaW5kLmpvaW4oJyAnKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZpZXdUb01vZGVsKCk7XG4gICAgICAgIHNjb3BlLiRhcHBseUFzeW5jKCk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuaXNFZGl0b3JBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAkZWxlbWVudFswXSA9PT0gJGRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICBzY29wZS4kb24oJ2V4ZWNDb21tYW5kJywgZnVuY3Rpb24gKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgJGVsZW1lbnRbMF0uZm9jdXMoKTtcblxuICAgICAgICB2YXIgaWVTdHlsZVRleHRTZWxlY3Rpb24gPSAkZG9jdW1lbnRbMF0uc2VsZWN0aW9uLFxuICAgICAgICAgIGNvbW1hbmQgPSBwYXJhbXMuY29tbWFuZCxcbiAgICAgICAgICBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGllU3R5bGVUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIHRleHRSYW5nZSA9IGllU3R5bGVUZXh0U2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGRvY3VtZW50WzBdLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCAmJiAhJGRvY3VtZW50WzBdLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjb21tYW5kKSkge1xuICAgICAgICAgIHRocm93ICdUaGUgY29tbWFuZCBcIicgKyBjb21tYW5kICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgJGRvY3VtZW50WzBdLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoaWVTdHlsZVRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB0ZXh0UmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgIHRleHRSYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXdUb01vZGVsKCk7XG4gICAgICB9KTtcblx0ICBcblx0ICBzY29wZS4kb24oJ253LWRpc2FibGVkJywgZnVuY3Rpb24oZXZlbnQsIGlzRGlzYWJsZWQpIHtcblx0XHQgICRlbGVtZW50LmF0dHIoJ2NvbnRlbnRlZGl0YWJsZScsICFpc0Rpc2FibGVkKTtcblx0ICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBsaW5rOiBpbml0XG4gICAgfVxuICB9XVxuKTtcblxuYW5ndWxhci5tb2R1bGUoJ25nV2lnJylcbiAgICAuZGlyZWN0aXZlKCduZ1dpZ1BsdWdpbicsIFtcIiRjb21waWxlXCIsIGZ1bmN0aW9uICgkY29tcGlsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gJzwnICsgc2NvcGUuYnV0dG9uLnBsdWdpbk5hbWUgKyAnIC8+JyxcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQgPSAkY29tcGlsZSh0ZW1wbGF0ZSkoc2NvcGUpO1xuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChjb21waWxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCduZ1dpZycpLnByb3ZpZGVyKCduZ1dpZ1Rvb2xiYXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGJ1dHRvbkxpYnJhcnkgPSB7XG4gICAgbGlzdDE6IHt0aXRsZTogJ1Vub3JkZXJlZCBMaXN0JywgY29tbWFuZDogJ2luc2VydHVub3JkZXJlZGxpc3QnLCBzdHlsZUNsYXNzOiAnbGlzdC11bCd9LFxuICAgIGxpc3QyOiB7dGl0bGU6ICdPcmRlcmVkIExpc3QnLCBjb21tYW5kOiAnaW5zZXJ0b3JkZXJlZGxpc3QnLCBzdHlsZUNsYXNzOiAnbGlzdC1vbCd9LFxuICAgIGJvbGQ6IHt0aXRsZTogJ0JvbGQnLCBjb21tYW5kOiAnYm9sZCcsIHN0eWxlQ2xhc3M6ICdib2xkJ30sXG4gICAgaXRhbGljOiB7dGl0bGU6ICdJdGFsaWMnLCBjb21tYW5kOiAnaXRhbGljJywgc3R5bGVDbGFzczogJ2l0YWxpYyd9LFxuICAgIGxpbms6IHt0aXRsZTogJ0xpbmsnLCBjb21tYW5kOiAnY3JlYXRlbGluaycsIHN0eWxlQ2xhc3M6ICdsaW5rJ31cbiAgfTtcblxuICB2YXIgZGVmYXVsdEJ1dHRvbnNMaXN0ID0gWydsaXN0MScsICdsaXN0MicsICdib2xkJywgJ2l0YWxpYycsICdsaW5rJ107XG5cbiAgdmFyIGlzQnV0dG9uQWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmQgJiYgZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUodGhpcy5jb21tYW5kKTtcbiAgfTtcblxuICB0aGlzLnNldEJ1dHRvbnMgPSBmdW5jdGlvbihidXR0b25zKSB7XG4gICAgaWYoIWFuZ3VsYXIuaXNBcnJheShidXR0b25zKSkge1xuICAgICAgdGhyb3cgJ0FyZ3VtZW50IFwiYnV0dG9uc1wiIHNob3VsZCBiZSBhbiBhcnJheSc7XG4gICAgfVxuXG4gICAgZGVmYXVsdEJ1dHRvbnNMaXN0ID0gYnV0dG9ucztcbiAgfTtcblxuICB0aGlzLmFkZFN0YW5kYXJkQnV0dG9uID0gZnVuY3Rpb24gKG5hbWUsIHRpdGxlLCBjb21tYW5kLCBzdHlsZUNsYXNzKSB7XG4gICAgaWYoIW5hbWUgfHwgIXRpdGxlIHx8ICFjb21tYW5kKSB7XG4gICAgICB0aHJvdyAnQXJndW1lbnRzIFwibmFtZVwiLCBcInRpdGxlXCIgYW5kIFwiY29tbWFuZFwiIGFyZSByZXF1aXJlZCc7XG4gICAgfVxuXG4gICAgc3R5bGVDbGFzcyA9IHN0eWxlQ2xhc3MgfHwgJyc7XG4gICAgYnV0dG9uTGlicmFyeVtuYW1lXSA9IHt0aXRsZTogdGl0bGUsIGNvbW1hbmQ6IGNvbW1hbmQsIHN0eWxlQ2xhc3M6IHN0eWxlQ2xhc3N9XG4gICAgZGVmYXVsdEJ1dHRvbnNMaXN0LnB1c2gobmFtZSk7XG4gIH07XG5cbiAgdGhpcy5hZGRDdXN0b21CdXR0b24gPSBmdW5jdGlvbiAobmFtZSwgcGx1Z2luTmFtZSkge1xuICAgIGlmKCFuYW1lIHx8ICFwbHVnaW5OYW1lKSB7XG4gICAgICB0aHJvdyAnQXJndW1lbnRzIFwibmFtZVwiIGFuZCBcInBsdWdpbk5hbWVcIiBhcmUgcmVxdWlyZWQnO1xuICAgIH1cblxuICAgIGJ1dHRvbkxpYnJhcnlbbmFtZV0gPSB7cGx1Z2luTmFtZTogcGx1Z2luTmFtZSwgaXNDb21wbGV4OiB0cnVlfTtcbiAgICBkZWZhdWx0QnV0dG9uc0xpc3QucHVzaChuYW1lKTtcbiAgfTtcblxuICB0aGlzLiRnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFRvb2xiYXJCdXR0b25zOiBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIHZhciB0b29sYmFyQnV0dG9ucyA9IFtdO1xuICAgICAgICAobGlzdCB8fCBkZWZhdWx0QnV0dG9uc0xpc3QpLmZvckVhY2goZnVuY3Rpb24oYnV0dG9uS2V5KSB7XG4gICAgICAgICAgaWYoIWJ1dHRvbkxpYnJhcnlbYnV0dG9uS2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgJ1RoZXJlIGlzIG5vIFwiJyArIGJ1dHRvbktleSArICdcIiBpbiB5b3VyIGxpYnJhcnkuIFBvc3NpYmxlIHZhcmlhbnRzOiAnICsgT2JqZWN0LmtleXMoYnV0dG9uTGlicmFyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJ1dHRvbiA9IGFuZ3VsYXIuY29weShidXR0b25MaWJyYXJ5W2J1dHRvbktleV0pO1xuXG4gICAgICAgICAgaWYoIWFuZ3VsYXIuaXNGdW5jdGlvbihidXR0b24uaXNBY3RpdmUpKSB7XG4gICAgICAgICAgICBidXR0b24uaXNBY3RpdmUgPSBpc0J1dHRvbkFjdGl2ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b29sYmFyQnV0dG9ucy5wdXNoKGJ1dHRvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG9vbGJhckJ1dHRvbnM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuXG59KTtcbmFuZ3VsYXIubW9kdWxlKCduZ1dpZycpXG4gICAgLmNvbmZpZyhbJ25nV2lnVG9vbGJhclByb3ZpZGVyJywgZnVuY3Rpb24gKG5nV2lnVG9vbGJhclByb3ZpZGVyKSB7XG4gICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkQ3VzdG9tQnV0dG9uKCdmb3JtYXRzJywgJ253LWZvcm1hdHMtYnV0dG9uJyk7XG4gICAgfV0pXG4gICAgLmRpcmVjdGl2ZSgnbndGb3JtYXRzQnV0dG9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPHNlbGVjdCBjbGFzcz1cIm53LXNlbGVjdFwiIG5nLW1vZGVsPVwiZm9ybWF0XCIgbmctY2hhbmdlPVwiZXhlY0NvbW1hbmQoXFwnZm9ybWF0YmxvY2tcXCcsIGZvcm1hdC52YWx1ZSlcIiBuZy1vcHRpb25zPVwiZm9ybWF0Lm5hbWUgZm9yIGZvcm1hdCBpbiBmb3JtYXRzXCIgbmctZGlzYWJsZWQ9XCJlZGl0TW9kZSB8fCBpc0Rpc2FibGVkXCI+PC9zZWxlY3Q+JyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmZvcm1hdHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnTm9ybWFsIHRleHQnLCB2YWx1ZTogJ3AnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdIZWFkZXIgMScsIHZhbHVlOiAnaDEnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdIZWFkZXIgMicsIHZhbHVlOiAnaDInfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdIZWFkZXIgMycsIHZhbHVlOiAnaDMnfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5mb3JtYXQgPSBzY29wZS5mb3JtYXRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG5cbmFuZ3VsYXIubW9kdWxlKCduZ3dpZy1hcHAtdGVtcGxhdGVzJywgWyduZy13aWcvdmlld3Mvbmctd2lnLmh0bWwnXSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwibmctd2lnL3ZpZXdzL25nLXdpZy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwibmctd2lnL3ZpZXdzL25nLXdpZy5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJuZy13aWdcXFwiPlxcblwiICtcbiAgICBcIiAgPHVsIGNsYXNzPVxcXCJudy10b29sYmFyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGxpIGNsYXNzPVxcXCJudy10b29sYmFyX19pdGVtXFxcIiBuZy1yZXBlYXQ9XFxcImJ1dHRvbiBpbiB0b29sYmFyQnV0dG9uc1xcXCIgPlxcblwiICtcbiAgICBcIiAgICAgICAgPGRpdiBuZy1pZj1cXFwiIWJ1dHRvbi5pc0NvbXBsZXhcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm53LWJ1dHRvbiB7e2J1dHRvbi5zdHlsZUNsYXNzfX1cXFwiIHRpdGxlPVxcXCJ7e2J1dHRvbi50aXRsZX19XFxcIiBuZy1jbGljaz1cXFwiZXhlY0NvbW1hbmQoYnV0dG9uLmNvbW1hbmQpXFxcIiBuZy1jbGFzcz1cXFwieyAnbnctYnV0dG9uLS1hY3RpdmUnOiBpc0VkaXRvckFjdGl2ZSgpICYmIGJ1dHRvbi5pc0FjdGl2ZSgpIH1cXFwiIG5nLWRpc2FibGVkPVxcXCJlZGl0TW9kZSB8fCBpc0Rpc2FibGVkXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgICAgICB7eyBidXR0b24udGl0bGUgfX1cXG5cIiArXG4gICAgXCIgICAgICAgICAgPC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxkaXYgbmctaWY9XFxcImJ1dHRvbi5pc0NvbXBsZXhcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgICA8bmctd2lnLXBsdWdpbiBwbHVnaW49XFxcInt7YnV0dG9ufX1cXFwiPjwvbmctd2lnLXBsdWdpbj5cXG5cIiArXG4gICAgXCIgICAgICAgIDwvZGl2PlxcblwiICtcbiAgICBcIiAgICA8L2xpPjwhLS1cXG5cIiArXG4gICAgXCIgICAgLS0+PGxpIGNsYXNzPVxcXCJudy10b29sYmFyX19pdGVtXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm53LWJ1dHRvbiBudy1idXR0b24tLXNvdXJjZVxcXCIgdGl0bGU9XFxcIkVkaXQgSFRNTFxcXCIgbmctY2xhc3M9XFxcInsgJ253LWJ1dHRvbi0tYWN0aXZlJzogZWRpdE1vZGUgfVxcXCIgbmctc2hvdz1cXFwiaXNTb3VyY2VNb2RlQWxsb3dlZFxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZUVkaXRNb2RlKClcXFwiIG5nLWRpc2FibGVkPVxcXCJpc0Rpc2FibGVkXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIEVkaXQgSFRNTFxcblwiICtcbiAgICBcIiAgICAgIDwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICA8L2xpPlxcblwiICtcbiAgICBcIiAgPC91bD5cXG5cIiArXG4gICAgXCJcXG5cIiArXG4gICAgXCIgIDxkaXYgY2xhc3M9XFxcIm53LWVkaXRvci1jb250YWluZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJudy1lZGl0b3JfX3NyYy1jb250YWluZXJcXFwiIG5nLXNob3c9XFxcImVkaXRNb2RlXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGV4dGFyZWEgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWRcXFwiIG5nLWRpc2FibGVkPVxcXCJpc0Rpc2FibGVkXFxcIiBjbGFzcz1cXFwibnctZWRpdG9yX19zcmNcXFwiIG5nLW1vZGVsPVxcXCJjb250ZW50XFxcIj48L3RleHRhcmVhPlxcblwiICtcbiAgICBcIiAgICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwibnctZWRpdG9yXFxcIiBuZy1jbGFzcz1cXFwieyAnbnctZGlzYWJsZWQnOiBpc0Rpc2FibGVkIH1cXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDxkaXYgbmFtZT1cXFwie3tmb3JtRWxlbWVudE5hbWV9fVxcXCIgbmctcmVxdWlyZWQ9XFxcImlzUmVxdWlyZWRcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgbmctY2xhc3M9XFxcInsnbnctaW52aXNpYmxlJzogZWRpdE1vZGV9XFxcIiBjbGFzcz1cXFwibnctZWRpdG9yX19yZXNcXFwiIG5nLW1vZGVsPVxcXCJjb250ZW50XFxcIiBuZy13aWctZWRpdGFibGUgb24tcGFzdGU9XFxcIm9uUGFzdGVcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L25nLXdpZy9kaXN0L25nLXdpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9lZGl0b3JCdXR0b25zLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9lZGl0b3JCdXR0b25zLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2VkaXRvckJ1dHRvbnMuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvZWRpdG9yQnV0dG9ucy5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm53LWJ1dHRvbi5oZWFkZXI6YmVmb3JlIHtcXHJcXG4gIGNvbnRlbnQ6ICdcXFxcRjFEQyc7IC8qIGZhLWhlYWRlciAqL1xcclxcbn1cXHJcXG5cXHJcXG4ubnctYnV0dG9uLnBhcmFncmFwaDpiZWZvcmUge1xcclxcbiAgY29udGVudDogJ1xcXFxGMUREJzsgLyogZmEtcGFyYWdyYXBoICovXFxyXFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9lZGl0b3JCdXR0b25zLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX19ndWlkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmd1aWQ7XHJcbnZhciByZXF1aXJlZF8xID0gcmVxdWlyZSgnLi4vLi4vYmVoYXZpb3JzL3JlcXVpcmVkL3JlcXVpcmVkJyk7XHJcbnZhciBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvY29tcG9uZW50VmFsaWRhdG9yL2NvbXBvbmVudFZhbGlkYXRvci5zZXJ2aWNlJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLmlucHV0JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdJbnB1dENvbnRyb2xsZXInO1xyXG52YXIgSW5wdXRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIElucHV0Q29udHJvbGxlcigkc2NvcGUsICRhdHRycywgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuJGF0dHJzID0gJGF0dHJzO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSA9IGNvbXBvbmVudFZhbGlkYXRvckZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy5pbnB1dFR5cGUgPSAnaW5wdXQnO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0Q29udHJvbGxlci5wcm90b3R5cGUsIFwiaW5wdXRWYWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5nTW9kZWwuJHZpZXdWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIElucHV0Q29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2YWxpZGF0b3JzID0gW107XHJcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMudmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2godGhpcy52YWxpZGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX19vYmplY3Qub2JqZWN0VXRpbGl0eS5pc051bGxPckVtcHR5KHRoaXMuJGF0dHJzLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGF0dHJzLiRzZXQoJ25hbWUnLCB0aGlzLmlucHV0VHlwZSArICctJyArIF9fZ3VpZC5ndWlkLnJhbmRvbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbmFtZTogJ3JsUmVxdWlyZWQnLFxyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICFfX29iamVjdC5vYmplY3RVdGlsaXR5LmlzTnVsbE9yRW1wdHkoX3RoaXMubmdNb2RlbC4kdmlld1ZhbHVlKTsgfSxcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogdGhpcy5yZXF1aXJlZC5tZXNzYWdlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF8uc29tZSh2YWxpZGF0b3JzKSkge1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0VmFsaWRhdG9yID0gdGhpcy5jb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgICAgIG5nTW9kZWw6IHRoaXMubmdNb2RlbCxcclxuICAgICAgICAgICAgICAgICRzY29wZTogdGhpcy4kc2NvcGUsXHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5wdXRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckYXR0cnMnLCBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLmZhY3RvcnlOYW1lXTtcclxuICAgIHJldHVybiBJbnB1dENvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSW5wdXRDb250cm9sbGVyID0gSW5wdXRDb250cm9sbGVyO1xyXG5leHBvcnRzLmlucHV0ID0ge1xyXG4gICAgcmVxdWlyZToge1xyXG4gICAgICAgIG5nTW9kZWw6ICduZ01vZGVsJyxcclxuICAgICAgICByZXF1aXJlZDogJz8nICsgcmVxdWlyZWRfMS5kaXJlY3RpdmVOYW1lLFxyXG4gICAgfSxcclxuICAgIHRlbXBsYXRlOiAnJyxcclxuICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICBjb250cm9sbGVyQXM6ICdpbnB1dCcsXHJcbiAgICBiaW5kaW5nczoge1xyXG4gICAgICAgIHZhbGlkYXRvcjogJzw/JyxcclxuICAgICAgICBsYWJlbDogJ0AnLFxyXG4gICAgICAgIG5hbWU6ICdAJyxcclxuICAgIH0sXHJcbn07XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW2NvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEubW9kdWxlTmFtZV0pXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBJbnB1dENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvaW5wdXQvaW5wdXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5wcm92aWRlck5hbWUgPSAncmljaFRleHRFZGl0b3InO1xyXG5yaWNoVGV4dEVkaXRvclByb3ZpZGVyLiRpbmplY3QgPSBbJ25nV2lnVG9vbGJhclByb3ZpZGVyJ107XHJcbmZ1bmN0aW9uIHJpY2hUZXh0RWRpdG9yUHJvdmlkZXIobmdXaWdUb29sYmFyUHJvdmlkZXIpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYWRkQ3VzdG9tQnV0dG9uOiBmdW5jdGlvbiAobmFtZSwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIG5nV2lnVG9vbGJhclByb3ZpZGVyLmFkZEN1c3RvbUJ1dHRvbihuYW1lLCBjb21wb25lbnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkU3RhbmRhcmRCdXR0b246IGZ1bmN0aW9uIChuYW1lLCB0b29sdGlwLCBjb21tYW5kLCBpY29uKSB7XHJcbiAgICAgICAgICAgIG5nV2lnVG9vbGJhclByb3ZpZGVyLmFkZFN0YW5kYXJkQnV0dG9uKG5hbWUsIHRvb2xiYXIsIGNvbW1hbmQsICdmYS0nICsgaWNvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG5nV2lnVG9vbGJhclByb3ZpZGVyLmFkZEN1c3RvbUJ1dHRvbigncGFyYWdyYXBoJywgJ3JsLXBhcmFncmFwaC1idXR0b24nKTtcclxuICAgICAgICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkQ3VzdG9tQnV0dG9uKCdoMScsICdybC1oZWFkZXItYnV0dG9uJyk7XHJcbiAgICAgICAgICAgIG5nV2lnVG9vbGJhclByb3ZpZGVyLmFkZFN0YW5kYXJkQnV0dG9uKCd1bmRlcmxpbmUnLCAnVW5kZXJsaW5lJywgJ3VuZGVybGluZScsICdmYS11bmRlcmxpbmUnKTtcclxuICAgICAgICAgICAgbmdXaWdUb29sYmFyUHJvdmlkZXIuYWRkU3RhbmRhcmRCdXR0b24oJ2luZGVudCcsICdJbmRlbnQnLCAnaW5kZW50JywgJ2ZhLWluZGVudCcpO1xyXG4gICAgICAgICAgICBuZ1dpZ1Rvb2xiYXJQcm92aWRlci5hZGRTdGFuZGFyZEJ1dHRvbignb3V0ZGVudCcsICdPdXRkZW50JywgJ291dGRlbnQnLCAnZmEtb3V0ZGVudCcpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucmljaFRleHRFZGl0b3JQcm92aWRlciA9IHJpY2hUZXh0RWRpdG9yUHJvdmlkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpY2hUZXh0RWRpdG9yLmNvbmZpZy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvcmljaFRleHRFZGl0b3IuY29uZmlnLmpzXG4gKiogbW9kdWxlIGlkID0gMTU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxuZXhwb3J0cy5oZWFkZXJCdXR0b25EaXJlY3RpdmVOYW1lID0gJ3JsSGVhZGVyQnV0dG9uJztcclxuZnVuY3Rpb24gaGVhZGVyQnV0dG9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwibnctYnV0dG9uIGhlYWRlclxcXCIgbmctY2xpY2s9XFxcInRyaWdnZXIoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImVkaXRNb2RlIHx8IGlzRGlzYWJsZWRcXFwiIHRpdGxlPVxcXCJIZWFkZXIgMVxcXCI+PC9idXR0b24+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5leGVjQ29tbWFuZCgnZm9ybWF0YmxvY2snLCAnaDEnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmhlYWRlckJ1dHRvbiA9IGhlYWRlckJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZGVyQnV0dG9uLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9yaWNoVGV4dEVkaXRvci9oZWFkZXJCdXR0b24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLnBhcmFncmFwaEJ1dHRvbkRpcmVjdGl2ZU5hbWUgPSAncmxQYXJhZ3JhcGhCdXR0b24nO1xyXG5mdW5jdGlvbiBwYXJhZ3JhcGhCdXR0b24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IFwiXFxuXFx0XFx0XFx0PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJudy1idXR0b24gcGFyYWdyYXBoXFxcIiBuZy1jbGljaz1cXFwidHJpZ2dlcigpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZWRpdE1vZGUgfHwgaXNEaXNhYmxlZFxcXCIgdGl0bGU9XFxcInBhcmFncmFwaFxcXCI+PC9idXR0b24+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5leGVjQ29tbWFuZCgnZm9ybWF0YmxvY2snLCAncCcpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucGFyYWdyYXBoQnV0dG9uID0gcGFyYWdyYXBoQnV0dG9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhZ3JhcGhCdXR0b24uanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3JpY2hUZXh0RWRpdG9yL3BhcmFncmFwaEJ1dHRvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjx0ZXh0YXJlYSBjbGFzcz1cXFwicmljaC10ZXh0LWVkaXRvclxcXCIgbmctd2lnPVxcXCJlZGl0b3IubmdNb2RlbFxcXCIgYnV0dG9ucz1cXFwie3tlZGl0b3IudG9vbGJhcn19XFxcIiBuZy1kaXNhYmxlZD1cXFwiZWRpdG9yLm5nRGlzYWJsZWRcXFwiPjwvdGV4dGFyZWE+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvcmljaFRleHRFZGl0b3IvcmljaFRleHRFZGl0b3IuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbnJlcXVpcmUoJ3VpLXNlbGVjdCcpO1xyXG5yZXF1aXJlKCd1aS1zZWxlY3QvZGlzdC9zZWxlY3QuY3NzJyk7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYmplY3QgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMub2JqZWN0O1xyXG52YXIgX190cmFuc2Zvcm0gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudHJhbnNmb3JtLnRyYW5zZm9ybTtcclxudmFyIGlucHV0XzEgPSByZXF1aXJlKCcuLi9pbnB1dC9pbnB1dCcpO1xyXG52YXIgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2NvbXBvbmVudFZhbGlkYXRvci9jb21wb25lbnRWYWxpZGF0b3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5zZWxlY3QnO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxTZWxlY3QnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NlbGVjdENvbnRyb2xsZXInO1xyXG52YXIgU2VsZWN0Q29udHJvbGxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU2VsZWN0Q29udHJvbGxlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNlbGVjdENvbnRyb2xsZXIoJHNjb3BlLCAkYXR0cnMsICRxLCBvYmplY3QsIGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAkc2NvcGUsICRhdHRycywgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSk7XHJcbiAgICAgICAgdGhpcy4kcSA9ICRxO1xyXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG4gICAgICAgIHRoaXMuX251bGxPcHRpb24gPSB7XHJcbiAgICAgICAgICAgIF9faXNOdWxsT3B0aW9uOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5pbnB1dFR5cGUgPSAnc2VsZWN0JztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZWxlY3RDb250cm9sbGVyLnByb3RvdHlwZSwgXCJzZWxlY3Rpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZ01vZGVsLiR2aWV3VmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuX19pc051bGxPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZ01vZGVsLiRzZXRWaWV3VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTZWxlY3RDb250cm9sbGVyLnByb3RvdHlwZS4kb25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS4kb25Jbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5vcHRpb25zKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRJdGVtcygpLnRoZW4oZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlndXJlT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZWxlY3RDb250cm9sbGVyLnByb3RvdHlwZS5nZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gIT0gbnVsbCAmJiBpdGVtLl9faXNOdWxsT3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bGxPcHRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfX3RyYW5zZm9ybS5nZXRWYWx1ZShpdGVtLCB0aGlzLnNlbGVjdG9yKTtcclxuICAgIH07XHJcbiAgICBTZWxlY3RDb250cm9sbGVyLnByb3RvdHlwZS5sb2FkSXRlbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvbWlzZTtcclxuICAgICAgICBwcm9taXNlID0gdGhpcy5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgaWYgKHByb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy4kcS53aGVuKHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIF90aGlzLmNvbmZpZ3VyZU9wdGlvbnMob3B0aW9ucyk7IH0pO1xyXG4gICAgfTtcclxuICAgIFNlbGVjdENvbnRyb2xsZXIucHJvdG90eXBlLmNvbmZpZ3VyZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmICghdGhpcy5vYmplY3QuaXNOdWxsT3JXaGl0ZXNwYWNlKHRoaXMubnVsbE9wdGlvbikpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy51bnNoaWZ0KHRoaXMuX251bGxPcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH07XHJcbiAgICBTZWxlY3RDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckYXR0cnMnLCAnJHEnLCBfX29iamVjdC5zZXJ2aWNlTmFtZSwgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMS5mYWN0b3J5TmFtZV07XHJcbiAgICByZXR1cm4gU2VsZWN0Q29udHJvbGxlcjtcclxufShpbnB1dF8xLklucHV0Q29udHJvbGxlcikpO1xyXG5leHBvcnRzLlNlbGVjdENvbnRyb2xsZXIgPSBTZWxlY3RDb250cm9sbGVyO1xyXG52YXIgc2VsZWN0ID0gXy5jbG9uZShpbnB1dF8xLmlucHV0KTtcclxuc2VsZWN0LnRlbXBsYXRlID0gcmVxdWlyZSgnLi9zZWxlY3QuaHRtbCcpO1xyXG5zZWxlY3QuY29udHJvbGxlciA9IGV4cG9ydHMuY29udHJvbGxlck5hbWU7XHJcbnNlbGVjdC5jb250cm9sbGVyQXMgPSAnc2VsZWN0JztcclxudmFyIHNlbGVjdEJpbmRpbmdzID0gc2VsZWN0LmJpbmRpbmdzO1xyXG5zZWxlY3RCaW5kaW5ncy5vcHRpb25zID0gJzw/Jztcclxuc2VsZWN0QmluZGluZ3MuZ2V0T3B0aW9ucyA9ICcmJztcclxuc2VsZWN0QmluZGluZ3Muc2VsZWN0b3IgPSAnPD8nO1xyXG5zZWxlY3RCaW5kaW5ncy5uZ0Rpc2FibGVkID0gJzw/Jztcclxuc2VsZWN0QmluZGluZ3MubnVsbE9wdGlvbiA9ICdAJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbJ3VpLnNlbGVjdCcsIF9fb2JqZWN0Lm1vZHVsZU5hbWUsIGlucHV0XzEubW9kdWxlTmFtZV0pXHJcbiAgICAuY29tcG9uZW50KGV4cG9ydHMuY29tcG9uZW50TmFtZSwgc2VsZWN0KVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgU2VsZWN0Q29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9kaXN0L3NlbGVjdC5qcycpO1xubW9kdWxlLmV4cG9ydHMgPSAndWkuc2VsZWN0JztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3VpLXNlbGVjdC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiB1aS1zZWxlY3RcbiAqIGh0dHA6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktc2VsZWN0XG4gKiBWZXJzaW9uOiAwLjE0LjYgLSAyMDE2LTAyLTE4VDIxOjAxOjM2Ljg5M1pcbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cblxuKGZ1bmN0aW9uICgpIHsgXG5cInVzZSBzdHJpY3RcIjtcbnZhciBLRVkgPSB7XG4gICAgVEFCOiA5LFxuICAgIEVOVEVSOiAxMyxcbiAgICBFU0M6IDI3LFxuICAgIFNQQUNFOiAzMixcbiAgICBMRUZUOiAzNyxcbiAgICBVUDogMzgsXG4gICAgUklHSFQ6IDM5LFxuICAgIERPV046IDQwLFxuICAgIFNISUZUOiAxNixcbiAgICBDVFJMOiAxNyxcbiAgICBBTFQ6IDE4LFxuICAgIFBBR0VfVVA6IDMzLFxuICAgIFBBR0VfRE9XTjogMzQsXG4gICAgSE9NRTogMzYsXG4gICAgRU5EOiAzNSxcbiAgICBCQUNLU1BBQ0U6IDgsXG4gICAgREVMRVRFOiA0NixcbiAgICBDT01NQU5EOiA5MSxcblxuICAgIE1BUDogeyA5MSA6IFwiQ09NTUFORFwiLCA4IDogXCJCQUNLU1BBQ0VcIiAsIDkgOiBcIlRBQlwiICwgMTMgOiBcIkVOVEVSXCIgLCAxNiA6IFwiU0hJRlRcIiAsIDE3IDogXCJDVFJMXCIgLCAxOCA6IFwiQUxUXCIgLCAxOSA6IFwiUEFVU0VCUkVBS1wiICwgMjAgOiBcIkNBUFNMT0NLXCIgLCAyNyA6IFwiRVNDXCIgLCAzMiA6IFwiU1BBQ0VcIiAsIDMzIDogXCJQQUdFX1VQXCIsIDM0IDogXCJQQUdFX0RPV05cIiAsIDM1IDogXCJFTkRcIiAsIDM2IDogXCJIT01FXCIgLCAzNyA6IFwiTEVGVFwiICwgMzggOiBcIlVQXCIgLCAzOSA6IFwiUklHSFRcIiAsIDQwIDogXCJET1dOXCIgLCA0MyA6IFwiK1wiICwgNDQgOiBcIlBSSU5UU0NSRUVOXCIgLCA0NSA6IFwiSU5TRVJUXCIgLCA0NiA6IFwiREVMRVRFXCIsIDQ4IDogXCIwXCIgLCA0OSA6IFwiMVwiICwgNTAgOiBcIjJcIiAsIDUxIDogXCIzXCIgLCA1MiA6IFwiNFwiICwgNTMgOiBcIjVcIiAsIDU0IDogXCI2XCIgLCA1NSA6IFwiN1wiICwgNTYgOiBcIjhcIiAsIDU3IDogXCI5XCIgLCA1OSA6IFwiO1wiLCA2MSA6IFwiPVwiICwgNjUgOiBcIkFcIiAsIDY2IDogXCJCXCIgLCA2NyA6IFwiQ1wiICwgNjggOiBcIkRcIiAsIDY5IDogXCJFXCIgLCA3MCA6IFwiRlwiICwgNzEgOiBcIkdcIiAsIDcyIDogXCJIXCIgLCA3MyA6IFwiSVwiICwgNzQgOiBcIkpcIiAsIDc1IDogXCJLXCIgLCA3NiA6IFwiTFwiLCA3NyA6IFwiTVwiICwgNzggOiBcIk5cIiAsIDc5IDogXCJPXCIgLCA4MCA6IFwiUFwiICwgODEgOiBcIlFcIiAsIDgyIDogXCJSXCIgLCA4MyA6IFwiU1wiICwgODQgOiBcIlRcIiAsIDg1IDogXCJVXCIgLCA4NiA6IFwiVlwiICwgODcgOiBcIldcIiAsIDg4IDogXCJYXCIgLCA4OSA6IFwiWVwiICwgOTAgOiBcIlpcIiwgOTYgOiBcIjBcIiAsIDk3IDogXCIxXCIgLCA5OCA6IFwiMlwiICwgOTkgOiBcIjNcIiAsIDEwMCA6IFwiNFwiICwgMTAxIDogXCI1XCIgLCAxMDIgOiBcIjZcIiAsIDEwMyA6IFwiN1wiICwgMTA0IDogXCI4XCIgLCAxMDUgOiBcIjlcIiwgMTA2IDogXCIqXCIgLCAxMDcgOiBcIitcIiAsIDEwOSA6IFwiLVwiICwgMTEwIDogXCIuXCIgLCAxMTEgOiBcIi9cIiwgMTEyIDogXCJGMVwiICwgMTEzIDogXCJGMlwiICwgMTE0IDogXCJGM1wiICwgMTE1IDogXCJGNFwiICwgMTE2IDogXCJGNVwiICwgMTE3IDogXCJGNlwiICwgMTE4IDogXCJGN1wiICwgMTE5IDogXCJGOFwiICwgMTIwIDogXCJGOVwiICwgMTIxIDogXCJGMTBcIiAsIDEyMiA6IFwiRjExXCIgLCAxMjMgOiBcIkYxMlwiLCAxNDQgOiBcIk5VTUxPQ0tcIiAsIDE0NSA6IFwiU0NST0xMTE9DS1wiICwgMTg2IDogXCI7XCIgLCAxODcgOiBcIj1cIiAsIDE4OCA6IFwiLFwiICwgMTg5IDogXCItXCIgLCAxOTAgOiBcIi5cIiAsIDE5MSA6IFwiL1wiICwgMTkyIDogXCJgXCIgLCAyMTkgOiBcIltcIiAsIDIyMCA6IFwiXFxcXFwiICwgMjIxIDogXCJdXCIgLCAyMjIgOiBcIidcIlxuICAgIH0sXG5cbiAgICBpc0NvbnRyb2w6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBrID0gZS53aGljaDtcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgS0VZLkNPTU1BTkQ6XG4gICAgICAgIGNhc2UgS0VZLlNISUZUOlxuICAgICAgICBjYXNlIEtFWS5DVFJMOlxuICAgICAgICBjYXNlIEtFWS5BTFQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzRnVuY3Rpb25LZXk6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGsgPSBrLndoaWNoID8gay53aGljaCA6IGs7XG4gICAgICAgIHJldHVybiBrID49IDExMiAmJiBrIDw9IDEyMztcbiAgICB9LFxuICAgIGlzVmVydGljYWxNb3ZlbWVudDogZnVuY3Rpb24gKGspe1xuICAgICAgcmV0dXJuIH5bS0VZLlVQLCBLRVkuRE9XTl0uaW5kZXhPZihrKTtcbiAgICB9LFxuICAgIGlzSG9yaXpvbnRhbE1vdmVtZW50OiBmdW5jdGlvbiAoayl7XG4gICAgICByZXR1cm4gfltLRVkuTEVGVCxLRVkuUklHSFQsS0VZLkJBQ0tTUEFDRSxLRVkuREVMRVRFXS5pbmRleE9mKGspO1xuICAgIH0sXG4gICAgdG9TZXBhcmF0b3I6IGZ1bmN0aW9uIChrKSB7XG4gICAgICB2YXIgc2VwID0ge0VOVEVSOlwiXFxuXCIsVEFCOlwiXFx0XCIsU1BBQ0U6XCIgXCJ9W2tdO1xuICAgICAgaWYgKHNlcCkgcmV0dXJuIHNlcDtcbiAgICAgIC8vIHJldHVybiB1bmRlZmluZWQgZm9yIHNwZWNpYWwga2V5cyBvdGhlciB0aGFuIGVudGVyLCB0YWIgb3Igc3BhY2UuXG4gICAgICAvLyBubyB3YXkgdG8gdXNlIHRoZW0gdG8gY3V0IHN0cmluZ3MuXG4gICAgICByZXR1cm4gS0VZW2tdID8gdW5kZWZpbmVkIDogaztcbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIHF1ZXJ5U2VsZWN0b3JBbGwoKSB0byBqcUxpdGUuXG4gKlxuICoganFMaXRlIGZpbmQoKSBpcyBsaW1pdGVkIHRvIGxvb2t1cHMgYnkgdGFnIG5hbWUuXG4gKiBUT0RPIFRoaXMgd2lsbCBjaGFuZ2Ugd2l0aCBmdXR1cmUgdmVyc2lvbnMgb2YgQW5ndWxhckpTLCB0byBiZSByZW1vdmVkIHdoZW4gdGhpcyBoYXBwZW5zXG4gKlxuICogU2VlIGpxTGl0ZS5maW5kIC0gd2h5IG5vdCB1c2UgcXVlcnlTZWxlY3RvckFsbD8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvMzU4NlxuICogU2VlIGZlYXQoanFMaXRlKTogdXNlIHF1ZXJ5U2VsZWN0b3JBbGwgaW5zdGVhZCBvZiBnZXRFbGVtZW50c0J5VGFnTmFtZSBpbiBqcUxpdGUuZmluZCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3B1bGwvMzU5OFxuICovXG5pZiAoYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID09PSB1bmRlZmluZWQpIHtcbiAgYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gYW5ndWxhci5lbGVtZW50KHRoaXNbMF0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB9O1xufVxuXG4vKipcbiAqIEFkZCBjbG9zZXN0KCkgdG8ganFMaXRlLlxuICovXG5pZiAoYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgYW5ndWxhci5lbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuICAgIHZhciBtYXRjaGVzU2VsZWN0b3IgPSBlbGVtLm1hdGNoZXMgfHwgZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yLmJpbmQoZWxlbSkoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbSA9IGVsZW0ucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG52YXIgbGF0ZXN0SWQgPSAwO1xuXG52YXIgdWlzID0gYW5ndWxhci5tb2R1bGUoJ3VpLnNlbGVjdCcsIFtdKVxuXG4uY29uc3RhbnQoJ3VpU2VsZWN0Q29uZmlnJywge1xuICB0aGVtZTogJ2Jvb3RzdHJhcCcsXG4gIHNlYXJjaEVuYWJsZWQ6IHRydWUsXG4gIHNvcnRhYmxlOiBmYWxzZSxcbiAgcGxhY2Vob2xkZXI6ICcnLCAvLyBFbXB0eSBieSBkZWZhdWx0LCBsaWtlIEhUTUwgdGFnIDxzZWxlY3Q+XG4gIHJlZnJlc2hEZWxheTogMTAwMCwgLy8gSW4gbWlsbGlzZWNvbmRzXG4gIGNsb3NlT25TZWxlY3Q6IHRydWUsXG4gIGRyb3Bkb3duUG9zaXRpb246ICdhdXRvJyxcbiAgZ2VuZXJhdGVJZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhdGVzdElkKys7XG4gIH0sXG4gIGFwcGVuZFRvQm9keTogZmFsc2Vcbn0pXG5cbi8vIFNlZSBSZW5hbWUgbWluRXJyIGFuZCBtYWtlIGl0IGFjY2Vzc2libGUgZnJvbSBvdXRzaWRlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvaXNzdWVzLzY5MTNcbi5zZXJ2aWNlKCd1aVNlbGVjdE1pbkVycicsIGZ1bmN0aW9uKCkge1xuICB2YXIgbWluRXJyID0gYW5ndWxhci4kJG1pbkVycigndWkuc2VsZWN0Jyk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXJyb3IgPSBtaW5FcnIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKCdcXG5odHRwOi8vZXJyb3JzLmFuZ3VsYXJqcy5vcmcvLionKSwgJycpO1xuICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH07XG59KVxuXG4vLyBSZWNyZWF0ZXMgb2xkIGJlaGF2aW9yIG9mIG5nLXRyYW5zY2x1ZGUuIFVzZWQgaW50ZXJuYWxseS5cbi5kaXJlY3RpdmUoJ3Vpc1RyYW5zY2x1ZGVBcHBlbmQnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybCwgdHJhbnNjbHVkZSkge1xuICAgICAgICB0cmFuc2NsdWRlKHNjb3BlLCBmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICBlbGVtZW50LmFwcGVuZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG59KVxuXG4vKipcbiAqIEhpZ2hsaWdodHMgdGV4dCB0aGF0IG1hdGNoZXMgJHNlbGVjdC5zZWFyY2guXG4gKlxuICogVGFrZW4gZnJvbSBBbmd1bGFyVUkgQm9vdHN0cmFwIFR5cGVhaGVhZFxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL2Jvb3RzdHJhcC9ibG9iLzAuMTAuMC9zcmMvdHlwZWFoZWFkL3R5cGVhaGVhZC5qcyNMMzQwXG4gKi9cbi5maWx0ZXIoJ2hpZ2hsaWdodCcsIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xuICAgIHJldHVybiAoJycgKyBxdWVyeVRvRXNjYXBlKS5yZXBsYWNlKC8oWy4/KiteJFtcXF1cXFxcKCl7fXwtXSkvZywgJ1xcXFwkMScpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG1hdGNoSXRlbSwgcXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkgJiYgbWF0Y2hJdGVtID8gKCcnICsgbWF0Y2hJdGVtKS5yZXBsYWNlKG5ldyBSZWdFeHAoZXNjYXBlUmVnZXhwKHF1ZXJ5KSwgJ2dpJyksICc8c3BhbiBjbGFzcz1cInVpLXNlbGVjdC1oaWdobGlnaHRcIj4kJjwvc3Bhbj4nKSA6IG1hdGNoSXRlbTtcbiAgfTtcbn0pXG5cbi8qKlxuICogQSByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBvZmZzZXQgZnVuY3Rpb246IGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9vZmZzZXQvXG4gKlxuICogVGFrZW4gZnJvbSBBbmd1bGFyVUkgQm9vdHN0cmFwIFBvc2l0aW9uOlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9zcmMvcG9zaXRpb24vcG9zaXRpb24uanMjTDcwXG4gKi9cbi5mYWN0b3J5KCd1aXNPZmZzZXQnLFxuICBbJyRkb2N1bWVudCcsICckd2luZG93JyxcbiAgZnVuY3Rpb24gKCRkb2N1bWVudCwgJHdpbmRvdykge1xuXG4gIHJldHVybiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBib3VuZGluZ0NsaWVudFJlY3Qud2lkdGggfHwgZWxlbWVudC5wcm9wKCdvZmZzZXRXaWR0aCcpLFxuICAgICAgaGVpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXG4gICAgICB0b3A6IGJvdW5kaW5nQ2xpZW50UmVjdC50b3AgKyAoJHdpbmRvdy5wYWdlWU9mZnNldCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXG4gICAgICBsZWZ0OiBib3VuZGluZ0NsaWVudFJlY3QubGVmdCArICgkd2luZG93LnBhZ2VYT2Zmc2V0IHx8ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdClcbiAgICB9O1xuICB9O1xufV0pO1xuXG51aXMuZGlyZWN0aXZlKCd1aVNlbGVjdENob2ljZXMnLFxuICBbJ3VpU2VsZWN0Q29uZmlnJywgJ3Vpc1JlcGVhdFBhcnNlcicsICd1aVNlbGVjdE1pbkVycicsICckY29tcGlsZScsXG4gIGZ1bmN0aW9uKHVpU2VsZWN0Q29uZmlnLCBSZXBlYXRQYXJzZXIsIHVpU2VsZWN0TWluRXJyLCAkY29tcGlsZSkge1xuXG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVxdWlyZTogJ151aVNlbGVjdCcsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbih0RWxlbWVudCkge1xuICAgICAgLy8gTmVlZGVkIHNvIHRoZSB1aVNlbGVjdCBjYW4gZGV0ZWN0IHRoZSB0cmFuc2NsdWRlZCBjb250ZW50XG4gICAgICB0RWxlbWVudC5hZGRDbGFzcygndWktc2VsZWN0LWNob2ljZXMnKTtcblxuICAgICAgLy8gR2V0cyB0aGVtZSBhdHRyaWJ1dGUgZnJvbSBwYXJlbnQgKHVpLXNlbGVjdClcbiAgICAgIHZhciB0aGVtZSA9IHRFbGVtZW50LnBhcmVudCgpLmF0dHIoJ3RoZW1lJykgfHwgdWlTZWxlY3RDb25maWcudGhlbWU7XG4gICAgICByZXR1cm4gdGhlbWUgKyAnL2Nob2ljZXMudHBsLmh0bWwnO1xuICAgIH0sXG5cbiAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG5cbiAgICAgIGlmICghdEF0dHJzLnJlcGVhdCkgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ3JlcGVhdCcsIFwiRXhwZWN0ZWQgJ3JlcGVhdCcgZXhwcmVzc2lvbi5cIik7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRycywgJHNlbGVjdCwgdHJhbnNjbHVkZUZuKSB7XG5cbiAgICAgICAgLy8gdmFyIHJlcGVhdCA9IFJlcGVhdFBhcnNlci5wYXJzZShhdHRycy5yZXBlYXQpO1xuICAgICAgICB2YXIgZ3JvdXBCeUV4cCA9IGF0dHJzLmdyb3VwQnk7XG4gICAgICAgIHZhciBncm91cEZpbHRlckV4cCA9IGF0dHJzLmdyb3VwRmlsdGVyO1xuXG4gICAgICAgICRzZWxlY3QucGFyc2VSZXBlYXRBdHRyKGF0dHJzLnJlcGVhdCwgZ3JvdXBCeUV4cCwgZ3JvdXBGaWx0ZXJFeHApOyAvL1Jlc3VsdCByZWFkeSBhdCAkc2VsZWN0LnBhcnNlclJlc3VsdFxuXG4gICAgICAgICRzZWxlY3QuZGlzYWJsZUNob2ljZUV4cHJlc3Npb24gPSBhdHRycy51aURpc2FibGVDaG9pY2U7XG4gICAgICAgICRzZWxlY3Qub25IaWdobGlnaHRDYWxsYmFjayA9IGF0dHJzLm9uSGlnaGxpZ2h0O1xuXG4gICAgICAgICRzZWxlY3QuZHJvcGRvd25Qb3NpdGlvbiA9IGF0dHJzLnBvc2l0aW9uID8gYXR0cnMucG9zaXRpb24udG9Mb3dlckNhc2UoKSA6IHVpU2VsZWN0Q29uZmlnLmRyb3Bkb3duUG9zaXRpb247XG5cbiAgICAgICAgaWYoZ3JvdXBCeUV4cCkge1xuICAgICAgICAgIHZhciBncm91cHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtY2hvaWNlcy1ncm91cCcpO1xuICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoICE9PSAxKSB0aHJvdyB1aVNlbGVjdE1pbkVycigncm93cycsIFwiRXhwZWN0ZWQgMSAudWktc2VsZWN0LWNob2ljZXMtZ3JvdXAgYnV0IGdvdCAnezB9Jy5cIiwgZ3JvdXBzLmxlbmd0aCk7XG4gICAgICAgICAgZ3JvdXBzLmF0dHIoJ25nLXJlcGVhdCcsIFJlcGVhdFBhcnNlci5nZXRHcm91cE5nUmVwZWF0RXhwcmVzc2lvbigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaG9pY2VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudWktc2VsZWN0LWNob2ljZXMtcm93Jyk7XG4gICAgICAgIGlmIChjaG9pY2VzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IHVpU2VsZWN0TWluRXJyKCdyb3dzJywgXCJFeHBlY3RlZCAxIC51aS1zZWxlY3QtY2hvaWNlcy1yb3cgYnV0IGdvdCAnezB9Jy5cIiwgY2hvaWNlcy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hvaWNlcy5hdHRyKCduZy1yZXBlYXQnLCAkc2VsZWN0LnBhcnNlclJlc3VsdC5yZXBlYXRFeHByZXNzaW9uKGdyb3VwQnlFeHApKVxuICAgICAgICAgICAgLmF0dHIoJ25nLWlmJywgJyRzZWxlY3Qub3BlbicpIC8vUHJldmVudCB1bm5lY2Vzc2FyeSB3YXRjaGVzIHdoZW4gZHJvcGRvd24gaXMgY2xvc2VkXG4gICAgICAgICAgICAuYXR0cignbmctY2xpY2snLCAnJHNlbGVjdC5zZWxlY3QoJyArICRzZWxlY3QucGFyc2VyUmVzdWx0Lml0ZW1OYW1lICsgJyxmYWxzZSwkZXZlbnQpJyk7XG5cbiAgICAgICAgdmFyIHJvd3NJbm5lciA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnVpLXNlbGVjdC1jaG9pY2VzLXJvdy1pbm5lcicpO1xuICAgICAgICBpZiAocm93c0lubmVyLmxlbmd0aCAhPT0gMSkgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ3Jvd3MnLCBcIkV4cGVjdGVkIDEgLnVpLXNlbGVjdC1jaG9pY2VzLXJvdy1pbm5lciBidXQgZ290ICd7MH0nLlwiLCByb3dzSW5uZXIubGVuZ3RoKTtcbiAgICAgICAgcm93c0lubmVyLmF0dHIoJ3Vpcy10cmFuc2NsdWRlLWFwcGVuZCcsICcnKTsgLy9BZGRpbmcgdWlzVHJhbnNjbHVkZUFwcGVuZCBkaXJlY3RpdmUgdG8gcm93IGVsZW1lbnQgYWZ0ZXIgY2hvaWNlcyBlbGVtZW50IGhhcyBuZ1JlcGVhdFxuXG4gICAgICAgICRjb21waWxlKGVsZW1lbnQsIHRyYW5zY2x1ZGVGbikoc2NvcGUpOyAvL1Bhc3NpbmcgY3VycmVudCB0cmFuc2NsdWRlRm4gdG8gYmUgYWJsZSB0byBhcHBlbmQgZWxlbWVudHMgY29ycmVjdGx5IGZyb20gdWlzVHJhbnNjbHVkZUFwcGVuZFxuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnJHNlbGVjdC5zZWFyY2gnLCBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgIGlmKG5ld1ZhbHVlICYmICEkc2VsZWN0Lm9wZW4gJiYgJHNlbGVjdC5tdWx0aXBsZSkgJHNlbGVjdC5hY3RpdmF0ZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgJHNlbGVjdC5hY3RpdmVJbmRleCA9ICRzZWxlY3QudGFnZ2luZy5pc0FjdGl2YXRlZCA/IC0xIDogMDtcbiAgICAgICAgICBpZiAoIWF0dHJzLm1pbmltdW1JbnB1dExlbmd0aCB8fCAkc2VsZWN0LnNlYXJjaC5sZW5ndGggPj0gYXR0cnMubWluaW11bUlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAkc2VsZWN0LnJlZnJlc2goYXR0cnMucmVmcmVzaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZWxlY3QuaXRlbXMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdyZWZyZXNoRGVsYXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyAkZXZhbCgpIGlzIG5lZWRlZCBvdGhlcndpc2Ugd2UgZ2V0IGEgc3RyaW5nIGluc3RlYWQgb2YgYSBudW1iZXJcbiAgICAgICAgICB2YXIgcmVmcmVzaERlbGF5ID0gc2NvcGUuJGV2YWwoYXR0cnMucmVmcmVzaERlbGF5KTtcbiAgICAgICAgICAkc2VsZWN0LnJlZnJlc2hEZWxheSA9IHJlZnJlc2hEZWxheSAhPT0gdW5kZWZpbmVkID8gcmVmcmVzaERlbGF5IDogdWlTZWxlY3RDb25maWcucmVmcmVzaERlbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufV0pO1xuXG4vKipcbiAqIENvbnRhaW5zIHVpLXNlbGVjdCBcImludGVsbGlnZW5jZVwiLlxuICpcbiAqIFRoZSBnb2FsIGlzIHRvIGxpbWl0IGRlcGVuZGVuY3kgb24gdGhlIERPTSB3aGVuZXZlciBwb3NzaWJsZSBhbmRcbiAqIHB1dCBhcyBtdWNoIGxvZ2ljIGluIHRoZSBjb250cm9sbGVyIChpbnN0ZWFkIG9mIHRoZSBsaW5rIGZ1bmN0aW9ucykgYXMgcG9zc2libGUgc28gaXQgY2FuIGJlIGVhc2lseSB0ZXN0ZWQuXG4gKi9cbnVpcy5jb250cm9sbGVyKCd1aVNlbGVjdEN0cmwnLFxuICBbJyRzY29wZScsICckZWxlbWVudCcsICckdGltZW91dCcsICckZmlsdGVyJywgJ3Vpc1JlcGVhdFBhcnNlcicsICd1aVNlbGVjdE1pbkVycicsICd1aVNlbGVjdENvbmZpZycsICckcGFyc2UnLCAnJGluamVjdG9yJyxcbiAgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJHRpbWVvdXQsICRmaWx0ZXIsIFJlcGVhdFBhcnNlciwgdWlTZWxlY3RNaW5FcnIsIHVpU2VsZWN0Q29uZmlnLCAkcGFyc2UsICRpbmplY3Rvcikge1xuXG4gIHZhciBjdHJsID0gdGhpcztcblxuICB2YXIgRU1QVFlfU0VBUkNIID0gJyc7XG5cbiAgY3RybC5wbGFjZWhvbGRlciA9IHVpU2VsZWN0Q29uZmlnLnBsYWNlaG9sZGVyO1xuICBjdHJsLnNlYXJjaEVuYWJsZWQgPSB1aVNlbGVjdENvbmZpZy5zZWFyY2hFbmFibGVkO1xuICBjdHJsLnNvcnRhYmxlID0gdWlTZWxlY3RDb25maWcuc29ydGFibGU7XG4gIGN0cmwucmVmcmVzaERlbGF5ID0gdWlTZWxlY3RDb25maWcucmVmcmVzaERlbGF5O1xuICBjdHJsLnBhc3RlID0gdWlTZWxlY3RDb25maWcucGFzdGU7XG5cbiAgY3RybC5yZW1vdmVTZWxlY3RlZCA9IGZhbHNlOyAvL0lmIHNlbGVjdGVkIGl0ZW0ocykgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkcm9wZG93biBsaXN0XG4gIGN0cmwuY2xvc2VPblNlbGVjdCA9IHRydWU7IC8vSW5pdGlhbGl6ZWQgaW5zaWRlIHVpU2VsZWN0IGRpcmVjdGl2ZSBsaW5rIGZ1bmN0aW9uXG4gIGN0cmwuc2VhcmNoID0gRU1QVFlfU0VBUkNIO1xuXG4gIGN0cmwuYWN0aXZlSW5kZXggPSAwOyAvL0Ryb3Bkb3duIG9mIGNob2ljZXNcbiAgY3RybC5pdGVtcyA9IFtdOyAvL0FsbCBhdmFpbGFibGUgY2hvaWNlc1xuXG4gIGN0cmwub3BlbiA9IGZhbHNlO1xuICBjdHJsLmZvY3VzID0gZmFsc2U7XG4gIGN0cmwuZGlzYWJsZWQgPSBmYWxzZTtcbiAgY3RybC5zZWxlY3RlZCA9IHVuZGVmaW5lZDtcblxuICBjdHJsLmRyb3Bkb3duUG9zaXRpb24gPSAnYXV0byc7XG5cbiAgY3RybC5mb2N1c3NlciA9IHVuZGVmaW5lZDsgLy9SZWZlcmVuY2UgdG8gaW5wdXQgZWxlbWVudCB1c2VkIHRvIGhhbmRsZSBmb2N1cyBldmVudHNcbiAgY3RybC5yZXNldFNlYXJjaElucHV0ID0gdHJ1ZTtcbiAgY3RybC5tdWx0aXBsZSA9IHVuZGVmaW5lZDsgLy8gSW5pdGlhbGl6ZWQgaW5zaWRlIHVpU2VsZWN0IGRpcmVjdGl2ZSBsaW5rIGZ1bmN0aW9uXG4gIGN0cmwuZGlzYWJsZUNob2ljZUV4cHJlc3Npb24gPSB1bmRlZmluZWQ7IC8vIEluaXRpYWxpemVkIGluc2lkZSB1aVNlbGVjdENob2ljZXMgZGlyZWN0aXZlIGxpbmsgZnVuY3Rpb25cbiAgY3RybC50YWdnaW5nID0ge2lzQWN0aXZhdGVkOiBmYWxzZSwgZmN0OiB1bmRlZmluZWR9O1xuICBjdHJsLnRhZ2dpbmdUb2tlbnMgPSB7aXNBY3RpdmF0ZWQ6IGZhbHNlLCB0b2tlbnM6IHVuZGVmaW5lZH07XG4gIGN0cmwubG9ja0Nob2ljZUV4cHJlc3Npb24gPSB1bmRlZmluZWQ7IC8vIEluaXRpYWxpemVkIGluc2lkZSB1aVNlbGVjdE1hdGNoIGRpcmVjdGl2ZSBsaW5rIGZ1bmN0aW9uXG4gIGN0cmwuY2xpY2tUcmlnZ2VyZWRTZWxlY3QgPSBmYWxzZTtcbiAgY3RybC4kZmlsdGVyID0gJGZpbHRlcjtcblxuICAvLyBVc2UgJGluamVjdG9yIHRvIGNoZWNrIGZvciAkYW5pbWF0ZSBhbmQgc3RvcmUgYSByZWZlcmVuY2UgdG8gaXRcbiAgY3RybC4kYW5pbWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZScpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gJGFuaW1hdGUgZG9lcyBub3QgZXhpc3RcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSkoKTtcblxuICBjdHJsLnNlYXJjaElucHV0ID0gJGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQudWktc2VsZWN0LXNlYXJjaCcpO1xuICBpZiAoY3RybC5zZWFyY2hJbnB1dC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyB1aVNlbGVjdE1pbkVycignc2VhcmNoSW5wdXQnLCBcIkV4cGVjdGVkIDEgaW5wdXQudWktc2VsZWN0LXNlYXJjaCBidXQgZ290ICd7MH0nLlwiLCBjdHJsLnNlYXJjaElucHV0Lmxlbmd0aCk7XG4gIH1cblxuICBjdHJsLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYW5ndWxhci5pc1VuZGVmaW5lZChjdHJsLnNlbGVjdGVkKSB8fCBjdHJsLnNlbGVjdGVkID09PSBudWxsIHx8IGN0cmwuc2VsZWN0ZWQgPT09ICcnIHx8IChjdHJsLm11bHRpcGxlICYmIGN0cmwuc2VsZWN0ZWQubGVuZ3RoID09PSAwKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfZmluZEluZGV4KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZyl7XG4gICAgaWYgKGNvbGxlY3Rpb24uZmluZEluZGV4KXtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmZpbmRJbmRleChwcmVkaWNhdGUsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGlzdCA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaSwgbGlzdCkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vc3Qgb2YgdGhlIHRpbWUgdGhlIHVzZXIgZG9lcyBub3Qgd2FudCB0byBlbXB0eSB0aGUgc2VhcmNoIGlucHV0IHdoZW4gaW4gdHlwZWFoZWFkIG1vZGVcbiAgZnVuY3Rpb24gX3Jlc2V0U2VhcmNoSW5wdXQoKSB7XG4gICAgaWYgKGN0cmwucmVzZXRTZWFyY2hJbnB1dCB8fCAoY3RybC5yZXNldFNlYXJjaElucHV0ID09PSB1bmRlZmluZWQgJiYgdWlTZWxlY3RDb25maWcucmVzZXRTZWFyY2hJbnB1dCkpIHtcbiAgICAgIGN0cmwuc2VhcmNoID0gRU1QVFlfU0VBUkNIO1xuICAgICAgLy9yZXNldCBhY3RpdmVJbmRleFxuICAgICAgaWYgKGN0cmwuc2VsZWN0ZWQgJiYgY3RybC5pdGVtcy5sZW5ndGggJiYgIWN0cmwubXVsdGlwbGUpIHtcbiAgICAgICAgY3RybC5hY3RpdmVJbmRleCA9IF9maW5kSW5kZXgoY3RybC5pdGVtcywgZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuZXF1YWxzKHRoaXMsIGl0ZW0pO1xuICAgICAgICB9LCBjdHJsLnNlbGVjdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAgIGZ1bmN0aW9uIF9ncm91cHNGaWx0ZXIoZ3JvdXBzLCBncm91cE5hbWVzKSB7XG4gICAgICB2YXIgaSwgaiwgcmVzdWx0ID0gW107XG4gICAgICBmb3IoaSA9IDA7IGkgPCBncm91cE5hbWVzLmxlbmd0aCA7aSsrKXtcbiAgICAgICAgZm9yKGogPSAwOyBqIDwgZ3JvdXBzLmxlbmd0aCA7aisrKXtcbiAgICAgICAgICBpZihncm91cHNbal0ubmFtZSA9PSBbZ3JvdXBOYW1lc1tpXV0pe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZ3JvdXBzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIC8vIFdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHVpLXNlbGVjdCwgZGlzcGxheXMgdGhlIGRyb3Bkb3duIGxpc3RcbiAgY3RybC5hY3RpdmF0ZSA9IGZ1bmN0aW9uKGluaXRTZWFyY2hWYWx1ZSwgYXZvaWRSZXNldCkge1xuICAgIGlmICghY3RybC5kaXNhYmxlZCAgJiYgIWN0cmwub3Blbikge1xuICAgICAgaWYoIWF2b2lkUmVzZXQpIF9yZXNldFNlYXJjaElucHV0KCk7XG5cbiAgICAgICRzY29wZS4kYnJvYWRjYXN0KCd1aXM6YWN0aXZhdGUnKTtcblxuICAgICAgY3RybC5vcGVuID0gdHJ1ZTtcblxuICAgICAgY3RybC5hY3RpdmVJbmRleCA9IGN0cmwuYWN0aXZlSW5kZXggPj0gY3RybC5pdGVtcy5sZW5ndGggPyAwIDogY3RybC5hY3RpdmVJbmRleDtcblxuICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGluZGV4IGlzIHNldCB0byB6ZXJvIGZvciB0YWdnaW5nIHZhcmlhbnRzXG4gICAgICAvLyB0aGF0IHdoZXJlIGZpcnN0IG9wdGlvbiBpcyBhdXRvLXNlbGVjdGVkXG4gICAgICBpZiAoIGN0cmwuYWN0aXZlSW5kZXggPT09IC0xICYmIGN0cmwudGFnZ2luZ0xhYmVsICE9PSBmYWxzZSApIHtcbiAgICAgICAgY3RybC5hY3RpdmVJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250YWluZXIgPSAkZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudWktc2VsZWN0LWNob2ljZXMtY29udGVudCcpO1xuICAgICAgaWYgKGN0cmwuJGFuaW1hdGUgJiYgY3RybC4kYW5pbWF0ZS5lbmFibGVkKGNvbnRhaW5lclswXSkpIHtcbiAgICAgICAgY3RybC4kYW5pbWF0ZS5vbignZW50ZXInLCBjb250YWluZXJbMF0sIGZ1bmN0aW9uIChlbGVtLCBwaGFzZSkge1xuICAgICAgICAgIGlmIChwaGFzZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgICAgICAgLy8gT25seSBmb2N1cyBpbnB1dCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZFxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjdHJsLmZvY3VzU2VhcmNoSW5wdXQoaW5pdFNlYXJjaFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3RybC5mb2N1c1NlYXJjaElucHV0KGluaXRTZWFyY2hWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjdHJsLmZvY3VzU2VhcmNoSW5wdXQgPSBmdW5jdGlvbiAoaW5pdFNlYXJjaFZhbHVlKSB7XG4gICAgY3RybC5zZWFyY2ggPSBpbml0U2VhcmNoVmFsdWUgfHwgY3RybC5zZWFyY2g7XG4gICAgY3RybC5zZWFyY2hJbnB1dFswXS5mb2N1cygpO1xuICAgIGlmKCFjdHJsLnRhZ2dpbmcuaXNBY3RpdmF0ZWQgJiYgY3RybC5pdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgIF9lbnN1cmVIaWdobGlnaHRWaXNpYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIGN0cmwuZmluZEdyb3VwQnlOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBjdHJsLmdyb3VwcyAmJiBjdHJsLmdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIHJldHVybiBncm91cC5uYW1lID09PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9O1xuXG4gIGN0cmwucGFyc2VSZXBlYXRBdHRyID0gZnVuY3Rpb24ocmVwZWF0QXR0ciwgZ3JvdXBCeUV4cCwgZ3JvdXBGaWx0ZXJFeHApIHtcbiAgICBmdW5jdGlvbiB1cGRhdGVHcm91cHMoaXRlbXMpIHtcbiAgICAgIHZhciBncm91cEZuID0gJHNjb3BlLiRldmFsKGdyb3VwQnlFeHApO1xuICAgICAgY3RybC5ncm91cHMgPSBbXTtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgZ3JvdXBOYW1lID0gYW5ndWxhci5pc0Z1bmN0aW9uKGdyb3VwRm4pID8gZ3JvdXBGbihpdGVtKSA6IGl0ZW1bZ3JvdXBGbl07XG4gICAgICAgIHZhciBncm91cCA9IGN0cmwuZmluZEdyb3VwQnlOYW1lKGdyb3VwTmFtZSk7XG4gICAgICAgIGlmKGdyb3VwKSB7XG4gICAgICAgICAgZ3JvdXAuaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHJsLmdyb3Vwcy5wdXNoKHtuYW1lOiBncm91cE5hbWUsIGl0ZW1zOiBbaXRlbV19KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZihncm91cEZpbHRlckV4cCl7XG4gICAgICAgIHZhciBncm91cEZpbHRlckZuID0gJHNjb3BlLiRldmFsKGdyb3VwRmlsdGVyRXhwKTtcbiAgICAgICAgaWYoIGFuZ3VsYXIuaXNGdW5jdGlvbihncm91cEZpbHRlckZuKSl7XG4gICAgICAgICAgY3RybC5ncm91cHMgPSBncm91cEZpbHRlckZuKGN0cmwuZ3JvdXBzKTtcbiAgICAgICAgfSBlbHNlIGlmKGFuZ3VsYXIuaXNBcnJheShncm91cEZpbHRlckZuKSl7XG4gICAgICAgICAgY3RybC5ncm91cHMgPSBfZ3JvdXBzRmlsdGVyKGN0cmwuZ3JvdXBzLCBncm91cEZpbHRlckZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3RybC5pdGVtcyA9IFtdO1xuICAgICAgY3RybC5ncm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuICAgICAgICBjdHJsLml0ZW1zID0gY3RybC5pdGVtcy5jb25jYXQoZ3JvdXAuaXRlbXMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UGxhaW5JdGVtcyhpdGVtcykge1xuICAgICAgY3RybC5pdGVtcyA9IGl0ZW1zO1xuICAgIH1cblxuICAgIGN0cmwuc2V0SXRlbXNGbiA9IGdyb3VwQnlFeHAgPyB1cGRhdGVHcm91cHMgOiBzZXRQbGFpbkl0ZW1zO1xuXG4gICAgY3RybC5wYXJzZXJSZXN1bHQgPSBSZXBlYXRQYXJzZXIucGFyc2UocmVwZWF0QXR0cik7XG5cbiAgICBjdHJsLmlzR3JvdXBlZCA9ICEhZ3JvdXBCeUV4cDtcbiAgICBjdHJsLml0ZW1Qcm9wZXJ0eSA9IGN0cmwucGFyc2VyUmVzdWx0Lml0ZW1OYW1lO1xuXG4gICAgLy9JZiBjb2xsZWN0aW9uIGlzIGFuIE9iamVjdCwgY29udmVydCBpdCB0byBBcnJheVxuXG4gICAgdmFyIG9yaWdpbmFsU291cmNlID0gY3RybC5wYXJzZXJSZXN1bHQuc291cmNlO1xuXG4gICAgLy9XaGVuIGFuIG9iamVjdCBpcyB1c2VkIGFzIHNvdXJjZSwgd2UgYmV0dGVyIGNyZWF0ZSBhbiBhcnJheSBhbmQgdXNlIGl0IGFzICdzb3VyY2UnXG4gICAgdmFyIGNyZWF0ZUFycmF5RnJvbU9iamVjdCA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgb3JpZ1NyYyA9IG9yaWdpbmFsU291cmNlKCRzY29wZSk7XG4gICAgICAkc2NvcGUuJHVpc1NvdXJjZSA9IE9iamVjdC5rZXlzKG9yaWdTcmMpLm1hcChmdW5jdGlvbih2KXtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbY3RybC5wYXJzZXJSZXN1bHQua2V5TmFtZV0gPSB2O1xuICAgICAgICByZXN1bHQudmFsdWUgPSBvcmlnU3JjW3ZdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjdHJsLnBhcnNlclJlc3VsdC5rZXlOYW1lKXsgLy8gQ2hlY2sgZm9yIChrZXksdmFsdWUpIHN5bnRheFxuICAgICAgY3JlYXRlQXJyYXlGcm9tT2JqZWN0KCk7XG4gICAgICBjdHJsLnBhcnNlclJlc3VsdC5zb3VyY2UgPSAkcGFyc2UoJyR1aXNTb3VyY2UnICsgY3RybC5wYXJzZXJSZXN1bHQuZmlsdGVycyk7XG4gICAgICAkc2NvcGUuJHdhdGNoKG9yaWdpbmFsU291cmNlLCBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCl7XG4gICAgICAgIGlmIChuZXdWYWwgIT09IG9sZFZhbCkgY3JlYXRlQXJyYXlGcm9tT2JqZWN0KCk7XG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICBjdHJsLnJlZnJlc2hJdGVtcyA9IGZ1bmN0aW9uIChkYXRhKXtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IGN0cmwucGFyc2VyUmVzdWx0LnNvdXJjZSgkc2NvcGUpO1xuICAgICAgdmFyIHNlbGVjdGVkSXRlbXMgPSBjdHJsLnNlbGVjdGVkO1xuICAgICAgLy9UT0RPIHNob3VsZCBpbXBsZW1lbnQgZm9yIHNpbmdsZSBtb2RlIHJlbW92ZVNlbGVjdGVkXG4gICAgICBpZiAoY3RybC5pc0VtcHR5KCkgfHwgKGFuZ3VsYXIuaXNBcnJheShzZWxlY3RlZEl0ZW1zKSAmJiAhc2VsZWN0ZWRJdGVtcy5sZW5ndGgpIHx8ICFjdHJsLnJlbW92ZVNlbGVjdGVkKSB7XG4gICAgICAgIGN0cmwuc2V0SXRlbXNGbihkYXRhKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGkpIHtyZXR1cm4gc2VsZWN0ZWRJdGVtcyAmJiBzZWxlY3RlZEl0ZW1zLmluZGV4T2YoaSkgPCAwO30pO1xuICAgICAgICAgIGN0cmwuc2V0SXRlbXNGbihmaWx0ZXJlZEl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN0cmwuZHJvcGRvd25Qb3NpdGlvbiA9PT0gJ2F1dG8nIHx8IGN0cmwuZHJvcGRvd25Qb3NpdGlvbiA9PT0gJ3VwJyl7XG4gICAgICAgICRzY29wZS5jYWxjdWxhdGVEcm9wZG93blBvcygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9ibG9iL3YxLjIuMTUvc3JjL25nL2RpcmVjdGl2ZS9uZ1JlcGVhdC5qcyNMMjU5XG4gICAgJHNjb3BlLiR3YXRjaENvbGxlY3Rpb24oY3RybC5wYXJzZXJSZXN1bHQuc291cmNlLCBmdW5jdGlvbihpdGVtcykge1xuICAgICAgaWYgKGl0ZW1zID09PSB1bmRlZmluZWQgfHwgaXRlbXMgPT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVzIHVuZGVmaW5lZCBvciBudWxsID0+IHJlc2V0IHRoZSBjb2xsZWN0aW9uXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogaXRlbXMgY2FuIGJlIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBkaWQgbm90IGluaXRpYWxpemVkIHRoZSBjb2xsZWN0aW9uIG9uIHRoZSBzY29wZVxuICAgICAgICAvLyBpLmUgJHNjb3BlLmFkZHJlc3NlcyA9IFtdIGlzIG1pc3NpbmdcbiAgICAgICAgY3RybC5pdGVtcyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFhbmd1bGFyLmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ2l0ZW1zJywgXCJFeHBlY3RlZCBhbiBhcnJheSBidXQgZ290ICd7MH0nLlwiLCBpdGVtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9SZW1vdmUgYWxyZWFkeSBzZWxlY3RlZCBpdGVtcyAoZXg6IHdoaWxlIHNlYXJjaGluZylcbiAgICAgICAgICAvL1RPRE8gU2hvdWxkIGFkZCBhIHRlc3RcbiAgICAgICAgICBjdHJsLnJlZnJlc2hJdGVtcyhpdGVtcyk7XG4gICAgICAgICAgY3RybC5uZ01vZGVsLiRtb2RlbFZhbHVlID0gbnVsbDsgLy9Gb3JjZSBzY29wZSBtb2RlbCB2YWx1ZSBhbmQgbmdNb2RlbCB2YWx1ZSB0byBiZSBvdXQgb2Ygc3luYyB0byByZS1ydW4gZm9ybWF0dGVyc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfTtcblxuICB2YXIgX3JlZnJlc2hEZWxheVByb21pc2U7XG5cbiAgLyoqXG4gICAqIFR5cGVhaGVhZCBtb2RlOiBsZXRzIHRoZSB1c2VyIHJlZnJlc2ggdGhlIGNvbGxlY3Rpb24gdXNpbmcgaGlzIG93biBmdW5jdGlvbi5cbiAgICpcbiAgICogU2VlIEV4cG9zZSAkc2VsZWN0LnNlYXJjaCBmb3IgZXh0ZXJuYWwgLyByZW1vdGUgZmlsdGVyaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXNlbGVjdC9wdWxsLzMxXG4gICAqL1xuICBjdHJsLnJlZnJlc2ggPSBmdW5jdGlvbihyZWZyZXNoQXR0cikge1xuICAgIGlmIChyZWZyZXNoQXR0ciAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIERlYm91bmNlXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvYm9vdHN0cmFwL2Jsb2IvMC4xMC4wL3NyYy90eXBlYWhlYWQvdHlwZWFoZWFkLmpzI0wxNTVcbiAgICAgIC8vIEZZSSBBbmd1bGFyU3RyYXAgdHlwZWFoZWFkIGRvZXMgbm90IGhhdmUgZGVib3VuY2luZzogaHR0cHM6Ly9naXRodWIuY29tL21nY3JlYS9hbmd1bGFyLXN0cmFwL2Jsb2IvdjIuMC4wLXJjLjQvc3JjL3R5cGVhaGVhZC90eXBlYWhlYWQuanMjTDE3N1xuICAgICAgaWYgKF9yZWZyZXNoRGVsYXlQcm9taXNlKSB7XG4gICAgICAgICR0aW1lb3V0LmNhbmNlbChfcmVmcmVzaERlbGF5UHJvbWlzZSk7XG4gICAgICB9XG4gICAgICBfcmVmcmVzaERlbGF5UHJvbWlzZSA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuJGV2YWwocmVmcmVzaEF0dHIpO1xuICAgICAgfSwgY3RybC5yZWZyZXNoRGVsYXkpO1xuICAgIH1cbiAgfTtcblxuICBjdHJsLmlzQWN0aXZlID0gZnVuY3Rpb24oaXRlbVNjb3BlKSB7XG4gICAgaWYgKCAhY3RybC5vcGVuICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaXRlbUluZGV4ID0gY3RybC5pdGVtcy5pbmRleE9mKGl0ZW1TY29wZVtjdHJsLml0ZW1Qcm9wZXJ0eV0pO1xuICAgIHZhciBpc0FjdGl2ZSA9ICBpdGVtSW5kZXggPT0gY3RybC5hY3RpdmVJbmRleDtcblxuICAgIGlmICggIWlzQWN0aXZlIHx8ICggaXRlbUluZGV4IDwgMCAmJiBjdHJsLnRhZ2dpbmdMYWJlbCAhPT0gZmFsc2UgKSB8fCggaXRlbUluZGV4IDwgMCAmJiBjdHJsLnRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UpICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0FjdGl2ZSAmJiAhYW5ndWxhci5pc1VuZGVmaW5lZChjdHJsLm9uSGlnaGxpZ2h0Q2FsbGJhY2spKSB7XG4gICAgICBpdGVtU2NvcGUuJGV2YWwoY3RybC5vbkhpZ2hsaWdodENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNBY3RpdmU7XG4gIH07XG5cbiAgY3RybC5pc0Rpc2FibGVkID0gZnVuY3Rpb24oaXRlbVNjb3BlKSB7XG5cbiAgICBpZiAoIWN0cmwub3BlbikgcmV0dXJuO1xuXG4gICAgdmFyIGl0ZW1JbmRleCA9IGN0cmwuaXRlbXMuaW5kZXhPZihpdGVtU2NvcGVbY3RybC5pdGVtUHJvcGVydHldKTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIHZhciBpdGVtO1xuXG4gICAgaWYgKGl0ZW1JbmRleCA+PSAwICYmICFhbmd1bGFyLmlzVW5kZWZpbmVkKGN0cmwuZGlzYWJsZUNob2ljZUV4cHJlc3Npb24pKSB7XG4gICAgICBpdGVtID0gY3RybC5pdGVtc1tpdGVtSW5kZXhdO1xuICAgICAgaXNEaXNhYmxlZCA9ICEhKGl0ZW1TY29wZS4kZXZhbChjdHJsLmRpc2FibGVDaG9pY2VFeHByZXNzaW9uKSk7IC8vIGZvcmNlIHRoZSBib29sZWFuIHZhbHVlXG4gICAgICBpdGVtLl91aVNlbGVjdENob2ljZURpc2FibGVkID0gaXNEaXNhYmxlZDsgLy8gc3RvcmUgdGhpcyBmb3IgbGF0ZXIgcmVmZXJlbmNlXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGlzYWJsZWQ7XG4gIH07XG5cblxuICAvLyBXaGVuIHRoZSB1c2VyIHNlbGVjdHMgYW4gaXRlbSB3aXRoIEVOVEVSIG9yIGNsaWNrcyB0aGUgZHJvcGRvd25cbiAgY3RybC5zZWxlY3QgPSBmdW5jdGlvbihpdGVtLCBza2lwRm9jdXNzZXIsICRldmVudCkge1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgIWl0ZW0uX3VpU2VsZWN0Q2hvaWNlRGlzYWJsZWQpIHtcblxuICAgICAgaWYgKCAhIGN0cmwuaXRlbXMgJiYgISBjdHJsLnNlYXJjaCAmJiAhIGN0cmwudGFnZ2luZy5pc0FjdGl2YXRlZCkgcmV0dXJuO1xuXG4gICAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uX3VpU2VsZWN0Q2hvaWNlRGlzYWJsZWQpIHtcbiAgICAgICAgaWYoY3RybC50YWdnaW5nLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgLy8gaWYgdGFnZ2luZ0xhYmVsIGlzIGRpc2FibGVkLCB3ZSBwdWxsIGZyb20gY3RybC5zZWFyY2ggdmFsXG4gICAgICAgICAgaWYgKCBjdHJsLnRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgICBpZiAoIGN0cmwuYWN0aXZlSW5kZXggPCAwICkge1xuICAgICAgICAgICAgICBpdGVtID0gY3RybC50YWdnaW5nLmZjdCAhPT0gdW5kZWZpbmVkID8gY3RybC50YWdnaW5nLmZjdChjdHJsLnNlYXJjaCkgOiBjdHJsLnNlYXJjaDtcbiAgICAgICAgICAgICAgaWYgKCFpdGVtIHx8IGFuZ3VsYXIuZXF1YWxzKCBjdHJsLml0ZW1zWzBdLCBpdGVtICkgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBrZXlib2FyZCBuYXYgaGFwcGVuZWQgZmlyc3QsIHVzZXIgc2VsZWN0ZWQgZnJvbSBkcm9wZG93blxuICAgICAgICAgICAgICBpdGVtID0gY3RybC5pdGVtc1tjdHJsLmFjdGl2ZUluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGFnZ2luZyBhbHdheXMgb3BlcmF0ZXMgYXQgaW5kZXggemVybywgdGFnZ2luZ0xhYmVsID09PSBmYWxzZSBwdXNoZXNcbiAgICAgICAgICAgIC8vIHRoZSBjdHJsLnNlYXJjaCB2YWx1ZSB3aXRob3V0IGhhdmluZyBpdCBpbmplY3RlZFxuICAgICAgICAgICAgaWYgKCBjdHJsLmFjdGl2ZUluZGV4ID09PSAwICkge1xuICAgICAgICAgICAgICAvLyBjdHJsLnRhZ2dpbmcgcHVzaGVzIGl0ZW1zIHRvIGN0cmwuaXRlbXMsIHNvIHdlIG9ubHkgaGF2ZSBlbXB0eSB2YWxcbiAgICAgICAgICAgICAgLy8gZm9yIGBpdGVtYCBpZiBpdCBpcyBhIGRldGVjdGVkIGR1cGxpY2F0ZVxuICAgICAgICAgICAgICBpZiAoIGl0ZW0gPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGl0ZW0gb24gdGhlIGZseSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lO1xuICAgICAgICAgICAgICAvLyB1c2UgdGFnZ2luZyBmdW5jdGlvbiBpZiB3ZSBoYXZlIG9uZVxuICAgICAgICAgICAgICBpZiAoIGN0cmwudGFnZ2luZy5mY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGN0cmwudGFnZ2luZy5mY3QoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgICAgICAgICAgIC8vIGlmIGl0ZW0gdHlwZSBpcyAnc3RyaW5nJywgYXBwbHkgdGhlIHRhZ2dpbmcgbGFiZWxcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgIC8vIHRyaW0gdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZShjdHJsLnRhZ2dpbmdMYWJlbCwnJykudHJpbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNlYXJjaCBjdHJsLnNlbGVjdGVkIGZvciBkdXBlcyBwb3RlbnRpYWxseSBjYXVzZWQgYnkgdGFnZ2luZyBhbmQgcmV0dXJuIGVhcmx5IGlmIGZvdW5kXG4gICAgICAgICAgaWYgKCBjdHJsLnNlbGVjdGVkICYmIGFuZ3VsYXIuaXNBcnJheShjdHJsLnNlbGVjdGVkKSAmJiBjdHJsLnNlbGVjdGVkLmZpbHRlciggZnVuY3Rpb24gKHNlbGVjdGlvbikgeyByZXR1cm4gYW5ndWxhci5lcXVhbHMoc2VsZWN0aW9uLCBpdGVtKTsgfSkubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIGN0cmwuY2xvc2Uoc2tpcEZvY3Vzc2VyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgndWlzOnNlbGVjdCcsIGl0ZW0pO1xuXG4gICAgICAgIHZhciBsb2NhbHMgPSB7fTtcbiAgICAgICAgbG9jYWxzW2N0cmwucGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IGl0ZW07XG5cbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBjdHJsLm9uU2VsZWN0Q2FsbGJhY2soJHNjb3BlLCB7XG4gICAgICAgICAgICAkaXRlbTogaXRlbSxcbiAgICAgICAgICAgICRtb2RlbDogY3RybC5wYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIoJHNjb3BlLCBsb2NhbHMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjdHJsLmNsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICBjdHJsLmNsb3NlKHNraXBGb2N1c3Nlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRldmVudCAmJiAkZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgIGN0cmwuY2xpY2tUcmlnZ2VyZWRTZWxlY3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIENsb3NlcyB0aGUgZHJvcGRvd25cbiAgY3RybC5jbG9zZSA9IGZ1bmN0aW9uKHNraXBGb2N1c3Nlcikge1xuICAgIGlmICghY3RybC5vcGVuKSByZXR1cm47XG4gICAgaWYgKGN0cmwubmdNb2RlbCAmJiBjdHJsLm5nTW9kZWwuJHNldFRvdWNoZWQpIGN0cmwubmdNb2RlbC4kc2V0VG91Y2hlZCgpO1xuICAgIF9yZXNldFNlYXJjaElucHV0KCk7XG4gICAgY3RybC5vcGVuID0gZmFsc2U7XG5cbiAgICAkc2NvcGUuJGJyb2FkY2FzdCgndWlzOmNsb3NlJywgc2tpcEZvY3Vzc2VyKTtcblxuICB9O1xuXG4gIGN0cmwuc2V0Rm9jdXMgPSBmdW5jdGlvbigpe1xuICAgIGlmICghY3RybC5mb2N1cykgY3RybC5mb2N1c0lucHV0WzBdLmZvY3VzKCk7XG4gIH07XG5cbiAgY3RybC5jbGVhciA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgIGN0cmwuc2VsZWN0KHVuZGVmaW5lZCk7XG4gICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgY3RybC5mb2N1c3NlclswXS5mb2N1cygpO1xuICAgIH0sIDAsIGZhbHNlKTtcbiAgfTtcblxuICAvLyBUb2dnbGUgZHJvcGRvd25cbiAgY3RybC50b2dnbGUgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGN0cmwub3Blbikge1xuICAgICAgY3RybC5jbG9zZSgpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3RybC5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBjdHJsLmlzTG9ja2VkID0gZnVuY3Rpb24oaXRlbVNjb3BlLCBpdGVtSW5kZXgpIHtcbiAgICAgIHZhciBpc0xvY2tlZCwgaXRlbSA9IGN0cmwuc2VsZWN0ZWRbaXRlbUluZGV4XTtcblxuICAgICAgaWYgKGl0ZW0gJiYgIWFuZ3VsYXIuaXNVbmRlZmluZWQoY3RybC5sb2NrQ2hvaWNlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICBpc0xvY2tlZCA9ICEhKGl0ZW1TY29wZS4kZXZhbChjdHJsLmxvY2tDaG9pY2VFeHByZXNzaW9uKSk7IC8vIGZvcmNlIHRoZSBib29sZWFuIHZhbHVlXG4gICAgICAgICAgaXRlbS5fdWlTZWxlY3RDaG9pY2VMb2NrZWQgPSBpc0xvY2tlZDsgLy8gc3RvcmUgdGhpcyBmb3IgbGF0ZXIgcmVmZXJlbmNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0xvY2tlZDtcbiAgfTtcblxuICB2YXIgc2l6ZVdhdGNoID0gbnVsbDtcbiAgY3RybC5zaXplU2VhcmNoSW5wdXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBpbnB1dCA9IGN0cmwuc2VhcmNoSW5wdXRbMF0sXG4gICAgICAgIGNvbnRhaW5lciA9IGN0cmwuc2VhcmNoSW5wdXQucGFyZW50KCkucGFyZW50KClbMF0sXG4gICAgICAgIGNhbGN1bGF0ZUNvbnRhaW5lcldpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb250YWluZXIgd2lkdGggb25seSBpZiB0aGUgc2VhcmNoIGlucHV0IGlzIHZpc2libGVcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudFdpZHRoICogISFpbnB1dC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUlmVmlzaWJsZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lcldpZHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbnB1dFdpZHRoID0gY29udGFpbmVyV2lkdGggLSBpbnB1dC5vZmZzZXRMZWZ0IC0gMTA7XG4gICAgICAgICAgaWYgKGlucHV0V2lkdGggPCA1MCkgaW5wdXRXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgIGN0cmwuc2VhcmNoSW5wdXQuY3NzKCd3aWR0aCcsIGlucHV0V2lkdGgrJ3B4Jyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICBjdHJsLnNlYXJjaElucHV0LmNzcygnd2lkdGgnLCAnMTBweCcpO1xuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkgeyAvL0dpdmUgdGFncyB0aW1lIHRvIHJlbmRlciBjb3JyZWN0bHlcbiAgICAgIGlmIChzaXplV2F0Y2ggPT09IG51bGwgJiYgIXVwZGF0ZUlmVmlzaWJsZShjYWxjdWxhdGVDb250YWluZXJXaWR0aCgpKSkge1xuICAgICAgICBzaXplV2F0Y2ggPSAkc2NvcGUuJHdhdGNoKGNhbGN1bGF0ZUNvbnRhaW5lcldpZHRoLCBmdW5jdGlvbihjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgIGlmICh1cGRhdGVJZlZpc2libGUoY29udGFpbmVyV2lkdGgpKSB7XG4gICAgICAgICAgICBzaXplV2F0Y2goKTtcbiAgICAgICAgICAgIHNpemVXYXRjaCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBfaGFuZGxlRHJvcERvd25TZWxlY3Rpb24oa2V5KSB7XG4gICAgdmFyIHByb2Nlc3NlZCA9IHRydWU7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgS0VZLkRPV046XG4gICAgICAgIGlmICghY3RybC5vcGVuICYmIGN0cmwubXVsdGlwbGUpIGN0cmwuYWN0aXZhdGUoZmFsc2UsIHRydWUpOyAvL0luIGNhc2UgaXRzIHRoZSBzZWFyY2ggaW5wdXQgaW4gJ211bHRpcGxlJyBtb2RlXG4gICAgICAgIGVsc2UgaWYgKGN0cmwuYWN0aXZlSW5kZXggPCBjdHJsLml0ZW1zLmxlbmd0aCAtIDEpIHsgY3RybC5hY3RpdmVJbmRleCsrOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVkuVVA6XG4gICAgICAgIGlmICghY3RybC5vcGVuICYmIGN0cmwubXVsdGlwbGUpIGN0cmwuYWN0aXZhdGUoZmFsc2UsIHRydWUpOyAvL0luIGNhc2UgaXRzIHRoZSBzZWFyY2ggaW5wdXQgaW4gJ211bHRpcGxlJyBtb2RlXG4gICAgICAgIGVsc2UgaWYgKGN0cmwuYWN0aXZlSW5kZXggPiAwIHx8IChjdHJsLnNlYXJjaC5sZW5ndGggPT09IDAgJiYgY3RybC50YWdnaW5nLmlzQWN0aXZhdGVkICYmIGN0cmwuYWN0aXZlSW5kZXggPiAtMSkpIHsgY3RybC5hY3RpdmVJbmRleC0tOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVkuVEFCOlxuICAgICAgICBpZiAoIWN0cmwubXVsdGlwbGUgfHwgY3RybC5vcGVuKSBjdHJsLnNlbGVjdChjdHJsLml0ZW1zW2N0cmwuYWN0aXZlSW5kZXhdLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWS5FTlRFUjpcbiAgICAgICAgaWYoY3RybC5vcGVuICYmIChjdHJsLnRhZ2dpbmcuaXNBY3RpdmF0ZWQgfHwgY3RybC5hY3RpdmVJbmRleCA+PSAwKSl7XG4gICAgICAgICAgY3RybC5zZWxlY3QoY3RybC5pdGVtc1tjdHJsLmFjdGl2ZUluZGV4XSk7IC8vIE1ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgZHJvcGRvd24gaXRlbSBpcyBoaWdobGlnaHRlZCBiZWZvcmUgYWRkaW5nIGlmIG5vdCBpbiB0YWdnaW5nIG1vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHJsLmFjdGl2YXRlKGZhbHNlLCB0cnVlKTsgLy9JbiBjYXNlIGl0cyB0aGUgc2VhcmNoIGlucHV0IGluICdtdWx0aXBsZScgbW9kZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVkuRVNDOlxuICAgICAgICBjdHJsLmNsb3NlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gIH1cblxuICAvLyBCaW5kIHRvIGtleWJvYXJkIHNob3J0Y3V0c1xuICBjdHJsLnNlYXJjaElucHV0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIGtleSA9IGUud2hpY2g7XG5cbiAgICAvLyBpZih+W0tFWS5FU0MsS0VZLlRBQl0uaW5kZXhPZihrZXkpKXtcbiAgICAvLyAgIC8vVE9ETzogU0VHVVJPP1xuICAgIC8vICAgY3RybC5jbG9zZSgpO1xuICAgIC8vIH1cblxuICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciB0YWdnZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGN0cmwuaXRlbXMubGVuZ3RoID4gMCB8fCBjdHJsLnRhZ2dpbmcuaXNBY3RpdmF0ZWQpIHtcbiAgICAgICAgX2hhbmRsZURyb3BEb3duU2VsZWN0aW9uKGtleSk7XG4gICAgICAgIGlmICggY3RybC50YWdnaW5nVG9rZW5zLmlzQWN0aXZhdGVkICkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3RybC50YWdnaW5nVG9rZW5zLnRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCBjdHJsLnRhZ2dpbmdUb2tlbnMudG9rZW5zW2ldID09PSBLRVkuTUFQW2Uua2V5Q29kZV0gKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIG5ldyB2YWx1ZSB0byBwdXNoIHZpYSB0YWdnaW5nXG4gICAgICAgICAgICAgIGlmICggY3RybC5zZWFyY2gubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgICAgICB0YWdnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggdGFnZ2VkICkge1xuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGN0cmwuc2VhcmNoSW5wdXQudHJpZ2dlckhhbmRsZXIoJ3RhZ2dlZCcpO1xuICAgICAgICAgICAgICB2YXIgbmV3SXRlbSA9IGN0cmwuc2VhcmNoLnJlcGxhY2UoS0VZLk1BUFtlLmtleUNvZGVdLCcnKS50cmltKCk7XG4gICAgICAgICAgICAgIGlmICggY3RybC50YWdnaW5nLmZjdCApIHtcbiAgICAgICAgICAgICAgICBuZXdJdGVtID0gY3RybC50YWdnaW5nLmZjdCggbmV3SXRlbSApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXdJdGVtKSBjdHJsLnNlbGVjdChuZXdJdGVtLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBpZihLRVkuaXNWZXJ0aWNhbE1vdmVtZW50KGtleSkgJiYgY3RybC5pdGVtcy5sZW5ndGggPiAwKXtcbiAgICAgIF9lbnN1cmVIaWdobGlnaHRWaXNpYmxlKCk7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gS0VZLkVOVEVSIHx8IGtleSA9PT0gS0VZLkVTQykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgY3RybC5zZWFyY2hJbnB1dC5vbigncGFzdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBkYXRhO1xuXG4gICAgaWYgKHdpbmRvdy5jbGlwYm9hcmREYXRhICYmIHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEpIHsgLy8gSUVcbiAgICAgIGRhdGEgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCdUZXh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSAoZS5vcmlnaW5hbEV2ZW50IHx8IGUpLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgIH1cblxuICAgIC8vIFByZXBlbmQgdGhlIGN1cnJlbnQgaW5wdXQgZmllbGQgdGV4dCB0byB0aGUgcGFzdGUgYnVmZmVyLlxuICAgIGRhdGEgPSBjdHJsLnNlYXJjaCArIGRhdGE7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRhZ2dpbmcgdHJ5IHRvIHNwbGl0IGJ5IHRva2VucyBhbmQgYWRkIGl0ZW1zXG4gICAgICBpZiAoY3RybC50YWdnaW5nVG9rZW5zLmlzQWN0aXZhdGVkKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBLRVkudG9TZXBhcmF0b3IoY3RybC50YWdnaW5nVG9rZW5zLnRva2Vuc1swXSk7XG4gICAgICAgIHZhciBpdGVtcyA9IGRhdGEuc3BsaXQoc2VwYXJhdG9yIHx8IGN0cmwudGFnZ2luZ1Rva2Vucy50b2tlbnNbMF0pOyAvLyBzcGxpdCBieSBmaXJzdCB0b2tlbiBvbmx5XG4gICAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBvbGRzZWFyY2ggPSBjdHJsLnNlYXJjaDtcbiAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgbmV3SXRlbSA9IGN0cmwudGFnZ2luZy5mY3QgPyBjdHJsLnRhZ2dpbmcuZmN0KGl0ZW0pIDogaXRlbTtcbiAgICAgICAgICAgIGlmIChuZXdJdGVtKSB7XG4gICAgICAgICAgICAgIGN0cmwuc2VsZWN0KG5ld0l0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN0cmwuc2VhcmNoID0gb2xkc2VhcmNoIHx8IEVNUFRZX1NFQVJDSDtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdHJsLnBhc3RlKSB7XG4gICAgICAgIGN0cmwucGFzdGUoZGF0YSk7XG4gICAgICAgIGN0cmwuc2VhcmNoID0gRU1QVFlfU0VBUkNIO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjdHJsLnNlYXJjaElucHV0Lm9uKCd0YWdnZWQnLCBmdW5jdGlvbigpIHtcbiAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXNldFNlYXJjaElucHV0KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIvYmxvYi8zLjQuNi9zZWxlY3QyLmpzI0wxNDMxXG4gIGZ1bmN0aW9uIF9lbnN1cmVIaWdobGlnaHRWaXNpYmxlKCkge1xuICAgIHZhciBjb250YWluZXIgPSAkZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudWktc2VsZWN0LWNob2ljZXMtY29udGVudCcpO1xuICAgIHZhciBjaG9pY2VzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtY2hvaWNlcy1yb3cnKTtcbiAgICBpZiAoY2hvaWNlcy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycignY2hvaWNlcycsIFwiRXhwZWN0ZWQgbXVsdGlwbGUgLnVpLXNlbGVjdC1jaG9pY2VzLXJvdyBidXQgZ290ICd7MH0nLlwiLCBjaG9pY2VzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKGN0cmwuYWN0aXZlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhpZ2hsaWdodGVkID0gY2hvaWNlc1tjdHJsLmFjdGl2ZUluZGV4XTtcbiAgICB2YXIgcG9zWSA9IGhpZ2hsaWdodGVkLm9mZnNldFRvcCArIGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCAtIGNvbnRhaW5lclswXS5zY3JvbGxUb3A7XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclswXS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBpZiAocG9zWSA+IGhlaWdodCkge1xuICAgICAgY29udGFpbmVyWzBdLnNjcm9sbFRvcCArPSBwb3NZIC0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zWSA8IGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCkge1xuICAgICAgaWYgKGN0cmwuaXNHcm91cGVkICYmIGN0cmwuYWN0aXZlSW5kZXggPT09IDApXG4gICAgICAgIGNvbnRhaW5lclswXS5zY3JvbGxUb3AgPSAwOyAvL1RvIG1ha2UgZ3JvdXAgaGVhZGVyIHZpc2libGUgd2hlbiBnb2luZyBhbGwgdGhlIHdheSB1cFxuICAgICAgZWxzZVxuICAgICAgICBjb250YWluZXJbMF0uc2Nyb2xsVG9wIC09IGhpZ2hsaWdodGVkLmNsaWVudEhlaWdodCAtIHBvc1k7XG4gICAgfVxuICB9XG5cbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICBjdHJsLnNlYXJjaElucHV0Lm9mZigna2V5dXAga2V5ZG93biB0YWdnZWQgYmx1ciBwYXN0ZScpO1xuICB9KTtcblxufV0pO1xuXG51aXMuZGlyZWN0aXZlKCd1aVNlbGVjdCcsXG4gIFsnJGRvY3VtZW50JywgJ3VpU2VsZWN0Q29uZmlnJywgJ3VpU2VsZWN0TWluRXJyJywgJ3Vpc09mZnNldCcsICckY29tcGlsZScsICckcGFyc2UnLCAnJHRpbWVvdXQnLFxuICBmdW5jdGlvbigkZG9jdW1lbnQsIHVpU2VsZWN0Q29uZmlnLCB1aVNlbGVjdE1pbkVyciwgdWlzT2Zmc2V0LCAkY29tcGlsZSwgJHBhcnNlLCAkdGltZW91dCkge1xuXG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcbiAgICAgIHZhciB0aGVtZSA9IHRBdHRycy50aGVtZSB8fCB1aVNlbGVjdENvbmZpZy50aGVtZTtcbiAgICAgIHJldHVybiB0aGVtZSArIChhbmd1bGFyLmlzRGVmaW5lZCh0QXR0cnMubXVsdGlwbGUpID8gJy9zZWxlY3QtbXVsdGlwbGUudHBsLmh0bWwnIDogJy9zZWxlY3QudHBsLmh0bWwnKTtcbiAgICB9LFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXF1aXJlOiBbJ3VpU2VsZWN0JywgJ15uZ01vZGVsJ10sXG4gICAgc2NvcGU6IHRydWUsXG5cbiAgICBjb250cm9sbGVyOiAndWlTZWxlY3RDdHJsJyxcbiAgICBjb250cm9sbGVyQXM6ICckc2VsZWN0JyxcbiAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG5cbiAgICAgIC8vIEFsbG93IHNldHRpbmcgbmdDbGFzcyBvbiB1aVNlbGVjdFxuICAgICAgdmFyIG1hdGNoID0gL3soLiopfVxccyp7KC4qKX0vLmV4ZWModEF0dHJzLm5nQ2xhc3MpO1xuICAgICAgaWYobWF0Y2gpIHtcbiAgICAgICAgdmFyIGNvbWJpbmVkID0gJ3snKyBtYXRjaFsxXSArJywgJysgbWF0Y2hbMl0gKyd9JztcbiAgICAgICAgdEF0dHJzLm5nQ2xhc3MgPSBjb21iaW5lZDtcbiAgICAgICAgdEVsZW1lbnQuYXR0cignbmctY2xhc3MnLCBjb21iaW5lZCk7XG4gICAgICB9XG5cbiAgICAgIC8vTXVsdGlwbGUgb3IgU2luZ2xlIGRlcGVuZGluZyBpZiBtdWx0aXBsZSBhdHRyaWJ1dGUgcHJlc2VuY2VcbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCh0QXR0cnMubXVsdGlwbGUpKVxuICAgICAgICB0RWxlbWVudC5hcHBlbmQoJzx1aS1zZWxlY3QtbXVsdGlwbGUvPicpLnJlbW92ZUF0dHIoJ211bHRpcGxlJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRFbGVtZW50LmFwcGVuZCgnPHVpLXNlbGVjdC1zaW5nbGUvPicpO1xuXG4gICAgICBpZiAodEF0dHJzLmlucHV0SWQpXG4gICAgICAgIHRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LnVpLXNlbGVjdC1zZWFyY2gnKVswXS5pZCA9IHRBdHRycy5pbnB1dElkO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscywgdHJhbnNjbHVkZUZuKSB7XG5cbiAgICAgICAgdmFyICRzZWxlY3QgPSBjdHJsc1swXTtcbiAgICAgICAgdmFyIG5nTW9kZWwgPSBjdHJsc1sxXTtcblxuICAgICAgICAkc2VsZWN0LmdlbmVyYXRlZElkID0gdWlTZWxlY3RDb25maWcuZ2VuZXJhdGVJZCgpO1xuICAgICAgICAkc2VsZWN0LmJhc2VUaXRsZSA9IGF0dHJzLnRpdGxlIHx8ICdTZWxlY3QgYm94JztcbiAgICAgICAgJHNlbGVjdC5mb2N1c3NlclRpdGxlID0gJHNlbGVjdC5iYXNlVGl0bGUgKyAnIGZvY3VzJztcbiAgICAgICAgJHNlbGVjdC5mb2N1c3NlcklkID0gJ2ZvY3Vzc2VyLScgKyAkc2VsZWN0LmdlbmVyYXRlZElkO1xuXG4gICAgICAgICRzZWxlY3QuY2xvc2VPblNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5jbG9zZU9uU2VsZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuICRwYXJzZShhdHRycy5jbG9zZU9uU2VsZWN0KSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdWlTZWxlY3RDb25maWcuY2xvc2VPblNlbGVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcblxuICAgICAgICAkc2VsZWN0Lm9uU2VsZWN0Q2FsbGJhY2sgPSAkcGFyc2UoYXR0cnMub25TZWxlY3QpO1xuICAgICAgICAkc2VsZWN0Lm9uUmVtb3ZlQ2FsbGJhY2sgPSAkcGFyc2UoYXR0cnMub25SZW1vdmUpO1xuXG4gICAgICAgIC8vTGltaXQgdGhlIG51bWJlciBvZiBzZWxlY3Rpb25zIGFsbG93ZWRcbiAgICAgICAgJHNlbGVjdC5saW1pdCA9IChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5saW1pdCkpID8gcGFyc2VJbnQoYXR0cnMubGltaXQsIDEwKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvL1NldCByZWZlcmVuY2UgdG8gbmdNb2RlbCBmcm9tIHVpU2VsZWN0Q3RybFxuICAgICAgICAkc2VsZWN0Lm5nTW9kZWwgPSBuZ01vZGVsO1xuXG4gICAgICAgICRzZWxlY3QuY2hvaWNlR3JvdXBlZCA9IGZ1bmN0aW9uKGdyb3VwKXtcbiAgICAgICAgICByZXR1cm4gJHNlbGVjdC5pc0dyb3VwZWQgJiYgZ3JvdXAgJiYgZ3JvdXAubmFtZTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZihhdHRycy50YWJpbmRleCl7XG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoJ3RhYmluZGV4JywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICRzZWxlY3QuZm9jdXNJbnB1dC5hdHRyKCd0YWJpbmRleCcsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnc2VhcmNoRW5hYmxlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaEVuYWJsZWQgPSBzY29wZS4kZXZhbChhdHRycy5zZWFyY2hFbmFibGVkKTtcbiAgICAgICAgICAgICRzZWxlY3Quc2VhcmNoRW5hYmxlZCA9IHNlYXJjaEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IHNlYXJjaEVuYWJsZWQgOiB1aVNlbGVjdENvbmZpZy5zZWFyY2hFbmFibGVkO1xuICAgICAgICB9KTtcblxuICAgICAgICBzY29wZS4kd2F0Y2goJ3NvcnRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc29ydGFibGUgPSBzY29wZS4kZXZhbChhdHRycy5zb3J0YWJsZSk7XG4gICAgICAgICAgICAkc2VsZWN0LnNvcnRhYmxlID0gc29ydGFibGUgIT09IHVuZGVmaW5lZCA/IHNvcnRhYmxlIDogdWlTZWxlY3RDb25maWcuc29ydGFibGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdkaXNhYmxlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gdXNlICRldmFsKCkgKHRoYW5rcyB0byBuZy1kaXNhYmxlZCkgc2luY2Ugd2UgYWxyZWFkeSBnZXQgYSBib29sZWFuIGluc3RlYWQgb2YgYSBzdHJpbmdcbiAgICAgICAgICAkc2VsZWN0LmRpc2FibGVkID0gYXR0cnMuZGlzYWJsZWQgIT09IHVuZGVmaW5lZCA/IGF0dHJzLmRpc2FibGVkIDogZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdyZXNldFNlYXJjaElucHV0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gJGV2YWwoKSBpcyBuZWVkZWQgb3RoZXJ3aXNlIHdlIGdldCBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgYm9vbGVhblxuICAgICAgICAgIHZhciByZXNldFNlYXJjaElucHV0ID0gc2NvcGUuJGV2YWwoYXR0cnMucmVzZXRTZWFyY2hJbnB1dCk7XG4gICAgICAgICAgJHNlbGVjdC5yZXNldFNlYXJjaElucHV0ID0gcmVzZXRTZWFyY2hJbnB1dCAhPT0gdW5kZWZpbmVkID8gcmVzZXRTZWFyY2hJbnB1dCA6IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCdwYXN0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRzZWxlY3QucGFzdGUgPSBzY29wZS4kZXZhbChhdHRycy5wYXN0ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF0dHJzLiRvYnNlcnZlKCd0YWdnaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoYXR0cnMudGFnZ2luZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vICRldmFsKCkgaXMgbmVlZGVkIG90aGVyd2lzZSB3ZSBnZXQgYSBzdHJpbmcgaW5zdGVhZCBvZiBhIGJvb2xlYW5cbiAgICAgICAgICAgIHZhciB0YWdnaW5nRXZhbCA9IHNjb3BlLiRldmFsKGF0dHJzLnRhZ2dpbmcpO1xuICAgICAgICAgICAgJHNlbGVjdC50YWdnaW5nID0ge2lzQWN0aXZhdGVkOiB0cnVlLCBmY3Q6IHRhZ2dpbmdFdmFsICE9PSB0cnVlID8gdGFnZ2luZ0V2YWwgOiB1bmRlZmluZWR9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgJHNlbGVjdC50YWdnaW5nID0ge2lzQWN0aXZhdGVkOiBmYWxzZSwgZmN0OiB1bmRlZmluZWR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ3RhZ2dpbmdMYWJlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGF0dHJzLnRhZ2dpbmcgIT09IHVuZGVmaW5lZCApXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gY2hlY2sgZXZhbCBmb3IgRkFMU0UsIGluIHRoaXMgY2FzZSwgd2UgZGlzYWJsZSB0aGUgbGFiZWxzXG4gICAgICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGFnZ2luZ1xuICAgICAgICAgICAgaWYgKCBhdHRycy50YWdnaW5nTGFiZWwgPT09ICdmYWxzZScgKSB7XG4gICAgICAgICAgICAgICRzZWxlY3QudGFnZ2luZ0xhYmVsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICRzZWxlY3QudGFnZ2luZ0xhYmVsID0gYXR0cnMudGFnZ2luZ0xhYmVsICE9PSB1bmRlZmluZWQgPyBhdHRycy50YWdnaW5nTGFiZWwgOiAnKG5ldyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ3RhZ2dpbmdUb2tlbnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoYXR0cnMudGFnZ2luZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gYXR0cnMudGFnZ2luZ1Rva2VucyAhPT0gdW5kZWZpbmVkID8gYXR0cnMudGFnZ2luZ1Rva2Vucy5zcGxpdCgnfCcpIDogWycsJywnRU5URVInXTtcbiAgICAgICAgICAgICRzZWxlY3QudGFnZ2luZ1Rva2VucyA9IHtpc0FjdGl2YXRlZDogdHJ1ZSwgdG9rZW5zOiB0b2tlbnMgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vQXV0b21hdGljYWxseSBnZXRzIGZvY3VzIHdoZW4gbG9hZGVkXG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5hdXRvZm9jdXMpKXtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgJHNlbGVjdC5zZXRGb2N1cygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9HZXRzIGZvY3VzIGJhc2VkIG9uIHNjb3BlIGV2ZW50IG5hbWUgKGUuZy4gZm9jdXMtb249J1NvbWVFdmVudE5hbWUnKVxuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZm9jdXNPbikpe1xuICAgICAgICAgIHNjb3BlLiRvbihhdHRycy5mb2N1c09uLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAkc2VsZWN0LnNldEZvY3VzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGUpIHtcbiAgICAgICAgICBpZiAoISRzZWxlY3Qub3BlbikgcmV0dXJuOyAvL1NraXAgaXQgaWYgZHJvcGRvd24gaXMgY2xvc2VcblxuICAgICAgICAgIHZhciBjb250YWlucyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHdpbmRvdy5qUXVlcnkpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggMy42IGRvZXMgbm90IHN1cHBvcnQgZWxlbWVudC5jb250YWlucygpXG4gICAgICAgICAgICAvLyBTZWUgTm9kZS5jb250YWlucyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS5jb250YWluc1xuICAgICAgICAgICAgY29udGFpbnMgPSB3aW5kb3cualF1ZXJ5LmNvbnRhaW5zKGVsZW1lbnRbMF0sIGUudGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbnMgPSBlbGVtZW50WzBdLmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zICYmICEkc2VsZWN0LmNsaWNrVHJpZ2dlcmVkU2VsZWN0KSB7XG4gICAgICAgICAgICAvL1dpbGwgbG9zZSBmb2N1cyBvbmx5IHdpdGggY2VydGFpbiB0YXJnZXRzXG4gICAgICAgICAgICB2YXIgZm9jdXNhYmxlQ29udHJvbHMgPSBbJ2lucHV0JywnYnV0dG9uJywndGV4dGFyZWEnLCdzZWxlY3QnXTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRDb250cm9sbGVyID0gYW5ndWxhci5lbGVtZW50KGUudGFyZ2V0KS5jb250cm9sbGVyKCd1aVNlbGVjdCcpOyAvL1RvIGNoZWNrIGlmIHRhcmdldCBpcyBvdGhlciB1aS1zZWxlY3RcbiAgICAgICAgICAgIHZhciBza2lwRm9jdXNzZXIgPSB0YXJnZXRDb250cm9sbGVyICYmIHRhcmdldENvbnRyb2xsZXIgIT09ICRzZWxlY3Q7IC8vVG8gY2hlY2sgaWYgdGFyZ2V0IGlzIG90aGVyIHVpLXNlbGVjdFxuICAgICAgICAgICAgaWYgKCFza2lwRm9jdXNzZXIpIHNraXBGb2N1c3NlciA9ICB+Zm9jdXNhYmxlQ29udHJvbHMuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpOyAvL0NoZWNrIGlmIHRhcmdldCBpcyBpbnB1dCwgYnV0dG9uIG9yIHRleHRhcmVhXG4gICAgICAgICAgICAkc2VsZWN0LmNsb3NlKHNraXBGb2N1c3Nlcik7XG4gICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRzZWxlY3QuY2xpY2tUcmlnZ2VyZWRTZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlZSBDbGljayBldmVyeXdoZXJlIGJ1dCBoZXJlIGV2ZW50IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI5MzEzNjlcbiAgICAgICAgJGRvY3VtZW50Lm9uKCdjbGljaycsIG9uRG9jdW1lbnRDbGljayk7XG5cbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRkb2N1bWVudC5vZmYoJ2NsaWNrJywgb25Eb2N1bWVudENsaWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTW92ZSB0cmFuc2NsdWRlZCBlbGVtZW50cyB0byB0aGVpciBjb3JyZWN0IHBvc2l0aW9uIGluIG1haW4gdGVtcGxhdGVcbiAgICAgICAgdHJhbnNjbHVkZUZuKHNjb3BlLCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgIC8vIFNlZSBUcmFuc2NsdWRlIGluIEFuZ3VsYXJKUyBodHRwOi8vYmxvZy5vbWthcnBhdGlsLmNvbS8yMDEyLzExL3RyYW5zY2x1ZGUtaW4tYW5ndWxhcmpzLmh0bWxcblxuICAgICAgICAgIC8vIE9uZSBkYXkganFMaXRlIHdpbGwgYmUgcmVwbGFjZWQgYnkgalF1ZXJ5IGFuZCB3ZSB3aWxsIGJlIGFibGUgdG8gd3JpdGU6XG4gICAgICAgICAgLy8gdmFyIHRyYW5zY2x1ZGVkRWxlbWVudCA9IGNsb25lLmZpbHRlcignLm15LWNsYXNzJylcbiAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgaGFja2lzaCBET00gZWxlbWVudDpcbiAgICAgICAgICB2YXIgdHJhbnNjbHVkZWQgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+JykuYXBwZW5kKGNsb25lKTtcblxuICAgICAgICAgIHZhciB0cmFuc2NsdWRlZE1hdGNoID0gdHJhbnNjbHVkZWQucXVlcnlTZWxlY3RvckFsbCgnLnVpLXNlbGVjdC1tYXRjaCcpO1xuICAgICAgICAgIHRyYW5zY2x1ZGVkTWF0Y2gucmVtb3ZlQXR0cigndWktc2VsZWN0LW1hdGNoJyk7IC8vVG8gYXZvaWQgbG9vcCBpbiBjYXNlIGRpcmVjdGl2ZSBhcyBhdHRyXG4gICAgICAgICAgdHJhbnNjbHVkZWRNYXRjaC5yZW1vdmVBdHRyKCdkYXRhLXVpLXNlbGVjdC1tYXRjaCcpOyAvLyBQcm9wZXJseSBoYW5kbGUgSFRNTDUgZGF0YS1hdHRyaWJ1dGVzXG4gICAgICAgICAgaWYgKHRyYW5zY2x1ZGVkTWF0Y2gubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycigndHJhbnNjbHVkZWQnLCBcIkV4cGVjdGVkIDEgLnVpLXNlbGVjdC1tYXRjaCBidXQgZ290ICd7MH0nLlwiLCB0cmFuc2NsdWRlZE1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnVpLXNlbGVjdC1tYXRjaCcpLnJlcGxhY2VXaXRoKHRyYW5zY2x1ZGVkTWF0Y2gpO1xuXG4gICAgICAgICAgdmFyIHRyYW5zY2x1ZGVkQ2hvaWNlcyA9IHRyYW5zY2x1ZGVkLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtY2hvaWNlcycpO1xuICAgICAgICAgIHRyYW5zY2x1ZGVkQ2hvaWNlcy5yZW1vdmVBdHRyKCd1aS1zZWxlY3QtY2hvaWNlcycpOyAvL1RvIGF2b2lkIGxvb3AgaW4gY2FzZSBkaXJlY3RpdmUgYXMgYXR0clxuICAgICAgICAgIHRyYW5zY2x1ZGVkQ2hvaWNlcy5yZW1vdmVBdHRyKCdkYXRhLXVpLXNlbGVjdC1jaG9pY2VzJyk7IC8vIFByb3Blcmx5IGhhbmRsZSBIVE1MNSBkYXRhLWF0dHJpYnV0ZXNcbiAgICAgICAgICBpZiAodHJhbnNjbHVkZWRDaG9pY2VzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ3RyYW5zY2x1ZGVkJywgXCJFeHBlY3RlZCAxIC51aS1zZWxlY3QtY2hvaWNlcyBidXQgZ290ICd7MH0nLlwiLCB0cmFuc2NsdWRlZENob2ljZXMubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudWktc2VsZWN0LWNob2ljZXMnKS5yZXBsYWNlV2l0aCh0cmFuc2NsdWRlZENob2ljZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdXBwb3J0IGZvciBhcHBlbmRpbmcgdGhlIHNlbGVjdCBmaWVsZCB0byB0aGUgYm9keSB3aGVuIGl0cyBvcGVuXG4gICAgICAgIHZhciBhcHBlbmRUb0JvZHkgPSBzY29wZS4kZXZhbChhdHRycy5hcHBlbmRUb0JvZHkpO1xuICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5ICE9PSB1bmRlZmluZWQgPyBhcHBlbmRUb0JvZHkgOiB1aVNlbGVjdENvbmZpZy5hcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgICBzY29wZS4kd2F0Y2goJyRzZWxlY3Qub3BlbicsIGZ1bmN0aW9uKGlzT3Blbikge1xuICAgICAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgICBwb3NpdGlvbkRyb3Bkb3duKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNldERyb3Bkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBNb3ZlIHRoZSBkcm9wZG93biBiYWNrIHRvIGl0cyBvcmlnaW5hbCBsb2NhdGlvbiB3aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWQuIE90aGVyd2lzZVxuICAgICAgICAgIC8vIGl0IG1pZ2h0IHN0aWNrIGFyb3VuZCB3aGVuIHRoZSB1c2VyIHJvdXRlcyBhd2F5IG9yIHRoZSBzZWxlY3QgZmllbGQgaXMgb3RoZXJ3aXNlIHJlbW92ZWRcbiAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXNldERyb3Bkb3duKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIb2xkIG9uIHRvIGEgcmVmZXJlbmNlIHRvIHRoZSAudWktc2VsZWN0LWNvbnRhaW5lciBlbGVtZW50IGZvciBhcHBlbmRUb0JvZHkgc3VwcG9ydFxuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBudWxsLFxuICAgICAgICAgICAgb3JpZ2luYWxXaWR0aCA9ICcnO1xuXG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uRHJvcGRvd24oKSB7XG4gICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHVpc09mZnNldChlbGVtZW50KTtcblxuICAgICAgICAgIC8vIENsb25lIHRoZSBlbGVtZW50IGludG8gYSBwbGFjZWhvbGRlciBlbGVtZW50IHRvIHRha2UgaXRzIG9yaWdpbmFsIHBsYWNlIGluIHRoZSBET01cbiAgICAgICAgICBwbGFjZWhvbGRlciA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBjbGFzcz1cInVpLXNlbGVjdC1wbGFjZWhvbGRlclwiPjwvZGl2PicpO1xuICAgICAgICAgIHBsYWNlaG9sZGVyWzBdLnN0eWxlLndpZHRoID0gb2Zmc2V0LndpZHRoICsgJ3B4JztcbiAgICAgICAgICBwbGFjZWhvbGRlclswXS5zdHlsZS5oZWlnaHQgPSBvZmZzZXQuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICBlbGVtZW50LmFmdGVyKHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZWxlbWVudCB3aWR0aCBpbmxpbmUgc3R5bGUsIHNvIGl0IGNhbiBiZSByZXN0b3JlZFxuICAgICAgICAgIC8vIHdoZW4gdGhlIGRyb3Bkb3duIGlzIGNsb3NlZFxuICAgICAgICAgIG9yaWdpbmFsV2lkdGggPSBlbGVtZW50WzBdLnN0eWxlLndpZHRoO1xuXG4gICAgICAgICAgLy8gTm93IG1vdmUgdGhlIGFjdHVhbCBkcm9wZG93biBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIGJvZHlcbiAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZChlbGVtZW50KTtcblxuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUubGVmdCA9IG9mZnNldC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICBlbGVtZW50WzBdLnN0eWxlLnRvcCA9IG9mZnNldC50b3AgKyAncHgnO1xuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUud2lkdGggPSBvZmZzZXQud2lkdGggKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVzZXREcm9wZG93bigpIHtcbiAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkcm9wZG93biBoYXMgbm90IGFjdHVhbGx5IGJlZW4gZGlzcGxheSB5ZXQsIHNvIHRoZXJlJ3Mgbm90aGluZyB0byByZXNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1vdmUgdGhlIGRyb3Bkb3duIGVsZW1lbnQgYmFjayB0byBpdHMgb3JpZ2luYWwgbG9jYXRpb24gaW4gdGhlIERPTVxuICAgICAgICAgIHBsYWNlaG9sZGVyLnJlcGxhY2VXaXRoKGVsZW1lbnQpO1xuICAgICAgICAgIHBsYWNlaG9sZGVyID0gbnVsbDtcblxuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgICBlbGVtZW50WzBdLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgICAgICBlbGVtZW50WzBdLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICAgIGVsZW1lbnRbMF0uc3R5bGUud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSG9sZCBvbiB0byBhIHJlZmVyZW5jZSB0byB0aGUgLnVpLXNlbGVjdC1kcm9wZG93biBlbGVtZW50IGZvciBkaXJlY3Rpb24gc3VwcG9ydC5cbiAgICAgICAgdmFyIGRyb3Bkb3duID0gbnVsbCxcbiAgICAgICAgICAgIGRpcmVjdGlvblVwQ2xhc3NOYW1lID0gJ2RpcmVjdGlvbi11cCc7XG5cbiAgICAgICAgLy8gU3VwcG9ydCBjaGFuZ2luZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBkcm9wZG93biBpZiB0aGVyZSBpc24ndCBlbm91Z2ggc3BhY2UgdG8gcmVuZGVyIGl0LlxuICAgICAgICBzY29wZS4kd2F0Y2goJyRzZWxlY3Qub3BlbicsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKCRzZWxlY3QuZHJvcGRvd25Qb3NpdGlvbiA9PT0gJ2F1dG8nIHx8ICRzZWxlY3QuZHJvcGRvd25Qb3NpdGlvbiA9PT0gJ3VwJyl7XG4gICAgICAgICAgICBzY29wZS5jYWxjdWxhdGVEcm9wZG93blBvcygpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2V0RHJvcGRvd25Qb3NVcCA9IGZ1bmN0aW9uKG9mZnNldCwgb2Zmc2V0RHJvcGRvd24pe1xuXG4gICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IHVpc09mZnNldChlbGVtZW50KTtcbiAgICAgICAgICBvZmZzZXREcm9wZG93biA9IG9mZnNldERyb3Bkb3duIHx8IHVpc09mZnNldChkcm9wZG93bik7XG5cbiAgICAgICAgICBkcm9wZG93blswXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUudG9wID0gKG9mZnNldERyb3Bkb3duLmhlaWdodCAqIC0xKSArICdweCc7XG4gICAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhkaXJlY3Rpb25VcENsYXNzTmFtZSk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2V0RHJvcGRvd25Qb3NEb3duID0gZnVuY3Rpb24ob2Zmc2V0LCBvZmZzZXREcm9wZG93bil7XG5cbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRpcmVjdGlvblVwQ2xhc3NOYW1lKTtcblxuICAgICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCB1aXNPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgICAgb2Zmc2V0RHJvcGRvd24gPSBvZmZzZXREcm9wZG93biB8fCB1aXNPZmZzZXQoZHJvcGRvd24pO1xuXG4gICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgICBkcm9wZG93blswXS5zdHlsZS50b3AgPSAnJztcblxuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLmNhbGN1bGF0ZURyb3Bkb3duUG9zID0gZnVuY3Rpb24oKXtcblxuICAgICAgICAgIGlmICgkc2VsZWN0Lm9wZW4pIHtcbiAgICAgICAgICAgIGRyb3Bkb3duID0gYW5ndWxhci5lbGVtZW50KGVsZW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aS1zZWxlY3QtZHJvcGRvd24nKTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93bi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIaWRlIHRoZSBkcm9wZG93biBzbyB0aGVyZSBpcyBubyBmbGlja2VyIHVudGlsICR0aW1lb3V0IGlzIGRvbmUgZXhlY3V0aW5nLlxuICAgICAgICAgICAgZHJvcGRvd25bMF0uc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgICAgIC8vIERlbGF5IHBvc2l0aW9uaW5nIHRoZSBkcm9wZG93biB1bnRpbCBhbGwgY2hvaWNlcyBoYXZlIGJlZW4gYWRkZWQgc28gaXRzIGhlaWdodCBpcyBjb3JyZWN0LlxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICBpZiAoJHNlbGVjdC5kcm9wZG93blBvc2l0aW9uID09PSAndXAnKXtcbiAgICAgICAgICAgICAgICAgIC8vR28gVVBcbiAgICAgICAgICAgICAgICAgIHNldERyb3Bkb3duUG9zVXAoKTtcblxuICAgICAgICAgICAgICB9ZWxzZXsgLy9BVVRPXG5cbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRpcmVjdGlvblVwQ2xhc3NOYW1lKTtcblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB1aXNPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldERyb3Bkb3duID0gdWlzT2Zmc2V0KGRyb3Bkb3duKTtcblxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM0MjMwNyNjNFxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCAkZG9jdW1lbnRbMF0uYm9keS5zY3JvbGxUb3A7IC8vVG8gbWFrZSBpdCBjcm9zcyBicm93c2VyIChibGluaywgd2Via2l0LCBJRSwgRmlyZWZveCkuXG5cbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZHJvcGRvd24gbmVlZHMgdG8gYmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0LnRvcCArIG9mZnNldC5oZWlnaHQgKyBvZmZzZXREcm9wZG93bi5oZWlnaHQgPiBzY3JvbGxUb3AgKyAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgLy9HbyBVUFxuICAgICAgICAgICAgICAgICAgc2V0RHJvcGRvd25Qb3NVcChvZmZzZXQsIG9mZnNldERyb3Bkb3duKTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIC8vR28gRE9XTlxuICAgICAgICAgICAgICAgICAgc2V0RHJvcGRvd25Qb3NEb3duKG9mZnNldCwgb2Zmc2V0RHJvcGRvd24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgZHJvcGRvd24gb25jZSBpdCBoYXMgYmVlbiBwb3NpdGlvbmVkLlxuICAgICAgICAgICAgICBkcm9wZG93blswXS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChkcm9wZG93biA9PT0gbnVsbCB8fCBkcm9wZG93bi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGRyb3Bkb3duLlxuICAgICAgICAgICAgICBkcm9wZG93blswXS5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgICAgICAgICAgICBkcm9wZG93blswXS5zdHlsZS50b3AgPSAnJztcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhkaXJlY3Rpb25VcENsYXNzTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XSk7XG5cbnVpcy5kaXJlY3RpdmUoJ3VpU2VsZWN0TWF0Y2gnLCBbJ3VpU2VsZWN0Q29uZmlnJywgZnVuY3Rpb24odWlTZWxlY3RDb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXF1aXJlOiAnXnVpU2VsZWN0JyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKHRFbGVtZW50KSB7XG4gICAgICAvLyBOZWVkZWQgc28gdGhlIHVpU2VsZWN0IGNhbiBkZXRlY3QgdGhlIHRyYW5zY2x1ZGVkIGNvbnRlbnRcbiAgICAgIHRFbGVtZW50LmFkZENsYXNzKCd1aS1zZWxlY3QtbWF0Y2gnKTtcblxuICAgICAgLy8gR2V0cyB0aGVtZSBhdHRyaWJ1dGUgZnJvbSBwYXJlbnQgKHVpLXNlbGVjdClcbiAgICAgIHZhciB0aGVtZSA9IHRFbGVtZW50LnBhcmVudCgpLmF0dHIoJ3RoZW1lJykgfHwgdWlTZWxlY3RDb25maWcudGhlbWU7XG4gICAgICB2YXIgbXVsdGkgPSB0RWxlbWVudC5wYXJlbnQoKS5hdHRyKCdtdWx0aXBsZScpO1xuICAgICAgcmV0dXJuIHRoZW1lICsgKG11bHRpID8gJy9tYXRjaC1tdWx0aXBsZS50cGwuaHRtbCcgOiAnL21hdGNoLnRwbC5odG1sJyk7XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsICRzZWxlY3QpIHtcbiAgICAgICRzZWxlY3QubG9ja0Nob2ljZUV4cHJlc3Npb24gPSBhdHRycy51aUxvY2tDaG9pY2U7XG4gICAgICBhdHRycy4kb2JzZXJ2ZSgncGxhY2Vob2xkZXInLCBmdW5jdGlvbihwbGFjZWhvbGRlcikge1xuICAgICAgICAkc2VsZWN0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXIgIT09IHVuZGVmaW5lZCA/IHBsYWNlaG9sZGVyIDogdWlTZWxlY3RDb25maWcucGxhY2Vob2xkZXI7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gc2V0QWxsb3dDbGVhcihhbGxvdykge1xuICAgICAgICAkc2VsZWN0LmFsbG93Q2xlYXIgPSAoYW5ndWxhci5pc0RlZmluZWQoYWxsb3cpKSA/IChhbGxvdyA9PT0gJycpID8gdHJ1ZSA6IChhbGxvdy50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzLiRvYnNlcnZlKCdhbGxvd0NsZWFyJywgc2V0QWxsb3dDbGVhcik7XG4gICAgICBzZXRBbGxvd0NsZWFyKGF0dHJzLmFsbG93Q2xlYXIpO1xuXG4gICAgICBpZigkc2VsZWN0Lm11bHRpcGxlKXtcbiAgICAgICAgJHNlbGVjdC5zaXplU2VhcmNoSW5wdXQoKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfTtcbn1dKTtcblxudWlzLmRpcmVjdGl2ZSgndWlTZWxlY3RNdWx0aXBsZScsIFsndWlTZWxlY3RNaW5FcnInLCckdGltZW91dCcsIGZ1bmN0aW9uKHVpU2VsZWN0TWluRXJyLCAkdGltZW91dCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHJlcXVpcmU6IFsnXnVpU2VsZWN0JywgJ15uZ01vZGVsJ10sXG5cbiAgICBjb250cm9sbGVyOiBbJyRzY29wZScsJyR0aW1lb3V0JywgZnVuY3Rpb24oJHNjb3BlLCAkdGltZW91dCl7XG5cbiAgICAgIHZhciBjdHJsID0gdGhpcyxcbiAgICAgICAgICAkc2VsZWN0ID0gJHNjb3BlLiRzZWxlY3QsXG4gICAgICAgICAgbmdNb2RlbDtcblxuICAgICAgLy9XYWl0IGZvciBsaW5rIGZuIHRvIGluamVjdCBpdCBcbiAgICAgICRzY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCl7IG5nTW9kZWwgPSAkc2NvcGUubmdNb2RlbDsgfSk7XG5cbiAgICAgIGN0cmwuYWN0aXZlTWF0Y2hJbmRleCA9IC0xO1xuXG4gICAgICBjdHJsLnVwZGF0ZU1vZGVsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKERhdGUubm93KCkpOyAvL1NldCB0aW1lc3RhbXAgYXMgYSB1bmlxdWUgc3RyaW5nIHRvIGZvcmNlIGNoYW5nZXNcbiAgICAgICAgY3RybC5yZWZyZXNoQ29tcG9uZW50KCk7XG4gICAgICB9O1xuXG4gICAgICBjdHJsLnJlZnJlc2hDb21wb25lbnQgPSBmdW5jdGlvbigpe1xuICAgICAgICAvL1JlbW92ZSBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgIC8vZS5nLiBXaGVuIHVzZXIgY2xpY2tzIG9uIGEgc2VsZWN0aW9uLCB0aGUgc2VsZWN0ZWQgYXJyYXkgY2hhbmdlcyBhbmQgXG4gICAgICAgIC8vdGhlIGRyb3Bkb3duIHNob3VsZCByZW1vdmUgdGhhdCBpdGVtXG4gICAgICAgICRzZWxlY3QucmVmcmVzaEl0ZW1zKCk7XG4gICAgICAgICRzZWxlY3Quc2l6ZVNlYXJjaElucHV0KCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBSZW1vdmUgaXRlbSBmcm9tIG11bHRpcGxlIHNlbGVjdFxuICAgICAgY3RybC5yZW1vdmVDaG9pY2UgPSBmdW5jdGlvbihpbmRleCl7XG5cbiAgICAgICAgdmFyIHJlbW92ZWRDaG9pY2UgPSAkc2VsZWN0LnNlbGVjdGVkW2luZGV4XTtcblxuICAgICAgICAvLyBpZiB0aGUgY2hvaWNlIGlzIGxvY2tlZCwgY2FuJ3QgcmVtb3ZlIGl0XG4gICAgICAgIGlmKHJlbW92ZWRDaG9pY2UuX3VpU2VsZWN0Q2hvaWNlTG9ja2VkKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xuICAgICAgICBsb2NhbHNbJHNlbGVjdC5wYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gcmVtb3ZlZENob2ljZTtcblxuICAgICAgICAkc2VsZWN0LnNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGN0cmwuYWN0aXZlTWF0Y2hJbmRleCA9IC0xO1xuICAgICAgICAkc2VsZWN0LnNpemVTZWFyY2hJbnB1dCgpO1xuXG4gICAgICAgIC8vIEdpdmUgc29tZSB0aW1lIGZvciBzY29wZSBwcm9wYWdhdGlvbi5cbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAkc2VsZWN0Lm9uUmVtb3ZlQ2FsbGJhY2soJHNjb3BlLCB7XG4gICAgICAgICAgICAkaXRlbTogcmVtb3ZlZENob2ljZSxcbiAgICAgICAgICAgICRtb2RlbDogJHNlbGVjdC5wYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIoJHNjb3BlLCBsb2NhbHMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0cmwudXBkYXRlTW9kZWwoKTtcblxuICAgICAgfTtcblxuICAgICAgY3RybC5nZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vUmVmYWN0b3Igc2luZ2xlP1xuICAgICAgICBpZigkc2VsZWN0LnNlbGVjdGVkICYmICRzZWxlY3Quc2VsZWN0ZWQubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHJldHVybiAkc2VsZWN0LnBsYWNlaG9sZGVyO1xuICAgICAgfTtcblxuXG4gICAgfV0sXG4gICAgY29udHJvbGxlckFzOiAnJHNlbGVjdE11bHRpcGxlJyxcblxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcblxuICAgICAgdmFyICRzZWxlY3QgPSBjdHJsc1swXTtcbiAgICAgIHZhciBuZ01vZGVsID0gc2NvcGUubmdNb2RlbCA9IGN0cmxzWzFdO1xuICAgICAgdmFyICRzZWxlY3RNdWx0aXBsZSA9IHNjb3BlLiRzZWxlY3RNdWx0aXBsZTtcblxuICAgICAgLy8kc2VsZWN0LnNlbGVjdGVkID0gcmF3IHNlbGVjdGVkIG9iamVjdHMgKGlnbm9yaW5nIGFueSBwcm9wZXJ0eSBiaW5kaW5nKVxuXG4gICAgICAkc2VsZWN0Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICRzZWxlY3QucmVtb3ZlU2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAvL0lucHV0IHRoYXQgd2lsbCBoYW5kbGUgZm9jdXNcbiAgICAgICRzZWxlY3QuZm9jdXNJbnB1dCA9ICRzZWxlY3Quc2VhcmNoSW5wdXQ7XG5cbiAgICAgIC8vRnJvbSB2aWV3IC0tPiBtb2RlbFxuICAgICAgbmdNb2RlbC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvY2FscyA9IHt9LFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9ICRzZWxlY3Quc2VsZWN0ZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBsb2NhbHMgPSB7fTtcbiAgICAgICAgICBsb2NhbHNbJHNlbGVjdC5wYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gJHNlbGVjdC5zZWxlY3RlZFtqXTtcbiAgICAgICAgICByZXN1bHQgPSAkc2VsZWN0LnBhcnNlclJlc3VsdC5tb2RlbE1hcHBlcihzY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICByZXN1bHRNdWx0aXBsZS51bnNoaWZ0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdE11bHRpcGxlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEZyb20gbW9kZWwgLS0+IHZpZXdcbiAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMudW5zaGlmdChmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuICAgICAgICB2YXIgZGF0YSA9ICRzZWxlY3QucGFyc2VyUmVzdWx0LnNvdXJjZSAoc2NvcGUsIHsgJHNlbGVjdCA6IHtzZWFyY2g6Jyd9fSksIC8vT3ZlcndyaXRlICRzZWFyY2hcbiAgICAgICAgICAgIGxvY2FscyA9IHt9LFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB2YXIgcmVzdWx0TXVsdGlwbGUgPSBbXTtcbiAgICAgICAgdmFyIGNoZWNrRm5NdWx0aXBsZSA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlKXtcbiAgICAgICAgICBpZiAoIWxpc3QgfHwgIWxpc3QubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgZm9yICh2YXIgcCA9IGxpc3QubGVuZ3RoIC0gMTsgcCA+PSAwOyBwLS0pIHtcbiAgICAgICAgICAgIGxvY2Fsc1skc2VsZWN0LnBhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBsaXN0W3BdO1xuICAgICAgICAgICAgcmVzdWx0ID0gJHNlbGVjdC5wYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIoc2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgICBpZigkc2VsZWN0LnBhcnNlclJlc3VsdC50cmFja0J5RXhwKXtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHNJdGVtTmFtZU1hdGNoZXMgPSAvKFxcdyopXFwuLy5leGVjKCRzZWxlY3QucGFyc2VyUmVzdWx0LnRyYWNrQnlFeHApO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gL1xcLihbXlxcc10rKS8uZXhlYygkc2VsZWN0LnBhcnNlclJlc3VsdC50cmFja0J5RXhwKTtcbiAgICAgICAgICAgICAgICBpZihwcm9wc0l0ZW1OYW1lTWF0Y2hlcyAmJiBwcm9wc0l0ZW1OYW1lTWF0Y2hlcy5sZW5ndGggPiAwICYmIHByb3BzSXRlbU5hbWVNYXRjaGVzWzFdID09ICRzZWxlY3QucGFyc2VyUmVzdWx0Lml0ZW1OYW1lKXtcbiAgICAgICAgICAgICAgICAgIGlmKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGg+MCAmJiByZXN1bHRbbWF0Y2hlc1sxXV0gPT0gdmFsdWVbbWF0Y2hlc1sxXV0pe1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxlLnVuc2hpZnQobGlzdFtwXSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuZXF1YWxzKHJlc3VsdCx2YWx1ZSkpe1xuICAgICAgICAgICAgICByZXN1bHRNdWx0aXBsZS51bnNoaWZ0KGxpc3RbcF0pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWlucHV0VmFsdWUpIHJldHVybiByZXN1bHRNdWx0aXBsZTsgLy9JZiBuZ01vZGVsIHdhcyB1bmRlZmluZWRcbiAgICAgICAgZm9yICh2YXIgayA9IGlucHV0VmFsdWUubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAvL0NoZWNrIG1vZGVsIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtcyBcbiAgICAgICAgICBpZiAoIWNoZWNrRm5NdWx0aXBsZSgkc2VsZWN0LnNlbGVjdGVkLCBpbnB1dFZhbHVlW2tdKSl7XG4gICAgICAgICAgICAvL0NoZWNrIG1vZGVsIGFycmF5IG9mIGFsbCBpdGVtcyBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICghY2hlY2tGbk11bHRpcGxlKGRhdGEsIGlucHV0VmFsdWVba10pKXtcbiAgICAgICAgICAgICAgLy9JZiBub3QgZm91bmQgb24gcHJldmlvdXMgbGlzdHMsIGp1c3QgYWRkIGl0IGRpcmVjdGx5IHRvIHJlc3VsdE11bHRpcGxlXG4gICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxlLnVuc2hpZnQoaW5wdXRWYWx1ZVtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRNdWx0aXBsZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvL1dhdGNoIGZvciBleHRlcm5hbCBtb2RlbCBjaGFuZ2VzIFxuICAgICAgc2NvcGUuJHdhdGNoQ29sbGVjdGlvbihmdW5jdGlvbigpeyByZXR1cm4gbmdNb2RlbC4kbW9kZWxWYWx1ZTsgfSwgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPSBuZXdWYWx1ZSl7XG4gICAgICAgICAgbmdNb2RlbC4kbW9kZWxWYWx1ZSA9IG51bGw7IC8vRm9yY2Ugc2NvcGUgbW9kZWwgdmFsdWUgYW5kIG5nTW9kZWwgdmFsdWUgdG8gYmUgb3V0IG9mIHN5bmMgdG8gcmUtcnVuIGZvcm1hdHRlcnNcbiAgICAgICAgICAkc2VsZWN0TXVsdGlwbGUucmVmcmVzaENvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbmdNb2RlbC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG1vZGVsIHZhbHVlIGlzIGFycmF5XG4gICAgICAgIGlmKCFhbmd1bGFyLmlzQXJyYXkobmdNb2RlbC4kdmlld1ZhbHVlKSl7XG4gICAgICAgICAgLy8gSGF2ZSB0b2xlcmFuY2UgZm9yIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgIGlmKGFuZ3VsYXIuaXNVbmRlZmluZWQobmdNb2RlbC4kdmlld1ZhbHVlKSB8fCBuZ01vZGVsLiR2aWV3VmFsdWUgPT09IG51bGwpe1xuICAgICAgICAgICAgJHNlbGVjdC5zZWxlY3RlZCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycignbXVsdGlhcnInLCBcIkV4cGVjdGVkIG1vZGVsIHZhbHVlIHRvIGJlIGFycmF5IGJ1dCBnb3QgJ3swfSdcIiwgbmdNb2RlbC4kdmlld1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHNlbGVjdC5zZWxlY3RlZCA9IG5nTW9kZWwuJHZpZXdWYWx1ZTtcbiAgICAgICAgc2NvcGUuJGV2YWxBc3luYygpOyAvL1RvIGZvcmNlICRkaWdlc3RcbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiRvbigndWlzOnNlbGVjdCcsIGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICBpZigkc2VsZWN0LnNlbGVjdGVkLmxlbmd0aCA+PSAkc2VsZWN0LmxpbWl0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICRzZWxlY3Quc2VsZWN0ZWQucHVzaChpdGVtKTtcbiAgICAgICAgJHNlbGVjdE11bHRpcGxlLnVwZGF0ZU1vZGVsKCk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJG9uKCd1aXM6YWN0aXZhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4ID0gLTE7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCckc2VsZWN0LmRpc2FibGVkJywgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIC8vIEFzIHRoZSBzZWFyY2ggaW5wdXQgZmllbGQgbWF5IG5vdyBiZWNvbWUgdmlzaWJsZSwgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byByZWNvbXB1dGUgaXRzIHNpemVcbiAgICAgICAgaWYgKG9sZFZhbHVlICYmICFuZXdWYWx1ZSkgJHNlbGVjdC5zaXplU2VhcmNoSW5wdXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAkc2VsZWN0LnNlYXJjaElucHV0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5ID0gZS53aGljaDtcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAvLyB2YXIgdGFnZ2VkID0gZmFsc2U7IC8vQ2hlY2ttZVxuICAgICAgICAgIGlmKEtFWS5pc0hvcml6b250YWxNb3ZlbWVudChrZXkpKXtcbiAgICAgICAgICAgIHByb2Nlc3NlZCA9IF9oYW5kbGVNYXRjaFNlbGVjdGlvbihrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvY2Vzc2VkICAmJiBrZXkgIT0gS0VZLlRBQikge1xuICAgICAgICAgICAgLy9UT0RPIENoZWNrIHNpIGVsIHRhYiBzZWxlY2Npb25hIGF1biBjb3JyZWN0YW1lbnRlXG4gICAgICAgICAgICAvL0NyZWFyIHRlc3RcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZnVuY3Rpb24gX2dldENhcmV0UG9zaXRpb24oZWwpIHtcbiAgICAgICAgaWYoYW5ndWxhci5pc051bWJlcihlbC5zZWxlY3Rpb25TdGFydCkpIHJldHVybiBlbC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgLy8gc2VsZWN0aW9uU3RhcnQgaXMgbm90IHN1cHBvcnRlZCBpbiBJRTggYW5kIHdlIGRvbid0IHdhbnQgaGFja3kgd29ya2Fyb3VuZHMgc28gd2UgY29tcHJvbWlzZVxuICAgICAgICBlbHNlIHJldHVybiBlbC52YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBIYW5kbGVzIHNlbGVjdGVkIG9wdGlvbnMgaW4gXCJtdWx0aXBsZVwiIG1vZGVcbiAgICAgIGZ1bmN0aW9uIF9oYW5kbGVNYXRjaFNlbGVjdGlvbihrZXkpe1xuICAgICAgICB2YXIgY2FyZXRQb3NpdGlvbiA9IF9nZXRDYXJldFBvc2l0aW9uKCRzZWxlY3Quc2VhcmNoSW5wdXRbMF0pLFxuICAgICAgICAgICAgbGVuZ3RoID0gJHNlbGVjdC5zZWxlY3RlZC5sZW5ndGgsXG4gICAgICAgICAgICAvLyBub25lICA9IC0xLFxuICAgICAgICAgICAgZmlyc3QgPSAwLFxuICAgICAgICAgICAgbGFzdCAgPSBsZW5ndGgtMSxcbiAgICAgICAgICAgIGN1cnIgID0gJHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXgsXG4gICAgICAgICAgICBuZXh0ICA9ICRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4KzEsXG4gICAgICAgICAgICBwcmV2ICA9ICRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4LTEsXG4gICAgICAgICAgICBuZXdJbmRleCA9IGN1cnI7XG5cbiAgICAgICAgaWYoY2FyZXRQb3NpdGlvbiA+IDAgfHwgKCRzZWxlY3Quc2VhcmNoLmxlbmd0aCAmJiBrZXkgPT0gS0VZLlJJR0hUKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICRzZWxlY3QuY2xvc2UoKTtcblxuICAgICAgICBmdW5jdGlvbiBnZXROZXdBY3RpdmVNYXRjaEluZGV4KCl7XG4gICAgICAgICAgc3dpdGNoKGtleSl7XG4gICAgICAgICAgICBjYXNlIEtFWS5MRUZUOlxuICAgICAgICAgICAgICAvLyBTZWxlY3QgcHJldmlvdXMvZmlyc3QgaXRlbVxuICAgICAgICAgICAgICBpZih+JHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXgpIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICAvLyBTZWxlY3QgbGFzdCBpdGVtXG4gICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBLRVkuUklHSFQ6XG4gICAgICAgICAgICAgIC8vIE9wZW4gZHJvcC1kb3duXG4gICAgICAgICAgICAgIGlmKCF+JHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggfHwgY3VyciA9PT0gbGFzdCl7XG4gICAgICAgICAgICAgICAgJHNlbGVjdC5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBTZWxlY3QgbmV4dC9sYXN0IGl0ZW1cbiAgICAgICAgICAgICAgZWxzZSByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWS5CQUNLU1BBQ0U6XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtIGFuZCBzZWxlY3QgcHJldmlvdXMvZmlyc3RcbiAgICAgICAgICAgICAgaWYofiRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4KXtcbiAgICAgICAgICAgICAgICAkc2VsZWN0TXVsdGlwbGUucmVtb3ZlQ2hvaWNlKGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFNlbGVjdCBsYXN0IGl0ZW1cbiAgICAgICAgICAgICAgZWxzZSByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEtFWS5ERUxFVEU6XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtIGFuZCBzZWxlY3QgbmV4dCBpdGVtXG4gICAgICAgICAgICAgIGlmKH4kc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCl7XG4gICAgICAgICAgICAgICAgJHNlbGVjdE11bHRpcGxlLnJlbW92ZUNob2ljZSgkc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3SW5kZXggPSBnZXROZXdBY3RpdmVNYXRjaEluZGV4KCk7XG5cbiAgICAgICAgaWYoISRzZWxlY3Quc2VsZWN0ZWQubGVuZ3RoIHx8IG5ld0luZGV4ID09PSBmYWxzZSkgJHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggPSAtMTtcbiAgICAgICAgZWxzZSAkc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCA9IE1hdGgubWluKGxhc3QsTWF0aC5tYXgoZmlyc3QsbmV3SW5kZXgpKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgJHNlbGVjdC5zZWFyY2hJbnB1dC5vbigna2V5dXAnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgaWYgKCAhIEtFWS5pc1ZlcnRpY2FsTW92ZW1lbnQoZS53aGljaCkgKSB7XG4gICAgICAgICAgc2NvcGUuJGV2YWxBc3luYyggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJHNlbGVjdC5hY3RpdmVJbmRleCA9ICRzZWxlY3QudGFnZ2luZ0xhYmVsID09PSBmYWxzZSA/IC0xIDogMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQdXNoIGEgXCJjcmVhdGUgbmV3XCIgaXRlbSBpbnRvIGFycmF5IGlmIHRoZXJlIGlzIGEgc2VhcmNoIHN0cmluZ1xuICAgICAgICBpZiAoICRzZWxlY3QudGFnZ2luZy5pc0FjdGl2YXRlZCAmJiAkc2VsZWN0LnNlYXJjaC5sZW5ndGggPiAwICkge1xuXG4gICAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGggdGhlc2Uga2V5c1xuICAgICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuVEFCIHx8IEtFWS5pc0NvbnRyb2woZSkgfHwgS0VZLmlzRnVuY3Rpb25LZXkoZSkgfHwgZS53aGljaCA9PT0gS0VZLkVTQyB8fCBLRVkuaXNWZXJ0aWNhbE1vdmVtZW50KGUud2hpY2gpICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhbHdheXMgcmVzZXQgdGhlIGFjdGl2ZUluZGV4IHRvIHRoZSBmaXJzdCBpdGVtIHdoZW4gdGFnZ2luZ1xuICAgICAgICAgICRzZWxlY3QuYWN0aXZlSW5kZXggPSAkc2VsZWN0LnRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UgPyAtMSA6IDA7XG4gICAgICAgICAgLy8gdGFnZ2luZ0xhYmVsID09PSBmYWxzZSBieXBhc3NlcyBhbGwgb2YgdGhpc1xuICAgICAgICAgIGlmICgkc2VsZWN0LnRhZ2dpbmdMYWJlbCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICAgIHZhciBpdGVtcyA9IGFuZ3VsYXIuY29weSggJHNlbGVjdC5pdGVtcyApO1xuICAgICAgICAgIHZhciBzdGFzaEFyciA9IGFuZ3VsYXIuY29weSggJHNlbGVjdC5pdGVtcyApO1xuICAgICAgICAgIHZhciBuZXdJdGVtO1xuICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgIHZhciBoYXNUYWcgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgZHVwZUluZGV4ID0gLTE7XG4gICAgICAgICAgdmFyIHRhZ0l0ZW1zO1xuICAgICAgICAgIHZhciB0YWdJdGVtO1xuXG4gICAgICAgICAgLy8gY2FzZSBmb3Igb2JqZWN0IHRhZ2dpbmcgdmlhIHRyYW5zZm9ybSBgJHNlbGVjdC50YWdnaW5nLmZjdGAgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoICRzZWxlY3QudGFnZ2luZy5mY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFnSXRlbXMgPSAkc2VsZWN0LiRmaWx0ZXIoJ2ZpbHRlcicpKGl0ZW1zLHsnaXNUYWcnOiB0cnVlfSk7XG4gICAgICAgICAgICBpZiAoIHRhZ0l0ZW1zLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgIHRhZ0l0ZW0gPSB0YWdJdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCwgaWYgaXQgaGFzIHRoZSBgaXNUYWdgIHByb3Agd2UgZ2VuZXJhdGUgYSBuZXcgb25lIHdpdGggZWFjaCBrZXl1cCwgc2hhdmluZyB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIGlmICggaXRlbXMubGVuZ3RoID4gMCAmJiB0YWdJdGVtICkge1xuICAgICAgICAgICAgICBoYXNUYWcgPSB0cnVlO1xuICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDEsaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgc3Rhc2hBcnIgPSBzdGFzaEFyci5zbGljZSgxLHN0YXNoQXJyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtID0gJHNlbGVjdC50YWdnaW5nLmZjdCgkc2VsZWN0LnNlYXJjaCk7XG4gICAgICAgICAgICBuZXdJdGVtLmlzVGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSB0aGUgdGhlIHRhZyBkb2Vzbid0IG1hdGNoIHRoZSB2YWx1ZSBvZiBhbiBleGlzdGluZyBpdGVtXG4gICAgICAgICAgICBpZiAoIHN0YXNoQXJyLmZpbHRlciggZnVuY3Rpb24gKG9yaWdJdGVtKSB7IHJldHVybiBhbmd1bGFyLmVxdWFscyggb3JpZ0l0ZW0sICRzZWxlY3QudGFnZ2luZy5mY3QoJHNlbGVjdC5zZWFyY2gpICk7IH0gKS5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtLmlzVGFnID0gdHJ1ZTtcbiAgICAgICAgICAvLyBoYW5kbGUgbmV3SXRlbSBzdHJpbmcgYW5kIHN0cmlwcGluZyBkdXBlcyBpbiB0YWdnaW5nIHN0cmluZyBjb250ZXh0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbmQgYW55IHRhZ2dpbmcgaXRlbXMgYWxyZWFkeSBpbiB0aGUgJHNlbGVjdC5pdGVtcyBhcnJheSBhbmQgc3RvcmUgdGhlbVxuICAgICAgICAgICAgdGFnSXRlbXMgPSAkc2VsZWN0LiRmaWx0ZXIoJ2ZpbHRlcicpKGl0ZW1zLGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVtLm1hdGNoKCRzZWxlY3QudGFnZ2luZ0xhYmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCB0YWdJdGVtcy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICB0YWdJdGVtID0gdGFnSXRlbXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbMF07XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmcgdGFnIGl0ZW0gaWYgZm91bmQgKHNob3VsZCBvbmx5IGV2ZXIgYmUgb25lIHRhZyBpdGVtKVxuICAgICAgICAgICAgaWYgKCBpdGVtICE9PSB1bmRlZmluZWQgJiYgaXRlbXMubGVuZ3RoID4gMCAmJiB0YWdJdGVtICkge1xuICAgICAgICAgICAgICBoYXNUYWcgPSB0cnVlO1xuICAgICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDEsaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgc3Rhc2hBcnIgPSBzdGFzaEFyci5zbGljZSgxLHN0YXNoQXJyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtID0gJHNlbGVjdC5zZWFyY2grJyAnKyRzZWxlY3QudGFnZ2luZ0xhYmVsO1xuICAgICAgICAgICAgaWYgKCBfZmluZEFwcHJveER1cGUoJHNlbGVjdC5zZWxlY3RlZCwgJHNlbGVjdC5zZWFyY2gpID4gLTEgKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZlcmlmeSB0aGUgdGhlIHRhZyBkb2Vzbid0IG1hdGNoIHRoZSB2YWx1ZSBvZiBhbiBleGlzdGluZyBpdGVtIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSBzZWFyY2hlZCBkYXRhIHNldCBvciB0aGUgaXRlbXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAgaWYgKCBfZmluZENhc2VJbnNlbnNpdGl2ZUR1cGUoc3Rhc2hBcnIuY29uY2F0KCRzZWxlY3Quc2VsZWN0ZWQpKSApIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB0YWcgZnJvbSBwcmV2IGl0ZXJhdGlvbiwgc3RyaXAgaXQgLyBxdWV1ZSB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgaWYgKCBoYXNUYWcgKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBzdGFzaEFycjtcbiAgICAgICAgICAgICAgICBzY29wZS4kZXZhbEFzeW5jKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAkc2VsZWN0LmFjdGl2ZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICRzZWxlY3QuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIF9maW5kQ2FzZUluc2Vuc2l0aXZlRHVwZShzdGFzaEFycikgKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGFnIGZyb20gcHJldiBpdGVyYXRpb24sIHN0cmlwIGl0XG4gICAgICAgICAgICAgIGlmICggaGFzVGFnICkge1xuICAgICAgICAgICAgICAgICRzZWxlY3QuaXRlbXMgPSBzdGFzaEFyci5zbGljZSgxLHN0YXNoQXJyLmxlbmd0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIGhhc1RhZyApIGR1cGVJbmRleCA9IF9maW5kQXBwcm94RHVwZSgkc2VsZWN0LnNlbGVjdGVkLCBuZXdJdGVtKTtcbiAgICAgICAgICAvLyBkdXBlIGZvdW5kLCBzaGF2ZSB0aGUgZmlyc3QgaXRlbVxuICAgICAgICAgIGlmICggZHVwZUluZGV4ID4gLTEgKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKGR1cGVJbmRleCsxLGl0ZW1zLmxlbmd0aC0xKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChzdGFzaEFycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLiRldmFsQXN5bmMoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRzZWxlY3QuYWN0aXZlSW5kZXggPSAwO1xuICAgICAgICAgICAgJHNlbGVjdC5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZ1bmN0aW9uIF9maW5kQ2FzZUluc2Vuc2l0aXZlRHVwZShhcnIpIHtcbiAgICAgICAgaWYgKCBhcnIgPT09IHVuZGVmaW5lZCB8fCAkc2VsZWN0LnNlYXJjaCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzRHVwZSA9IGFyci5maWx0ZXIoIGZ1bmN0aW9uIChvcmlnSXRlbSkge1xuICAgICAgICAgIGlmICggJHNlbGVjdC5zZWFyY2gudG9VcHBlckNhc2UoKSA9PT0gdW5kZWZpbmVkIHx8IG9yaWdJdGVtID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnSXRlbS50b1VwcGVyQ2FzZSgpID09PSAkc2VsZWN0LnNlYXJjaC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KS5sZW5ndGggPiAwO1xuXG4gICAgICAgIHJldHVybiBoYXNEdXBlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX2ZpbmRBcHByb3hEdXBlKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICAgICAgdmFyIGR1cGVJbmRleCA9IC0xO1xuICAgICAgICBpZihhbmd1bGFyLmlzQXJyYXkoaGF5c3RhY2spKSB7XG4gICAgICAgICAgdmFyIHRlbXBBcnIgPSBhbmd1bGFyLmNvcHkoaGF5c3RhY2spO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDx0ZW1wQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHNpbXBsZSBzdHJpbmcgdmVyc2lvbiBvZiB0YWdnaW5nXG4gICAgICAgICAgICBpZiAoICRzZWxlY3QudGFnZ2luZy5mY3QgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgLy8gc2VhcmNoIHRoZSBhcnJheSBmb3IgdGhlIG1hdGNoXG4gICAgICAgICAgICAgIGlmICggdGVtcEFycltpXSsnICcrJHNlbGVjdC50YWdnaW5nTGFiZWwgPT09IG5lZWRsZSApIHtcbiAgICAgICAgICAgICAgZHVwZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBvYmplY3QgdGFnZ2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG1vY2tPYmogPSB0ZW1wQXJyW2ldO1xuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc09iamVjdChtb2NrT2JqKSkge1xuICAgICAgICAgICAgICAgIG1vY2tPYmouaXNUYWcgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICggYW5ndWxhci5lcXVhbHMobW9ja09iaiwgbmVlZGxlKSApIHtcbiAgICAgICAgICAgICAgICBkdXBlSW5kZXggPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkdXBlSW5kZXg7XG4gICAgICB9XG5cbiAgICAgICRzZWxlY3Quc2VhcmNoSW5wdXQub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggPSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIH1cbiAgfTtcbn1dKTtcblxudWlzLmRpcmVjdGl2ZSgndWlTZWxlY3RTaW5nbGUnLCBbJyR0aW1lb3V0JywnJGNvbXBpbGUnLCBmdW5jdGlvbigkdGltZW91dCwgJGNvbXBpbGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXF1aXJlOiBbJ151aVNlbGVjdCcsICdebmdNb2RlbCddLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcblxuICAgICAgdmFyICRzZWxlY3QgPSBjdHJsc1swXTtcbiAgICAgIHZhciBuZ01vZGVsID0gY3RybHNbMV07XG5cbiAgICAgIC8vRnJvbSB2aWV3IC0tPiBtb2RlbFxuICAgICAgbmdNb2RlbC4kcGFyc2Vycy51bnNoaWZ0KGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG4gICAgICAgIHZhciBsb2NhbHMgPSB7fSxcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgbG9jYWxzWyRzZWxlY3QucGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IGlucHV0VmFsdWU7XG4gICAgICAgIHJlc3VsdCA9ICRzZWxlY3QucGFyc2VyUmVzdWx0Lm1vZGVsTWFwcGVyKHNjb3BlLCBsb2NhbHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vRnJvbSBtb2RlbCAtLT4gdmlld1xuICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy51bnNoaWZ0KGZ1bmN0aW9uIChpbnB1dFZhbHVlKSB7XG4gICAgICAgIHZhciBkYXRhID0gJHNlbGVjdC5wYXJzZXJSZXN1bHQuc291cmNlIChzY29wZSwgeyAkc2VsZWN0IDoge3NlYXJjaDonJ319KSwgLy9PdmVyd3JpdGUgJHNlYXJjaFxuICAgICAgICAgICAgbG9jYWxzID0ge30sXG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmIChkYXRhKXtcbiAgICAgICAgICB2YXIgY2hlY2tGblNpbmdsZSA9IGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgbG9jYWxzWyRzZWxlY3QucGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IGQ7XG4gICAgICAgICAgICByZXN1bHQgPSAkc2VsZWN0LnBhcnNlclJlc3VsdC5tb2RlbE1hcHBlcihzY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vSWYgcG9zc2libGUgcGFzcyBzYW1lIG9iamVjdCBzdG9yZWQgaW4gJHNlbGVjdC5zZWxlY3RlZFxuICAgICAgICAgIGlmICgkc2VsZWN0LnNlbGVjdGVkICYmIGNoZWNrRm5TaW5nbGUoJHNlbGVjdC5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAkc2VsZWN0LnNlbGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrRm5TaW5nbGUoZGF0YVtpXSkpIHJldHVybiBkYXRhW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvL1VwZGF0ZSB2aWV3VmFsdWUgaWYgbW9kZWwgY2hhbmdlXG4gICAgICBzY29wZS4kd2F0Y2goJyRzZWxlY3Quc2VsZWN0ZWQnLCBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmdNb2RlbC4kdmlld1ZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBuZ01vZGVsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJHNlbGVjdC5zZWxlY3RlZCA9IG5nTW9kZWwuJHZpZXdWYWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHNjb3BlLiRvbigndWlzOnNlbGVjdCcsIGZ1bmN0aW9uIChldmVudCwgaXRlbSkge1xuICAgICAgICAkc2VsZWN0LnNlbGVjdGVkID0gaXRlbTtcbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJ3VpczpjbG9zZScsIGZ1bmN0aW9uIChldmVudCwgc2tpcEZvY3Vzc2VyKSB7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgJHNlbGVjdC5mb2N1c3Nlci5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoIXNraXBGb2N1c3NlcikgJHNlbGVjdC5mb2N1c3NlclswXS5mb2N1cygpO1xuICAgICAgICB9LDAsZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiRvbigndWlzOmFjdGl2YXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb2N1c3Nlci5wcm9wKCdkaXNhYmxlZCcsIHRydWUpOyAvL1dpbGwgcmVhY3RpdmF0ZSBpdCBvbiAuY2xvc2UoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vSWRlYSBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIvYmxvYi83OWI1YmY2ZGI5MThkNzU2MGJkZDk1OTEwOWI3YmNmYjQ3ZWRhZjQzL3NlbGVjdDIuanMjTDE5NTRcbiAgICAgIHZhciBmb2N1c3NlciA9IGFuZ3VsYXIuZWxlbWVudChcIjxpbnB1dCBuZy1kaXNhYmxlZD0nJHNlbGVjdC5kaXNhYmxlZCcgY2xhc3M9J3VpLXNlbGVjdC1mb2N1c3NlciB1aS1zZWxlY3Qtb2Zmc2NyZWVuJyB0eXBlPSd0ZXh0JyBpZD0ne3sgJHNlbGVjdC5mb2N1c3NlcklkIH19JyBhcmlhLWxhYmVsPSd7eyAkc2VsZWN0LmZvY3Vzc2VyVGl0bGUgfX0nIGFyaWEtaGFzcG9wdXA9J3RydWUnIHJvbGU9J2J1dHRvbicgLz5cIik7XG4gICAgICAkY29tcGlsZShmb2N1c3Nlcikoc2NvcGUpO1xuICAgICAgJHNlbGVjdC5mb2N1c3NlciA9IGZvY3Vzc2VyO1xuXG4gICAgICAvL0lucHV0IHRoYXQgd2lsbCBoYW5kbGUgZm9jdXNcbiAgICAgICRzZWxlY3QuZm9jdXNJbnB1dCA9IGZvY3Vzc2VyO1xuXG4gICAgICBlbGVtZW50LnBhcmVudCgpLmFwcGVuZChmb2N1c3Nlcik7XG4gICAgICBmb2N1c3Nlci5iaW5kKFwiZm9jdXNcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgc2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICRzZWxlY3QuZm9jdXMgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZm9jdXNzZXIuYmluZChcImJsdXJcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgc2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpe1xuICAgICAgICAgICRzZWxlY3QuZm9jdXMgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGZvY3Vzc2VyLmJpbmQoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgIGlmIChlLndoaWNoID09PSBLRVkuQkFDS1NQQUNFKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgJHNlbGVjdC5zZWxlY3QodW5kZWZpbmVkKTtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS53aGljaCA9PT0gS0VZLlRBQiB8fCBLRVkuaXNDb250cm9sKGUpIHx8IEtFWS5pc0Z1bmN0aW9uS2V5KGUpIHx8IGUud2hpY2ggPT09IEtFWS5FU0MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS53aGljaCA9PSBLRVkuRE9XTiAgfHwgZS53aGljaCA9PSBLRVkuVVAgfHwgZS53aGljaCA9PSBLRVkuRU5URVIgfHwgZS53aGljaCA9PSBLRVkuU1BBQ0Upe1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICRzZWxlY3QuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb2N1c3Nlci5iaW5kKFwia2V5dXAgaW5wdXRcIiwgZnVuY3Rpb24oZSl7XG5cbiAgICAgICAgaWYgKGUud2hpY2ggPT09IEtFWS5UQUIgfHwgS0VZLmlzQ29udHJvbChlKSB8fCBLRVkuaXNGdW5jdGlvbktleShlKSB8fCBlLndoaWNoID09PSBLRVkuRVNDIHx8IGUud2hpY2ggPT0gS0VZLkVOVEVSIHx8IGUud2hpY2ggPT09IEtFWS5CQUNLU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAkc2VsZWN0LmFjdGl2YXRlKGZvY3Vzc2VyLnZhbCgpKTsgLy9Vc2VyIHByZXNzZWQgc29tZSByZWd1bGFyIGtleSwgc28gd2UgcGFzcyBpdCB0byB0aGUgc2VhcmNoIGlucHV0XG4gICAgICAgIGZvY3Vzc2VyLnZhbCgnJyk7XG4gICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcblxuICAgICAgfSk7XG5cblxuICAgIH1cbiAgfTtcbn1dKTtcbi8vIE1ha2UgbXVsdGlwbGUgbWF0Y2hlcyBzb3J0YWJsZVxudWlzLmRpcmVjdGl2ZSgndWlTZWxlY3RTb3J0JywgWyckdGltZW91dCcsICd1aVNlbGVjdENvbmZpZycsICd1aVNlbGVjdE1pbkVycicsIGZ1bmN0aW9uKCR0aW1lb3V0LCB1aVNlbGVjdENvbmZpZywgdWlTZWxlY3RNaW5FcnIpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXl51aVNlbGVjdCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCAkc2VsZWN0KSB7XG4gICAgICBpZiAoc2NvcGVbYXR0cnMudWlTZWxlY3RTb3J0XSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB1aVNlbGVjdE1pbkVycignc29ydCcsICdFeHBlY3RlZCBhIGxpc3QgdG8gc29ydCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKHtcbiAgICAgICAgICBheGlzOiAnaG9yaXpvbnRhbCdcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGUuJGV2YWwoYXR0cnMudWlTZWxlY3RTb3J0T3B0aW9ucykpO1xuXG4gICAgICB2YXIgYXhpcyA9IG9wdGlvbnMuYXhpcztcbiAgICAgIHZhciBkcmFnZ2luZ0NsYXNzTmFtZSA9ICdkcmFnZ2luZyc7XG4gICAgICB2YXIgZHJvcHBpbmdDbGFzc05hbWUgPSAnZHJvcHBpbmcnO1xuICAgICAgdmFyIGRyb3BwaW5nQmVmb3JlQ2xhc3NOYW1lID0gJ2Ryb3BwaW5nLWJlZm9yZSc7XG4gICAgICB2YXIgZHJvcHBpbmdBZnRlckNsYXNzTmFtZSA9ICdkcm9wcGluZy1hZnRlcic7XG5cbiAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gJHNlbGVjdC5zb3J0YWJsZTtcbiAgICAgIH0sIGZ1bmN0aW9uKG5ld1ZhbHVlKXtcbiAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZWxlbWVudC5hdHRyKCdkcmFnZ2FibGUnLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHIoJ2RyYWdnYWJsZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhkcmFnZ2luZ0NsYXNzTmFtZSk7XG5cbiAgICAgICAgKGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlcikuc2V0RGF0YSgndGV4dC9wbGFpbicsIHNjb3BlLiRpbmRleCk7XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5vbignZHJhZ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRyYWdnaW5nQ2xhc3NOYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbW92ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgICAgICB0aGlzLnNwbGljZSh0bywgMCwgdGhpcy5zcGxpY2UoZnJvbSwgMSlbMF0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRyYWdPdmVySGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IGF4aXMgPT09ICd2ZXJ0aWNhbCcgPyBldmVudC5vZmZzZXRZIHx8IGV2ZW50LmxheWVyWSB8fCAoZXZlbnQub3JpZ2luYWxFdmVudCA/IGV2ZW50Lm9yaWdpbmFsRXZlbnQub2Zmc2V0WSA6IDApIDogZXZlbnQub2Zmc2V0WCB8fCBldmVudC5sYXllclggfHwgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgPyBldmVudC5vcmlnaW5hbEV2ZW50Lm9mZnNldFggOiAwKTtcblxuICAgICAgICBpZiAob2Zmc2V0IDwgKHRoaXNbYXhpcyA9PT0gJ3ZlcnRpY2FsJyA/ICdvZmZzZXRIZWlnaHQnIDogJ29mZnNldFdpZHRoJ10gLyAyKSkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoZHJvcHBpbmdBZnRlckNsYXNzTmFtZSk7XG4gICAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhkcm9wcGluZ0JlZm9yZUNsYXNzTmFtZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRyb3BwaW5nQmVmb3JlQ2xhc3NOYW1lKTtcbiAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKGRyb3BwaW5nQWZ0ZXJDbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZHJvcFRpbWVvdXQ7XG5cbiAgICAgIHZhciBkcm9wSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGRyb3BwZWRJdGVtSW5kZXggPSBwYXJzZUludCgoZXZlbnQuZGF0YVRyYW5zZmVyIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyKS5nZXREYXRhKCd0ZXh0L3BsYWluJyksIDEwKTtcblxuICAgICAgICAvLyBwcmV2ZW50IGV2ZW50IGZpcmluZyBtdWx0aXBsZSB0aW1lcyBpbiBmaXJlZm94XG4gICAgICAgICR0aW1lb3V0LmNhbmNlbChkcm9wVGltZW91dCk7XG4gICAgICAgIGRyb3BUaW1lb3V0ID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX2Ryb3BIYW5kbGVyKGRyb3BwZWRJdGVtSW5kZXgpO1xuICAgICAgICB9LCAyMCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgX2Ryb3BIYW5kbGVyID0gZnVuY3Rpb24oZHJvcHBlZEl0ZW1JbmRleCkge1xuICAgICAgICB2YXIgdGhlTGlzdCA9IHNjb3BlLiRldmFsKGF0dHJzLnVpU2VsZWN0U29ydCk7XG4gICAgICAgIHZhciBpdGVtVG9Nb3ZlID0gdGhlTGlzdFtkcm9wcGVkSXRlbUluZGV4XTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gbnVsbDtcblxuICAgICAgICBpZiAoZWxlbWVudC5oYXNDbGFzcyhkcm9wcGluZ0JlZm9yZUNsYXNzTmFtZSkpIHtcbiAgICAgICAgICBpZiAoZHJvcHBlZEl0ZW1JbmRleCA8IHNjb3BlLiRpbmRleCkge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBzY29wZS4kaW5kZXggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IHNjb3BlLiRpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRyb3BwZWRJdGVtSW5kZXggPCBzY29wZS4kaW5kZXgpIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gc2NvcGUuJGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRleCA9IHNjb3BlLiRpbmRleCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbW92ZS5hcHBseSh0aGVMaXN0LCBbZHJvcHBlZEl0ZW1JbmRleCwgbmV3SW5kZXhdKTtcblxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2NvcGUuJGVtaXQoJ3VpU2VsZWN0U29ydDpjaGFuZ2UnLCB7XG4gICAgICAgICAgICBhcnJheTogdGhlTGlzdCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1Ub01vdmUsXG4gICAgICAgICAgICBmcm9tOiBkcm9wcGVkSXRlbUluZGV4LFxuICAgICAgICAgICAgdG86IG5ld0luZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoZHJvcHBpbmdDbGFzc05hbWUpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRyb3BwaW5nQmVmb3JlQ2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhkcm9wcGluZ0FmdGVyQ2xhc3NOYW1lKTtcblxuICAgICAgICBlbGVtZW50Lm9mZignZHJvcCcsIGRyb3BIYW5kbGVyKTtcbiAgICAgIH07XG5cbiAgICAgIGVsZW1lbnQub24oJ2RyYWdlbnRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNDbGFzcyhkcmFnZ2luZ0NsYXNzTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LmFkZENsYXNzKGRyb3BwaW5nQ2xhc3NOYW1lKTtcblxuICAgICAgICBlbGVtZW50Lm9uKCdkcmFnb3ZlcicsIGRyYWdPdmVySGFuZGxlcik7XG4gICAgICAgIGVsZW1lbnQub24oJ2Ryb3AnLCBkcm9wSGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5vbignZHJhZ2xlYXZlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoZHJvcHBpbmdDbGFzc05hbWUpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGRyb3BwaW5nQmVmb3JlQ2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhkcm9wcGluZ0FmdGVyQ2xhc3NOYW1lKTtcblxuICAgICAgICBlbGVtZW50Lm9mZignZHJhZ292ZXInLCBkcmFnT3ZlckhhbmRsZXIpO1xuICAgICAgICBlbGVtZW50Lm9mZignZHJvcCcsIGRyb3BIYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyoqXG4gKiBQYXJzZXMgXCJyZXBlYXRcIiBhdHRyaWJ1dGUuXG4gKlxuICogVGFrZW4gZnJvbSBBbmd1bGFySlMgbmdSZXBlYXQgc291cmNlIGNvZGVcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2Jsb2IvdjEuMi4xNS9zcmMvbmcvZGlyZWN0aXZlL25nUmVwZWF0LmpzI0wyMTFcbiAqXG4gKiBPcmlnaW5hbCBkaXNjdXNzaW9uIGFib3V0IHBhcnNpbmcgXCJyZXBlYXRcIiBhdHRyaWJ1dGUgaW5zdGVhZCBvZiBmdWxseSByZWx5aW5nIG9uIG5nLXJlcGVhdDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXNlbGVjdC9jb21taXQvNWRkNjNhZCNjb21taXRjb21tZW50LTU1MDQ2OTdcbiAqL1xuXG51aXMuc2VydmljZSgndWlzUmVwZWF0UGFyc2VyJywgWyd1aVNlbGVjdE1pbkVycicsJyRwYXJzZScsIGZ1bmN0aW9uKHVpU2VsZWN0TWluRXJyLCAkcGFyc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8qKlxuICAgKiBFeGFtcGxlOlxuICAgKiBleHByZXNzaW9uID0gXCJhZGRyZXNzIGluIGFkZHJlc3NlcyB8IGZpbHRlcjoge3N0cmVldDogJHNlbGVjdC5zZWFyY2h9IHRyYWNrIGJ5ICRpbmRleFwiXG4gICAqIGl0ZW1OYW1lID0gXCJhZGRyZXNzXCIsXG4gICAqIHNvdXJjZSA9IFwiYWRkcmVzc2VzIHwgZmlsdGVyOiB7c3RyZWV0OiAkc2VsZWN0LnNlYXJjaH1cIixcbiAgICogdHJhY2tCeUV4cCA9IFwiJGluZGV4XCIsXG4gICAqL1xuICBzZWxmLnBhcnNlID0gZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuXG5cbiAgICB2YXIgbWF0Y2g7XG4gICAgdmFyIGlzT2JqZWN0Q29sbGVjdGlvbiA9IC9cXChcXHMqKFtcXCRcXHddW1xcJFxcd10qKVxccyosXFxzKihbXFwkXFx3XVtcXCRcXHddKilcXHMqXFwpLy50ZXN0KGV4cHJlc3Npb24pO1xuICAgIC8vIElmIGFuIGFycmF5IGlzIHVzZWQgYXMgY29sbGVjdGlvblxuXG4gICAgLy8gaWYgKGlzT2JqZWN0Q29sbGVjdGlvbil7XG4gICAgICAvLzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExMTExMDAwMDAwMDAwMDAwMDAwMjIyMjIyMjIyMjIyMjIwMDMzMzMzMzMzMzMzMzMzMzMzMzMzMzMwMDAwNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0MDAwMDAwMDAwMDAwMDAwNTU2NjY2NjYwMDAwMDc3Nzc3Nzc3Nzc3NzU1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODgwMDAwMDAwXG4gICAgbWF0Y2ggPSBleHByZXNzaW9uLm1hdGNoKC9eXFxzKig/OihbXFxzXFxTXSs/KVxccythc1xccyspPyg/OihbXFwkXFx3XVtcXCRcXHddKil8KD86XFwoXFxzKihbXFwkXFx3XVtcXCRcXHddKilcXHMqLFxccyooW1xcJFxcd11bXFwkXFx3XSopXFxzKlxcKSkpXFxzK2luXFxzKygoW1xcd1xcLl0rKT9cXHMqKHxcXHMqW1xcc1xcU10rPykpPyg/Olxccyt0cmFja1xccytieVxccysoW1xcc1xcU10rPykpP1xccyokLyk7ICAgICAgXG5cbiAgICAvLyAxIEFsaWFzXG4gICAgLy8gMiBJdGVtXG4gICAgLy8gMyBLZXkgb24gKGtleSx2YWx1ZSlcbiAgICAvLyA0IFZhbHVlIG9uIChrZXksdmFsdWUpXG4gICAgLy8gNSBDb2xsZWN0aW9uIGV4cHJlc2lvbiAob25seSB1c2VkIHdoZW4gdXNpbmcgYW4gYXJyYXkgY29sbGVjdGlvbilcbiAgICAvLyA2IE9iamVjdCB0aGF0IHdpbGwgYmUgY29udmVydGVkIHRvIEFycmF5IHdoZW4gdXNpbmcgKGtleSx2YWx1ZSkgc3ludGF4XG4gICAgLy8gNyBGaWx0ZXJzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvICM2IHdoZW4gdXNpbmcgKGtleSx2YWx1ZSkgc3ludGF4XG4gICAgLy8gOCBUcmFjayBieVxuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ2lleHAnLCBcIkV4cGVjdGVkIGV4cHJlc3Npb24gaW4gZm9ybSBvZiAnX2l0ZW1fIGluIF9jb2xsZWN0aW9uX1sgdHJhY2sgYnkgX2lkX10nIGJ1dCBnb3QgJ3swfScuXCIsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoWzZdICYmIGlzT2JqZWN0Q29sbGVjdGlvbikge1xuICAgICAgdGhyb3cgdWlTZWxlY3RNaW5FcnIoJ2lleHAnLCBcIkV4cGVjdGVkIGV4cHJlc3Npb24gaW4gZm9ybSBvZiAnX2l0ZW1fIGFzIChfa2V5XywgX2l0ZW1fKSBpbiBfT2JqQ29sbGVjdGlvbl8gWyB0cmFjayBieSBfaWRfXScgYnV0IGdvdCAnezB9Jy5cIixcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1OYW1lOiBtYXRjaFs0XSB8fCBtYXRjaFsyXSwgLy8gKGxocykgTGVmdC1oYW5kIHNpZGUsXG4gICAgICBrZXlOYW1lOiBtYXRjaFszXSwgLy9mb3IgKGtleSwgdmFsdWUpIHN5bnRheFxuICAgICAgc291cmNlOiAkcGFyc2UoIW1hdGNoWzNdID8gbWF0Y2hbNV0gOiBtYXRjaFs2XSksXG4gICAgICBzb3VyY2VOYW1lOiBtYXRjaFs2XSxcbiAgICAgIGZpbHRlcnM6IG1hdGNoWzddLFxuICAgICAgdHJhY2tCeUV4cDogbWF0Y2hbOF0sXG4gICAgICBtb2RlbE1hcHBlcjogJHBhcnNlKG1hdGNoWzFdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzJdKSxcbiAgICAgIHJlcGVhdEV4cHJlc3Npb246IGZ1bmN0aW9uIChncm91cGVkKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5pdGVtTmFtZSArICcgaW4gJyArIChncm91cGVkID8gJyRncm91cC5pdGVtcycgOiAnJHNlbGVjdC5pdGVtcycpO1xuICAgICAgICBpZiAodGhpcy50cmFja0J5RXhwKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiArPSAnIHRyYWNrIGJ5ICcgKyB0aGlzLnRyYWNrQnlFeHA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICB9IFxuICAgIH07XG5cbiAgfTtcblxuICBzZWxmLmdldEdyb3VwTmdSZXBlYXRFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICckZ3JvdXAgaW4gJHNlbGVjdC5ncm91cHMnO1xuICB9O1xuXG59XSk7XG5cbn0oKSk7XG5hbmd1bGFyLm1vZHVsZShcInVpLnNlbGVjdFwiKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHskdGVtcGxhdGVDYWNoZS5wdXQoXCJib290c3RyYXAvY2hvaWNlcy50cGwuaHRtbFwiLFwiPHVsIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcyB1aS1zZWxlY3QtY2hvaWNlcy1jb250ZW50IHVpLXNlbGVjdC1kcm9wZG93biBkcm9wZG93bi1tZW51XFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIiBuZy1zaG93PVxcXCIkc2VsZWN0Lml0ZW1zLmxlbmd0aCA+IDBcXFwiPjxsaSBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXMtZ3JvdXBcXFwiIGlkPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy17eyAkc2VsZWN0LmdlbmVyYXRlZElkIH19XFxcIj48ZGl2IGNsYXNzPVxcXCJkaXZpZGVyXFxcIiBuZy1zaG93PVxcXCIkc2VsZWN0LmlzR3JvdXBlZCAmJiAkaW5kZXggPiAwXFxcIj48L2Rpdj48ZGl2IG5nLXNob3c9XFxcIiRzZWxlY3QuaXNHcm91cGVkXFxcIiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXMtZ3JvdXAtbGFiZWwgZHJvcGRvd24taGVhZGVyXFxcIiBuZy1iaW5kPVxcXCIkZ3JvdXAubmFtZVxcXCI+PC9kaXY+PGRpdiBpZD1cXFwidWktc2VsZWN0LWNob2ljZXMtcm93LXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX0te3skaW5kZXh9fVxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXJvd1xcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6ICRzZWxlY3QuaXNBY3RpdmUodGhpcyksIGRpc2FibGVkOiAkc2VsZWN0LmlzRGlzYWJsZWQodGhpcyl9XFxcIiByb2xlPVxcXCJvcHRpb25cXFwiPjxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXJvdy1pbm5lclxcXCI+PC9hPjwvZGl2PjwvbGk+PC91bD5cIik7XG4kdGVtcGxhdGVDYWNoZS5wdXQoXCJib290c3RyYXAvbWF0Y2gtbXVsdGlwbGUudHBsLmh0bWxcIixcIjxzcGFuIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiPjxzcGFuIG5nLXJlcGVhdD1cXFwiJGl0ZW0gaW4gJHNlbGVjdC5zZWxlY3RlZFxcXCI+PHNwYW4gY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaC1pdGVtIGJ0biBidG4tZGVmYXVsdCBidG4teHNcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIiBuZy1kaXNhYmxlZD1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctY2xpY2s9XFxcIiRzZWxlY3RNdWx0aXBsZS5hY3RpdmVNYXRjaEluZGV4ID0gJGluZGV4O1xcXCIgbmctY2xhc3M9XFxcIntcXCdidG4tcHJpbWFyeVxcJzokc2VsZWN0TXVsdGlwbGUuYWN0aXZlTWF0Y2hJbmRleCA9PT0gJGluZGV4LCBcXCdzZWxlY3QtbG9ja2VkXFwnOiRzZWxlY3QuaXNMb2NrZWQodGhpcywgJGluZGV4KX1cXFwiIHVpLXNlbGVjdC1zb3J0PVxcXCIkc2VsZWN0LnNlbGVjdGVkXFxcIj48c3BhbiBjbGFzcz1cXFwiY2xvc2UgdWktc2VsZWN0LW1hdGNoLWNsb3NlXFxcIiBuZy1oaWRlPVxcXCIkc2VsZWN0LmRpc2FibGVkXFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdE11bHRpcGxlLnJlbW92ZUNob2ljZSgkaW5kZXgpXFxcIj4mbmJzcDsmdGltZXM7PC9zcGFuPiA8c3BhbiB1aXMtdHJhbnNjbHVkZS1hcHBlbmQ9XFxcIlxcXCI+PC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcImJvb3RzdHJhcC9tYXRjaC50cGwuaHRtbFwiLFwiPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LW1hdGNoXFxcIiBuZy1oaWRlPVxcXCIkc2VsZWN0Lm9wZW5cXFwiIG5nLWRpc2FibGVkPVxcXCIkc2VsZWN0LmRpc2FibGVkXFxcIiBuZy1jbGFzcz1cXFwie1xcJ2J0bi1kZWZhdWx0LWZvY3VzXFwnOiRzZWxlY3QuZm9jdXN9XFxcIj48c3BhbiB0YWJpbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgZm9ybS1jb250cm9sIHVpLXNlbGVjdC10b2dnbGVcXFwiIGFyaWEtbGFiZWw9XFxcInt7ICRzZWxlY3QuYmFzZVRpdGxlIH19IGFjdGl2YXRlXFxcIiBuZy1kaXNhYmxlZD1cXFwiJHNlbGVjdC5kaXNhYmxlZFxcXCIgbmctY2xpY2s9XFxcIiRzZWxlY3QuYWN0aXZhdGUoKVxcXCIgc3R5bGU9XFxcIm91dGxpbmU6IDA7XFxcIj48c3BhbiBuZy1zaG93PVxcXCIkc2VsZWN0LmlzRW1wdHkoKVxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1wbGFjZWhvbGRlciB0ZXh0LW11dGVkXFxcIj57eyRzZWxlY3QucGxhY2Vob2xkZXJ9fTwvc3Bhbj4gPHNwYW4gbmctaGlkZT1cXFwiJHNlbGVjdC5pc0VtcHR5KClcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2gtdGV4dCBwdWxsLWxlZnRcXFwiIG5nLWNsYXNzPVxcXCJ7XFwndWktc2VsZWN0LWFsbG93LWNsZWFyXFwnOiAkc2VsZWN0LmFsbG93Q2xlYXIgJiYgISRzZWxlY3QuaXNFbXB0eSgpfVxcXCIgbmctdHJhbnNjbHVkZT1cXFwiXFxcIj48L3NwYW4+IDxpIGNsYXNzPVxcXCJjYXJldCBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdC50b2dnbGUoJGV2ZW50KVxcXCI+PC9pPiA8YSBuZy1zaG93PVxcXCIkc2VsZWN0LmFsbG93Q2xlYXIgJiYgISRzZWxlY3QuaXNFbXB0eSgpXFxcIiBhcmlhLWxhYmVsPVxcXCJ7eyAkc2VsZWN0LmJhc2VUaXRsZSB9fSBjbGVhclxcXCIgc3R5bGU9XFxcIm1hcmdpbi1yaWdodDogMTBweFxcXCIgbmctY2xpY2s9XFxcIiRzZWxlY3QuY2xlYXIoJGV2ZW50KVxcXCIgY2xhc3M9XFxcImJ0biBidG4teHMgYnRuLWxpbmsgcHVsbC1yaWdodFxcXCI+PGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPjwvYT48L3NwYW4+PC9kaXY+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwiYm9vdHN0cmFwL3NlbGVjdC1tdWx0aXBsZS50cGwuaHRtbFwiLFwiPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNvbnRhaW5lciB1aS1zZWxlY3QtbXVsdGlwbGUgdWktc2VsZWN0LWJvb3RzdHJhcCBkcm9wZG93biBmb3JtLWNvbnRyb2xcXFwiIG5nLWNsYXNzPVxcXCJ7b3BlbjogJHNlbGVjdC5vcGVufVxcXCI+PGRpdj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiPjwvZGl2PjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBhdXRvY29tcGxldGU9XFxcImZhbHNlXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1zZWFyY2ggaW5wdXQteHNcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyRzZWxlY3RNdWx0aXBsZS5nZXRQbGFjZWhvbGRlcigpfX1cXFwiIG5nLWRpc2FibGVkPVxcXCIkc2VsZWN0LmRpc2FibGVkXFxcIiBuZy1oaWRlPVxcXCIkc2VsZWN0LmRpc2FibGVkXFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdC5hY3RpdmF0ZSgpXFxcIiBuZy1tb2RlbD1cXFwiJHNlbGVjdC5zZWFyY2hcXFwiIHJvbGU9XFxcImNvbWJvYm94XFxcIiBhcmlhLWxhYmVsPVxcXCJ7eyAkc2VsZWN0LmJhc2VUaXRsZSB9fVxcXCIgb25kcm9wPVxcXCJyZXR1cm4gZmFsc2U7XFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlc1xcXCI+PC9kaXY+PC9kaXY+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwiYm9vdHN0cmFwL3NlbGVjdC50cGwuaHRtbFwiLFwiPGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNvbnRhaW5lciB1aS1zZWxlY3QtYm9vdHN0cmFwIGRyb3Bkb3duXFxcIiBuZy1jbGFzcz1cXFwie29wZW46ICRzZWxlY3Qub3Blbn1cXFwiPjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCI+PC9kaXY+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIGF1dG9jb21wbGV0ZT1cXFwiZmFsc2VcXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgYXJpYS1leHBhbmRlZD1cXFwidHJ1ZVxcXCIgYXJpYS1sYWJlbD1cXFwie3sgJHNlbGVjdC5iYXNlVGl0bGUgfX1cXFwiIGFyaWEtb3ducz1cXFwidWktc2VsZWN0LWNob2ljZXMte3sgJHNlbGVjdC5nZW5lcmF0ZWRJZCB9fVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1yb3cte3sgJHNlbGVjdC5nZW5lcmF0ZWRJZCB9fS17eyAkc2VsZWN0LmFjdGl2ZUluZGV4IH19XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIHVpLXNlbGVjdC1zZWFyY2hcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyRzZWxlY3QucGxhY2Vob2xkZXJ9fVxcXCIgbmctbW9kZWw9XFxcIiRzZWxlY3Quc2VhcmNoXFxcIiBuZy1zaG93PVxcXCIkc2VsZWN0LnNlYXJjaEVuYWJsZWQgJiYgJHNlbGVjdC5vcGVuXFxcIj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlc1xcXCI+PC9kaXY+PC9kaXY+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwic2VsZWN0Mi9jaG9pY2VzLnRwbC5odG1sXCIsXCI8dWwgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzIHVpLXNlbGVjdC1jaG9pY2VzLWNvbnRlbnQgc2VsZWN0Mi1yZXN1bHRzXFxcIj48bGkgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLWdyb3VwXFxcIiBuZy1jbGFzcz1cXFwie1xcJ3NlbGVjdDItcmVzdWx0LXdpdGgtY2hpbGRyZW5cXCc6ICRzZWxlY3QuY2hvaWNlR3JvdXBlZCgkZ3JvdXApIH1cXFwiPjxkaXYgbmctc2hvdz1cXFwiJHNlbGVjdC5jaG9pY2VHcm91cGVkKCRncm91cClcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1ncm91cC1sYWJlbCBzZWxlY3QyLXJlc3VsdC1sYWJlbFxcXCIgbmctYmluZD1cXFwiJGdyb3VwLm5hbWVcXFwiPjwvZGl2Pjx1bCByb2xlPVxcXCJsaXN0Ym94XFxcIiBpZD1cXFwidWktc2VsZWN0LWNob2ljZXMte3sgJHNlbGVjdC5nZW5lcmF0ZWRJZCB9fVxcXCIgbmctY2xhc3M9XFxcIntcXCdzZWxlY3QyLXJlc3VsdC1zdWJcXCc6ICRzZWxlY3QuY2hvaWNlR3JvdXBlZCgkZ3JvdXApLCBcXCdzZWxlY3QyLXJlc3VsdC1zaW5nbGVcXCc6ICEkc2VsZWN0LmNob2ljZUdyb3VwZWQoJGdyb3VwKSB9XFxcIj48bGkgcm9sZT1cXFwib3B0aW9uXFxcIiBpZD1cXFwidWktc2VsZWN0LWNob2ljZXMtcm93LXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX0te3skaW5kZXh9fVxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXJvd1xcXCIgbmctY2xhc3M9XFxcIntcXCdzZWxlY3QyLWhpZ2hsaWdodGVkXFwnOiAkc2VsZWN0LmlzQWN0aXZlKHRoaXMpLCBcXCdzZWxlY3QyLWRpc2FibGVkXFwnOiAkc2VsZWN0LmlzRGlzYWJsZWQodGhpcyl9XFxcIj48ZGl2IGNsYXNzPVxcXCJzZWxlY3QyLXJlc3VsdC1sYWJlbCB1aS1zZWxlY3QtY2hvaWNlcy1yb3ctaW5uZXJcXFwiPjwvZGl2PjwvbGk+PC91bD48L2xpPjwvdWw+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwic2VsZWN0Mi9tYXRjaC1tdWx0aXBsZS50cGwuaHRtbFwiLFwiPHNwYW4gY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCI+PGxpIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2gtaXRlbSBzZWxlY3QyLXNlYXJjaC1jaG9pY2VcXFwiIG5nLXJlcGVhdD1cXFwiJGl0ZW0gaW4gJHNlbGVjdC5zZWxlY3RlZFxcXCIgbmctY2xhc3M9XFxcIntcXCdzZWxlY3QyLXNlYXJjaC1jaG9pY2UtZm9jdXNcXCc6JHNlbGVjdE11bHRpcGxlLmFjdGl2ZU1hdGNoSW5kZXggPT09ICRpbmRleCwgXFwnc2VsZWN0Mi1sb2NrZWRcXCc6JHNlbGVjdC5pc0xvY2tlZCh0aGlzLCAkaW5kZXgpfVxcXCIgdWktc2VsZWN0LXNvcnQ9XFxcIiRzZWxlY3Quc2VsZWN0ZWRcXFwiPjxzcGFuIHVpcy10cmFuc2NsdWRlLWFwcGVuZD1cXFwiXFxcIj48L3NwYW4+IDxhIGhyZWY9XFxcImphdmFzY3JpcHQ6O1xcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaC1jbG9zZSBzZWxlY3QyLXNlYXJjaC1jaG9pY2UtY2xvc2VcXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0TXVsdGlwbGUucmVtb3ZlQ2hvaWNlKCRpbmRleClcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PC9hPjwvbGk+PC9zcGFuPlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcInNlbGVjdDIvbWF0Y2gudHBsLmh0bWxcIixcIjxhIGNsYXNzPVxcXCJzZWxlY3QyLWNob2ljZSB1aS1zZWxlY3QtbWF0Y2hcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnc2VsZWN0Mi1kZWZhdWx0XFwnOiAkc2VsZWN0LmlzRW1wdHkoKX1cXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0LnRvZ2dsZSgkZXZlbnQpXFxcIiBhcmlhLWxhYmVsPVxcXCJ7eyAkc2VsZWN0LmJhc2VUaXRsZSB9fSBzZWxlY3RcXFwiPjxzcGFuIG5nLXNob3c9XFxcIiRzZWxlY3QuaXNFbXB0eSgpXFxcIiBjbGFzcz1cXFwic2VsZWN0Mi1jaG9zZW5cXFwiPnt7JHNlbGVjdC5wbGFjZWhvbGRlcn19PC9zcGFuPiA8c3BhbiBuZy1oaWRlPVxcXCIkc2VsZWN0LmlzRW1wdHkoKVxcXCIgY2xhc3M9XFxcInNlbGVjdDItY2hvc2VuXFxcIiBuZy10cmFuc2NsdWRlPVxcXCJcXFwiPjwvc3Bhbj4gPGFiYnIgbmctaWY9XFxcIiRzZWxlY3QuYWxsb3dDbGVhciAmJiAhJHNlbGVjdC5pc0VtcHR5KClcXFwiIGNsYXNzPVxcXCJzZWxlY3QyLXNlYXJjaC1jaG9pY2UtY2xvc2VcXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0LmNsZWFyKCRldmVudClcXFwiPjwvYWJicj4gPHNwYW4gY2xhc3M9XFxcInNlbGVjdDItYXJyb3cgdWktc2VsZWN0LXRvZ2dsZVxcXCI+PGI+PC9iPjwvc3Bhbj48L2E+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwic2VsZWN0Mi9zZWxlY3QtbXVsdGlwbGUudHBsLmh0bWxcIixcIjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1jb250YWluZXIgdWktc2VsZWN0LW11bHRpcGxlIHNlbGVjdDIgc2VsZWN0Mi1jb250YWluZXIgc2VsZWN0Mi1jb250YWluZXItbXVsdGlcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnc2VsZWN0Mi1jb250YWluZXItYWN0aXZlIHNlbGVjdDItZHJvcGRvd24tb3BlbiBvcGVuXFwnOiAkc2VsZWN0Lm9wZW4sIFxcJ3NlbGVjdDItY29udGFpbmVyLWRpc2FibGVkXFwnOiAkc2VsZWN0LmRpc2FibGVkfVxcXCI+PHVsIGNsYXNzPVxcXCJzZWxlY3QyLWNob2ljZXNcXFwiPjxzcGFuIGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiPjwvc3Bhbj48bGkgY2xhc3M9XFxcInNlbGVjdDItc2VhcmNoLWZpZWxkXFxcIj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJmYWxzZVxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiIHJvbGU9XFxcImNvbWJvYm94XFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJ0cnVlXFxcIiBhcmlhLW93bnM9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX1cXFwiIGFyaWEtbGFiZWw9XFxcInt7ICRzZWxlY3QuYmFzZVRpdGxlIH19XFxcIiBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9XFxcInVpLXNlbGVjdC1jaG9pY2VzLXJvdy17eyAkc2VsZWN0LmdlbmVyYXRlZElkIH19LXt7ICRzZWxlY3QuYWN0aXZlSW5kZXggfX1cXFwiIGNsYXNzPVxcXCJzZWxlY3QyLWlucHV0IHVpLXNlbGVjdC1zZWFyY2hcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyRzZWxlY3RNdWx0aXBsZS5nZXRQbGFjZWhvbGRlcigpfX1cXFwiIG5nLWRpc2FibGVkPVxcXCIkc2VsZWN0LmRpc2FibGVkXFxcIiBuZy1oaWRlPVxcXCIkc2VsZWN0LmRpc2FibGVkXFxcIiBuZy1tb2RlbD1cXFwiJHNlbGVjdC5zZWFyY2hcXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0LmFjdGl2YXRlKClcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMzRweDtcXFwiIG9uZHJvcD1cXFwicmV0dXJuIGZhbHNlO1xcXCI+PC9saT48L3VsPjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1kcm9wZG93biBzZWxlY3QyLWRyb3Agc2VsZWN0Mi13aXRoLXNlYXJjaGJveCBzZWxlY3QyLWRyb3AtYWN0aXZlXFxcIiBuZy1jbGFzcz1cXFwie1xcJ3NlbGVjdDItZGlzcGxheS1ub25lXFwnOiAhJHNlbGVjdC5vcGVufVxcXCI+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXNcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcInNlbGVjdDIvc2VsZWN0LnRwbC5odG1sXCIsXCI8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY29udGFpbmVyIHNlbGVjdDIgc2VsZWN0Mi1jb250YWluZXJcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnc2VsZWN0Mi1jb250YWluZXItYWN0aXZlIHNlbGVjdDItZHJvcGRvd24tb3BlbiBvcGVuXFwnOiAkc2VsZWN0Lm9wZW4sIFxcJ3NlbGVjdDItY29udGFpbmVyLWRpc2FibGVkXFwnOiAkc2VsZWN0LmRpc2FibGVkLCBcXCdzZWxlY3QyLWNvbnRhaW5lci1hY3RpdmVcXCc6ICRzZWxlY3QuZm9jdXMsIFxcJ3NlbGVjdDItYWxsb3djbGVhclxcJzogJHNlbGVjdC5hbGxvd0NsZWFyICYmICEkc2VsZWN0LmlzRW1wdHkoKX1cXFwiPjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwidWktc2VsZWN0LWRyb3Bkb3duIHNlbGVjdDItZHJvcCBzZWxlY3QyLXdpdGgtc2VhcmNoYm94IHNlbGVjdDItZHJvcC1hY3RpdmVcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnc2VsZWN0Mi1kaXNwbGF5LW5vbmVcXCc6ICEkc2VsZWN0Lm9wZW59XFxcIj48ZGl2IGNsYXNzPVxcXCJzZWxlY3QyLXNlYXJjaFxcXCIgbmctc2hvdz1cXFwiJHNlbGVjdC5zZWFyY2hFbmFibGVkXFxcIj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJmYWxzZVxcXCIgYXV0b2NvcnJlY3Q9XFxcImZhbHNlXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCIgcm9sZT1cXFwiY29tYm9ib3hcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcInRydWVcXFwiIGFyaWEtb3ducz1cXFwidWktc2VsZWN0LWNob2ljZXMte3sgJHNlbGVjdC5nZW5lcmF0ZWRJZCB9fVxcXCIgYXJpYS1sYWJlbD1cXFwie3sgJHNlbGVjdC5iYXNlVGl0bGUgfX1cXFwiIGFyaWEtYWN0aXZlZGVzY2VuZGFudD1cXFwidWktc2VsZWN0LWNob2ljZXMtcm93LXt7ICRzZWxlY3QuZ2VuZXJhdGVkSWQgfX0te3sgJHNlbGVjdC5hY3RpdmVJbmRleCB9fVxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1zZWFyY2ggc2VsZWN0Mi1pbnB1dFxcXCIgbmctbW9kZWw9XFxcIiRzZWxlY3Quc2VhcmNoXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlc1xcXCI+PC9kaXY+PC9kaXY+PC9kaXY+XCIpO1xuJHRlbXBsYXRlQ2FjaGUucHV0KFwic2VsZWN0aXplL2Nob2ljZXMudHBsLmh0bWxcIixcIjxkaXYgbmctc2hvdz1cXFwiJHNlbGVjdC5vcGVuXFxcIiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXMgdWktc2VsZWN0LWRyb3Bkb3duIHNlbGVjdGl6ZS1kcm9wZG93biBzaW5nbGVcXFwiPjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLWNvbnRlbnQgc2VsZWN0aXplLWRyb3Bkb3duLWNvbnRlbnRcXFwiPjxkaXYgY2xhc3M9XFxcInVpLXNlbGVjdC1jaG9pY2VzLWdyb3VwIG9wdGdyb3VwXFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIj48ZGl2IG5nLXNob3c9XFxcIiRzZWxlY3QuaXNHcm91cGVkXFxcIiBjbGFzcz1cXFwidWktc2VsZWN0LWNob2ljZXMtZ3JvdXAtbGFiZWwgb3B0Z3JvdXAtaGVhZGVyXFxcIiBuZy1iaW5kPVxcXCIkZ3JvdXAubmFtZVxcXCI+PC9kaXY+PGRpdiByb2xlPVxcXCJvcHRpb25cXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlcy1yb3dcXFwiIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiAkc2VsZWN0LmlzQWN0aXZlKHRoaXMpLCBkaXNhYmxlZDogJHNlbGVjdC5pc0Rpc2FibGVkKHRoaXMpfVxcXCI+PGRpdiBjbGFzcz1cXFwib3B0aW9uIHVpLXNlbGVjdC1jaG9pY2VzLXJvdy1pbm5lclxcXCIgZGF0YS1zZWxlY3RhYmxlPVxcXCJcXFwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PlwiKTtcbiR0ZW1wbGF0ZUNhY2hlLnB1dChcInNlbGVjdGl6ZS9tYXRjaC50cGwuaHRtbFwiLFwiPGRpdiBuZy1oaWRlPVxcXCIoJHNlbGVjdC5vcGVuIHx8ICRzZWxlY3QuaXNFbXB0eSgpKVxcXCIgY2xhc3M9XFxcInVpLXNlbGVjdC1tYXRjaFxcXCIgbmctdHJhbnNjbHVkZT1cXFwiXFxcIj48L2Rpdj5cIik7XG4kdGVtcGxhdGVDYWNoZS5wdXQoXCJzZWxlY3RpemUvc2VsZWN0LnRwbC5odG1sXCIsXCI8ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY29udGFpbmVyIHNlbGVjdGl6ZS1jb250cm9sIHNpbmdsZVxcXCIgbmctY2xhc3M9XFxcIntcXCdvcGVuXFwnOiAkc2VsZWN0Lm9wZW59XFxcIj48ZGl2IGNsYXNzPVxcXCJzZWxlY3RpemUtaW5wdXRcXFwiIG5nLWNsYXNzPVxcXCJ7XFwnZm9jdXNcXCc6ICRzZWxlY3Qub3BlbiwgXFwnZGlzYWJsZWRcXCc6ICRzZWxlY3QuZGlzYWJsZWQsIFxcJ3NlbGVjdGl6ZS1mb2N1c1xcJyA6ICRzZWxlY3QuZm9jdXN9XFxcIiBuZy1jbGljaz1cXFwiJHNlbGVjdC5vcGVuICYmICEkc2VsZWN0LnNlYXJjaEVuYWJsZWQgPyAkc2VsZWN0LnRvZ2dsZSgkZXZlbnQpIDogJHNlbGVjdC5hY3RpdmF0ZSgpXFxcIj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtbWF0Y2hcXFwiPjwvZGl2PjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBhdXRvY29tcGxldGU9XFxcImZhbHNlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJ1aS1zZWxlY3Qtc2VhcmNoIHVpLXNlbGVjdC10b2dnbGVcXFwiIG5nLWNsaWNrPVxcXCIkc2VsZWN0LnRvZ2dsZSgkZXZlbnQpXFxcIiBwbGFjZWhvbGRlcj1cXFwie3skc2VsZWN0LnBsYWNlaG9sZGVyfX1cXFwiIG5nLW1vZGVsPVxcXCIkc2VsZWN0LnNlYXJjaFxcXCIgbmctaGlkZT1cXFwiISRzZWxlY3Quc2VhcmNoRW5hYmxlZCB8fCAoJHNlbGVjdC5zZWxlY3RlZCAmJiAhJHNlbGVjdC5vcGVuKVxcXCIgbmctZGlzYWJsZWQ9XFxcIiRzZWxlY3QuZGlzYWJsZWRcXFwiIGFyaWEtbGFiZWw9XFxcInt7ICRzZWxlY3QuYmFzZVRpdGxlIH19XFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJ1aS1zZWxlY3QtY2hvaWNlc1xcXCI+PC9kaXY+PC9kaXY+XCIpO31dKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zZWxlY3QuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zZWxlY3QuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zZWxlY3QuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi91aS1zZWxlY3QvZGlzdC9zZWxlY3QuY3NzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxuICogdWktc2VsZWN0XFxuICogaHR0cDovL2dpdGh1Yi5jb20vYW5ndWxhci11aS91aS1zZWxlY3RcXG4gKiBWZXJzaW9uOiAwLjE0LjYgLSAyMDE2LTAyLTE4VDIxOjAxOjM2Ljk3MlpcXG4gKiBMaWNlbnNlOiBNSVRcXG4gKi9cXG5cXG5cXG4vKiBTdHlsZSB3aGVuIGhpZ2hsaWdodGluZyBhIHNlYXJjaC4gKi9cXG4udWktc2VsZWN0LWhpZ2hsaWdodCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLnVpLXNlbGVjdC1vZmZzY3JlZW4ge1xcbiAgY2xpcDogcmVjdCgwIDAgMCAwKSAhaW1wb3J0YW50O1xcbiAgd2lkdGg6IDFweCAhaW1wb3J0YW50O1xcbiAgaGVpZ2h0OiAxcHggIWltcG9ydGFudDtcXG4gIGJvcmRlcjogMCAhaW1wb3J0YW50O1xcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XFxuICBwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XFxuICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcXG4gIG91dGxpbmU6IDAgIWltcG9ydGFudDtcXG4gIGxlZnQ6IDBweCAhaW1wb3J0YW50O1xcbiAgdG9wOiAwcHggIWltcG9ydGFudDtcXG59XFxuXFxuXFxuLnVpLXNlbGVjdC1jaG9pY2VzLXJvdzpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNWY1O1xcbn1cXG5cXG4vKiBTZWxlY3QyIHRoZW1lICovXFxuXFxuLyogTWFyayBpbnZhbGlkIFNlbGVjdDIgKi9cXG4ubmctZGlydHkubmctaW52YWxpZCA+IGEuc2VsZWN0Mi1jaG9pY2Uge1xcbiAgICBib3JkZXItY29sb3I6ICNENDQ5NTA7XFxufVxcblxcbi5zZWxlY3QyLXJlc3VsdC1zaW5nbGUge1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbn1cXG5cXG4uc2VsZWN0Mi1sb2NrZWQgPiAuc2VsZWN0Mi1zZWFyY2gtY2hvaWNlLWNsb3Nle1xcbiAgZGlzcGxheTpub25lO1xcbn1cXG5cXG4uc2VsZWN0LWxvY2tlZCA+IC51aS1zZWxlY3QtbWF0Y2gtY2xvc2V7XFxuICAgIGRpc3BsYXk6bm9uZTtcXG59XFxuXFxuYm9keSA+IC5zZWxlY3QyLWNvbnRhaW5lci5vcGVuIHtcXG4gIHotaW5kZXg6IDk5OTk7IC8qIFRoZSB6LWluZGV4IFNlbGVjdDIgYXBwbGllcyB0byB0aGUgc2VsZWN0Mi1kcm9wICovXFxufVxcblxcbi8qIEhhbmRsZSB1cCBkaXJlY3Rpb24gU2VsZWN0MiAqL1xcbi51aS1zZWxlY3QtY29udGFpbmVyW3RoZW1lPVxcXCJzZWxlY3QyXFxcIl0uZGlyZWN0aW9uLXVwIC51aS1zZWxlY3QtbWF0Y2gge1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7IC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxufVxcbi51aS1zZWxlY3QtY29udGFpbmVyW3RoZW1lPVxcXCJzZWxlY3QyXFxcIl0uZGlyZWN0aW9uLXVwIC51aS1zZWxlY3QtZHJvcGRvd24ge1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7IC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDsgIC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuXFxuICAgIGJveC1zaGFkb3c6IDAgLTRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG5cXG4gICAgbWFyZ2luLXRvcDogLTRweDsgLyogRklYTUUgaGFyZGNvZGVkIHZhbHVlIDotLyAqL1xcbn1cXG4udWktc2VsZWN0LWNvbnRhaW5lclt0aGVtZT1cXFwic2VsZWN0MlxcXCJdLmRpcmVjdGlvbi11cCAudWktc2VsZWN0LWRyb3Bkb3duIC5zZWxlY3QyLXNlYXJjaCB7XFxuICAgIG1hcmdpbi10b3A6IDRweDsgLyogRklYTUUgaGFyZGNvZGVkIHZhbHVlIDotLyAqL1xcbn1cXG4udWktc2VsZWN0LWNvbnRhaW5lclt0aGVtZT1cXFwic2VsZWN0MlxcXCJdLmRpcmVjdGlvbi11cC5zZWxlY3QyLWRyb3Bkb3duLW9wZW4gLnVpLXNlbGVjdC1tYXRjaCB7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6ICM1ODk3ZmI7XFxufVxcblxcbi8qIFNlbGVjdGl6ZSB0aGVtZSAqL1xcblxcbi8qIEhlbHBlciBjbGFzcyB0byBzaG93IHN0eWxlcyB3aGVuIGZvY3VzICovXFxuLnNlbGVjdGl6ZS1pbnB1dC5zZWxlY3RpemUtZm9jdXN7XFxuICBib3JkZXItY29sb3I6ICMwMDdGQkIgIWltcG9ydGFudDtcXG59XFxuXFxuLyogRml4IGlucHV0IHdpZHRoIGZvciBTZWxlY3RpemUgdGhlbWUgKi9cXG4uc2VsZWN0aXplLWNvbnRyb2wgPiAuc2VsZWN0aXplLWlucHV0ID4gaW5wdXQge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi8qIEZpeCBkcm9wZG93biB3aWR0aCBmb3IgU2VsZWN0aXplIHRoZW1lICovXFxuLnNlbGVjdGl6ZS1jb250cm9sID4gLnNlbGVjdGl6ZS1kcm9wZG93biB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLyogTWFyayBpbnZhbGlkIFNlbGVjdGl6ZSAqL1xcbi5uZy1kaXJ0eS5uZy1pbnZhbGlkID4gZGl2LnNlbGVjdGl6ZS1pbnB1dCB7XFxuICAgIGJvcmRlci1jb2xvcjogI0Q0NDk1MDtcXG59XFxuXFxuLyogSGFuZGxlIHVwIGRpcmVjdGlvbiBTZWxlY3RpemUgKi9cXG4udWktc2VsZWN0LWNvbnRhaW5lclt0aGVtZT1cXFwic2VsZWN0aXplXFxcIl0uZGlyZWN0aW9uLXVwIC51aS1zZWxlY3QtZHJvcGRvd24ge1xcbiAgICBib3gtc2hhZG93OiAwIC00cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuXFxuICAgIG1hcmdpbi10b3A6IC0ycHg7IC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG59XFxuXFxuLyogQm9vdHN0cmFwIHRoZW1lICovXFxuXFxuLyogSGVscGVyIGNsYXNzIHRvIHNob3cgc3R5bGVzIHdoZW4gZm9jdXMgKi9cXG4uYnRuLWRlZmF1bHQtZm9jdXMge1xcbiAgY29sb3I6ICMzMzM7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjRUJFQkVCO1xcbiAgYm9yZGVyLWNvbG9yOiAjQURBREFEO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgb3V0bGluZTogNXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjA3NSksIDAgMCA4cHggcmdiYSgxMDIsIDE3NSwgMjMzLCAwLjYpO1xcbn1cXG5cXG4udWktc2VsZWN0LWJvb3RzdHJhcCAudWktc2VsZWN0LXRvZ2dsZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi51aS1zZWxlY3QtYm9vdHN0cmFwIC51aS1zZWxlY3QtdG9nZ2xlID4gLmNhcmV0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGhlaWdodDogMTBweDtcXG4gIHRvcDogNTAlO1xcbiAgcmlnaHQ6IDEwcHg7XFxuICBtYXJnaW4tdG9wOiAtMnB4O1xcbn1cXG5cXG4vKiBGaXggQm9vdHN0cmFwIGRyb3Bkb3duIHBvc2l0aW9uIHdoZW4gaW5zaWRlIGEgaW5wdXQtZ3JvdXAgKi9cXG4uaW5wdXQtZ3JvdXAgPiAudWktc2VsZWN0LWJvb3RzdHJhcC5kcm9wZG93biB7XFxuICAvKiBJbnN0ZWFkIG9mIHJlbGF0aXZlICovXFxuICBwb3NpdGlvbjogc3RhdGljO1xcbn1cXG5cXG4uaW5wdXQtZ3JvdXAgPiAudWktc2VsZWN0LWJvb3RzdHJhcCA+IGlucHV0LnVpLXNlbGVjdC1zZWFyY2guZm9ybS1jb250cm9sIHtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDsgLyogRklYTUUgaGFyZGNvZGVkIHZhbHVlIDotLyAqL1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG59XFxuLmlucHV0LWdyb3VwID4gLnVpLXNlbGVjdC1ib290c3RyYXAgPiBpbnB1dC51aS1zZWxlY3Qtc2VhcmNoLmZvcm0tY29udHJvbC5kaXJlY3Rpb24tdXAge1xcbiAgYm9yZGVyLXJhZGl1czogNHB4ICFpbXBvcnRhbnQ7IC8qIEZJWE1FIGhhcmRjb2RlZCB2YWx1ZSA6LS8gKi9cXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwICFpbXBvcnRhbnQ7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMCAhaW1wb3J0YW50O1xcbn1cXG5cXG4udWktc2VsZWN0LWJvb3RzdHJhcCA+IC51aS1zZWxlY3QtbWF0Y2ggPiAuYnRue1xcbiAgLyogSW5zdGVhZCBvZiBjZW50ZXIgYmVjYXVzZSBvZiAuYnRuICovXFxuICB0ZXh0LWFsaWduOiBsZWZ0ICFpbXBvcnRhbnQ7XFxufVxcblxcbi51aS1zZWxlY3QtYm9vdHN0cmFwID4gLnVpLXNlbGVjdC1tYXRjaCA+IC5jYXJldCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDQ1JTtcXG4gIHJpZ2h0OiAxNXB4O1xcbn1cXG5cXG4vKiBTZWUgU2Nyb2xsYWJsZSBNZW51IHdpdGggQm9vdHN0cmFwIDMgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTIyNzQ5NiAqL1xcbi51aS1zZWxlY3QtYm9vdHN0cmFwID4gLnVpLXNlbGVjdC1jaG9pY2VzIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgbWF4LWhlaWdodDogMjAwcHg7XFxuICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICBtYXJnaW4tdG9wOiAtMXB4O1xcbn1cXG5cXG5ib2R5ID4gLnVpLXNlbGVjdC1ib290c3RyYXAub3BlbiB7XFxuICB6LWluZGV4OiAxMDAwOyAvKiBTdGFuZGFyZCBCb290c3RyYXAgZHJvcGRvd24gei1pbmRleCAqL1xcbn1cXG5cXG4udWktc2VsZWN0LW11bHRpcGxlLnVpLXNlbGVjdC1ib290c3RyYXAge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgcGFkZGluZzogM3B4IDNweCAwIDNweDtcXG59XFxuXFxuLnVpLXNlbGVjdC1tdWx0aXBsZS51aS1zZWxlY3QtYm9vdHN0cmFwIGlucHV0LnVpLXNlbGVjdC1zZWFyY2gge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDsgLyogVG8gcHJldmVudCBkb3VibGUgYmFja2dyb3VuZCB3aGVuIGRpc2FibGVkICovXFxuICBib3JkZXI6IG5vbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgaGVpZ2h0OiAxLjY2NjY2NmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogM3B4O1xcbn1cXG5cXG4udWktc2VsZWN0LW11bHRpcGxlLnVpLXNlbGVjdC1ib290c3RyYXAgLnVpLXNlbGVjdC1tYXRjaCAuY2xvc2Uge1xcbiAgZm9udC1zaXplOiAxLjZlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjc1O1xcbn1cXG5cXG4udWktc2VsZWN0LW11bHRpcGxlLnVpLXNlbGVjdC1ib290c3RyYXAgLnVpLXNlbGVjdC1tYXRjaC1pdGVtIHtcXG4gIG91dGxpbmU6IDA7XFxuICBtYXJnaW46IDAgM3B4IDNweCAwO1xcbn1cXG5cXG4udWktc2VsZWN0LW11bHRpcGxlIC51aS1zZWxlY3QtbWF0Y2gtaXRlbSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi51aS1zZWxlY3QtbXVsdGlwbGUgLnVpLXNlbGVjdC1tYXRjaC1pdGVtLmRyb3BwaW5nLWJlZm9yZTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICByaWdodDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG1hcmdpbi1yaWdodDogMnB4O1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjNDI4YmNhO1xcbn1cXG5cXG4udWktc2VsZWN0LW11bHRpcGxlIC51aS1zZWxlY3QtbWF0Y2gtaXRlbS5kcm9wcGluZy1hZnRlcjphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW4tbGVmdDogMnB4O1xcbiAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgIzQyOGJjYTtcXG59XFxuXFxuLnVpLXNlbGVjdC1ib290c3RyYXAgLnVpLXNlbGVjdC1jaG9pY2VzLXJvdz5hIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHBhZGRpbmc6IDNweCAyMHB4O1xcbiAgICBjbGVhcjogYm90aDtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDI4NTcxNDM7XFxuICAgIGNvbG9yOiAjMzMzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4udWktc2VsZWN0LWJvb3RzdHJhcCAudWktc2VsZWN0LWNob2ljZXMtcm93PmE6aG92ZXIsIC51aS1zZWxlY3QtYm9vdHN0cmFwIC51aS1zZWxlY3QtY2hvaWNlcy1yb3c+YTpmb2N1cyB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgY29sb3I6ICMyNjI2MjY7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XFxufVxcblxcbi51aS1zZWxlY3QtYm9vdHN0cmFwIC51aS1zZWxlY3QtY2hvaWNlcy1yb3cuYWN0aXZlPmEge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBvdXRsaW5lOiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDI4YmNhO1xcbn1cXG5cXG4udWktc2VsZWN0LWJvb3RzdHJhcCAudWktc2VsZWN0LWNob2ljZXMtcm93LmRpc2FibGVkPmEsXFxuLnVpLXNlbGVjdC1ib290c3RyYXAgLnVpLXNlbGVjdC1jaG9pY2VzLXJvdy5hY3RpdmUuZGlzYWJsZWQ+YSB7XFxuICAgIGNvbG9yOiAjNzc3O1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbn1cXG5cXG4vKiBmaXggaGlkZS9zaG93IGFuZ3VsYXIgYW5pbWF0aW9uICovXFxuLnVpLXNlbGVjdC1tYXRjaC5uZy1oaWRlLWFkZCxcXG4udWktc2VsZWN0LXNlYXJjaC5uZy1oaWRlLWFkZCB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuLyogTWFyayBpbnZhbGlkIEJvb3RzdHJhcCAqL1xcbi51aS1zZWxlY3QtYm9vdHN0cmFwLm5nLWRpcnR5Lm5nLWludmFsaWQgPiBidXR0b24uYnRuLnVpLXNlbGVjdC1tYXRjaCB7XFxuICAgIGJvcmRlci1jb2xvcjogI0Q0NDk1MDtcXG59XFxuXFxuLyogSGFuZGxlIHVwIGRpcmVjdGlvbiBCb290c3RyYXAgKi9cXG4udWktc2VsZWN0LWNvbnRhaW5lclt0aGVtZT1cXFwiYm9vdHN0cmFwXFxcIl0uZGlyZWN0aW9uLXVwIC51aS1zZWxlY3QtZHJvcGRvd24ge1xcbiAgICBib3gtc2hhZG93OiAwIC00cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3VpLXNlbGVjdC9kaXN0L3NlbGVjdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCIgbmctY2xhc3M9XFxcInsgJ2hhcy1lcnJvcic6IHNlbGVjdC5uZ01vZGVsLiRpbnZhbGlkIH1cXFwiPlxcclxcblxcdDxsYWJlbCBuZy1zaG93PVxcXCJzZWxlY3Quc2VsZWN0aW9uXFxcIiBjbGFzcz1cXFwic2hvdy1oaWRlIGFuZ3VsYXItYW5pbWF0ZVxcXCI+XFxyXFxuXFx0XFx0e3tzZWxlY3QubGFiZWx9fVxcclxcblxcdDwvbGFiZWw+XFxyXFxuXFx0PHVpLXNlbGVjdCBuZy1tb2RlbD1cXFwic2VsZWN0LnNlbGVjdGlvblxcXCIgc2VhcmNoLWVuYWJsZWQ9XFxcImZhbHNlXFxcIiB0aGVtZT1cXFwiYm9vdHN0cmFwXFxcIiBuZy1kaXNhYmxlZD1cXFwic2VsZWN0Lm5nRGlzYWJsZWRcXFwiPlxcclxcblxcdFxcdDx1aS1zZWxlY3QtbWF0Y2ggcGxhY2Vob2xkZXI9XFxcInt7c2VsZWN0LmxhYmVsfX1cXFwiPnt7c2VsZWN0LmdldERpc3BsYXlOYW1lKCRzZWxlY3Quc2VsZWN0ZWQpfX08L3VpLXNlbGVjdC1tYXRjaD5cXHJcXG5cXHRcXHQ8dWktc2VsZWN0LWNob2ljZXMgcmVwZWF0PVxcXCJvcHRpb24gaW4gc2VsZWN0Lm9wdGlvbnNcXFwiPlxcclxcblxcdFxcdFxcdHt7c2VsZWN0LmdldERpc3BsYXlOYW1lKG9wdGlvbil9fVxcclxcblxcdFxcdDwvdWktc2VsZWN0LWNob2ljZXM+XFxyXFxuXFx0PC91aS1zZWxlY3Q+XFxyXFxuXFx0PHNwYW4gY2xhc3M9XFxcImVycm9yLXN0cmluZ1xcXCIgbmctc2hvdz1cXFwic2VsZWN0LmlucHV0VmFsaWRhdG9yLmVycm9yXFxcIj57e3NlbGVjdC5pbnB1dFZhbGlkYXRvci5lcnJvcn19PC9zcGFuPlxcclxcblxcdDxybC1idXN5IGxvYWRpbmc9XFxcInNlbGVjdC5sb2FkaW5nXFxcIj48L3JsLWJ1c3k+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5odG1sXG4gKiogbW9kdWxlIGlkID0gMTY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgU2lnbmF0dXJlUGFkID0gcmVxdWlyZSgnc2lnbmF0dXJlX3BhZCcpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy5zaWduYXR1cmVQYWQnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTaWduYXR1cmVQYWQnO1xyXG5mdW5jdGlvbiBzaWduYXR1cmVQYWQoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgcmVxdWlyZTogJ25nTW9kZWwnLFxyXG4gICAgICAgIHRlbXBsYXRlOiBcIlxcblxcdFxcdFxcdDxjYW52YXMgY2xhc3M9XFxcInNpZ25hdHVyZS1wYWRcXFwiIG5nLWlmPVxcXCIhbmdEaXNhYmxlZFxcXCI+PC9jYW52YXM+XFxuXFx0XFx0XFx0PGltZyBuZy1zcmM9XFxcInt7bmdNb2RlbC4kdmlld1ZhbHVlfX1cXFwiIG5nLXN0eWxlPVxcXCJzdHlsZVxcXCIgbmctaWY9XFxcIm5nRGlzYWJsZWRcXFwiIC8+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgc2NvcGU6IHtcclxuICAgICAgICAgICAgcGFkOiAnPScsXHJcbiAgICAgICAgICAgIGhlaWdodDogJz0nLFxyXG4gICAgICAgICAgICB3aWR0aDogJz0nLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XHJcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgnbmdEaXNhYmxlZCcsIGZ1bmN0aW9uIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGUubmdNb2RlbCA9IG5nTW9kZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5zdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzY29wZS5oZWlnaHQgIT0gbnVsbCA/IHNjb3BlLmhlaWdodCA6IDEwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNjb3BlLndpZHRoICE9IG51bGwgPyBzY29wZS53aWR0aCA6IDIwMCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGVsZW1lbnQuZmluZCgnLnNpZ25hdHVyZS1wYWQnKS5nZXQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYigyNTUsIDI1NSwgMjU1KScsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5wYWQgPSBuZXcgU2lnbmF0dXJlUGFkKGNhbnZhcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHNjb3BlLmhlaWdodCAhPSBudWxsID8gc2NvcGUuaGVpZ2h0IDogMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNjb3BlLndpZHRoICE9IG51bGwgPyBzY29wZS53aWR0aCA6IDIwMDtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gbmdNb2RlbC4kdmlld1ZhbHVlOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnBhZC5mcm9tRGF0YVVSTCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGUucGFkLnRvRGF0YVVSTCgpOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zaWduYXR1cmVQYWQgPSBzaWduYXR1cmVQYWQ7XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW10pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgc2lnbmF0dXJlUGFkKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlUGFkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zaWduYXR1cmVQYWQvc2lnbmF0dXJlUGFkLmpzXG4gKiogbW9kdWxlIGlkID0gMTY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xID0gcmVxdWlyZSgndHlwZXNjcmlwdC1hbmd1bGFyLXV0aWxpdGllcycpO1xyXG52YXIgX19vYnNlcnZhYmxlID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9ic2VydmFibGU7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbnZhciBjYXJkID0gcmVxdWlyZSgnLi9zaW1wbGVDYXJkJyk7XHJcbmV4cG9ydHMuc2ltcGxlQ2FyZCA9IGNhcmQ7XHJcbnZhciBsaXN0ID0gcmVxdWlyZSgnLi9zaW1wbGVDYXJkTGlzdCcpO1xyXG5leHBvcnRzLnNpbXBsZUNhcmRMaXN0ID0gbGlzdDtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuc2ltcGxlQ2FyZExpc3QnO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtfX29ic2VydmFibGUubW9kdWxlTmFtZSwgX19wYXJlbnRDaGlsZC5tb2R1bGVOYW1lXSlcclxuICAgIC5kaXJlY3RpdmUobGlzdC5kaXJlY3RpdmVOYW1lLCBsaXN0LnNpbXBsZUNhcmRMaXN0KVxyXG4gICAgLmNvbnRyb2xsZXIobGlzdC5jb250cm9sbGVyTmFtZSwgbGlzdC5TaW1wbGVDYXJkTGlzdENvbnRyb2xsZXIpXHJcbiAgICAuZGlyZWN0aXZlKGNhcmQuZGlyZWN0aXZlTmFtZSwgY2FyZC5zaW1wbGVDYXJkKVxyXG4gICAgLmNvbnRyb2xsZXIoY2FyZC5jb250cm9sbGVyTmFtZSwgY2FyZC5TaW1wbGVDYXJkQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZUNhcmRMaXN0Lm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc2ltcGxlQ2FyZExpc3Qvc2ltcGxlQ2FyZExpc3QubW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3BhcmVudENoaWxkID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLnBhcmVudENoaWxkQmVoYXZpb3I7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFNpbXBsZUNhcmQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NpbXBsZUNhcmRDb250cm9sbGVyJztcclxudmFyIFNpbXBsZUNhcmRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNpbXBsZUNhcmRDb250cm9sbGVyKCRzY29wZSwgJGVsZW1lbnQsIHBhcmVudENoaWxkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkID0gcGFyZW50Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy5zaG93Q29udGVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0b3NhdmVMaW5rID0ge307XHJcbiAgICAgICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnNob3dDb250ZW50ID09PSBmYWxzZSB8fCBfdGhpcy5hbHdheXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXV0b3NhdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmNhbk9wZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbk9wZW4gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpc3RDb250cm9sbGVyID0gJGVsZW1lbnQuY29udHJvbGxlcigncmxTaW1wbGVDYXJkTGlzdCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RDb250cm9sbGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0Q29udHJvbGxlciA9IHRoaXMubm9MaXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHtcclxuICAgICAgICAgICAgYXV0b3NhdmU6IHRoaXMuYXV0b3NhdmUuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgY2xvc2U6IHRoaXMuY2xvc2UsXHJcbiAgICAgICAgICAgIHNldEFsd2F5c09wZW46IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWx3YXlzT3BlbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5saXN0Q29udHJvbGxlci5yZWdpc3RlckNhcmQoYmVoYXZpb3IpO1xyXG4gICAgICAgIHBhcmVudENoaWxkLnJlZ2lzdGVyQ2hpbGRCZWhhdmlvcih0aGlzLmNoaWxkTGluaywgYmVoYXZpb3IpO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWx3YXlzT3BlbjsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvd0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgU2ltcGxlQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLnRvZ2dsZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0NvbnRlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNpbXBsZUNhcmRDb250cm9sbGVyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbk9wZW4gJiYgdGhpcy5saXN0Q29udHJvbGxlci5vcGVuQ2FyZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm9uT3BlbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTaW1wbGVDYXJkQ29udHJvbGxlci5wcm90b3R5cGUuYXV0b3NhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRDaGlsZC50cmlnZ2VyQ2hpbGRCZWhhdmlvcih0aGlzLmF1dG9zYXZlTGluaywgZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIHZhciBjYW5DbG9zZSA9IGJlaGF2aW9yLmF1dG9zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChjYW5DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FuQ2xvc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU2ltcGxlQ2FyZENvbnRyb2xsZXIucHJvdG90eXBlLm5vTGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcGVuQ2FyZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyQ2FyZDogZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFNpbXBsZUNhcmRDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckZWxlbWVudCcsIF9fcGFyZW50Q2hpbGQuc2VydmljZU5hbWVdO1xyXG4gICAgcmV0dXJuIFNpbXBsZUNhcmRDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlNpbXBsZUNhcmRDb250cm9sbGVyID0gU2ltcGxlQ2FyZENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHNpbXBsZUNhcmQoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZToge1xyXG4gICAgICAgICAgICAnaGVhZGVyU2xvdCc6ICc/cmxDYXJkSGVhZGVyJyxcclxuICAgICAgICAgICAgJ2NvbnRlbnRTbG90JzogJz9ybENhcmRDb250ZW50JyxcclxuICAgICAgICAgICAgJ2Zvb3RlclNsb3QnOiAnP3JsQ2FyZEZvb3RlcicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXF1aXJlOiAnP15ecmxTaW1wbGVDYXJkTGlzdCcsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vc2ltcGxlQ2FyZC5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICdjYXJkJyxcclxuICAgICAgICBzY29wZToge30sXHJcbiAgICAgICAgYmluZFRvQ29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICBvbk9wZW46ICcmJyxcclxuICAgICAgICAgICAgY2FuT3BlbjogJz0/JyxcclxuICAgICAgICAgICAgYWx3YXlzT3BlbjogJz0/JyxcclxuICAgICAgICAgICAgY2hpbGRMaW5rOiAnPT8nLFxyXG4gICAgICAgICAgICBzYXZlOiAnJicsXHJcbiAgICAgICAgICAgIHNhdmVXaGVuSW52YWxpZDogJzw/JyxcclxuICAgICAgICAgICAgY2FyZFR5cGU6ICdAJyxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnNpbXBsZUNhcmQgPSBzaW1wbGVDYXJkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVDYXJkLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkLmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiY2FyZCBjb2wteHMtMTIge3tjYXJkLmNhcmRUeXBlfX1cXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcImhlYWRlciByb3dcXFwiIG5nLWNsYXNzPVxcXCJ7ICdhY3RpdmUnOiBjYXJkLmNhbk9wZW4gJiYgIWNhcmQuYWx3YXlzT3BlbiwgJ2Vycm9yJzogY2FyZEZvcm0uJGludmFsaWQgfVxcXCIgbmctY2xpY2s9XFxcImNhcmQudG9nZ2xlQ29udGVudCgpXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IG5nLXRyYW5zY2x1ZGU9XFxcImhlYWRlclNsb3RcXFwiPjwvZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj48L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG5cXHJcXG5cXHQ8bmctZm9ybSBuYW1lPVxcXCJjYXJkRm9ybVxcXCIgcmwtYXV0b3NhdmU9XFxcImNhcmQuYXV0b3NhdmVMaW5rXFxcIiBzYXZlPVxcXCJjYXJkLnNhdmUoKVxcXCIgc2F2ZS13aGVuLWludmFsaWQ9XFxcImNhcmQuc2F2ZVdoZW5JbnZhbGlkXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IG5nLXNob3c9XFxcImNhcmQuc2hvd0NvbnRlbnQgfHwgY2FyZC5hbHdheXNPcGVuXFxcIj5cXHJcXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJib2R5IHJvd1xcXCI+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBuZy10cmFuc2NsdWRlPVxcXCJjb250ZW50U2xvdFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImZvb3RlciByb3dcXFwiPlxcclxcblxcdFxcdFxcdFxcdDxkaXYgbmctdHJhbnNjbHVkZT1cXFwiZm9vdGVyU2xvdFxcXCI+PC9kaXY+XFxyXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPjwvZGl2PlxcclxcblxcdFxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvbmctZm9ybT5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy9zaW1wbGVDYXJkTGlzdC9zaW1wbGVDYXJkLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fb2JzZXJ2YWJsZSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYnNlcnZhYmxlO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTaW1wbGVDYXJkTGlzdCc7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyJztcclxudmFyIFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTaW1wbGVDYXJkTGlzdENvbnRyb2xsZXIoJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgb2JzZXJ2YWJsZUZhY3RvcnkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGVGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiAkcGFyc2UoJGF0dHJzLmFsd2F5c09wZW4pKCRzY29wZSk7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5hbHdheXNPcGVuID0gdmFsdWU7XHJcbiAgICAgICAgICAgIF90aGlzLm9ic2VydmFibGUuZmlyZSgnYWx3YXlzT3BlbicsIHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFNpbXBsZUNhcmRMaXN0Q29udHJvbGxlci5wcm90b3R5cGUucmVnaXN0ZXJDYXJkID0gZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgYmVoYXZpb3Iuc2V0QWx3YXlzT3Blbih0aGlzLmFsd2F5c09wZW4pO1xyXG4gICAgICAgIHZhciB1bnJlZ2lzdGVyRnVuY3Rpb25zID0gW107XHJcbiAgICAgICAgdW5yZWdpc3RlckZ1bmN0aW9ucy5wdXNoKHRoaXMub2JzZXJ2YWJsZS5yZWdpc3RlcihiZWhhdmlvci5jbG9zZSwgJ2Nsb3NlJykpO1xyXG4gICAgICAgIHVucmVnaXN0ZXJGdW5jdGlvbnMucHVzaCh0aGlzLm9ic2VydmFibGUucmVnaXN0ZXIoYmVoYXZpb3Iuc2V0QWx3YXlzT3BlbiwgJ2Fsd2F5c09wZW4nKSk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgXy5lYWNoKHVucmVnaXN0ZXJGdW5jdGlvbnMsIGZ1bmN0aW9uICh1bnJlZ2lzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyLnByb3RvdHlwZS5vcGVuQ2FyZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXy5ldmVyeSh0aGlzLm9ic2VydmFibGUuZmlyZSgnY2xvc2UnKSk7XHJcbiAgICB9O1xyXG4gICAgU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgX19vYnNlcnZhYmxlLmZhY3RvcnlOYW1lXTtcclxuICAgIHJldHVybiBTaW1wbGVDYXJkTGlzdENvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyID0gU2ltcGxlQ2FyZExpc3RDb250cm9sbGVyO1xyXG5mdW5jdGlvbiBzaW1wbGVDYXJkTGlzdCgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdBRScsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zaW1wbGVDYXJkTGlzdCA9IHNpbXBsZUNhcmRMaXN0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGVDYXJkTGlzdC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc2ltcGxlQ2FyZExpc3Qvc2ltcGxlQ2FyZExpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvYm9vdHN0cmFwLXRvdWNoc3Bpbi9ib290c3RyYXAtdG91Y2hzcGluLmQudHMnIC8+XHJcbi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvanF1ZXJ5L2pxdWVyeS5kLnRzJyAvPlxyXG4vLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL2NvbW1vbmpzLmQudHMnIC8+XHJcbid1c2Ugc3RyaWN0JztcclxucmVxdWlyZSgnLi4vLi4vLi4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vaW5kZXgnKTtcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX3N0cmluZyA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5zdHJpbmc7XHJcbnZhciBfX251bWJlciA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5udW1iZXI7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbnZhciBfX2d1aWQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuZ3VpZDtcclxudmFyIHJlcXVpcmVkXzEgPSByZXF1aXJlKCcuLi8uLi9iZWhhdmlvcnMvcmVxdWlyZWQvcmVxdWlyZWQnKTtcclxudmFyIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEgPSByZXF1aXJlKCcuLi8uLi9zZXJ2aWNlcy9jb21wb25lbnRWYWxpZGF0b3IvY29tcG9uZW50VmFsaWRhdG9yLnNlcnZpY2UnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLnVpLmNvbXBvbmVudHMuc3Bpbm5lcic7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFNwaW5uZXInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1NwaW5uZXJDb250cm9sbGVyJztcclxuZXhwb3J0cy5kZWZhdWx0TWF4VmFsdWUgPSAxMDAwMDAwMDAwMDAwMDAwMDAwMDA7XHJcbnZhciBTcGlubmVyQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTcGlubmVyQ29udHJvbGxlcigkc2NvcGUsICRhdHRycywgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKF9fb2JqZWN0Lm9iamVjdFV0aWxpdHkuaXNOdWxsT3JFbXB0eSgkYXR0cnMubmFtZSkpIHtcclxuICAgICAgICAgICAgJGF0dHJzLiRzZXQoJ25hbWUnLCAnc3Bpbm5lci0nICsgX19ndWlkLmd1aWQucmFuZG9tKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdW5yZWdpc3RlciA9ICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubmdNb2RlbDsgfSwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWxpZGF0b3JzID0gW107XHJcbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChfdGhpcy52YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goX3RoaXMudmFsaWRhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMucmVxdWlyZWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmxSZXF1aXJlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICFfX29iamVjdC5vYmplY3RVdGlsaXR5LmlzTnVsbE9yRW1wdHkoX3RoaXMubmdNb2RlbC4kdmlld1ZhbHVlKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IF90aGlzLnJlcXVpcmVkLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXy5zb21lKHZhbGlkYXRvcnMpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zcGlubmVyVmFsaWRhdG9yID0gY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeS5nZXRJbnN0YW5jZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmdNb2RlbDogX3RoaXMubmdNb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGU6ICRzY29wZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW5yZWdpc3RlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgU3Bpbm5lckNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRhdHRycycsIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEuZmFjdG9yeU5hbWVdO1xyXG4gICAgcmV0dXJuIFNwaW5uZXJDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlNwaW5uZXJDb250cm9sbGVyID0gU3Bpbm5lckNvbnRyb2xsZXI7XHJcbnNwaW5uZXIuJGluamVjdCA9IFsnJHRpbWVvdXQnLCBfX3N0cmluZy5zZXJ2aWNlTmFtZSwgX19udW1iZXIuc2VydmljZU5hbWVdO1xyXG5mdW5jdGlvbiBzcGlubmVyKCR0aW1lb3V0LCBzdHJpbmdVdGlsaXR5LCBudW1iZXJVdGlsaXR5KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vc3Bpbm5lci5odG1sJyksXHJcbiAgICAgICAgcmVxdWlyZTogWyduZ01vZGVsJywgJz8nICsgcmVxdWlyZWRfMS5kaXJlY3RpdmVOYW1lXSxcclxuICAgICAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgICAgIGNvbnRyb2xsZXJBczogJ3NwaW5uZXInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIG1pbjogJz0nLFxyXG4gICAgICAgICAgICBtYXg6ICc9JyxcclxuICAgICAgICAgICAgc3RlcDogJz0nLFxyXG4gICAgICAgICAgICBkZWNpbWFsczogJz0nLFxyXG4gICAgICAgICAgICBwcmVmaXg6ICdAJyxcclxuICAgICAgICAgICAgcG9zdGZpeDogJ0AnLFxyXG4gICAgICAgICAgICByb3VuZFRvU3RlcDogJz0nLFxyXG4gICAgICAgICAgICBuZ0Rpc2FibGVkOiAnPScsXHJcbiAgICAgICAgICAgIHNwaW5uZXJJZDogJ0AnLFxyXG4gICAgICAgICAgICBuYW1lOiAnQCcsXHJcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHNwaW5uZXIgPSBzY29wZS5zcGlubmVyO1xyXG4gICAgICAgICAgICB2YXIgbmdNb2RlbCA9IGNvbnRyb2xsZXJzWzBdO1xyXG4gICAgICAgICAgICBzcGlubmVyLnJlcXVpcmVkID0gY29udHJvbGxlcnNbMV07XHJcbiAgICAgICAgICAgIHNwaW5uZXIubmdNb2RlbCA9IG5nTW9kZWw7XHJcbiAgICAgICAgICAgIHZhciB1bmJpbmRXYXRjaGVzO1xyXG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ3NwaW5uZXIubmdEaXNhYmxlZCcsIGZ1bmN0aW9uIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih1bmJpbmRXYXRjaGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRXYXRjaGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3Bpbm5lciBhZnRlciAkdGltZW91dCB0byBnaXZlIGFuZ3VsYXIgYSBjaGFuY2UgaW5pdGlhbGl6ZSBuZ01vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG91Y2hzcGluID0gZWxlbWVudC5maW5kKCdpbnB1dC5zcGlubmVyJykuVG91Y2hTcGluKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogKHNwaW5uZXIubWluICE9IG51bGwgPyBzcGlubmVyLm1pbiA6IDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiAoc3Bpbm5lci5tYXggIT0gbnVsbCA/IHNwaW5uZXIubWF4IDogZXhwb3J0cy5kZWZhdWx0TWF4VmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3Bpbm5lci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBzcGlubmVyLnByZWZpeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RmaXg6IHNwaW5uZXIucG9zdGZpeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBzcGlubmVyLmRlY2ltYWxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdHZhbDogbmdNb2RlbC4kdmlld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VzdGVwZGl2aXNpYmlsaXR5OiBzcGlubmVyLnJvdW5kVG9TdGVwID8gJ3JvdW5kJyA6ICdub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoc3Bpbi5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BpblZhbHVlID0gdG91Y2hzcGluLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZShzdHJpbmdVdGlsaXR5LnRvTnVtYmVyKHNwaW5WYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5iaW5kVmlld1dhdGNoID0gc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZ01vZGVsLiR2aWV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hzcGluLnZhbChuZXdWYWx1ZSAhPSBudWxsID8gbmV3VmFsdWUudG9TdHJpbmcoKSA6ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmJpbmRNb2RlbFdhdGNoID0gc2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZ01vZGVsLiRtb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAobmV3TW9kZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5nTW9kZWwuJG1vZGVsVmFsdWUgPSByb3VuZChuZXdNb2RlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRXYXRjaGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5iaW5kVmlld1dhdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmJpbmRNb2RlbFdhdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiByb3VuZChudW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChudW0gIT0gbnVsbCAmJiBzcGlubmVyLnJvdW5kVG9TdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gbnVtYmVyVXRpbGl0eS5yb3VuZFRvU3RlcChudW0sIHNwaW5uZXIuc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gbnVtYmVyVXRpbGl0eS5wcmVjaXNlUm91bmQobnVtLCBzcGlubmVyLmRlY2ltYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmFuZ3VsYXIubW9kdWxlKGV4cG9ydHMubW9kdWxlTmFtZSwgW19fc3RyaW5nLm1vZHVsZU5hbWUsIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEubW9kdWxlTmFtZSwgX19udW1iZXIubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgc3Bpbm5lcilcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFNwaW5uZXJDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Bpbm5lci5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuXHJcbnJlcXVpcmUoJy4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzJyk7XHJcbnJlcXVpcmUoJy4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4nKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGlicmFyaWVzL2Jvb3RzdHJhcC10b3VjaHNwaW4vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vanF1ZXJ5LmJvb3RzdHJhcC10b3VjaHNwaW4uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYnJhcmllcy9ib290c3RyYXAtdG91Y2hzcGluL2pxdWVyeS5ib290c3RyYXAtdG91Y2hzcGluLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcclxcbiAqICBCb290c3RyYXAgVG91Y2hTcGluIC0gdjMuMC4xXFxyXFxuICogIEEgbW9iaWxlIGFuZCB0b3VjaCBmcmllbmRseSBpbnB1dCBzcGlubmVyIGNvbXBvbmVudCBmb3IgQm9vdHN0cmFwIDMuXFxyXFxuICogIGh0dHA6Ly93d3cudmlydHVvc29mdC5ldS9jb2RlL2Jvb3RzdHJhcC10b3VjaHNwaW4vXFxyXFxuICpcXHJcXG4gKiAgTWFkZSBieSBJc3R2w6FuIFVqai1Nw6lzesOhcm9zXFxyXFxuICogIFVuZGVyIEFwYWNoZSBMaWNlbnNlIHYyLjAgTGljZW5zZVxcclxcbiAqL1xcclxcblxcclxcbi5ib290c3RyYXAtdG91Y2hzcGluIC5pbnB1dC1ncm91cC1idG4tdmVydGljYWwge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG4gIHdpZHRoOiAxJTtcXHJcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxyXFxuICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcclxcbn1cXHJcXG5cXHJcXG4uYm9vdHN0cmFwLXRvdWNoc3BpbiAuaW5wdXQtZ3JvdXAtYnRuLXZlcnRpY2FsID4gLmJ0biB7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIGZsb2F0OiBub25lO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxuICBwYWRkaW5nOiA4cHggMTBweDtcXHJcXG4gIG1hcmdpbi1sZWZ0OiAtMXB4O1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4uYm9vdHN0cmFwLXRvdWNoc3BpbiAuaW5wdXQtZ3JvdXAtYnRuLXZlcnRpY2FsIC5ib290c3RyYXAtdG91Y2hzcGluLXVwIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxyXFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uYm9vdHN0cmFwLXRvdWNoc3BpbiAuaW5wdXQtZ3JvdXAtYnRuLXZlcnRpY2FsIC5ib290c3RyYXAtdG91Y2hzcGluLWRvd24ge1xcclxcbiAgbWFyZ2luLXRvcDogLTJweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxyXFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uYm9vdHN0cmFwLXRvdWNoc3BpbiAuaW5wdXQtZ3JvdXAtYnRuLXZlcnRpY2FsIGkge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgdG9wOiAzcHg7XFxyXFxuICBsZWZ0OiA1cHg7XFxyXFxuICBmb250LXNpemU6IDlweDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxyXFxufVxcclxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9saWJyYXJpZXMvYm9vdHN0cmFwLXRvdWNoc3Bpbi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcbiAqICBCb290c3RyYXAgVG91Y2hTcGluIC0gdjMuMC4xXHJcbiAqICBBIG1vYmlsZSBhbmQgdG91Y2ggZnJpZW5kbHkgaW5wdXQgc3Bpbm5lciBjb21wb25lbnQgZm9yIEJvb3RzdHJhcCAzLlxyXG4gKiAgaHR0cDovL3d3dy52aXJ0dW9zb2Z0LmV1L2NvZGUvYm9vdHN0cmFwLXRvdWNoc3Bpbi9cclxuICpcclxuICogIE1hZGUgYnkgSXN0dsOhbiBVamotTcOpc3rDoXJvc1xyXG4gKiAgVW5kZXIgQXBhY2hlIExpY2Vuc2UgdjIuMCBMaWNlbnNlXHJcbiAqL1xyXG4oZnVuY3Rpb24oJCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIF9jdXJyZW50U3Bpbm5lcklkID0gMDtcclxuXHJcbiAgZnVuY3Rpb24gX3Njb3BlZEV2ZW50TmFtZShuYW1lLCBpZCkge1xyXG4gICAgcmV0dXJuIG5hbWUgKyAnLnRvdWNoc3Bpbl8nICsgaWQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBfc2NvcGVFdmVudE5hbWVzKG5hbWVzLCBpZCkge1xyXG4gICAgcmV0dXJuICQubWFwKG5hbWVzLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgIHJldHVybiBfc2NvcGVkRXZlbnROYW1lKG5hbWUsIGlkKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgJC5mbi5Ub3VjaFNwaW4gPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgPT09ICdkZXN0cm95Jykge1xyXG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsaW5wdXQgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgICBvcmlnaW5hbGlucHV0X2RhdGEgPSBvcmlnaW5hbGlucHV0LmRhdGEoKTtcclxuICAgICAgICAkKGRvY3VtZW50KS5vZmYoX3Njb3BlRXZlbnROYW1lcyhbXHJcbiAgICAgICAgICAnbW91c2V1cCcsXHJcbiAgICAgICAgICAndG91Y2hlbmQnLFxyXG4gICAgICAgICAgJ3RvdWNoY2FuY2VsJyxcclxuICAgICAgICAgICdtb3VzZW1vdmUnLFxyXG4gICAgICAgICAgJ3RvdWNobW92ZScsXHJcbiAgICAgICAgICAnc2Nyb2xsJyxcclxuICAgICAgICAgICdzY3JvbGxzdGFydCddLCBvcmlnaW5hbGlucHV0X2RhdGEuc3Bpbm5lcmlkKS5qb2luKCcgJykpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWZhdWx0cyA9IHtcclxuICAgICAgbWluOiAwLFxyXG4gICAgICBtYXg6IDEwMCxcclxuICAgICAgaW5pdHZhbDogJycsXHJcbiAgICAgIHN0ZXA6IDEsXHJcbiAgICAgIGRlY2ltYWxzOiAwLFxyXG4gICAgICBzdGVwaW50ZXJ2YWw6IDEwMCxcclxuICAgICAgZm9yY2VzdGVwZGl2aXNpYmlsaXR5OiAncm91bmQnLCAvLyBub25lIHwgZmxvb3IgfCByb3VuZCB8IGNlaWxcclxuICAgICAgc3RlcGludGVydmFsZGVsYXk6IDUwMCxcclxuICAgICAgdmVydGljYWxidXR0b25zOiBmYWxzZSxcclxuICAgICAgdmVydGljYWx1cGNsYXNzOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwJyxcclxuICAgICAgdmVydGljYWxkb3duY2xhc3M6ICdnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93bicsXHJcbiAgICAgIHByZWZpeDogJycsXHJcbiAgICAgIHBvc3RmaXg6ICcnLFxyXG4gICAgICBwcmVmaXhfZXh0cmFjbGFzczogJycsXHJcbiAgICAgIHBvc3RmaXhfZXh0cmFjbGFzczogJycsXHJcbiAgICAgIGJvb3N0ZXI6IHRydWUsXHJcbiAgICAgIGJvb3N0YXQ6IDEwLFxyXG4gICAgICBtYXhib29zdGVkc3RlcDogZmFsc2UsXHJcbiAgICAgIG1vdXNld2hlZWw6IHRydWUsXHJcbiAgICAgIGJ1dHRvbmRvd25fY2xhc3M6ICdidG4gYnRuLWRlZmF1bHQnLFxyXG4gICAgICBidXR0b251cF9jbGFzczogJ2J0biBidG4tZGVmYXVsdCcsXHJcblx0ICBidXR0b25kb3duX3R4dDogJy0nLFxyXG5cdCAgYnV0dG9udXBfdHh0OiAnKydcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGF0dHJpYnV0ZU1hcCA9IHtcclxuICAgICAgbWluOiAnbWluJyxcclxuICAgICAgbWF4OiAnbWF4JyxcclxuICAgICAgaW5pdHZhbDogJ2luaXQtdmFsJyxcclxuICAgICAgc3RlcDogJ3N0ZXAnLFxyXG4gICAgICBkZWNpbWFsczogJ2RlY2ltYWxzJyxcclxuICAgICAgc3RlcGludGVydmFsOiAnc3RlcC1pbnRlcnZhbCcsXHJcbiAgICAgIHZlcnRpY2FsYnV0dG9uczogJ3ZlcnRpY2FsLWJ1dHRvbnMnLFxyXG4gICAgICB2ZXJ0aWNhbHVwY2xhc3M6ICd2ZXJ0aWNhbC11cC1jbGFzcycsXHJcbiAgICAgIHZlcnRpY2FsZG93bmNsYXNzOiAndmVydGljYWwtZG93bi1jbGFzcycsXHJcbiAgICAgIGZvcmNlc3RlcGRpdmlzaWJpbGl0eTogJ2ZvcmNlLXN0ZXAtZGl2aXNpYmlsaXR5JyxcclxuICAgICAgc3RlcGludGVydmFsZGVsYXk6ICdzdGVwLWludGVydmFsLWRlbGF5JyxcclxuICAgICAgcHJlZml4OiAncHJlZml4JyxcclxuICAgICAgcG9zdGZpeDogJ3Bvc3RmaXgnLFxyXG4gICAgICBwcmVmaXhfZXh0cmFjbGFzczogJ3ByZWZpeC1leHRyYS1jbGFzcycsXHJcbiAgICAgIHBvc3RmaXhfZXh0cmFjbGFzczogJ3Bvc3RmaXgtZXh0cmEtY2xhc3MnLFxyXG4gICAgICBib29zdGVyOiAnYm9vc3RlcicsXHJcbiAgICAgIGJvb3N0YXQ6ICdib29zdGF0JyxcclxuICAgICAgbWF4Ym9vc3RlZHN0ZXA6ICdtYXgtYm9vc3RlZC1zdGVwJyxcclxuICAgICAgbW91c2V3aGVlbDogJ21vdXNlLXdoZWVsJyxcclxuICAgICAgYnV0dG9uZG93bl9jbGFzczogJ2J1dHRvbi1kb3duLWNsYXNzJyxcclxuICAgICAgYnV0dG9udXBfY2xhc3M6ICdidXR0b24tdXAtY2xhc3MnLFxyXG5cdCAgYnV0dG9uZG93bl90eHQ6ICdidXR0b24tZG93bi10eHQnLFxyXG5cdCAgYnV0dG9udXBfdHh0OiAnYnV0dG9uLXVwLXR4dCdcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciBzZXR0aW5ncyxcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQgPSAkKHRoaXMpLFxyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dF9kYXRhID0gb3JpZ2luYWxpbnB1dC5kYXRhKCksXHJcbiAgICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgICBlbGVtZW50cyxcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgZG93blNwaW5UaW1lcixcclxuICAgICAgICAgIHVwU3BpblRpbWVyLFxyXG4gICAgICAgICAgZG93bkRlbGF5VGltZW91dCxcclxuICAgICAgICAgIHVwRGVsYXlUaW1lb3V0LFxyXG4gICAgICAgICAgc3BpbmNvdW50ID0gMCxcclxuICAgICAgICAgIHNwaW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICBpbml0KCk7XHJcblxyXG5cclxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5kYXRhKCdhbHJlYWR5aW5pdGlhbGl6ZWQnKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5kYXRhKCdhbHJlYWR5aW5pdGlhbGl6ZWQnLCB0cnVlKTtcclxuICAgICAgICBfY3VycmVudFNwaW5uZXJJZCArPSAxO1xyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQuZGF0YSgnc3Bpbm5lcmlkJywgX2N1cnJlbnRTcGlubmVySWQpO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKCFvcmlnaW5hbGlucHV0LmlzKCdpbnB1dCcpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnTXVzdCBiZSBhbiBpbnB1dC4nKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF9pbml0U2V0dGluZ3MoKTtcclxuICAgICAgICBfc2V0SW5pdHZhbCgpO1xyXG4gICAgICAgIF9jaGVja1ZhbHVlKCk7XHJcbiAgICAgICAgX2J1aWxkSHRtbCgpO1xyXG4gICAgICAgIF9pbml0RWxlbWVudHMoKTtcclxuICAgICAgICBfaGlkZUVtcHR5UHJlZml4UG9zdGZpeCgpO1xyXG4gICAgICAgIF9iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgX2JpbmRFdmVudHNJbnRlcmZhY2UoKTtcclxuICAgICAgICBlbGVtZW50cy5pbnB1dC5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX3NldEluaXR2YWwoKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmluaXR2YWwgIT09ICcnICYmIG9yaWdpbmFsaW5wdXQudmFsKCkgPT09ICcnKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnZhbChzZXR0aW5ncy5pbml0dmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNoYW5nZVNldHRpbmdzKG5ld3NldHRpbmdzKSB7XHJcbiAgICAgICAgX3VwZGF0ZVNldHRpbmdzKG5ld3NldHRpbmdzKTtcclxuICAgICAgICBfY2hlY2tWYWx1ZSgpO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSBlbGVtZW50cy5pbnB1dC52YWwoKTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgdmFsdWUgPSBOdW1iZXIoZWxlbWVudHMuaW5wdXQudmFsKCkpO1xyXG4gICAgICAgICAgZWxlbWVudHMuaW5wdXQudmFsKHZhbHVlLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9pbml0U2V0dGluZ3MoKSB7XHJcbiAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9yaWdpbmFsaW5wdXRfZGF0YSwgX3BhcnNlQXR0cmlidXRlcygpLCBvcHRpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX3BhcnNlQXR0cmlidXRlcygpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgICAgICQuZWFjaChhdHRyaWJ1dGVNYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgIHZhciBhdHRyTmFtZSA9ICdidHMtJyArIHZhbHVlICsgJyc7XHJcbiAgICAgICAgICBpZiAob3JpZ2luYWxpbnB1dC5pcygnW2RhdGEtJyArIGF0dHJOYW1lICsgJ10nKSkge1xyXG4gICAgICAgICAgICBkYXRhW2tleV0gPSBvcmlnaW5hbGlucHV0LmRhdGEoYXR0ck5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfdXBkYXRlU2V0dGluZ3MobmV3c2V0dGluZ3MpIHtcclxuICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBzZXR0aW5ncywgbmV3c2V0dGluZ3MpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBfYnVpbGRIdG1sKCkge1xyXG4gICAgICAgIHZhciBpbml0dmFsID0gb3JpZ2luYWxpbnB1dC52YWwoKSxcclxuICAgICAgICAgICAgcGFyZW50ZWxlbWVudCA9IG9yaWdpbmFsaW5wdXQucGFyZW50KCk7XHJcblxyXG4gICAgICAgIGlmIChpbml0dmFsICE9PSAnJykge1xyXG4gICAgICAgICAgaW5pdHZhbCA9IE51bWJlcihpbml0dmFsKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQuZGF0YSgnaW5pdHZhbHVlJywgaW5pdHZhbCkudmFsKGluaXR2YWwpO1xyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xyXG5cclxuICAgICAgICBpZiAocGFyZW50ZWxlbWVudC5oYXNDbGFzcygnaW5wdXQtZ3JvdXAnKSkge1xyXG4gICAgICAgICAgX2FkdmFuY2VJbnB1dEdyb3VwKHBhcmVudGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIF9idWlsZElucHV0R3JvdXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9hZHZhbmNlSW5wdXRHcm91cChwYXJlbnRlbGVtZW50KSB7XHJcbiAgICAgICAgcGFyZW50ZWxlbWVudC5hZGRDbGFzcygnYm9vdHN0cmFwLXRvdWNoc3BpbicpO1xyXG5cclxuICAgICAgICB2YXIgcHJldiA9IG9yaWdpbmFsaW5wdXQucHJldigpLFxyXG4gICAgICAgICAgICBuZXh0ID0gb3JpZ2luYWxpbnB1dC5uZXh0KCk7XHJcblxyXG4gICAgICAgIHZhciBkb3duaHRtbCxcclxuICAgICAgICAgICAgdXBodG1sLFxyXG4gICAgICAgICAgICBwcmVmaXhodG1sID0gJzxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gYm9vdHN0cmFwLXRvdWNoc3Bpbi1wcmVmaXhcIj4nICsgc2V0dGluZ3MucHJlZml4ICsgJzwvc3Bhbj4nLFxyXG4gICAgICAgICAgICBwb3N0Zml4aHRtbCA9ICc8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGJvb3RzdHJhcC10b3VjaHNwaW4tcG9zdGZpeFwiPicgKyBzZXR0aW5ncy5wb3N0Zml4ICsgJzwvc3Bhbj4nO1xyXG5cclxuICAgICAgICBpZiAocHJldi5oYXNDbGFzcygnaW5wdXQtZ3JvdXAtYnRuJykpIHtcclxuICAgICAgICAgIGRvd25odG1sID0gJzxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9uZG93bl9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi1kb3duXCIgdHlwZT1cImJ1dHRvblwiPicgKyBzZXR0aW5ncy5idXR0b25kb3duX3R4dCArICc8L2J1dHRvbj4nO1xyXG4gICAgICAgICAgcHJldi5hcHBlbmQoZG93bmh0bWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGRvd25odG1sID0gJzxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCI+PGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b25kb3duX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLWRvd25cIiB0eXBlPVwiYnV0dG9uXCI+JyArIHNldHRpbmdzLmJ1dHRvbmRvd25fdHh0ICsgJzwvYnV0dG9uPjwvc3Bhbj4nO1xyXG4gICAgICAgICAgJChkb3duaHRtbCkuaW5zZXJ0QmVmb3JlKG9yaWdpbmFsaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5leHQuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwLWJ0bicpKSB7XHJcbiAgICAgICAgICB1cGh0bWwgPSAnPGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b251cF9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi11cFwiIHR5cGU9XCJidXR0b25cIj4nICsgc2V0dGluZ3MuYnV0dG9udXBfdHh0ICsgJzwvYnV0dG9uPic7XHJcbiAgICAgICAgICBuZXh0LnByZXBlbmQodXBodG1sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB1cGh0bWwgPSAnPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj48YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbnVwX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLXVwXCIgdHlwZT1cImJ1dHRvblwiPicgKyBzZXR0aW5ncy5idXR0b251cF90eHQgKyAnPC9idXR0b24+PC9zcGFuPic7XHJcbiAgICAgICAgICAkKHVwaHRtbCkuaW5zZXJ0QWZ0ZXIob3JpZ2luYWxpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkKHByZWZpeGh0bWwpLmluc2VydEJlZm9yZShvcmlnaW5hbGlucHV0KTtcclxuICAgICAgICAkKHBvc3RmaXhodG1sKS5pbnNlcnRBZnRlcihvcmlnaW5hbGlucHV0KTtcclxuXHJcbiAgICAgICAgY29udGFpbmVyID0gcGFyZW50ZWxlbWVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2J1aWxkSW5wdXRHcm91cCgpIHtcclxuICAgICAgICB2YXIgaHRtbDtcclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnZlcnRpY2FsYnV0dG9ucykge1xyXG4gICAgICAgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgYm9vdHN0cmFwLXRvdWNoc3BpblwiPjxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYWRkb24gYm9vdHN0cmFwLXRvdWNoc3Bpbi1wcmVmaXhcIj4nICsgc2V0dGluZ3MucHJlZml4ICsgJzwvc3Bhbj48c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGJvb3RzdHJhcC10b3VjaHNwaW4tcG9zdGZpeFwiPicgKyBzZXR0aW5ncy5wb3N0Zml4ICsgJzwvc3Bhbj48c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWJ0bi12ZXJ0aWNhbFwiPjxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9uZG93bl9jbGFzcyArICcgYm9vdHN0cmFwLXRvdWNoc3Bpbi11cFwiIHR5cGU9XCJidXR0b25cIj48aSBjbGFzcz1cIicgKyBzZXR0aW5ncy52ZXJ0aWNhbHVwY2xhc3MgKyAnXCI+PC9pPjwvYnV0dG9uPjxidXR0b24gY2xhc3M9XCInICsgc2V0dGluZ3MuYnV0dG9udXBfY2xhc3MgKyAnIGJvb3RzdHJhcC10b3VjaHNwaW4tZG93blwiIHR5cGU9XCJidXR0b25cIj48aSBjbGFzcz1cIicgKyBzZXR0aW5ncy52ZXJ0aWNhbGRvd25jbGFzcyArICdcIj48L2k+PC9idXR0b24+PC9zcGFuPjwvZGl2Pic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgYm9vdHN0cmFwLXRvdWNoc3BpblwiPjxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtYnRuXCI+PGJ1dHRvbiBjbGFzcz1cIicgKyBzZXR0aW5ncy5idXR0b25kb3duX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLWRvd25cIiB0eXBlPVwiYnV0dG9uXCI+JyArIHNldHRpbmdzLmJ1dHRvbmRvd25fdHh0ICsgJzwvYnV0dG9uPjwvc3Bhbj48c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLWFkZG9uIGJvb3RzdHJhcC10b3VjaHNwaW4tcHJlZml4XCI+JyArIHNldHRpbmdzLnByZWZpeCArICc8L3NwYW4+PHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBib290c3RyYXAtdG91Y2hzcGluLXBvc3RmaXhcIj4nICsgc2V0dGluZ3MucG9zdGZpeCArICc8L3NwYW4+PHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1idG5cIj48YnV0dG9uIGNsYXNzPVwiJyArIHNldHRpbmdzLmJ1dHRvbnVwX2NsYXNzICsgJyBib290c3RyYXAtdG91Y2hzcGluLXVwXCIgdHlwZT1cImJ1dHRvblwiPicgKyBzZXR0aW5ncy5idXR0b251cF90eHQgKyAnPC9idXR0b24+PC9zcGFuPjwvZGl2Pic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250YWluZXIgPSAkKGh0bWwpLmluc2VydEJlZm9yZShvcmlnaW5hbGlucHV0KTtcclxuXHJcbiAgICAgICAgJCgnLmJvb3RzdHJhcC10b3VjaHNwaW4tcHJlZml4JywgY29udGFpbmVyKS5hZnRlcihvcmlnaW5hbGlucHV0KTtcclxuXHJcbiAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaGFzQ2xhc3MoJ2lucHV0LXNtJykpIHtcclxuICAgICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcygnaW5wdXQtZ3JvdXAtc20nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3JpZ2luYWxpbnB1dC5oYXNDbGFzcygnaW5wdXQtbGcnKSkge1xyXG4gICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKCdpbnB1dC1ncm91cC1sZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gX2luaXRFbGVtZW50cygpIHtcclxuICAgICAgICBlbGVtZW50cyA9IHtcclxuICAgICAgICAgIGRvd246ICQoJy5ib290c3RyYXAtdG91Y2hzcGluLWRvd24nLCBjb250YWluZXIpLFxyXG4gICAgICAgICAgdXA6ICQoJy5ib290c3RyYXAtdG91Y2hzcGluLXVwJywgY29udGFpbmVyKSxcclxuICAgICAgICAgIGlucHV0OiAkKCdpbnB1dCcsIGNvbnRhaW5lciksXHJcbiAgICAgICAgICBwcmVmaXg6ICQoJy5ib290c3RyYXAtdG91Y2hzcGluLXByZWZpeCcsIGNvbnRhaW5lcikuYWRkQ2xhc3Moc2V0dGluZ3MucHJlZml4X2V4dHJhY2xhc3MpLFxyXG4gICAgICAgICAgcG9zdGZpeDogJCgnLmJvb3RzdHJhcC10b3VjaHNwaW4tcG9zdGZpeCcsIGNvbnRhaW5lcikuYWRkQ2xhc3Moc2V0dGluZ3MucG9zdGZpeF9leHRyYWNsYXNzKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9oaWRlRW1wdHlQcmVmaXhQb3N0Zml4KCkge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5wcmVmaXggPT09ICcnKSB7XHJcbiAgICAgICAgICBlbGVtZW50cy5wcmVmaXguaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnBvc3RmaXggPT09ICcnKSB7XHJcbiAgICAgICAgICBlbGVtZW50cy5wb3N0Zml4LmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ2tleWRvd24nLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgdmFyIGNvZGUgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoO1xyXG5cclxuICAgICAgICAgIGlmIChjb2RlID09PSAzOCkge1xyXG4gICAgICAgICAgICBpZiAoc3Bpbm5pbmcgIT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICB1cE9uY2UoKTtcclxuICAgICAgICAgICAgICBzdGFydFVwU3BpbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSA0MCkge1xyXG4gICAgICAgICAgICBpZiAoc3Bpbm5pbmcgIT09ICdkb3duJykge1xyXG4gICAgICAgICAgICAgIGRvd25PbmNlKCk7XHJcbiAgICAgICAgICAgICAgc3RhcnREb3duU3BpbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ2tleXVwJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuXHJcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzgpIHtcclxuICAgICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPT09IDQwKSB7XHJcbiAgICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ2JsdXInLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIF9jaGVja1ZhbHVlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmRvd24ub24oJ2tleWRvd24nLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgdmFyIGNvZGUgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoO1xyXG5cclxuICAgICAgICAgIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSAxMykge1xyXG4gICAgICAgICAgICBpZiAoc3Bpbm5pbmcgIT09ICdkb3duJykge1xyXG4gICAgICAgICAgICAgIGRvd25PbmNlKCk7XHJcbiAgICAgICAgICAgICAgc3RhcnREb3duU3BpbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmRvd24ub24oJ2tleXVwJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIHZhciBjb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuXHJcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gMTMpIHtcclxuICAgICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMudXAub24oJ2tleWRvd24nLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgdmFyIGNvZGUgPSBldi5rZXlDb2RlIHx8IGV2LndoaWNoO1xyXG5cclxuICAgICAgICAgIGlmIChjb2RlID09PSAzMiB8fCBjb2RlID09PSAxMykge1xyXG4gICAgICAgICAgICBpZiAoc3Bpbm5pbmcgIT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICB1cE9uY2UoKTtcclxuICAgICAgICAgICAgICBzdGFydFVwU3BpbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCdrZXl1cCcsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICB2YXIgY29kZSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2g7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmRvd24ub24oJ21vdXNlZG93bi50b3VjaHNwaW4nLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgZWxlbWVudHMuZG93bi5vZmYoJ3RvdWNoc3RhcnQudG91Y2hzcGluJyk7ICAvLyBhbmRyb2lkIDQgd29ya2Fyb3VuZFxyXG5cclxuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCc6ZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZG93bk9uY2UoKTtcclxuICAgICAgICAgIHN0YXJ0RG93blNwaW4oKTtcclxuXHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmRvd24ub24oJ3RvdWNoc3RhcnQudG91Y2hzcGluJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGVsZW1lbnRzLmRvd24ub2ZmKCdtb3VzZWRvd24udG91Y2hzcGluJyk7ICAvLyBhbmRyb2lkIDQgd29ya2Fyb3VuZFxyXG5cclxuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCc6ZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZG93bk9uY2UoKTtcclxuICAgICAgICAgIHN0YXJ0RG93blNwaW4oKTtcclxuXHJcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCdtb3VzZWRvd24udG91Y2hzcGluJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGVsZW1lbnRzLnVwLm9mZigndG91Y2hzdGFydC50b3VjaHNwaW4nKTsgIC8vIGFuZHJvaWQgNCB3b3JrYXJvdW5kXHJcblxyXG4gICAgICAgICAgaWYgKG9yaWdpbmFsaW5wdXQuaXMoJzpkaXNhYmxlZCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB1cE9uY2UoKTtcclxuICAgICAgICAgIHN0YXJ0VXBTcGluKCk7XHJcblxyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy51cC5vbigndG91Y2hzdGFydC50b3VjaHNwaW4nLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgZWxlbWVudHMudXAub2ZmKCdtb3VzZWRvd24udG91Y2hzcGluJyk7ICAvLyBhbmRyb2lkIDQgd29ya2Fyb3VuZFxyXG5cclxuICAgICAgICAgIGlmIChvcmlnaW5hbGlucHV0LmlzKCc6ZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdXBPbmNlKCk7XHJcbiAgICAgICAgICBzdGFydFVwU3BpbigpO1xyXG5cclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMudXAub24oJ21vdXNlb3V0IHRvdWNobGVhdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbihldikge1xyXG4gICAgICAgICAgaWYgKCFzcGlubmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBlbGVtZW50cy5kb3duLm9uKCdtb3VzZW91dCB0b3VjaGxlYXZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGlmICghc3Bpbm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZWxlbWVudHMuZG93bi5vbignbW91c2Vtb3ZlIHRvdWNobW92ZScsIGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICBpZiAoIXNwaW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLnVwLm9uKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGlmICghc3Bpbm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJChkb2N1bWVudCkub24oX3Njb3BlRXZlbnROYW1lcyhbJ21vdXNldXAnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnXSwgX2N1cnJlbnRTcGlubmVySWQpLmpvaW4oJyAnKSwgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGlmICghc3Bpbm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAkKGRvY3VtZW50KS5vbihfc2NvcGVFdmVudE5hbWVzKFsnbW91c2Vtb3ZlJywgJ3RvdWNobW92ZScsICdzY3JvbGwnLCAnc2Nyb2xsc3RhcnQnXSwgX2N1cnJlbnRTcGlubmVySWQpLmpvaW4oJyAnKSwgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGlmICghc3Bpbm5pbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCdtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsJywgZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgIGlmICghc2V0dGluZ3MubW91c2V3aGVlbCB8fCAhb3JpZ2luYWxpbnB1dC5pcygnOmZvY3VzJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBkZWx0YSA9IGV2Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSB8fCAtZXYub3JpZ2luYWxFdmVudC5kZWx0YVkgfHwgLWV2Lm9yaWdpbmFsRXZlbnQuZGV0YWlsO1xyXG5cclxuICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgIGRvd25PbmNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXBPbmNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9iaW5kRXZlbnRzSW50ZXJmYWNlKCkge1xyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi51cG9uY2UnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgICB1cE9uY2UoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLmRvd25vbmNlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzdG9wU3BpbigpO1xyXG4gICAgICAgICAgZG93bk9uY2UoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC5vbigndG91Y2hzcGluLnN0YXJ0dXBzcGluJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzdGFydFVwU3BpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCd0b3VjaHNwaW4uc3RhcnRkb3duc3BpbicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc3RhcnREb3duU3BpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0Lm9uKCd0b3VjaHNwaW4uc3RvcHNwaW4nLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG9yaWdpbmFsaW5wdXQub24oJ3RvdWNoc3Bpbi51cGRhdGVzZXR0aW5ncycsIGZ1bmN0aW9uKGUsIG5ld3NldHRpbmdzKSB7XHJcbiAgICAgICAgICBjaGFuZ2VTZXR0aW5ncyhuZXdzZXR0aW5ncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9mb3JjZXN0ZXBkaXZpc2liaWxpdHkodmFsdWUpIHtcclxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmZvcmNlc3RlcGRpdmlzaWJpbGl0eSkge1xyXG4gICAgICAgICAgY2FzZSAncm91bmQnOlxyXG4gICAgICAgICAgICByZXR1cm4gKE1hdGgucm91bmQodmFsdWUgLyBzZXR0aW5ncy5zdGVwKSAqIHNldHRpbmdzLnN0ZXApLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpO1xyXG4gICAgICAgICAgY2FzZSAnZmxvb3InOlxyXG4gICAgICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IodmFsdWUgLyBzZXR0aW5ncy5zdGVwKSAqIHNldHRpbmdzLnN0ZXApLnRvRml4ZWQoc2V0dGluZ3MuZGVjaW1hbHMpO1xyXG4gICAgICAgICAgY2FzZSAnY2VpbCc6XHJcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5jZWlsKHZhbHVlIC8gc2V0dGluZ3Muc3RlcCkgKiBzZXR0aW5ncy5zdGVwKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9jaGVja1ZhbHVlKCkge1xyXG4gICAgICAgIHZhciB2YWwsIHBhcnNlZHZhbCwgcmV0dXJudmFsO1xyXG5cclxuICAgICAgICB2YWwgPSBvcmlnaW5hbGlucHV0LnZhbCgpO1xyXG5cclxuICAgICAgICBpZiAodmFsID09PSAnJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxzID4gMCAmJiB2YWwgPT09ICcuJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkdmFsID0gcGFyc2VGbG9hdCh2YWwpO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4ocGFyc2VkdmFsKSkge1xyXG4gICAgICAgICAgcGFyc2VkdmFsID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybnZhbCA9IHBhcnNlZHZhbDtcclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZHZhbC50b1N0cmluZygpICE9PSB2YWwpIHtcclxuICAgICAgICAgIHJldHVybnZhbCA9IHBhcnNlZHZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWR2YWwgPCBzZXR0aW5ncy5taW4pIHtcclxuICAgICAgICAgIHJldHVybnZhbCA9IHNldHRpbmdzLm1pbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWR2YWwgPiBzZXR0aW5ncy5tYXgpIHtcclxuICAgICAgICAgIHJldHVybnZhbCA9IHNldHRpbmdzLm1heDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybnZhbCA9IF9mb3JjZXN0ZXBkaXZpc2liaWxpdHkocmV0dXJudmFsKTtcclxuXHJcbiAgICAgICAgaWYgKE51bWJlcih2YWwpLnRvU3RyaW5nKCkgIT09IHJldHVybnZhbC50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnZhbChyZXR1cm52YWwpO1xyXG4gICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIF9nZXRCb29zdGVkU3RlcCgpIHtcclxuICAgICAgICBpZiAoIXNldHRpbmdzLmJvb3N0ZXIpIHtcclxuICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5zdGVwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhciBib29zdGVkID0gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihzcGluY291bnQgLyBzZXR0aW5ncy5ib29zdGF0KSkgKiBzZXR0aW5ncy5zdGVwO1xyXG5cclxuICAgICAgICAgIGlmIChzZXR0aW5ncy5tYXhib29zdGVkc3RlcCkge1xyXG4gICAgICAgICAgICBpZiAoYm9vc3RlZCA+IHNldHRpbmdzLm1heGJvb3N0ZWRzdGVwKSB7XHJcbiAgICAgICAgICAgICAgYm9vc3RlZCA9IHNldHRpbmdzLm1heGJvb3N0ZWRzdGVwO1xyXG4gICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCgodmFsdWUgLyBib29zdGVkKSkgKiBib29zdGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHNldHRpbmdzLnN0ZXAsIGJvb3N0ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gdXBPbmNlKCkge1xyXG4gICAgICAgIF9jaGVja1ZhbHVlKCk7XHJcblxyXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdChlbGVtZW50cy5pbnB1dC52YWwoKSk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGluaXR2YWx1ZSA9IHZhbHVlLFxyXG4gICAgICAgICAgICBib29zdGVkc3RlcCA9IF9nZXRCb29zdGVkU3RlcCgpO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlICsgYm9vc3RlZHN0ZXA7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA+IHNldHRpbmdzLm1heCkge1xyXG4gICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5tYXg7XHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5tYXgnKTtcclxuICAgICAgICAgIHN0b3BTcGluKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbGVtZW50cy5pbnB1dC52YWwoTnVtYmVyKHZhbHVlKS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKSk7XHJcblxyXG4gICAgICAgIGlmIChpbml0dmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gZG93bk9uY2UoKSB7XHJcbiAgICAgICAgX2NoZWNrVmFsdWUoKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KGVsZW1lbnRzLmlucHV0LnZhbCgpKTtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW5pdHZhbHVlID0gdmFsdWUsXHJcbiAgICAgICAgICAgIGJvb3N0ZWRzdGVwID0gX2dldEJvb3N0ZWRTdGVwKCk7XHJcblxyXG4gICAgICAgIHZhbHVlID0gdmFsdWUgLSBib29zdGVkc3RlcDtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlIDwgc2V0dGluZ3MubWluKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLm1pbjtcclxuICAgICAgICAgIG9yaWdpbmFsaW5wdXQudHJpZ2dlcigndG91Y2hzcGluLm9uLm1pbicpO1xyXG4gICAgICAgICAgc3RvcFNwaW4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsZW1lbnRzLmlucHV0LnZhbCh2YWx1ZS50b0ZpeGVkKHNldHRpbmdzLmRlY2ltYWxzKSk7XHJcblxyXG4gICAgICAgIGlmIChpbml0dmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3RhcnREb3duU3BpbigpIHtcclxuICAgICAgICBzdG9wU3BpbigpO1xyXG5cclxuICAgICAgICBzcGluY291bnQgPSAwO1xyXG4gICAgICAgIHNwaW5uaW5nID0gJ2Rvd24nO1xyXG5cclxuICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdGFydHNwaW4nKTtcclxuICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdGFydGRvd25zcGluJyk7XHJcblxyXG4gICAgICAgIGRvd25EZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgZG93blNwaW5UaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBzcGluY291bnQrKztcclxuICAgICAgICAgICAgZG93bk9uY2UoKTtcclxuICAgICAgICAgIH0sIHNldHRpbmdzLnN0ZXBpbnRlcnZhbCk7XHJcbiAgICAgICAgfSwgc2V0dGluZ3Muc3RlcGludGVydmFsZGVsYXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdGFydFVwU3BpbigpIHtcclxuICAgICAgICBzdG9wU3BpbigpO1xyXG5cclxuICAgICAgICBzcGluY291bnQgPSAwO1xyXG4gICAgICAgIHNwaW5uaW5nID0gJ3VwJztcclxuXHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RhcnRzcGluJyk7XHJcbiAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RhcnR1cHNwaW4nKTtcclxuXHJcbiAgICAgICAgdXBEZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdXBTcGluVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgc3BpbmNvdW50Kys7XHJcbiAgICAgICAgICAgIHVwT25jZSgpO1xyXG4gICAgICAgICAgfSwgc2V0dGluZ3Muc3RlcGludGVydmFsKTtcclxuICAgICAgICB9LCBzZXR0aW5ncy5zdGVwaW50ZXJ2YWxkZWxheSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN0b3BTcGluKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChkb3duRGVsYXlUaW1lb3V0KTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodXBEZWxheVRpbWVvdXQpO1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZG93blNwaW5UaW1lcik7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh1cFNwaW5UaW1lcik7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoc3Bpbm5pbmcpIHtcclxuICAgICAgICAgIGNhc2UgJ3VwJzpcclxuICAgICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RvcHVwc3BpbicpO1xyXG4gICAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdG9wc3BpbicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2Rvd24nOlxyXG4gICAgICAgICAgICBvcmlnaW5hbGlucHV0LnRyaWdnZXIoJ3RvdWNoc3Bpbi5vbi5zdG9wZG93bnNwaW4nKTtcclxuICAgICAgICAgICAgb3JpZ2luYWxpbnB1dC50cmlnZ2VyKCd0b3VjaHNwaW4ub24uc3RvcHNwaW4nKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcGluY291bnQgPSAwO1xyXG4gICAgICAgIHNwaW5uaW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcbiAgfTtcclxuXHJcbn0pKGpRdWVyeSk7XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWJyYXJpZXMvYm9vdHN0cmFwLXRvdWNoc3Bpbi9qcXVlcnkuYm9vdHN0cmFwLXRvdWNoc3Bpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxybC1nZW5lcmljLWNvbnRhaW5lciBzZWxlY3Rvcj1cXFwic3Bpbm5lci5uZ0Rpc2FibGVkXFxcIj5cXHJcXG5cXHQ8dGVtcGxhdGUgZGVmYXVsdD5cXHJcXG5cXHRcXHQ8ZGl2IG5nLWNsYXNzPVxcXCJ7ICdlcnJvcic6IHNwaW5uZXIubmdNb2RlbC4kaW52YWxpZCB9XFxcIj5cXHJcXG5cXHRcXHRcXHQ8aW5wdXQgbmFtZT1cXFwie3tzcGlubmVyLm5hbWV9fVxcXCIgY2xhc3M9XFxcInNwaW5uZXJcXFwiIGlkPVxcXCJ7e3NwaW5uZXIuc3Bpbm5lcklkfX1cXFwiIHR5cGU9XFxcInRleHRcXFwiIC8+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImVycm9yLXN0cmluZ1xcXCIgbmctaGlkZT1cXFwic3Bpbm5lci5zcGlubmVyVmFsaWRhdG9yLmVycm9yIHwgaXNFbXB0eVxcXCI+e3tzcGlubmVyLnNwaW5uZXJWYWxpZGF0b3IuZXJyb3J9fTwvc3Bhbj5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3RlbXBsYXRlPlxcclxcblxcdDx0ZW1wbGF0ZSB3aGVuLXNlbGVjdG9yPVxcXCJ0cnVlXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCIgbmctc2hvdz1cXFwic3Bpbm5lci5wcmVmaXggIT0gbnVsbCAmJiBzcGlubmVyLnBvc3RmaXggIT0gbnVsbFxcXCI+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj57e3NwaW5uZXIucHJlZml4fX08L3NwYW4+XFxyXFxuXFx0XFx0XFx0PGlucHV0IGRpc2FibGVkPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic3Bpbm5lci5uZ01vZGVsLiR2aWV3VmFsdWVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIC8+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj57e3NwaW5uZXIucG9zdGZpeH19PC9zcGFuPlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIiBuZy1zaG93PVxcXCJzcGlubmVyLnByZWZpeCAhPSBudWxsICYmIHNwaW5uZXIucG9zdGZpeCA9PSBudWxsXFxcIj5cXHJcXG5cXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwiaW5wdXQtZ3JvdXAtYWRkb25cXFwiPnt7c3Bpbm5lci5wcmVmaXh9fTwvc3Bhbj5cXHJcXG5cXHRcXHRcXHQ8aW5wdXQgZGlzYWJsZWQ9XFxcInRydWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJzcGlubmVyLm5nTW9kZWwuJHZpZXdWYWx1ZVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgLz5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1ncm91cFxcXCIgbmctc2hvdz1cXFwic3Bpbm5lci5wcmVmaXggPT0gbnVsbCAmJiBzcGlubmVyLnBvc3RmaXggIT0gbnVsbFxcXCI+XFxyXFxuXFx0XFx0XFx0PGlucHV0IGRpc2FibGVkPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic3Bpbm5lci5uZ01vZGVsLiR2aWV3VmFsdWVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIC8+XFxyXFxuXFx0XFx0XFx0PHNwYW4gY2xhc3M9XFxcImlucHV0LWdyb3VwLWFkZG9uXFxcIj57e3NwaW5uZXIucG9zdGZpeH19PC9zcGFuPlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWdyb3VwXFxcIiBuZy1zaG93PVxcXCJzcGlubmVyLnByZWZpeCA9PSBudWxsICYmIHNwaW5uZXIucG9zdGZpeCA9PSBudWxsXFxcIj5cXHJcXG5cXHRcXHRcXHQ8aW5wdXQgZGlzYWJsZWQ9XFxcInRydWVcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJzcGlubmVyLm5nTW9kZWwuJHZpZXdWYWx1ZVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgLz5cXHJcXG5cXHRcXHQ8L2Rpdj5cXHJcXG5cXHQ8L3RlbXBsYXRlPlxcclxcbjwvcmwtZ2VuZXJpYy1jb250YWluZXI+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcclxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX29iamVjdCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5vYmplY3Q7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnN0cmluZ1dpdGhXYXRlcm1hcmsnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxTdHJpbmdXaXRoV2F0ZXJtYXJrJztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlcic7XHJcbnZhciBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlcigkc2NvcGUsIG9iamVjdFV0aWxpdHkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RyaW5nOyB9LCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFzU3RyaW5nID0gb2JqZWN0VXRpbGl0eS5pc051bGxPckVtcHR5KHZhbHVlKSA9PT0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCBfX29iamVjdC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuU3RyaW5nV2l0aFdhdGVybWFya0NvbnRyb2xsZXIgPSBTdHJpbmdXaXRoV2F0ZXJtYXJrQ29udHJvbGxlcjtcclxuZnVuY3Rpb24gc3RyaW5nV2l0aFdhdGVybWFyaygpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8c3Bhbj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBuZy1zaG93PVxcXCJjb250cm9sbGVyLmhhc1N0cmluZ1xcXCI+e3tjb250cm9sbGVyLnN0cmluZ319PC9zcGFuPlxcblxcdFxcdFxcdFxcdDxzcGFuIG5nLWhpZGU9XFxcImNvbnRyb2xsZXIuaGFzU3RyaW5nXFxcIiBjbGFzcz1cXFwid2F0ZXJtYXJrXFxcIj57e2NvbnRyb2xsZXIud2F0ZXJtYXJrfX08L3NwYW4+XFxuXFx0XFx0XFx0PC9zcGFuPlxcblxcdFxcdFwiLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnY29udHJvbGxlcicsXHJcbiAgICAgICAgc2NvcGU6IHt9LFxyXG4gICAgICAgIGJpbmRUb0NvbnRyb2xsZXI6IHtcclxuICAgICAgICAgICAgc3RyaW5nOiAnQCcsXHJcbiAgICAgICAgICAgIHdhdGVybWFyazogJ0AnLFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5zdHJpbmdXaXRoV2F0ZXJtYXJrID0gc3RyaW5nV2l0aFdhdGVybWFyaztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19vYmplY3QubW9kdWxlTmFtZV0pXHJcbiAgICAuZGlyZWN0aXZlKGV4cG9ydHMuZGlyZWN0aXZlTmFtZSwgc3RyaW5nV2l0aFdhdGVybWFyaylcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFN0cmluZ1dpdGhXYXRlcm1hcmtDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nV2l0aFdhdGVybWFyay5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvc3RyaW5nV2l0aFdhdGVybWFyay9zdHJpbmdXaXRoV2F0ZXJtYXJrLmpzXG4gKiogbW9kdWxlIGlkID0gMTgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgdGFiXzEgPSByZXF1aXJlKCcuL3RhYicpO1xyXG5leHBvcnRzLnRhYkRpcmVjdGl2ZU5hbWUgPSB0YWJfMS5kaXJlY3RpdmVOYW1lO1xyXG5leHBvcnRzLnRhYiA9IHRhYl8xLnRhYjtcclxuZXhwb3J0cy50YWJDb250cm9sbGVyTmFtZSA9IHRhYl8xLmNvbnRyb2xsZXJOYW1lO1xyXG5leHBvcnRzLlRhYkNvbnRyb2xsZXIgPSB0YWJfMS5UYWJDb250cm9sbGVyO1xyXG52YXIgdGFic2V0XzEgPSByZXF1aXJlKCcuL3RhYnNldCcpO1xyXG5leHBvcnRzLnRhYnNldERpcmVjdGl2ZU5hbWUgPSB0YWJzZXRfMS5kaXJlY3RpdmVOYW1lO1xyXG5leHBvcnRzLnRhYnNldCA9IHRhYnNldF8xLnRhYnNldDtcclxuZXhwb3J0cy50YWJzZXRDb250cm9sbGVyTmFtZSA9IHRhYnNldF8xLmNvbnRyb2xsZXJOYW1lO1xyXG5leHBvcnRzLlRhYnNldENvbnRyb2xsZXIgPSB0YWJzZXRfMS5UYWJzZXRDb250cm9sbGVyO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy50YWJzJztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5kaXJlY3RpdmUodGFiXzEuZGlyZWN0aXZlTmFtZSwgdGFiXzEudGFiKVxyXG4gICAgLmNvbnRyb2xsZXIodGFiXzEuY29udHJvbGxlck5hbWUsIHRhYl8xLlRhYkNvbnRyb2xsZXIpXHJcbiAgICAuZGlyZWN0aXZlKHRhYnNldF8xLmRpcmVjdGl2ZU5hbWUsIHRhYnNldF8xLnRhYnNldClcclxuICAgIC5jb250cm9sbGVyKHRhYnNldF8xLmNvbnRyb2xsZXJOYW1lLCB0YWJzZXRfMS5UYWJzZXRDb250cm9sbGVyKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFicy5tb2R1bGUuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3RhYnMvdGFicy5tb2R1bGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxUYWInO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ3JsVGFiQ29udHJvbGxlcic7XHJcbnZhciBUYWJDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhYkNvbnRyb2xsZXIoJHNjb3BlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAkc2NvcGUuJHdhdGNoKCd0YWJGb3JtLiR2YWxpZCcsIGZ1bmN0aW9uIChpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhlYWRlci5pc1ZhbGlkID0gaXNWYWxpZCAhPSBudWxsID8gaXNWYWxpZCA6IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBUYWJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRzY29wZSddO1xyXG4gICAgcmV0dXJuIFRhYkNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVGFiQ29udHJvbGxlciA9IFRhYkNvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHRhYigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB7XHJcbiAgICAgICAgICAgICdoZWFkZXJTbG90JzogJz9ybFRhYkhlYWRlcicsXHJcbiAgICAgICAgICAgICdjb250ZW50U2xvdCc6ICc/cmxUYWJDb250ZW50JyxcclxuICAgICAgICAgICAgJ2Zvb3RlclNsb3QnOiAnP3JsVGFiRm9vdGVyJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlcXVpcmU6IFsnXl5ybFRhYnNldCcsICdybFRhYiddLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RhYi5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICd0YWInLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7fSxcclxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250cm9sbGVycywgdHJhbnNjbHVkZSkge1xyXG4gICAgICAgICAgICB0cmFuc2NsdWRlKGZ1bmN0aW9uIChoZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWJzZXQgPSBjb250cm9sbGVyc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciB0YWIgPSBjb250cm9sbGVyc1sxXTtcclxuICAgICAgICAgICAgICAgIHRhYi5oZWFkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGhlYWRlci5odG1sKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0YWJzZXQucmVnaXN0ZXJUYWIoZWxlbWVudCwgdGFiLmhlYWRlcik7XHJcbiAgICAgICAgICAgIH0sIG51bGwsICdoZWFkZXJTbG90Jyk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy50YWIgPSB0YWI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYi5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvdGFicy90YWIuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJ0YWItcGFuZVxcXCIgbmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IHRhYi5oZWFkZXIuaXNWaXNpYmxlIH1cXFwiPlxcclxcblxcdDxkaXYgY2xhc3M9XFxcInRhYi1ib2R5XFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IG5nLXRyYW5zY2x1ZGU9XFxcImNvbnRlbnRTbG90XFxcIiBuZy1mb3JtPVxcXCJ0YWJGb3JtXFxcIj48L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwidGFiLWZvb3RlclxcXCI+XFxyXFxuXFx0XFx0PGRpdiBuZy10cmFuc2NsdWRlPVxcXCJmb290ZXJTbG90XFxcIj48L2Rpdj5cXHJcXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjbGVhcmZpeFxcXCI+PC9kaXY+XFxyXFxuXFx0PC9kaXY+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvdGFicy90YWIuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEgPSByZXF1aXJlKCd0eXBlc2NyaXB0LWFuZ3VsYXItdXRpbGl0aWVzJyk7XHJcbnZhciBfX2FycmF5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxUYWJzZXQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ3JsVGFic2V0Q29udHJvbGxlcic7XHJcbnZhciBUYWJzZXRDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhYnNldENvbnRyb2xsZXIoKSB7XHJcbiAgICAgICAgdGhpcy50YWJIZWFkZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBUYWJzZXRDb250cm9sbGVyLnByb3RvdHlwZS5yZWdpc3RlclRhYiA9IGZ1bmN0aW9uIChlbGVtZW50LCBoZWFkZXIpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmZpbmRQb3NpdGlvbihlbGVtZW50KTtcclxuICAgICAgICBpZiAoX19hcnJheS5hcnJheVV0aWxpdHkuaGFzKHRoaXMudGFiSGVhZGVycywgaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGhlYWRlci5pc1Zpc2libGUgPSB0aGlzLnRhYkhlYWRlcnNbaW5kZXhdLmlzVmlzaWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYWRlci5pc1Zpc2libGUgPSAoaW5kZXggPT09IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRhYkhlYWRlcnNbaW5kZXhdID0gaGVhZGVyO1xyXG4gICAgfTtcclxuICAgIFRhYnNldENvbnRyb2xsZXIucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICh0YWIpIHtcclxuICAgICAgICBfLmVhY2godGhpcy50YWJIZWFkZXJzLCBmdW5jdGlvbiAob3RoZXJUYWIpIHtcclxuICAgICAgICAgICAgb3RoZXJUYWIuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGFiLmlzVmlzaWJsZSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRhYnNldENvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVGFic2V0Q29udHJvbGxlciA9IFRhYnNldENvbnRyb2xsZXI7XHJcbmZ1bmN0aW9uIHRhYnNldCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVzdHJpY3Q6ICdFJyxcclxuICAgICAgICB0cmFuc2NsdWRlOiB0cnVlLFxyXG4gICAgICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RhYnNldC5odG1sJyksXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICd0YWJzZXQnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBsaW5rOiB7XHJcbiAgICAgICAgICAgIHByZTogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdGFic2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0YWJzZXQuZmluZFBvc2l0aW9uID0gZnVuY3Rpb24gKHRhYkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgYnkgaXRlcmF0aW5nIG92ZXIgdGhlIHRhYnMgYW5kIGZpbmRpbmcgYSBtYXRjaGluZyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYnMgPSBlbGVtZW50LmZpbmQoJ3JsLXRhYicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW07XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHRhYnMsIGZ1bmN0aW9uIChlbGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFiRWxlbWVudFswXSA9PT0gZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnRhYnNldCA9IHRhYnNldDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2V0LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90YWJzL3RhYnNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcIm5hdi10YWJzLWRyb3BzaGFkb3dcXFwiPlxcclxcblxcdDx1bCBjbGFzcz1cXFwibmF2IG5hdi10YWJzXFxcIj5cXHJcXG5cXHRcXHQ8bGkgbmctcmVwZWF0PVxcXCJ0YWJIZWFkZXIgaW4gdGFic2V0LnRhYkhlYWRlcnNcXFwiIG5nLWNsaWNrPVxcXCJ0YWJzZXQuc2VsZWN0KHRhYkhlYWRlcilcXFwiXFxyXFxuXFx0XFx0XFx0bmctY2xhc3M9XFxcInsgJ2FjdGl2ZSc6IHRhYkhlYWRlci5pc1Zpc2libGUsICdlcnJvcic6ICF0YWJIZWFkZXIuaXNWYWxpZCB9XFxcIj5cXHJcXG5cXHRcXHRcXHQ8YT48c3BhbiBuZy1iaW5kLWh0bWw9XFxcInRhYkhlYWRlci50ZW1wbGF0ZVxcXCI+PC9zcGFuPjwvYT5cXHJcXG5cXHRcXHQ8L2xpPlxcclxcblxcdDwvdWw+XFxyXFxuXFx0PGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnRcXFwiPlxcclxcblxcdFxcdDxkaXYgbmctdHJhbnNjbHVkZT48L2Rpdj5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90YWJzL3RhYnNldC5odG1sXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAvLy8gPHJlZmVyZW5jZSBwYXRoPScuLi8uLi8uLi90eXBpbmdzL25vZGUvbm9kZS5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy50ZW1wbGF0ZVJlbmRlcmVyJztcclxuZXhwb3J0cy5jb21wb25lbnROYW1lID0gJ3JsVGVtcGxhdGVSZW5kZXJlcic7XHJcbmV4cG9ydHMuY29udHJvbGxlck5hbWUgPSAnVGVtcGxhdGVSZW5kZXJlckNvbnRyb2xsZXInO1xyXG52YXIgVGVtcGxhdGVSZW5kZXJlckNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVSZW5kZXJlckNvbnRyb2xsZXIoJGNvbXBpbGUsICRlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9ICRlbGVtZW50LmZpbmQoJy50ZW1wbGF0ZS10YXJnZXQnKTtcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0YXJnZXQuYXBwZW5kKHRoaXMudGVtcGxhdGUudGVtcGxhdGUpO1xyXG4gICAgICAgICRjb21waWxlKHRlbXBsYXRlKSh0aGlzLnRlbXBsYXRlLnNjb3BlKTtcclxuICAgIH1cclxuICAgIFRlbXBsYXRlUmVuZGVyZXJDb250cm9sbGVyLiRpbmplY3QgPSBbJyRjb21waWxlJywgJyRlbGVtZW50J107XHJcbiAgICByZXR1cm4gVGVtcGxhdGVSZW5kZXJlckNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVGVtcGxhdGVSZW5kZXJlckNvbnRyb2xsZXIgPSBUZW1wbGF0ZVJlbmRlcmVyQ29udHJvbGxlcjtcclxudmFyIHRlbXBsYXRlUmVuZGVyZXIgPSB7XHJcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0ZW1wbGF0ZS10YXJnZXRcIj48L2Rpdj4nLFxyXG4gICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgIGNvbnRyb2xsZXJBczogJ2NvbnRyb2xsZXInLFxyXG4gICAgYmluZGluZ3M6IHtcclxuICAgICAgICB0ZW1wbGF0ZTogJzwnLFxyXG4gICAgfSxcclxufTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXSlcclxuICAgIC5jb21wb25lbnQoZXhwb3J0cy5jb21wb25lbnROYW1lLCB0ZW1wbGF0ZVJlbmRlcmVyKVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgVGVtcGxhdGVSZW5kZXJlckNvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZVJlbmRlcmVyLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90ZW1wbGF0ZVJlbmRlcmVyL3RlbXBsYXRlUmVuZGVyZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIC8vLyA8cmVmZXJlbmNlIHBhdGg9Jy4uLy4uLy4uL3R5cGluZ3MvY29tbW9uanMuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIGlucHV0XzEgPSByZXF1aXJlKCcuLi9pbnB1dC9pbnB1dCcpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy50ZXh0YXJlYSc7XHJcbmV4cG9ydHMuY29tcG9uZW50TmFtZSA9ICdybFRleHRhcmVhJztcclxudmFyIHRleHRhcmVhID0gXy5jbG9uZShpbnB1dF8xLmlucHV0KTtcclxudGV4dGFyZWEudGVtcGxhdGUgPSByZXF1aXJlKCcuL3RleHRhcmVhLmh0bWwnKTtcclxudmFyIHRleHRhcmVhQmluZGluZ3MgPSB0ZXh0YXJlYS5iaW5kaW5ncztcclxudGV4dGFyZWFCaW5kaW5ncy5yb3dzID0gJzw/JztcclxudGV4dGFyZWFCaW5kaW5ncy5uZ0Rpc2FibGVkID0gJzw/JztcclxudGV4dGFyZWFCaW5kaW5ncy5tYXhsZW5ndGggPSAnPD8nO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtpbnB1dF8xLm1vZHVsZU5hbWVdKVxyXG4gICAgLmNvbXBvbmVudChleHBvcnRzLmNvbXBvbmVudE5hbWUsIHRleHRhcmVhKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dGFyZWEuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3RleHRhcmVhL3RleHRhcmVhLmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiIG5nLWNsYXNzPVxcXCJ7ICdlcnJvcic6IGlucHV0Lm5nTW9kZWwuJGludmFsaWQgfVxcXCI+XFxyXFxuXFx0PGxhYmVsIG5nLXNob3c9XFxcImlucHV0LmlucHV0VmFsdWUgJiYgaW5wdXQubGFiZWxcXFwiIGNsYXNzPVxcXCJzaG93LWhpZGUgYW5ndWxhci1hbmltYXRlXFxcIj57e2lucHV0LmxhYmVsfX08L2xhYmVsPlxcclxcblxcdDx0ZXh0YXJlYSBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiaW5wdXQuaW5wdXRWYWx1ZVxcXCIgcm93cz1cXFwie3tpbnB1dC5yb3dzfX1cXFwiIG1heGxlbmd0aD1cXFwie3tpbnB1dC5tYXhsZW5ndGh9fVxcXCIgbmctZGlzYWJsZWQ9XFxcImlucHV0Lm5nRGlzYWJsZWRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7e2lucHV0LmxhYmVsfX1cXFwiPjwvdGV4dGFyZWE+XFxyXFxuXFx0PHNwYW4gY2xhc3M9XFxcImVycm9yLXN0cmluZ1xcXCIgbmctaGlkZT1cXFwiaW5wdXQuaW5wdXRWYWxpZGF0b3IuZXJyb3IgfCBpc0VtcHR5XFxcIj57e2lucHV0LmlucHV0VmFsaWRhdG9yLmVycm9yfX08L3NwYW4+XFxyXFxuPC9kaXY+XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL2NvbXBvbmVudHMvdGV4dGFyZWEvdGV4dGFyZWEuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgaW5wdXRfMSA9IHJlcXVpcmUoJy4uL2lucHV0L2lucHV0Jyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnRleHRib3gnO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxUZXh0Ym94JztcclxudmFyIHRleHRib3ggPSBfLmNsb25lKGlucHV0XzEuaW5wdXQpO1xyXG50ZXh0Ym94LnRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZXh0Ym94Lmh0bWwnKTtcclxudmFyIHRleHRib3hCaW5kaW5ncyA9IHRleHRib3guYmluZGluZ3M7XHJcbnRleHRib3hCaW5kaW5ncy5tYXhsZW5ndGggPSAnPD8nO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtpbnB1dF8xLm1vZHVsZU5hbWVdKVxyXG4gICAgLmNvbXBvbmVudChleHBvcnRzLmNvbXBvbmVudE5hbWUsIHRleHRib3gpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0Ym94LmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0Ym94L3RleHRib3guanNcbiAqKiBtb2R1bGUgaWQgPSAxODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCIgbmctY2xhc3M9XFxcInsgJ2Vycm9yJzogaW5wdXQubmdNb2RlbC4kaW52YWxpZCB9XFxcIj5cXHJcXG5cXHQ8bGFiZWwgbmctc2hvdz1cXFwiaW5wdXQuaW5wdXRWYWx1ZSAmJiBpbnB1dC5sYWJlbFxcXCIgY2xhc3M9XFxcInNob3ctaGlkZSBhbmd1bGFyLWFuaW1hdGVcXFwiPnt7aW5wdXQubGFiZWx9fTwvbGFiZWw+XFxyXFxuXFx0PGlucHV0ICB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGFuZ3VsYXItYW5pbWF0ZVxcXCIgbmctbW9kZWw9XFxcImlucHV0LmlucHV0VmFsdWVcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7e2lucHV0LmxhYmVsfX1cXFwiIG1heGxlbmd0aD1cXFwie3tpbnB1dC5tYXhsZW5ndGh9fVxcXCIgLz5cXHJcXG5cXHQ8c3BhbiBjbGFzcz1cXFwiZXJyb3Itc3RyaW5nXFxcIiBuZy1oaWRlPVxcXCJpbnB1dC5pbnB1dFZhbGlkYXRvci5lcnJvciB8IGlzRW1wdHlcXFwiPnt7aW5wdXQuaW5wdXRWYWxpZGF0b3IuZXJyb3J9fTwvc3Bhbj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90ZXh0Ym94L3RleHRib3guaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcGFyZW50Q2hpbGQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucGFyZW50Q2hpbGRCZWhhdmlvcjtcclxudmFyIF9fZ2VuZXJpY1NlYXJjaCA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy5nZW5lcmljU2VhcmNoRmlsdGVyO1xyXG52YXIgX19vYmplY3RVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLm9iamVjdDtcclxudmFyIF9fYXJyYXlVdGlsaXR5ID0gdHlwZXNjcmlwdF9hbmd1bGFyX3V0aWxpdGllc18xLnNlcnZpY2VzLmFycmF5O1xyXG52YXIgX190cmFuc2Zvcm0gPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMudHJhbnNmb3JtLnRyYW5zZm9ybTtcclxudmFyIGlucHV0XzEgPSByZXF1aXJlKCcuLi9pbnB1dC9pbnB1dCcpO1xyXG52YXIgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2NvbXBvbmVudFZhbGlkYXRvci9jb21wb25lbnRWYWxpZGF0b3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy50eXBlYWhlYWQnO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxUeXBlYWhlYWQnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1R5cGVhaGVhZENvbnRyb2xsZXInO1xyXG52YXIgVHlwZWFoZWFkQ29udHJvbGxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVHlwZWFoZWFkQ29udHJvbGxlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFR5cGVhaGVhZENvbnRyb2xsZXIoJHNjb3BlLCAkcSwgJGF0dHJzLCAkdGltZW91dCwgcGFyZW50Q2hpbGQsIGdlbmVyaWNTZWFyY2hGYWN0b3J5LCBvYmplY3QsIGFycmF5LCBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5KSB7XHJcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJHNjb3BlLCAkYXR0cnMsIGNvbXBvbmVudFZhbGlkYXRvckZhY3RvcnkpO1xyXG4gICAgICAgIHRoaXMuJHEgPSAkcTtcclxuICAgICAgICB0aGlzLiR0aW1lb3V0ID0gJHRpbWVvdXQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRDaGlsZCA9IHBhcmVudENoaWxkO1xyXG4gICAgICAgIHRoaXMuZ2VuZXJpY1NlYXJjaEZhY3RvcnkgPSBnZW5lcmljU2VhcmNoRmFjdG9yeTtcclxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhhc1NlYXJjaE9wdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NlYXJjaE9wdGlvbiA9IHtcclxuICAgICAgICAgICAgX19pc1NlYXJjaE9wdGlvbjogdHJ1ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5wdXRUeXBlID0gJ3R5cGVhaGVhZCc7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUsIFwic2VsZWN0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmdNb2RlbC4kdmlld1ZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fX2lzU2VhcmNoT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNyZWF0ZSh7IHZhbHVlOiB2YWx1ZS50ZXh0IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoeyB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xsYXBzZU9uU2VsZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmdNb2RlbC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuJG9uSW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoRmlsdGVyID0gdGhpcy5nZW5lcmljU2VhcmNoRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZERlbGF5ID0gdGhpcy51c2VDbGllbnRTZWFyY2hpbmcgPyAxMDAgOiA1MDA7XHJcbiAgICAgICAgdGhpcy5wcmVmaXggPSB0aGlzLnByZWZpeCB8fCAnU2VhcmNoIGZvcic7XHJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHRoaXMubGFiZWwgIT0gbnVsbCA/IHRoaXMucHJlZml4ICsgJyAnICsgdGhpcy5sYWJlbC50b0xvd2VyQ2FzZSgpIDogJ1NlYXJjaCc7XHJcbiAgICAgICAgdmFyICRhdHRycyA9IHRoaXMuJGF0dHJzO1xyXG4gICAgICAgIHRoaXMuY29sbGFwc2VPblNlbGVjdCA9IHRoaXMuYWxsb3dDb2xsYXBzZSB8fCB0aGlzLm9iamVjdC5pc051bGxPckVtcHR5KCRhdHRycy5zZWxlY3QpO1xyXG4gICAgICAgIHRoaXMuYWxsb3dDdXN0b21PcHRpb24gPSAhdGhpcy5vYmplY3QuaXNOdWxsT3JFbXB0eSgkYXR0cnMuY3JlYXRlKTtcclxuICAgICAgICB0aGlzLiR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbGxhcHNlT25TZWxlY3QgJiYgIV90aGlzLm9iamVjdC5pc051bGxPckVtcHR5KF90aGlzLm5nTW9kZWwuJHZpZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvbGxhcHNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkLnJlZ2lzdGVyQ2hpbGRCZWhhdmlvcih0aGlzLmNoaWxkTGluaywge1xyXG4gICAgICAgICAgICBhZGQ6IHRoaXMuYWRkSXRlbS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICByZW1vdmU6IHRoaXMucmVtb3ZlSXRlbS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5uZ01vZGVsLiR2aWV3VmFsdWU7IH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBfdGhpcy5jb2xsYXBzZU9uU2VsZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2xsYXBzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmIChpdGVtICE9IG51bGwgJiYgaXRlbS5fX2lzU2VhcmNoT3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfX3RyYW5zZm9ybS5nZXRWYWx1ZShpdGVtLCB0aGlzLnRyYW5zZm9ybSk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChzZWFyY2gpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLm9iamVjdC5pc051bGxPckVtcHR5KHNlYXJjaCkpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlSXRlbXMgPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEl0ZW1zKHNlYXJjaCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMuX3NlYXJjaE9wdGlvbi50ZXh0ID0gc2VhcmNoO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2hvd0N1c3RvbVNlYXJjaChzZWFyY2gpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYXNTZWFyY2hPcHRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmlzaWJsZUl0ZW1zLnVuc2hpZnQoX3RoaXMuX3NlYXJjaE9wdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUeXBlYWhlYWRDb250cm9sbGVyLnByb3RvdHlwZS5sb2FkSXRlbXMgPSBmdW5jdGlvbiAoc2VhcmNoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMudXNlQ2xpZW50U2VhcmNoaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRxLndoZW4odGhpcy5nZXRJdGVtcyh7XHJcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHNlYXJjaCxcclxuICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52aXNpYmxlSXRlbXMgPSBpdGVtcztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEZpbHRlci5zZWFyY2hUZXh0ID0gc2VhcmNoO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZWRJdGVtcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2libGVJdGVtcyA9IHRoaXMuZmlsdGVyKHRoaXMuY2FjaGVkSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEud2hlbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHEud2hlbih0aGlzLmdldEl0ZW1zKCkpLnRoZW4oZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FjaGVkSXRlbXMgPSBpdGVtcztcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aXNpYmxlSXRlbXMgPSBfdGhpcy5maWx0ZXIoaXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5uZ01vZGVsLiRzZXRWaWV3VmFsdWUobnVsbCk7XHJcbiAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBUeXBlYWhlYWRDb250cm9sbGVyLnByb3RvdHlwZS5zaG93Q3VzdG9tU2VhcmNoID0gZnVuY3Rpb24gKHNlYXJjaCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb3dDdXN0b21PcHRpb25cclxuICAgICAgICAgICAgJiYgIXRoaXMuaGFzU2VhcmNoT3B0aW9uXHJcbiAgICAgICAgICAgICYmICFfLmZpbmQodGhpcy52aXNpYmxlSXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0RGlzcGxheU5hbWUoaXRlbSkgPT09IHNlYXJjaDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGxpc3QpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfLmZpbHRlcihsaXN0LCBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gX3RoaXMuc2VhcmNoRmlsdGVyLmZpbHRlcihpdGVtKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkQ29udHJvbGxlci5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkSXRlbXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlZEl0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFR5cGVhaGVhZENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlZEl0ZW1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5hcnJheS5yZW1vdmUodGhpcy5jYWNoZWRJdGVtcywgaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFR5cGVhaGVhZENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJyxcclxuICAgICAgICAnJHEnLFxyXG4gICAgICAgICckYXR0cnMnLFxyXG4gICAgICAgICckdGltZW91dCcsXHJcbiAgICAgICAgX19wYXJlbnRDaGlsZC5zZXJ2aWNlTmFtZSxcclxuICAgICAgICBfX2dlbmVyaWNTZWFyY2guZmFjdG9yeU5hbWUsXHJcbiAgICAgICAgX19vYmplY3RVdGlsaXR5LnNlcnZpY2VOYW1lLFxyXG4gICAgICAgIF9fYXJyYXlVdGlsaXR5LnNlcnZpY2VOYW1lLFxyXG4gICAgICAgIGNvbXBvbmVudFZhbGlkYXRvcl9zZXJ2aWNlXzEuZmFjdG9yeU5hbWVdO1xyXG4gICAgcmV0dXJuIFR5cGVhaGVhZENvbnRyb2xsZXI7XHJcbn0oaW5wdXRfMS5JbnB1dENvbnRyb2xsZXIpKTtcclxuZXhwb3J0cy5UeXBlYWhlYWRDb250cm9sbGVyID0gVHlwZWFoZWFkQ29udHJvbGxlcjtcclxudmFyIHR5cGVhaGVhZCA9IF8uY2xvbmUoaW5wdXRfMS5pbnB1dCk7XHJcbnR5cGVhaGVhZC50ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdHlwZWFoZWFkLmh0bWwnKTtcclxudHlwZWFoZWFkLmNvbnRyb2xsZXIgPSBleHBvcnRzLmNvbnRyb2xsZXJOYW1lO1xyXG50eXBlYWhlYWQuY29udHJvbGxlckFzID0gJ3R5cGVhaGVhZCc7XHJcbnZhciB0eXBlYWhlYWRCaW5kaW5ncyA9IHR5cGVhaGVhZC5iaW5kaW5ncztcclxudHlwZWFoZWFkQmluZGluZ3MuY2hpbGRMaW5rID0gJz0/JztcclxudHlwZWFoZWFkQmluZGluZ3Muc2VsZWN0ID0gJyYnO1xyXG50eXBlYWhlYWRCaW5kaW5ncy5jcmVhdGUgPSAnJic7XHJcbnR5cGVhaGVhZEJpbmRpbmdzLmFsbG93Q29sbGFwc2UgPSAnPD8nO1xyXG50eXBlYWhlYWRCaW5kaW5ncy50cmFuc2Zvcm0gPSAnPD8nO1xyXG50eXBlYWhlYWRCaW5kaW5ncy5nZXRJdGVtcyA9ICcmJztcclxudHlwZWFoZWFkQmluZGluZ3MucHJlZml4ID0gJ0AnO1xyXG50eXBlYWhlYWRCaW5kaW5ncy51c2VDbGllbnRTZWFyY2hpbmcgPSAnPD8nO1xyXG50eXBlYWhlYWRCaW5kaW5ncy5uZ0Rpc2FibGVkID0gJzw/JztcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbXHJcbiAgICBfX3BhcmVudENoaWxkLm1vZHVsZU5hbWUsXHJcbiAgICBfX2dlbmVyaWNTZWFyY2gubW9kdWxlTmFtZSxcclxuICAgIF9fb2JqZWN0VXRpbGl0eS5tb2R1bGVOYW1lLFxyXG4gICAgX19hcnJheVV0aWxpdHkubW9kdWxlTmFtZSxcclxuICAgIGlucHV0XzEubW9kdWxlTmFtZVxyXG5dKVxyXG4gICAgLmNvbXBvbmVudChleHBvcnRzLmNvbXBvbmVudE5hbWUsIHR5cGVhaGVhZClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFR5cGVhaGVhZENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlYWhlYWQuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCIgbmctY2xhc3M9XFxcInsgJ2hhcy1lcnJvcic6IHR5cGVhaGVhZC5uZ01vZGVsLiRpbnZhbGlkIH1cXFwiPlxcclxcblxcdDxsYWJlbCBuZy1zaG93PVxcXCJ0eXBlYWhlYWQuc2VsZWN0aW9uXFxcIiBjbGFzcz1cXFwic2hvdy1oaWRlIGFuZ3VsYXItYW5pbWF0ZVxcXCI+XFxyXFxuXFx0XFx0e3t0eXBlYWhlYWQubGFiZWx9fVxcclxcblxcdDwvbGFiZWw+XFxyXFxuXFx0PGRpdiBuZy1pZj1cXFwiIXR5cGVhaGVhZC5jb2xsYXBzZWRcXFwiPlxcclxcblxcdFxcdDx1aS1zZWxlY3QgbmctbW9kZWw9XFxcInR5cGVhaGVhZC5zZWxlY3Rpb25cXFwiIHRoZW1lPVxcXCJib290c3RyYXBcXFwiIG5nLWRpc2FibGVkPVxcXCJ0eXBlYWhlYWQubmdEaXNhYmxlZFxcXCI+XFxyXFxuXFx0XFx0XFx0PHVpLXNlbGVjdC1tYXRjaCBwbGFjZWhvbGRlcj1cXFwie3t0eXBlYWhlYWQucGxhY2Vob2xkZXJ9fVxcXCI+e3t0eXBlYWhlYWQuZ2V0RGlzcGxheU5hbWUoJHNlbGVjdC5zZWxlY3RlZCl9fTwvdWktc2VsZWN0LW1hdGNoPlxcclxcblxcdFxcdFxcdDx1aS1zZWxlY3QtY2hvaWNlcyByZXBlYXQ9XFxcIml0ZW0gaW4gdHlwZWFoZWFkLnZpc2libGVJdGVtc1xcXCJcXHJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZWZyZXNoPVxcXCJ0eXBlYWhlYWQucmVmcmVzaCgkc2VsZWN0LnNlYXJjaClcXFwiXFxyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVmcmVzaC1kZWxheT1cXFwidHlwZWFoZWFkLmxvYWREZWxheVxcXCI+XFxyXFxuXFx0XFx0XFx0XFx0e3t0eXBlYWhlYWQuZ2V0RGlzcGxheU5hbWUoaXRlbSl9fVxcclxcblxcdFxcdFxcdDwvdWktc2VsZWN0LWNob2ljZXM+XFxyXFxuXFx0XFx0PC91aS1zZWxlY3Q+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBuZy1pZj1cXFwidHlwZWFoZWFkLmNvbGxhcHNlZFxcXCI+XFxyXFxuXFx0XFx0PHNwYW4+e3t0eXBlYWhlYWQuZ2V0RGlzcGxheU5hbWUodHlwZWFoZWFkLnNlbGVjdGlvbil9fTwvc3Bhbj5cXHJcXG5cXHRcXHQ8cmwtYnV0dG9uIHR5cGU9XFxcImRlZmF1bHQgZmxhdFxcXCIgYWN0aW9uPVxcXCJ0eXBlYWhlYWQuY2xlYXIoKVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPjwvcmwtYnV0dG9uPlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxzcGFuIGNsYXNzPVxcXCJlcnJvci1zdHJpbmdcXFwiIG5nLXNob3c9XFxcInR5cGVhaGVhZC5pbnB1dFZhbGlkYXRvci5lcnJvclxcXCI+e3t0eXBlYWhlYWQuaW5wdXRWYWxpZGF0b3IuZXJyb3J9fTwvc3Bhbj5cXHJcXG5cXHQ8cmwtYnVzeSBsb2FkaW5nPVxcXCJ0eXBlYWhlYWQubG9hZGluZ1xcXCI+PC9ybC1idXN5PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9ub2RlL25vZGUuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMSA9IHJlcXVpcmUoJ3R5cGVzY3JpcHQtYW5ndWxhci11dGlsaXRpZXMnKTtcclxudmFyIF9fcGFyZW50Q2hpbGQgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMucGFyZW50Q2hpbGRCZWhhdmlvcjtcclxudmFyIF9fYXJyYXkgPSB0eXBlc2NyaXB0X2FuZ3VsYXJfdXRpbGl0aWVzXzEuc2VydmljZXMuYXJyYXk7XHJcbnZhciBfX3RyYW5zZm9ybSA9IHR5cGVzY3JpcHRfYW5ndWxhcl91dGlsaXRpZXNfMS5zZXJ2aWNlcy50cmFuc2Zvcm0udHJhbnNmb3JtO1xyXG52YXIgdHlwZWFoZWFkSXRlbV8xID0gcmVxdWlyZSgnLi90eXBlYWhlYWRJdGVtJyk7XHJcbmV4cG9ydHMubW9kdWxlTmFtZSA9ICdybC51aS5jb21wb25lbnRzLnR5cGVhaGVhZExpc3QnO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxUeXBlYWhlYWRMaXN0JztcclxuZXhwb3J0cy5jb250cm9sbGVyTmFtZSA9ICdUeXBlYWhlYWRMaXN0Q29udHJvbGxlcic7XHJcbnZhciBUeXBlYWhlYWRMaXN0Q29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUeXBlYWhlYWRMaXN0Q29udHJvbGxlcigkc2NvcGUsICRlbGVtZW50LCAkdHJhbnNjbHVkZSwgcGFyZW50Q2hpbGQpIHtcclxuICAgICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcclxuICAgICAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy4kdHJhbnNjbHVkZSA9ICR0cmFuc2NsdWRlO1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQgPSBwYXJlbnRDaGlsZDtcclxuICAgIH1cclxuICAgIFR5cGVhaGVhZExpc3RDb250cm9sbGVyLnByb3RvdHlwZS4kb25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUuJHJlbW92ZSA9IHRoaXMucmVtb3ZlSXRlbS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlLiR0cmFuc2Zvcm0gPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX190cmFuc2Zvcm0uZ2V0VmFsdWUoaXRlbSwgX3RoaXMudHJhbnNmb3JtKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQucmVnaXN0ZXJDaGlsZEJlaGF2aW9yKHRoaXMuY2hpbGRMaW5rLCB7XHJcbiAgICAgICAgICAgIGFkZDogdGhpcy5hZGRJdGVtLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIHJlbW92ZTogdGhpcy5yZW1vdmVJdGVtLmJpbmQodGhpcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkTGlzdENvbnRyb2xsZXIucHJvdG90eXBlLmxvYWRJdGVtcyA9IGZ1bmN0aW9uIChzZWFyY2gpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZW1zKHsgc2VhcmNoOiBzZWFyY2ggfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5maWx0ZXIoZGF0YSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhXy5maW5kKF90aGlzLm5nTW9kZWwuJHZpZXdWYWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFR5cGVhaGVhZExpc3RDb250cm9sbGVyLnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLm5nTW9kZWwuJHZpZXdWYWx1ZS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIHRoaXMucGFyZW50Q2hpbGQudHJpZ2dlckNoaWxkQmVoYXZpb3IodGhpcy50eXBlYWhlYWRMaW5rLCBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgYmVoYXZpb3IucmVtb3ZlKGl0ZW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWRkKHsgaXRlbTogaXRlbSB9KTtcclxuICAgIH07XHJcbiAgICBUeXBlYWhlYWRMaXN0Q29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgX19hcnJheS5hcnJheVV0aWxpdHkucmVtb3ZlKHRoaXMubmdNb2RlbC4kdmlld1ZhbHVlLCBpdGVtKTtcclxuICAgICAgICB0aGlzLnBhcmVudENoaWxkLnRyaWdnZXJDaGlsZEJlaGF2aW9yKHRoaXMudHlwZWFoZWFkTGluaywgZnVuY3Rpb24gKGJlaGF2aW9yKSB7XHJcbiAgICAgICAgICAgIGJlaGF2aW9yLmFkZChpdGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlbW92ZSh7IGl0ZW06IGl0ZW0gfSk7XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkTGlzdENvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyR0cmFuc2NsdWRlJywgX19wYXJlbnRDaGlsZC5zZXJ2aWNlTmFtZV07XHJcbiAgICByZXR1cm4gVHlwZWFoZWFkTGlzdENvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVHlwZWFoZWFkTGlzdENvbnRyb2xsZXIgPSBUeXBlYWhlYWRMaXN0Q29udHJvbGxlcjtcclxudmFyIHR5cGVhaGVhZExpc3QgPSB7XHJcbiAgICByZXF1aXJlOiB7IG5nTW9kZWw6ICduZ01vZGVsJyB9LFxyXG4gICAgdHJhbnNjbHVkZToge1xyXG4gICAgICAgIGhlYWRlclNsb3Q6ICc/cmxMaXN0SGVhZGVyJyxcclxuICAgICAgICBsaXN0SXRlbVNsb3Q6ICc/cmxMaXN0SXRlbScsXHJcbiAgICB9LFxyXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vdHlwZWFoZWFkTGlzdC5odG1sJyksXHJcbiAgICBjb250cm9sbGVyOiBleHBvcnRzLmNvbnRyb2xsZXJOYW1lLFxyXG4gICAgY29udHJvbGxlckFzOiAnbGlzdCcsXHJcbiAgICBiaW5kaW5nczoge1xyXG4gICAgICAgIGdldEl0ZW1zOiAnJicsXHJcbiAgICAgICAgYWRkOiAnJicsXHJcbiAgICAgICAgcmVtb3ZlOiAnJicsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAnPD8nLFxyXG4gICAgICAgIGxhYmVsOiAnQCcsXHJcbiAgICAgICAgcHJlZml4OiAnQCcsXHJcbiAgICAgICAgdXNlQ2xpZW50U2VhcmNoaW5nOiAnPD8nLFxyXG4gICAgICAgIG5nRGlzYWJsZWQ6ICc8PycsXHJcbiAgICAgICAgaXRlbUFzOiAnQCcsXHJcbiAgICAgICAgY2hpbGRMaW5rOiAnPT8nLFxyXG4gICAgfSxcclxufTtcclxuYW5ndWxhci5tb2R1bGUoZXhwb3J0cy5tb2R1bGVOYW1lLCBbX19wYXJlbnRDaGlsZC5tb2R1bGVOYW1lXSlcclxuICAgIC5jb21wb25lbnQoZXhwb3J0cy5jb21wb25lbnROYW1lLCB0eXBlYWhlYWRMaXN0KVxyXG4gICAgLmNvbnRyb2xsZXIoZXhwb3J0cy5jb250cm9sbGVyTmFtZSwgVHlwZWFoZWFkTGlzdENvbnRyb2xsZXIpXHJcbiAgICAuY29tcG9uZW50KHR5cGVhaGVhZEl0ZW1fMS5jb21wb25lbnROYW1lLCB0eXBlYWhlYWRJdGVtXzEudHlwZWFoZWFkSXRlbSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVhaGVhZExpc3QuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZExpc3QvdHlwZWFoZWFkTGlzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9ub2RlL25vZGUuZC50cycgLz5cclxuJ3VzZSBzdHJpY3QnO1xyXG5leHBvcnRzLmNvbXBvbmVudE5hbWUgPSAncmxUeXBlYWhlYWRMaXN0SXRlbSc7XHJcbnZhciBUeXBlYWhlYWRJdGVtQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUeXBlYWhlYWRJdGVtQ29udHJvbGxlcigkc2NvcGUsICRlbGVtZW50LCAkY29tcGlsZSkge1xyXG4gICAgICAgIHRoaXMuJHNjb3BlID0gJHNjb3BlO1xyXG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcclxuICAgICAgICB0aGlzLiRjb21waWxlID0gJGNvbXBpbGU7XHJcbiAgICB9XHJcbiAgICBUeXBlYWhlYWRJdGVtQ29udHJvbGxlci5wcm90b3R5cGUuJG9uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXRlbVNjb3BlID0gdGhpcy4kc2NvcGUuJHBhcmVudC4kbmV3KCk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRBcmVhID0gdGhpcy4kZWxlbWVudC5maW5kKCcuY29udGVudC10YXJnZXQnKTtcclxuICAgICAgICBpZiAodGhpcy50cmFuc2NsdWRlLmlzU2xvdEZpbGxlZCgnbGlzdEl0ZW1TbG90JykpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2NsdWRlKGl0ZW1TY29wZSwgZnVuY3Rpb24gKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50QXJlYS5hcHBlbmQodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB9LCBudWxsLCAnbGlzdEl0ZW1TbG90Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBjb250ZW50QXJlYS5hcHBlbmQocmVxdWlyZSgnLi9kZWZhdWx0TGlzdEl0ZW0uaHRtbCcpKTtcclxuICAgICAgICAgICAgdGhpcy4kY29tcGlsZSh0ZW1wbGF0ZSkoaXRlbVNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVHlwZWFoZWFkSXRlbUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRjb21waWxlJ107XHJcbiAgICByZXR1cm4gVHlwZWFoZWFkSXRlbUNvbnRyb2xsZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMudHlwZWFoZWFkSXRlbSA9IHtcclxuICAgIGJpbmRpbmdzOiB7XHJcbiAgICAgICAgdHJhbnNjbHVkZTogJzwnLFxyXG4gICAgfSxcclxuICAgIGNvbnRyb2xsZXI6IFR5cGVhaGVhZEl0ZW1Db250cm9sbGVyLFxyXG4gICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwiY29udGVudC10YXJnZXRcXFwiPjwvZGl2PlwiLFxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlYWhlYWRJdGVtLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWRMaXN0L3R5cGVhaGVhZEl0ZW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJjb2wteHMtMTBcXFwiPnt7JHRyYW5zZm9ybSgkaXRlbSl9fTwvZGl2PlxcclxcbjxkaXYgY2xhc3M9XFxcImNvbC14cy0yXFxcIj5cXHJcXG5cXHQ8cmwtYnV0dG9uIHR5cGU9XFxcImRhbmdlclxcXCIgYWN0aW9uPVxcXCIkcmVtb3ZlKCRpdGVtKVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXJlbW92ZVxcXCI+PC9pPjwvcmwtYnV0dG9uPlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3R5cGVhaGVhZExpc3QvZGVmYXVsdExpc3RJdGVtLmh0bWxcbiAqKiBtb2R1bGUgaWQgPSAxOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8cmwtdHlwZWFoZWFkIG5nLW1vZGVsPVxcXCJsaXN0Lm1vZGVsXFxcIiBzZWxlY3Q9XFxcImxpc3QuYWRkSXRlbSh2YWx1ZSlcXFwiIGFsbG93LWNvbGxhcHNlPVxcXCJmYWxzZVxcXCJcXHJcXG5cXHRcXHRcXHQgIHRyYW5zZm9ybT1cXFwibGlzdC50cmFuc2Zvcm1cXFwiIGdldC1pdGVtcz1cXFwibGlzdC5sb2FkSXRlbXMoc2VhcmNoKVxcXCIgbGFiZWw9XFxcInt7bGlzdC5sYWJlbH19XFxcIlxcclxcblxcdFxcdFxcdCAgcHJlZml4PVxcXCJ7e2xpc3QucHJlZml4fX1cXFwiIHVzZS1jbGllbnQtc2VhcmNoaW5nPVxcXCJsaXN0LnVzZUNsaWVudFNlYXJjaGluZ1xcXCIgbmctZGlzYWJsZWQ9XFxcImxpc3QubmdEaXNhYmxlZFxcXCI+PC9ybC10eXBlYWhlYWQ+XFxyXFxuPGRpdiBjbGFzcz1cXFwidGFibGUtY29udGFpbmVyXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJyb3cgdGFibGUtaGVhZGVyXFxcIj5cXHJcXG5cXHRcXHQ8ZGl2IG5nLXRyYW5zY2x1ZGU9XFxcImhlYWRlclNsb3RcXFwiPlxcclxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbC14cy0xMlxcXCI+TmFtZTwvZGl2PlxcclxcblxcdFxcdDwvZGl2PlxcclxcblxcdDwvZGl2PlxcclxcblxcdDxkaXYgY2xhc3M9XFxcInJvdyB0YWJsZS1yb3dcXFwiIG5nLXJlcGVhdD1cXFwiJGl0ZW0gaW4gbGlzdC5uZ01vZGVsLiR2aWV3VmFsdWVcXFwiIHJsLWFsaWFzPVxcXCIkaXRlbSBhcyB7e2xpc3QuaXRlbUFzfX1cXFwiPlxcclxcblxcdFxcdDxybC10eXBlYWhlYWQtbGlzdC1pdGVtIHRyYW5zY2x1ZGU9XFxcImxpc3QuJHRyYW5zY2x1ZGVcXFwiPjwvcmwtdHlwZWFoZWFkLWxpc3QtaXRlbT5cXHJcXG5cXHQ8L2Rpdj5cXHJcXG48L2Rpdj5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvY29tcG9uZW50cy90eXBlYWhlYWRMaXN0L3R5cGVhaGVhZExpc3QuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuZXhwb3J0cy5tb2R1bGVOYW1lID0gJ3JsLmNvbXBvbmVudHMudXNlclJhdGluZyc7XHJcbmV4cG9ydHMuZGlyZWN0aXZlTmFtZSA9ICdybFVzZXJSYXRpbmcnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1VzZXJSYXRpbmdDb250cm9sbGVyJztcclxudmFyIFVzZXJSYXRpbmdDb250cm9sbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVzZXJSYXRpbmdDb250cm9sbGVyKCRzY29wZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy4kc2NvcGUgPSAkc2NvcGU7XHJcbiAgICAgICAgdGhpcy5zdGFycyA9IFtdO1xyXG4gICAgICAgIHZhciByYW5nZVNpemUgPSB0aGlzLiRzY29wZS5yYW5nZSAhPSBudWxsID8gdGhpcy4kc2NvcGUucmFuZ2UgOiA1O1xyXG4gICAgICAgIC8vIGNzcyBzdHlsZSByZXF1aXJlcyB0aGUgc3RhcnMgdG8gc2hvdyByaWdodCB0byBsZWZ0LiBSZXZlcnNlIHRoZSBsaXN0IHNvIHRoZSBoaWdoZXN0IHZhbHVlIGlzIGZpcnN0XHJcbiAgICAgICAgdmFyIHJhbmdlID0gXy5yYW5nZSgxLCByYW5nZVNpemUgKyAxKS5yZXZlcnNlKCk7XHJcbiAgICAgICAgXy5lYWNoKHJhbmdlLCBmdW5jdGlvbiAocmF0aW5nKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJhdGluZyxcclxuICAgICAgICAgICAgICAgIGZpbGxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciB1bmJpbmQgPSB0aGlzLiRzY29wZS4kd2F0Y2goJ25nTW9kZWwnLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlU3RhclZpZXcoX3RoaXMuJHNjb3BlLm5nTW9kZWwuJHZpZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIHVuYmluZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgVXNlclJhdGluZ0NvbnRyb2xsZXIucHJvdG90eXBlLnNldFJhdGluZyA9IGZ1bmN0aW9uIChyYXRpbmcpIHtcclxuICAgICAgICB0aGlzLiRzY29wZS5uZ01vZGVsLiRzZXRWaWV3VmFsdWUocmF0aW5nKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXJWaWV3KHJhdGluZyk7XHJcbiAgICB9O1xyXG4gICAgVXNlclJhdGluZ0NvbnRyb2xsZXIucHJvdG90eXBlLnVwZGF0ZVN0YXJWaWV3ID0gZnVuY3Rpb24gKHJhdGluZykge1xyXG4gICAgICAgIF8uZWFjaCh0aGlzLnN0YXJzLCBmdW5jdGlvbiAoc3Rhcikge1xyXG4gICAgICAgICAgICBpZiAoc3Rhci52YWx1ZSA8PSByYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHN0YXIuZmlsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXIuZmlsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBVc2VyUmF0aW5nQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnXTtcclxuICAgIHJldHVybiBVc2VyUmF0aW5nQ29udHJvbGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Vc2VyUmF0aW5nQ29udHJvbGxlciA9IFVzZXJSYXRpbmdDb250cm9sbGVyO1xyXG5mdW5jdGlvbiB1c2VyUmF0aW5nKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcclxuICAgICAgICB0ZW1wbGF0ZTogXCJcXG5cXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwicmF0aW5nXFxcIj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwic3RhclxcXCIgbmctcmVwZWF0PVxcXCJzdGFyIGluIHVzZXJSYXRpbmcuc3RhcnNcXFwiIG5nLWNsYXNzPVxcXCJ7ICdmaWxsZWQnOiBzdGFyLmZpbGxlZCB9XFxcIiBuZy1jbGljaz1cXFwidXNlclJhdGluZy5zZXRSYXRpbmcoc3Rhci52YWx1ZSlcXFwiPjwvc3Bhbj5cXG5cXHRcXHRcXHQ8L3NwYW4+XFxuXFx0XFx0XCIsXHJcbiAgICAgICAgY29udHJvbGxlcjogZXhwb3J0cy5jb250cm9sbGVyTmFtZSxcclxuICAgICAgICBjb250cm9sbGVyQXM6ICd1c2VyUmF0aW5nJyxcclxuICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICByYW5nZTogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xyXG4gICAgICAgICAgICBzY29wZS5uZ01vZGVsID0gbmdNb2RlbDtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnVzZXJSYXRpbmcgPSB1c2VyUmF0aW5nO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHVzZXJSYXRpbmcpXHJcbiAgICAuY29udHJvbGxlcihleHBvcnRzLmNvbnRyb2xsZXJOYW1lLCBVc2VyUmF0aW5nQ29udHJvbGxlcik7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZXJSYXRpbmcuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3VzZXJSYXRpbmcvdXNlclJhdGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gLy8vIDxyZWZlcmVuY2UgcGF0aD0nLi4vLi4vLi4vdHlwaW5ncy9jb21tb25qcy5kLnRzJyAvPlxyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgY29tcG9uZW50VmFsaWRhdG9yX3NlcnZpY2VfMSA9IHJlcXVpcmUoJy4uLy4uL3NlcnZpY2VzL2NvbXBvbmVudFZhbGlkYXRvci9jb21wb25lbnRWYWxpZGF0b3Iuc2VydmljZScpO1xyXG5leHBvcnRzLm1vZHVsZU5hbWUgPSAncmwudWkuY29tcG9uZW50cy52YWxpZGF0aW9uR3JvdXAnO1xyXG5leHBvcnRzLmRpcmVjdGl2ZU5hbWUgPSAncmxWYWxpZGF0aW9uR3JvdXAnO1xyXG5leHBvcnRzLmNvbnRyb2xsZXJOYW1lID0gJ1ZhbGlkYXRpb25Hcm91cENvbnRyb2xsZXInO1xyXG52YXIgVmFsaWRhdGlvbkdyb3VwQ29udHJvbGxlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uR3JvdXBDb250cm9sbGVyKCRzY29wZSwgY29tcG9uZW50VmFsaWRhdG9yRmFjdG9yeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVuYmluZCA9ICRzY29wZS4kd2F0Y2goJ3ZhbGlkYXRpb25Hcm91cEZvcm0nLCBmdW5jdGlvbiAoZm9ybSkge1xyXG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX3RoaXMudmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZ3JvdXBWYWxpZGF0b3IgPSBjb21wb25lbnRWYWxpZGF0b3JGYWN0b3J5LmdldEluc3RhbmNlKHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtOiAkc2NvcGUudmFsaWRhdGlvbkdyb3VwRm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAkc2NvcGU6ICRzY29wZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiBbX3RoaXMudmFsaWRhdG9yXSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuYmluZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgVmFsaWRhdGlvbkdyb3VwQ29udHJvbGxlci4kaW5qZWN0ID0gWyckc2NvcGUnLCBjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLmZhY3RvcnlOYW1lXTtcclxuICAgIHJldHVybiBWYWxpZGF0aW9uR3JvdXBDb250cm9sbGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlZhbGlkYXRpb25Hcm91cENvbnRyb2xsZXIgPSBWYWxpZGF0aW9uR3JvdXBDb250cm9sbGVyO1xyXG5mdW5jdGlvbiB2YWxpZGF0aW9uR3JvdXAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3RyaWN0OiAnRScsXHJcbiAgICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcclxuICAgICAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi92YWxpZGF0aW9uR3JvdXAuaHRtbCcpLFxyXG4gICAgICAgIGNvbnRyb2xsZXI6IGV4cG9ydHMuY29udHJvbGxlck5hbWUsXHJcbiAgICAgICAgY29udHJvbGxlckFzOiAnZ3JvdXAnLFxyXG4gICAgICAgIHNjb3BlOiB7fSxcclxuICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRvcjogJz0nLFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMudmFsaWRhdGlvbkdyb3VwID0gdmFsaWRhdGlvbkdyb3VwO1xyXG5hbmd1bGFyLm1vZHVsZShleHBvcnRzLm1vZHVsZU5hbWUsIFtjb21wb25lbnRWYWxpZGF0b3Jfc2VydmljZV8xLm1vZHVsZU5hbWVdKVxyXG4gICAgLmRpcmVjdGl2ZShleHBvcnRzLmRpcmVjdGl2ZU5hbWUsIHZhbGlkYXRpb25Hcm91cClcclxuICAgIC5jb250cm9sbGVyKGV4cG9ydHMuY29udHJvbGxlck5hbWUsIFZhbGlkYXRpb25Hcm91cENvbnRyb2xsZXIpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uR3JvdXAuanMubWFwXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3ZhbGlkYXRpb25Hcm91cC92YWxpZGF0aW9uR3JvdXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJjb250ZW50LWdyb3VwXFxcIiBuZy1mb3JtPVxcXCJ2YWxpZGF0aW9uR3JvdXBGb3JtXFxcIj5cXHJcXG5cXHQ8ZGl2IGNsYXNzPVxcXCJlcnJvclxcXCIgbmctc2hvdz1cXFwidmFsaWRhdGlvbkdyb3VwRm9ybS4kZXJyb3IuY3VzdG9tVmFsaWRhdGlvblxcXCI+XFxyXFxuXFx0XFx0PGxhYmVsPnt7Z3JvdXAuZ3JvdXBWYWxpZGF0b3IuZXJyb3J9fTwvbGFiZWw+XFxyXFxuXFx0PC9kaXY+XFxyXFxuXFx0PGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcclxcbjwvZGl2PlwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NvdXJjZS9jb21wb25lbnRzL3ZhbGlkYXRpb25Hcm91cC92YWxpZGF0aW9uR3JvdXAuaHRtbFxuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgbmdNb2RlbCA9IHJlcXVpcmUoJy4vZm9ybVZhbGlkYXRvcnMnKTtcclxuZXhwb3J0cy5uZ01vZGVsID0gbmdNb2RlbDtcclxudmFyIHZpZXdEYXRhID0gcmVxdWlyZSgnLi92aWV3RGF0YScpO1xyXG5leHBvcnRzLnZpZXdEYXRhID0gdmlld0RhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLm1vZHVsZS5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3R5cGVzL3R5cGVzLm1vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtVmFsaWRhdG9ycy5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc291cmNlL3R5cGVzL2Zvcm1WYWxpZGF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMjAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdEYXRhLmpzLm1hcFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zb3VyY2UvdHlwZXMvdmlld0RhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=